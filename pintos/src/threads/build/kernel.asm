
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020058 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020058:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002005d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002005f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020060:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020062:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020064:	66 05 00 04          	add    $0x400,%ax
c0020068:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002006a:	66 3d 00 00          	cmp    $0x0,%ax
c002006e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020070:	76 06                	jbe    c0020078 <start+0x20>
	mov $0x10000, %eax
c0020072:	66 b8 00 00          	mov    $0x0,%ax
c0020076:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020078:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002007c:	67 66 a3 5e 01       	addr16 mov %ax,0x15e
c0020081:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c0020083:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020085:	a8 02                	test   $0x2,%al
	jnz 1b
c0020087:	75 fa                	jne    c0020083 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c0020089:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c002008b:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c002008d:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c002008f:	a8 02                	test   $0x2,%al
	jnz 1b
c0020091:	75 fa                	jne    c002008d <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c0020093:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c0020095:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c0020097:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020099:	a8 02                	test   $0x2,%al
	jnz 1b
c002009b:	75 fa                	jne    c0020097 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c002009d:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200a2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200a5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200a8:	66 b9 00 04          	mov    $0x400,%cx
c00200ac:	00 00                	add    %al,(%eax)
	rep stosl
c00200ae:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200b1:	66 b8 07 00          	mov    $0x7,%ax
c00200b5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200b7:	66 b9 11 00          	mov    $0x11,%cx
c00200bb:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200bd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200c0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200c7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200c8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200cb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200d2:	00 e2                	add    %ah,%dl
	loop 1b
c00200d4:	eb b8                	jmp    c002008e <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200d6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200d8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200da:	66 b8 07 00          	mov    $0x7,%ax
c00200de:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c00200e0:	66 b9 00 40          	mov    $0x4000,%cx
c00200e4:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200e6:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e9:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c00200f0:	66 
	addw $4, %di
	addl $0x1000, %eax
c00200f1:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c00200f6:	e2 f1                	loop   c00200e9 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c00200f8:	66 b8 00 f0          	mov    $0xf000,%ax
c00200fc:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c00200fe:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020101:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020102:	67 66 0f 01 15       	lgdtw  (%di)
c0020107:	58                   	pop    %eax
c0020108:	01 00                	add    %eax,(%eax)
c002010a:	00 0f                	add    %cl,(%edi)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002010c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002010e:	66 0d 05 00          	or     $0x5,%ax
c0020112:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020118:	ea 1f 01 02 c0 08 00 	ljmp   $0x8,$0xc002011f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002011f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020123:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020125:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020127:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020129:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002012b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002012d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020133:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020138:	e8 56 00 00 00       	call   c0020193 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002013d:	eb fe                	jmp    c002013d <start+0xe5>
	...

c0020140 <gdt>:
	...
c0020148:	ff                   	(bad)  
c0020149:	ff 00                	incl   (%eax)
c002014b:	00 00                	add    %al,(%eax)
c002014d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020154:	00                   	.byte 0x0
c0020155:	92                   	xchg   %eax,%edx
c0020156:	cf                   	iret   
	...

c0020158 <gdtdesc>:
c0020158:	17                   	pop    %ss
c0020159:	00 40 01             	add    %al,0x1(%eax)
c002015c:	02 c0                	add    %al,%al

c002015e <init_ram_pages>:
c002015e:	00 00                	add    %al,(%eax)
	...

c0020162 <run_task>:
}

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020162:	53                   	push   %ebx
c0020163:	83 ec 10             	sub    $0x10,%esp
  const char *task = argv[1];
c0020166:	8b 44 24 18          	mov    0x18(%esp),%eax
c002016a:	8b 58 04             	mov    0x4(%eax),%ebx
  
  printf ("Executing '%s':\n", task);
c002016d:	53                   	push   %ebx
c002016e:	68 d1 d8 02 c0       	push   $0xc002d8d1
c0020173:	e8 e7 66 00 00       	call   c002685f <printf>
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c0020178:	89 1c 24             	mov    %ebx,(%esp)
c002017b:	e8 93 9c 00 00       	call   c0029e13 <run_test>
#endif
  printf ("Execution of '%s' complete.\n", task);
c0020180:	83 c4 08             	add    $0x8,%esp
c0020183:	53                   	push   %ebx
c0020184:	68 e2 d8 02 c0       	push   $0xc002d8e2
c0020189:	e8 d1 66 00 00       	call   c002685f <printf>
}
c002018e:	83 c4 18             	add    $0x18,%esp
c0020191:	5b                   	pop    %ebx
c0020192:	c3                   	ret    

c0020193 <pintos_init>:
{
c0020193:	55                   	push   %ebp
c0020194:	57                   	push   %edi
c0020195:	56                   	push   %esi
c0020196:	53                   	push   %ebx
c0020197:	83 ec 2c             	sub    $0x2c,%esp
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c002019a:	b9 6d 9f 03 c0       	mov    $0xc0039f6d,%ecx
c002019f:	81 e9 b4 80 03 c0    	sub    $0xc00380b4,%ecx
c00201a5:	ba b4 80 03 c0       	mov    $0xc00380b4,%edx
c00201aa:	b0 00                	mov    $0x0,%al
c00201ac:	89 d7                	mov    %edx,%edi
c00201ae:	f3 aa                	rep stos %al,%es:(%edi)
  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00201b0:	8b 3d 3a 7d 00 c0    	mov    0xc0007d3a,%edi
  for (i = 0; i < argc; i++) 
c00201b6:	85 ff                	test   %edi,%edi
c00201b8:	0f 8e 54 05 00 00    	jle    c0020712 <pintos_init+0x57f>
c00201be:	be 00 00 00 00       	mov    $0x0,%esi
c00201c3:	bb 3e 7d 00 c0       	mov    $0xc0007d3e,%ebx
      p += strnlen (p, end - p) + 1;
c00201c8:	bd be 7d 00 c0       	mov    $0xc0007dbe,%ebp
c00201cd:	eb 08                	jmp    c00201d7 <pintos_init+0x44>
      if (p >= end)
c00201cf:	81 fb bd 7d 00 c0    	cmp    $0xc0007dbd,%ebx
c00201d5:	77 43                	ja     c002021a <pintos_init+0x87>
      argv[i] = p;
c00201d7:	89 1c b5 c0 80 03 c0 	mov    %ebx,-0x3ffc7f40(,%esi,4)
      p += strnlen (p, end - p) + 1;
c00201de:	83 ec 08             	sub    $0x8,%esp
c00201e1:	89 e8                	mov    %ebp,%eax
c00201e3:	29 d8                	sub    %ebx,%eax
c00201e5:	50                   	push   %eax
c00201e6:	53                   	push   %ebx
c00201e7:	e8 f0 77 00 00       	call   c00279dc <strnlen>
c00201ec:	8d 5c 03 01          	lea    0x1(%ebx,%eax,1),%ebx
  for (i = 0; i < argc; i++) 
c00201f0:	46                   	inc    %esi
c00201f1:	83 c4 10             	add    $0x10,%esp
c00201f4:	39 f7                	cmp    %esi,%edi
c00201f6:	75 d7                	jne    c00201cf <pintos_init+0x3c>
  argv[argc] = NULL;
c00201f8:	c7 04 b5 c0 80 03 c0 	movl   $0x0,-0x3ffc7f40(,%esi,4)
c00201ff:	00 00 00 00 
  printf ("Kernel command line:");
c0020203:	83 ec 0c             	sub    $0xc,%esp
c0020206:	68 cf d9 02 c0       	push   $0xc002d9cf
c002020b:	e8 4f 66 00 00       	call   c002685f <printf>
c0020210:	83 c4 10             	add    $0x10,%esp
c0020213:	bb 00 00 00 00       	mov    $0x0,%ebx
c0020218:	eb 33                	jmp    c002024d <pintos_init+0xba>
        PANIC ("command line arguments overflow");
c002021a:	68 e4 d9 02 c0       	push   $0xc002d9e4
c002021f:	68 a8 c1 02 c0       	push   $0xc002c1a8
c0020224:	68 fa 00 00 00       	push   $0xfa
c0020229:	68 ff d8 02 c0       	push   $0xc002d8ff
c002022e:	e8 da 80 00 00       	call   c002830d <debug_panic>
      printf (" %s", argv[i]);
c0020233:	83 ec 08             	sub    $0x8,%esp
c0020236:	56                   	push   %esi
c0020237:	68 57 e7 02 c0       	push   $0xc002e757
c002023c:	e8 1e 66 00 00       	call   c002685f <printf>
c0020241:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c0020244:	43                   	inc    %ebx
c0020245:	39 df                	cmp    %ebx,%edi
c0020247:	0f 84 e0 04 00 00    	je     c002072d <pintos_init+0x59a>
    if (strchr (argv[i], ' ') == NULL)
c002024d:	8b 34 9d c0 80 03 c0 	mov    -0x3ffc7f40(,%ebx,4),%esi
c0020254:	83 ec 08             	sub    $0x8,%esp
c0020257:	6a 20                	push   $0x20
c0020259:	56                   	push   %esi
c002025a:	e8 c6 74 00 00       	call   c0027725 <strchr>
c002025f:	83 c4 10             	add    $0x10,%esp
c0020262:	85 c0                	test   %eax,%eax
c0020264:	74 cd                	je     c0020233 <pintos_init+0xa0>
      printf (" '%s'", argv[i]);
c0020266:	83 ec 08             	sub    $0x8,%esp
c0020269:	56                   	push   %esi
c002026a:	68 14 d9 02 c0       	push   $0xc002d914
c002026f:	e8 eb 65 00 00       	call   c002685f <printf>
c0020274:	83 c4 10             	add    $0x10,%esp
c0020277:	eb cb                	jmp    c0020244 <pintos_init+0xb1>
/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020279:	83 ec 0c             	sub    $0xc,%esp
c002027c:	68 04 da 02 c0       	push   $0xc002da04
c0020281:	e8 ce 9a 00 00       	call   c0029d54 <puts>
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c0020286:	e8 97 5e 00 00       	call   c0026122 <shutdown_power_off>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c002028b:	83 ec 0c             	sub    $0xc,%esp
c002028e:	6a 01                	push   $0x1
c0020290:	e8 17 5e 00 00       	call   c00260ac <shutdown_configure>
c0020295:	83 c4 10             	add    $0x10,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020298:	83 c5 04             	add    $0x4,%ebp
c002029b:	8b 45 00             	mov    0x0(%ebp),%eax
c002029e:	85 c0                	test   %eax,%eax
c00202a0:	0f 84 07 01 00 00    	je     c00203ad <pintos_init+0x21a>
c00202a6:	80 38 2d             	cmpb   $0x2d,(%eax)
c00202a9:	0f 85 fe 00 00 00    	jne    c00203ad <pintos_init+0x21a>
      char *name = strtok_r (*argv, "=", &save_ptr);
c00202af:	83 ec 04             	sub    $0x4,%esp
c00202b2:	53                   	push   %ebx
c00202b3:	68 ea e5 02 c0       	push   $0xc002e5ea
c00202b8:	50                   	push   %eax
c00202b9:	e8 6f 75 00 00       	call   c002782d <strtok_r>
c00202be:	89 c6                	mov    %eax,%esi
c00202c0:	89 44 24 10          	mov    %eax,0x10(%esp)
      char *value = strtok_r (NULL, "", &save_ptr);
c00202c4:	83 c4 0c             	add    $0xc,%esp
c00202c7:	53                   	push   %ebx
c00202c8:	68 e2 ee 02 c0       	push   $0xc002eee2
c00202cd:	6a 00                	push   $0x0
c00202cf:	e8 59 75 00 00       	call   c002782d <strtok_r>
      if (!strcmp (name, "-h"))
c00202d4:	bf 1a d9 02 c0       	mov    $0xc002d91a,%edi
c00202d9:	b9 03 00 00 00       	mov    $0x3,%ecx
c00202de:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00202e0:	0f 97 c1             	seta   %cl
c00202e3:	0f 92 c2             	setb   %dl
c00202e6:	83 c4 10             	add    $0x10,%esp
c00202e9:	38 d1                	cmp    %dl,%cl
c00202eb:	74 8c                	je     c0020279 <pintos_init+0xe6>
      else if (!strcmp (name, "-q"))
c00202ed:	bf 1d d9 02 c0       	mov    $0xc002d91d,%edi
c00202f2:	b9 03 00 00 00       	mov    $0x3,%ecx
c00202f7:	8b 34 24             	mov    (%esp),%esi
c00202fa:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00202fc:	0f 97 c1             	seta   %cl
c00202ff:	0f 92 c2             	setb   %dl
c0020302:	38 d1                	cmp    %dl,%cl
c0020304:	74 85                	je     c002028b <pintos_init+0xf8>
      else if (!strcmp (name, "-r"))
c0020306:	bf 20 d9 02 c0       	mov    $0xc002d920,%edi
c002030b:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020310:	8b 34 24             	mov    (%esp),%esi
c0020313:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020315:	0f 97 c1             	seta   %cl
c0020318:	0f 92 c2             	setb   %dl
c002031b:	38 d1                	cmp    %dl,%cl
c002031d:	74 3e                	je     c002035d <pintos_init+0x1ca>
      else if (!strcmp (name, "-rs"))
c002031f:	bf 23 d9 02 c0       	mov    $0xc002d923,%edi
c0020324:	b9 04 00 00 00       	mov    $0x4,%ecx
c0020329:	8b 34 24             	mov    (%esp),%esi
c002032c:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002032e:	0f 97 c1             	seta   %cl
c0020331:	0f 92 c2             	setb   %dl
c0020334:	38 d1                	cmp    %dl,%cl
c0020336:	74 37                	je     c002036f <pintos_init+0x1dc>
      else if (!strcmp (name, "-mlfqs"))
c0020338:	bf 27 d9 02 c0       	mov    $0xc002d927,%edi
c002033d:	b9 07 00 00 00       	mov    $0x7,%ecx
c0020342:	8b 34 24             	mov    (%esp),%esi
c0020345:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020347:	0f 97 c2             	seta   %dl
c002034a:	0f 92 c0             	setb   %al
c002034d:	38 c2                	cmp    %al,%dl
c002034f:	75 37                	jne    c0020388 <pintos_init+0x1f5>
        thread_mlfqs = true;
c0020351:	c6 05 6c 9f 03 c0 01 	movb   $0x1,0xc0039f6c
c0020358:	e9 3b ff ff ff       	jmp    c0020298 <pintos_init+0x105>
        shutdown_configure (SHUTDOWN_REBOOT);
c002035d:	83 ec 0c             	sub    $0xc,%esp
c0020360:	6a 02                	push   $0x2
c0020362:	e8 45 5d 00 00       	call   c00260ac <shutdown_configure>
c0020367:	83 c4 10             	add    $0x10,%esp
c002036a:	e9 29 ff ff ff       	jmp    c0020298 <pintos_init+0x105>
        random_init (atoi (value));
c002036f:	83 ec 0c             	sub    $0xc,%esp
c0020372:	50                   	push   %eax
c0020373:	e8 31 70 00 00       	call   c00273a9 <atoi>
c0020378:	89 04 24             	mov    %eax,(%esp)
c002037b:	e8 5c 5f 00 00       	call   c00262dc <random_init>
c0020380:	83 c4 10             	add    $0x10,%esp
c0020383:	e9 10 ff ff ff       	jmp    c0020298 <pintos_init+0x105>
        PANIC ("unknown option `%s' (use -h for help)", name);
c0020388:	83 ec 0c             	sub    $0xc,%esp
c002038b:	ff 74 24 0c          	pushl  0xc(%esp)
c002038f:	68 d4 db 02 c0       	push   $0xc002dbd4
c0020394:	68 98 c1 02 c0       	push   $0xc002c198
c0020399:	68 33 01 00 00       	push   $0x133
c002039e:	68 ff d8 02 c0       	push   $0xc002d8ff
c00203a3:	e8 65 7f 00 00       	call   c002830d <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c00203a8:	bd c0 80 03 c0       	mov    $0xc00380c0,%ebp
  random_init (rtc_get_time ());
c00203ad:	e8 67 5b 00 00       	call   c0025f19 <rtc_get_time>
c00203b2:	83 ec 0c             	sub    $0xc,%esp
c00203b5:	50                   	push   %eax
c00203b6:	e8 21 5f 00 00       	call   c00262dc <random_init>
  thread_init ();
c00203bb:	e8 f1 05 00 00       	call   c00209b1 <thread_init>
  console_init ();
c00203c0:	e8 1e 99 00 00       	call   c0029ce3 <console_init>
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00203c5:	83 c4 08             	add    $0x8,%esp
          init_ram_pages * PGSIZE / 1024);
c00203c8:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00203cd:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00203d0:	c1 e8 0a             	shr    $0xa,%eax
c00203d3:	50                   	push   %eax
c00203d4:	68 fc db 02 c0       	push   $0xc002dbfc
c00203d9:	e8 81 64 00 00       	call   c002685f <printf>
  palloc_init (user_page_limit);
c00203de:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c00203e5:	e8 3a 2e 00 00       	call   c0023224 <palloc_init>
  malloc_init ();
c00203ea:	e8 e4 31 00 00       	call   c00235d3 <malloc_init>
  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00203ef:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c00203f6:	e8 52 2f 00 00       	call   c002334d <palloc_get_page>
c00203fb:	89 44 24 18          	mov    %eax,0x18(%esp)
c00203ff:	a3 68 9f 03 c0       	mov    %eax,0xc0039f68
  for (page = 0; page < init_ram_pages; page++)
c0020404:	83 c4 10             	add    $0x10,%esp
c0020407:	83 3d 5e 01 02 c0 00 	cmpl   $0x0,0xc002015e
c002040e:	0f 84 23 01 00 00    	je     c0020537 <pintos_init+0x3a4>
c0020414:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
c0020419:	b8 00 00 00 00       	mov    $0x0,%eax
c002041e:	be 00 00 00 00       	mov    $0x0,%esi
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020423:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
c0020427:	eb 5c                	jmp    c0020485 <pintos_init+0x2f2>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020429:	bd c0 80 03 c0       	mov    $0xc00380c0,%ebp
c002042e:	e9 7a ff ff ff       	jmp    c00203ad <pintos_init+0x21a>
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020433:	b1 00                	mov    $0x0,%cl
c0020435:	83 e1 01             	and    $0x1,%ecx
c0020438:	88 4c 24 07          	mov    %cl,0x7(%esp)
      if (pd[pde_idx] == 0)
c002043c:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0020440:	8d 2c 91             	lea    (%ecx,%edx,4),%ebp
c0020443:	83 7d 00 00          	cmpl   $0x0,0x0(%ebp)
c0020447:	74 62                	je     c00204ab <pintos_init+0x318>
      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c0020449:	8d 0c 98             	lea    (%eax,%ebx,4),%ecx
/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
  ASSERT (is_kernel_vaddr (vaddr));
c002044c:	81 3c 24 ff ff ff bf 	cmpl   $0xbfffffff,(%esp)
c0020453:	0f 86 bc 00 00 00    	jbe    c0020515 <pintos_init+0x382>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020459:	8d 97 00 00 00 40    	lea    0x40000000(%edi),%edx
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
  ASSERT (pg_ofs (page) == 0);
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002045f:	8a 5c 24 07          	mov    0x7(%esp),%bl
c0020463:	83 f3 01             	xor    $0x1,%ebx
c0020466:	0f b6 db             	movzbl %bl,%ebx
c0020469:	d1 e3                	shl    %ebx
c002046b:	83 ca 01             	or     $0x1,%edx
c002046e:	09 da                	or     %ebx,%edx
c0020470:	89 11                	mov    %edx,(%ecx)
  for (page = 0; page < init_ram_pages; page++)
c0020472:	46                   	inc    %esi
c0020473:	3b 35 5e 01 02 c0    	cmp    0xc002015e,%esi
c0020479:	0f 83 b4 00 00 00    	jae    c0020533 <pintos_init+0x3a0>
c002047f:	81 c7 00 10 00 00    	add    $0x1000,%edi
  return (uintptr_t) va >> PDSHIFT;
c0020485:	89 fa                	mov    %edi,%edx
c0020487:	c1 ea 16             	shr    $0x16,%edx
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002048a:	89 fb                	mov    %edi,%ebx
c002048c:	c1 eb 0c             	shr    $0xc,%ebx
c002048f:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
c0020495:	89 3c 24             	mov    %edi,(%esp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020498:	81 ff 00 00 02 c0    	cmp    $0xc0020000,%edi
c002049e:	72 93                	jb     c0020433 <pintos_init+0x2a0>
c00204a0:	81 ff 00 10 03 c0    	cmp    $0xc0031000,%edi
c00204a6:	0f 92 c1             	setb   %cl
c00204a9:	eb 8a                	jmp    c0020435 <pintos_init+0x2a2>
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00204ab:	83 ec 0c             	sub    $0xc,%esp
c00204ae:	6a 03                	push   $0x3
c00204b0:	e8 98 2e 00 00       	call   c002334d <palloc_get_page>
  return (uintptr_t) va & PGMASK;
c00204b5:	89 c2                	mov    %eax,%edx
  ASSERT (pg_ofs (pt) == 0);
c00204b7:	83 c4 10             	add    $0x10,%esp
c00204ba:	a9 ff 0f 00 00       	test   $0xfff,%eax
c00204bf:	75 18                	jne    c00204d9 <pintos_init+0x346>
  ASSERT (is_kernel_vaddr (vaddr));
c00204c1:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00204c6:	76 2f                	jbe    c00204f7 <pintos_init+0x364>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00204c8:	81 c2 00 00 00 40    	add    $0x40000000,%edx
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c00204ce:	83 ca 07             	or     $0x7,%edx
c00204d1:	89 55 00             	mov    %edx,0x0(%ebp)
c00204d4:	e9 70 ff ff ff       	jmp    c0020449 <pintos_init+0x2b6>
  ASSERT (pg_ofs (pt) == 0);
c00204d9:	83 ec 0c             	sub    $0xc,%esp
c00204dc:	68 2e d9 02 c0       	push   $0xc002d92e
c00204e1:	68 3f d9 02 c0       	push   $0xc002d93f
c00204e6:	68 8c c1 02 c0       	push   $0xc002c18c
c00204eb:	6a 48                	push   $0x48
c00204ed:	68 56 d9 02 c0       	push   $0xc002d956
c00204f2:	e8 16 7e 00 00       	call   c002830d <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c00204f7:	83 ec 0c             	sub    $0xc,%esp
c00204fa:	68 6a d9 02 c0       	push   $0xc002d96a
c00204ff:	68 3f d9 02 c0       	push   $0xc002d93f
c0020504:	68 84 c1 02 c0       	push   $0xc002c184
c0020509:	6a 54                	push   $0x54
c002050b:	68 82 d9 02 c0       	push   $0xc002d982
c0020510:	e8 f8 7d 00 00       	call   c002830d <debug_panic>
c0020515:	83 ec 0c             	sub    $0xc,%esp
c0020518:	68 6a d9 02 c0       	push   $0xc002d96a
c002051d:	68 3f d9 02 c0       	push   $0xc002d93f
c0020522:	68 84 c1 02 c0       	push   $0xc002c184
c0020527:	6a 54                	push   $0x54
c0020529:	68 82 d9 02 c0       	push   $0xc002d982
c002052e:	e8 da 7d 00 00       	call   c002830d <debug_panic>
c0020533:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c0020537:	a1 68 9f 03 c0       	mov    0xc0039f68,%eax
c002053c:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020541:	76 4c                	jbe    c002058f <pintos_init+0x3fc>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020543:	05 00 00 00 40       	add    $0x40000000,%eax
c0020548:	0f 22 d8             	mov    %eax,%cr3
  intr_init ();
c002054b:	e8 c7 11 00 00       	call   c0021717 <intr_init>
  timer_init ();
c0020550:	e8 5d 38 00 00       	call   c0023db2 <timer_init>
  kbd_init ();
c0020555:	e8 1c 3d 00 00       	call   c0024276 <kbd_init>
  input_init ();
c002055a:	e8 b3 54 00 00       	call   c0025a12 <input_init>
  thread_start ();
c002055f:	e8 4e 0f 00 00       	call   c00214b2 <thread_start>
  serial_init_queue ();
c0020564:	e8 11 41 00 00       	call   c002467a <serial_init_queue>
  timer_calibrate ();
c0020569:	e8 6a 38 00 00       	call   c0023dd8 <timer_calibrate>
  printf ("Boot complete.\n");
c002056e:	83 ec 0c             	sub    $0xc,%esp
c0020571:	68 98 d9 02 c0       	push   $0xc002d998
c0020576:	e8 d9 97 00 00       	call   c0029d54 <puts>
  if (*argv != NULL) {
c002057b:	8b 75 00             	mov    0x0(%ebp),%esi
c002057e:	83 c4 10             	add    $0x10,%esp
c0020581:	85 f6                	test   %esi,%esi
c0020583:	74 28                	je     c00205ad <pintos_init+0x41a>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c0020585:	bf 66 df 02 c0       	mov    $0xc002df66,%edi
c002058a:	e9 87 00 00 00       	jmp    c0020616 <pintos_init+0x483>
  ASSERT (is_kernel_vaddr (vaddr));
c002058f:	83 ec 0c             	sub    $0xc,%esp
c0020592:	68 6a d9 02 c0       	push   $0xc002d96a
c0020597:	68 3f d9 02 c0       	push   $0xc002d93f
c002059c:	68 84 c1 02 c0       	push   $0xc002c184
c00205a1:	6a 54                	push   $0x54
c00205a3:	68 82 d9 02 c0       	push   $0xc002d982
c00205a8:	e8 60 7d 00 00       	call   c002830d <debug_panic>
c00205ad:	bb 00 00 00 00       	mov    $0x0,%ebx
        failed_cnt = 0;
c00205b2:	bd 00 00 00 00       	mov    $0x0,%ebp
c00205b7:	e9 aa 00 00 00       	jmp    c0020666 <pintos_init+0x4d3>
      for (i = 1; i < a->argc; i++)
c00205bc:	8b 53 04             	mov    0x4(%ebx),%edx
c00205bf:	83 fa 01             	cmp    $0x1,%edx
c00205c2:	7e 36                	jle    c00205fa <pintos_init+0x467>
        if (argv[i] == NULL)
c00205c4:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c00205c8:	74 11                	je     c00205db <pintos_init+0x448>
c00205ca:	b8 01 00 00 00       	mov    $0x1,%eax
      for (i = 1; i < a->argc; i++)
c00205cf:	40                   	inc    %eax
c00205d0:	39 d0                	cmp    %edx,%eax
c00205d2:	74 26                	je     c00205fa <pintos_init+0x467>
        if (argv[i] == NULL)
c00205d4:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c00205d9:	75 f4                	jne    c00205cf <pintos_init+0x43c>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c00205db:	83 ec 08             	sub    $0x8,%esp
c00205de:	4a                   	dec    %edx
c00205df:	52                   	push   %edx
c00205e0:	56                   	push   %esi
c00205e1:	68 48 dc 02 c0       	push   $0xc002dc48
c00205e6:	68 60 c1 02 c0       	push   $0xc002c160
c00205eb:	68 7c 01 00 00       	push   $0x17c
c00205f0:	68 ff d8 02 c0       	push   $0xc002d8ff
c00205f5:	e8 13 7d 00 00       	call   c002830d <debug_panic>
      a->function (argv);
c00205fa:	83 ec 0c             	sub    $0xc,%esp
c00205fd:	55                   	push   %ebp
c00205fe:	ff 53 08             	call   *0x8(%ebx)
      argv += a->argc;
c0020601:	8b 43 04             	mov    0x4(%ebx),%eax
c0020604:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
  while (*argv != NULL)
c0020608:	8b 75 00             	mov    0x0(%ebp),%esi
c002060b:	83 c4 10             	add    $0x10,%esp
c002060e:	85 f6                	test   %esi,%esi
c0020610:	0f 84 f2 00 00 00    	je     c0020708 <pintos_init+0x575>
c0020616:	89 f8                	mov    %edi,%eax
c0020618:	bb 6c c1 02 c0       	mov    $0xc002c16c,%ebx
        else if (!strcmp (*argv, a->name))
c002061d:	83 ec 08             	sub    $0x8,%esp
c0020620:	50                   	push   %eax
c0020621:	56                   	push   %esi
c0020622:	e8 9b 70 00 00       	call   c00276c2 <strcmp>
c0020627:	83 c4 10             	add    $0x10,%esp
c002062a:	85 c0                	test   %eax,%eax
c002062c:	74 8e                	je     c00205bc <pintos_init+0x429>
      for (a = actions; ; a++)
c002062e:	83 c3 0c             	add    $0xc,%ebx
        if (a->name == NULL)
c0020631:	8b 03                	mov    (%ebx),%eax
c0020633:	85 c0                	test   %eax,%eax
c0020635:	75 e6                	jne    c002061d <pintos_init+0x48a>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c0020637:	83 ec 0c             	sub    $0xc,%esp
c002063a:	56                   	push   %esi
c002063b:	68 20 dc 02 c0       	push   $0xc002dc20
c0020640:	68 60 c1 02 c0       	push   $0xc002c160
c0020645:	68 75 01 00 00       	push   $0x175
c002064a:	68 ff d8 02 c0       	push   $0xc002d8ff
c002064f:	e8 b9 7c 00 00       	call   c002830d <debug_panic>
        puts ("I am Pintakina!");
c0020654:	83 ec 0c             	sub    $0xc,%esp
c0020657:	68 ba d9 02 c0       	push   $0xc002d9ba
c002065c:	e8 f3 96 00 00       	call   c0029d54 <puts>
c0020661:	83 c4 10             	add    $0x10,%esp
        failed_cnt = 0;
c0020664:	89 eb                	mov    %ebp,%ebx
      printf("Pintakina$ ");
c0020666:	83 ec 0c             	sub    $0xc,%esp
c0020669:	68 a7 d9 02 c0       	push   $0xc002d9a7
c002066e:	e8 ec 61 00 00       	call   c002685f <printf>
      input_getline (cmd, MAX_CMD_LENGTH);
c0020673:	83 c4 08             	add    $0x8,%esp
c0020676:	68 80 00 00 00       	push   $0x80
c002067b:	68 e0 81 03 c0       	push   $0xc00381e0
c0020680:	e8 85 54 00 00       	call   c0025b0a <input_getline>
      if (strcmp(cmd, "whoami") == 0) {
c0020685:	be e0 81 03 c0       	mov    $0xc00381e0,%esi
c002068a:	bf b3 d9 02 c0       	mov    $0xc002d9b3,%edi
c002068f:	b9 07 00 00 00       	mov    $0x7,%ecx
c0020694:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020696:	0f 97 c2             	seta   %dl
c0020699:	0f 92 c0             	setb   %al
c002069c:	83 c4 10             	add    $0x10,%esp
c002069f:	38 c2                	cmp    %al,%dl
c00206a1:	74 b1                	je     c0020654 <pintos_init+0x4c1>
      } else if (strcmp(cmd, "exit") == 0){
c00206a3:	be e0 81 03 c0       	mov    $0xc00381e0,%esi
c00206a8:	bf ca d9 02 c0       	mov    $0xc002d9ca,%edi
c00206ad:	b9 05 00 00 00       	mov    $0x5,%ecx
c00206b2:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00206b4:	0f 97 c2             	seta   %dl
c00206b7:	0f 92 c0             	setb   %al
c00206ba:	38 c2                	cmp    %al,%dl
c00206bc:	74 3d                	je     c00206fb <pintos_init+0x568>
      } else if (strcmp(cmd, "") != 0){
c00206be:	80 3d e0 81 03 c0 00 	cmpb   $0x0,0xc00381e0
c00206c5:	74 9d                	je     c0020664 <pintos_init+0x4d1>
        failed_cnt ++;
c00206c7:	8d 73 01             	lea    0x1(%ebx),%esi
        for (i = 0; i < failed_cnt; i++) putchar ('?');
c00206ca:	85 f6                	test   %esi,%esi
c00206cc:	7e 19                	jle    c00206e7 <pintos_init+0x554>
c00206ce:	89 f7                	mov    %esi,%edi
c00206d0:	bb 00 00 00 00       	mov    $0x0,%ebx
c00206d5:	83 ec 0c             	sub    $0xc,%esp
c00206d8:	6a 3f                	push   $0x3f
c00206da:	e8 e1 96 00 00       	call   c0029dc0 <putchar>
c00206df:	43                   	inc    %ebx
c00206e0:	83 c4 10             	add    $0x10,%esp
c00206e3:	39 fb                	cmp    %edi,%ebx
c00206e5:	75 ee                	jne    c00206d5 <pintos_init+0x542>
        putchar ('\n');
c00206e7:	83 ec 0c             	sub    $0xc,%esp
c00206ea:	6a 0a                	push   $0xa
c00206ec:	e8 cf 96 00 00       	call   c0029dc0 <putchar>
c00206f1:	83 c4 10             	add    $0x10,%esp
        failed_cnt ++;
c00206f4:	89 f3                	mov    %esi,%ebx
c00206f6:	e9 6b ff ff ff       	jmp    c0020666 <pintos_init+0x4d3>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c00206fb:	83 ec 0c             	sub    $0xc,%esp
c00206fe:	6a 01                	push   $0x1
c0020700:	e8 a7 59 00 00       	call   c00260ac <shutdown_configure>
        break;
c0020705:	83 c4 10             	add    $0x10,%esp
  shutdown ();
c0020708:	e8 94 5a 00 00       	call   c00261a1 <shutdown>
  thread_exit ();
c002070d:	e8 30 0b 00 00       	call   c0021242 <thread_exit>
  argv[argc] = NULL;
c0020712:	c7 04 bd c0 80 03 c0 	movl   $0x0,-0x3ffc7f40(,%edi,4)
c0020719:	00 00 00 00 
  printf ("Kernel command line:");
c002071d:	83 ec 0c             	sub    $0xc,%esp
c0020720:	68 cf d9 02 c0       	push   $0xc002d9cf
c0020725:	e8 35 61 00 00       	call   c002685f <printf>
c002072a:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c002072d:	83 ec 0c             	sub    $0xc,%esp
c0020730:	6a 0a                	push   $0xa
c0020732:	e8 89 96 00 00       	call   c0029dc0 <putchar>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020737:	a1 c0 80 03 c0       	mov    0xc00380c0,%eax
c002073c:	83 c4 10             	add    $0x10,%esp
c002073f:	85 c0                	test   %eax,%eax
c0020741:	0f 84 61 fc ff ff    	je     c00203a8 <pintos_init+0x215>
c0020747:	80 38 2d             	cmpb   $0x2d,(%eax)
c002074a:	0f 85 d9 fc ff ff    	jne    c0020429 <pintos_init+0x296>
c0020750:	bd c0 80 03 c0       	mov    $0xc00380c0,%ebp
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020755:	8d 5c 24 1c          	lea    0x1c(%esp),%ebx
c0020759:	e9 51 fb ff ff       	jmp    c00202af <pintos_init+0x11c>

c002075e <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c002075e:	57                   	push   %edi
c002075f:	56                   	push   %esi
c0020760:	53                   	push   %ebx
c0020761:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level;

	ASSERT (t != NULL);
c0020764:	85 c0                	test   %eax,%eax
c0020766:	0f 84 ab 00 00 00    	je     c0020817 <init_thread+0xb9>
c002076c:	89 c3                	mov    %eax,%ebx
c002076e:	89 ce                	mov    %ecx,%esi
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020770:	83 f9 3f             	cmp    $0x3f,%ecx
c0020773:	0f 87 bf 00 00 00    	ja     c0020838 <init_thread+0xda>
  ASSERT (name != NULL);
c0020779:	85 d2                	test   %edx,%edx
c002077b:	0f 84 d8 00 00 00    	je     c0020859 <init_thread+0xfb>

  memset (t, 0, sizeof *t);
c0020781:	b9 1a 00 00 00       	mov    $0x1a,%ecx
c0020786:	b8 00 00 00 00       	mov    $0x0,%eax
c002078b:	89 df                	mov    %ebx,%edi
c002078d:	f3 ab                	rep stos %eax,%es:(%edi)
  t->status = THREAD_BLOCKED;
c002078f:	c7 43 08 02 00 00 00 	movl   $0x2,0x8(%ebx)
  strlcpy (t->name, name, sizeof t->name);
c0020796:	83 ec 04             	sub    $0x4,%esp
c0020799:	6a 10                	push   $0x10
c002079b:	52                   	push   %edx
c002079c:	8d 43 0c             	lea    0xc(%ebx),%eax
c002079f:	50                   	push   %eax
c00207a0:	e8 62 72 00 00       	call   c0027a07 <strlcpy>
  t->stack = (uint8_t *) t + PGSIZE;
c00207a5:	8d 83 00 10 00 00    	lea    0x1000(%ebx),%eax
c00207ab:	89 43 1c             	mov    %eax,0x1c(%ebx)
  t->priority = priority;
c00207ae:	89 73 20             	mov    %esi,0x20(%ebx)
/* fstqwq */
  t->sleep_remain = 0;
c00207b1:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)

  if (thread_mlfqs) {
c00207b8:	83 c4 10             	add    $0x10,%esp
c00207bb:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c00207c2:	0f 85 b2 00 00 00    	jne    c002087a <init_thread+0x11c>
    t->nice = 0;
    t->recent_cpu = fixed32_init(0);
    t->priority = 0;
  }

  list_init (&t->lock_list);
c00207c8:	83 ec 0c             	sub    $0xc,%esp
c00207cb:	8d 43 30             	lea    0x30(%ebx),%eax
c00207ce:	50                   	push   %eax
c00207cf:	e8 e0 7b 00 00       	call   c00283b4 <list_init>
  t->priority_to_set = -1;
c00207d4:	c7 43 44 ff ff ff ff 	movl   $0xffffffff,0x44(%ebx)
  t->max_donate_delta = 0;
c00207db:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  t->father = 0;
c00207e2:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)

/* end fstqwq */

  t->magic = THREAD_MAGIC;
c00207e9:	c7 43 64 4b bf 6a cd 	movl   $0xcd6abf4b,0x64(%ebx)
  t->mapping_cnt = 2;
  list_init(&t->mappings);
#endif
  /* end yveh */

  old_level = intr_disable ();
c00207f0:	e8 01 0f 00 00       	call   c00216f6 <intr_disable>
c00207f5:	89 c6                	mov    %eax,%esi
  list_push_back (&all_list, &t->allelem);
c00207f7:	83 c4 08             	add    $0x8,%esp
c00207fa:	83 c3 54             	add    $0x54,%ebx
c00207fd:	53                   	push   %ebx
c00207fe:	68 bc 82 03 c0       	push   $0xc00382bc
c0020803:	e8 f8 7f 00 00       	call   c0028800 <list_push_back>
  intr_set_level (old_level);
c0020808:	89 34 24             	mov    %esi,(%esp)
c002080b:	e8 ed 0e 00 00       	call   c00216fd <intr_set_level>
}
c0020810:	83 c4 20             	add    $0x20,%esp
c0020813:	5b                   	pop    %ebx
c0020814:	5e                   	pop    %esi
c0020815:	5f                   	pop    %edi
c0020816:	c3                   	ret    
	ASSERT (t != NULL);
c0020817:	83 ec 0c             	sub    $0xc,%esp
c002081a:	68 c3 f1 02 c0       	push   $0xc002f1c3
c002081f:	68 3f d9 02 c0       	push   $0xc002d93f
c0020824:	68 10 c3 02 c0       	push   $0xc002c310
c0020829:	68 8c 02 00 00       	push   $0x28c
c002082e:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020833:	e8 d5 7a 00 00       	call   c002830d <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020838:	83 ec 0c             	sub    $0xc,%esp
c002083b:	68 b8 dd 02 c0       	push   $0xc002ddb8
c0020840:	68 3f d9 02 c0       	push   $0xc002d93f
c0020845:	68 10 c3 02 c0       	push   $0xc002c310
c002084a:	68 8d 02 00 00       	push   $0x28d
c002084f:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020854:	e8 b4 7a 00 00       	call   c002830d <debug_panic>
  ASSERT (name != NULL);
c0020859:	83 ec 0c             	sub    $0xc,%esp
c002085c:	68 83 dc 02 c0       	push   $0xc002dc83
c0020861:	68 3f d9 02 c0       	push   $0xc002d93f
c0020866:	68 10 c3 02 c0       	push   $0xc002c310
c002086b:	68 8e 02 00 00       	push   $0x28e
c0020870:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020875:	e8 93 7a 00 00       	call   c002830d <debug_panic>
    t->nice = 0;
c002087a:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
    t->recent_cpu = fixed32_init(0);
c0020881:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020885:	83 ec 08             	sub    $0x8,%esp
c0020888:	6a 00                	push   $0x0
c002088a:	50                   	push   %eax
c002088b:	e8 2b 31 00 00       	call   c00239bb <fixed32_init>
c0020890:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020894:	89 43 2c             	mov    %eax,0x2c(%ebx)
    t->priority = 0;
c0020897:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
c002089e:	83 c4 0c             	add    $0xc,%esp
c00208a1:	e9 22 ff ff ff       	jmp    c00207c8 <init_thread+0x6a>

c00208a6 <is_thread>:
{
c00208a6:	53                   	push   %ebx
c00208a7:	83 ec 08             	sub    $0x8,%esp
c00208aa:	89 c3                	mov    %eax,%ebx
  if (!(t != NULL && t->magic == THREAD_MAGIC)) {
c00208ac:	85 c0                	test   %eax,%eax
c00208ae:	74 3e                	je     c00208ee <is_thread+0x48>
c00208b0:	81 78 64 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x64(%eax)
c00208b7:	74 27                	je     c00208e0 <is_thread+0x3a>
    printf("is thread failed : %u", t);
c00208b9:	83 ec 08             	sub    $0x8,%esp
c00208bc:	50                   	push   %eax
c00208bd:	68 90 dc 02 c0       	push   $0xc002dc90
c00208c2:	e8 98 5f 00 00       	call   c002685f <printf>
  return t != NULL && t->magic == THREAD_MAGIC;
c00208c7:	83 c4 10             	add    $0x10,%esp
c00208ca:	81 7b 64 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x64(%ebx)
c00208d1:	74 14                	je     c00208e7 <is_thread+0x41>
c00208d3:	b8 00 00 00 00       	mov    $0x0,%eax
c00208d8:	83 e0 01             	and    $0x1,%eax
}
c00208db:	83 c4 08             	add    $0x8,%esp
c00208de:	5b                   	pop    %ebx
c00208df:	c3                   	ret    
  return t != NULL && t->magic == THREAD_MAGIC;
c00208e0:	b8 01 00 00 00       	mov    $0x1,%eax
c00208e5:	eb f1                	jmp    c00208d8 <is_thread+0x32>
c00208e7:	b8 01 00 00 00       	mov    $0x1,%eax
c00208ec:	eb ea                	jmp    c00208d8 <is_thread+0x32>
    printf("is thread failed : %u", t);
c00208ee:	83 ec 08             	sub    $0x8,%esp
c00208f1:	50                   	push   %eax
c00208f2:	68 90 dc 02 c0       	push   $0xc002dc90
c00208f7:	e8 63 5f 00 00       	call   c002685f <printf>
c00208fc:	83 c4 10             	add    $0x10,%esp
c00208ff:	eb d2                	jmp    c00208d3 <is_thread+0x2d>

c0020901 <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c0020901:	56                   	push   %esi
c0020902:	53                   	push   %ebx
c0020903:	83 ec 04             	sub    $0x4,%esp
c0020906:	89 c3                	mov    %eax,%ebx
c0020908:	89 d6                	mov    %edx,%esi
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c002090a:	e8 97 ff ff ff       	call   c00208a6 <is_thread>
c002090f:	84 c0                	test   %al,%al
c0020911:	74 16                	je     c0020929 <alloc_frame+0x28>
  ASSERT (size % sizeof (uint32_t) == 0);
c0020913:	f7 c6 03 00 00 00    	test   $0x3,%esi
c0020919:	75 2f                	jne    c002094a <alloc_frame+0x49>

  t->stack -= size;
c002091b:	8b 43 1c             	mov    0x1c(%ebx),%eax
c002091e:	29 f0                	sub    %esi,%eax
c0020920:	89 43 1c             	mov    %eax,0x1c(%ebx)
  return t->stack;
}
c0020923:	83 c4 04             	add    $0x4,%esp
c0020926:	5b                   	pop    %ebx
c0020927:	5e                   	pop    %esi
c0020928:	c3                   	ret    
  ASSERT (is_thread (t));
c0020929:	83 ec 0c             	sub    $0xc,%esp
c002092c:	68 a6 dc 02 c0       	push   $0xc002dca6
c0020931:	68 3f d9 02 c0       	push   $0xc002d93f
c0020936:	68 e4 c2 02 c0       	push   $0xc002c2e4
c002093b:	68 c5 02 00 00       	push   $0x2c5
c0020940:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020945:	e8 c3 79 00 00       	call   c002830d <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c002094a:	83 ec 0c             	sub    $0xc,%esp
c002094d:	68 b4 dc 02 c0       	push   $0xc002dcb4
c0020952:	68 3f d9 02 c0       	push   $0xc002d93f
c0020957:	68 e4 c2 02 c0       	push   $0xc002c2e4
c002095c:	68 c6 02 00 00       	push   $0x2c6
c0020961:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020966:	e8 a2 79 00 00       	call   c002830d <debug_panic>

c002096b <thread_update_priority>:
thread_update_priority(struct thread* t, void* aux UNUSED){
c002096b:	53                   	push   %ebx
c002096c:	83 ec 18             	sub    $0x18,%esp
c002096f:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  if(t != idle_thread) {
c0020973:	39 1d b8 82 03 c0    	cmp    %ebx,0xc00382b8
c0020979:	74 31                	je     c00209ac <thread_update_priority+0x41>
                - fixed32_trunc(fixed32_div_int(t->recent_cpu, 4))
c002097b:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002097f:	83 ec 04             	sub    $0x4,%esp
c0020982:	6a 04                	push   $0x4
c0020984:	ff 73 2c             	pushl  0x2c(%ebx)
c0020987:	50                   	push   %eax
c0020988:	e8 e2 31 00 00       	call   c0023b6f <fixed32_div_int>
c002098d:	ff 74 24 18          	pushl  0x18(%esp)
c0020991:	e8 35 30 00 00       	call   c00239cb <fixed32_trunc>
c0020996:	ba 3f 00 00 00       	mov    $0x3f,%edx
c002099b:	29 c2                	sub    %eax,%edx
c002099d:	89 d0                	mov    %edx,%eax
                - t->nice * 2;
c002099f:	8b 53 28             	mov    0x28(%ebx),%edx
c00209a2:	01 d2                	add    %edx,%edx
c00209a4:	29 d0                	sub    %edx,%eax
c00209a6:	89 43 20             	mov    %eax,0x20(%ebx)
    t->priority = PRI_MAX
c00209a9:	83 c4 10             	add    $0x10,%esp
}
c00209ac:	83 c4 18             	add    $0x18,%esp
c00209af:	5b                   	pop    %ebx
c00209b0:	c3                   	ret    

c00209b1 <thread_init>:
{
c00209b1:	56                   	push   %esi
c00209b2:	53                   	push   %ebx
c00209b3:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00209b6:	e8 fe 0c 00 00       	call   c00216b9 <intr_get_level>
c00209bb:	85 c0                	test   %eax,%eax
c00209bd:	75 7c                	jne    c0020a3b <thread_init+0x8a>
  lock_init (&tid_lock);
c00209bf:	83 ec 0c             	sub    $0xc,%esp
c00209c2:	68 80 82 03 c0       	push   $0xc0038280
c00209c7:	e8 32 20 00 00       	call   c00229fe <lock_init>
  list_init (&ready_list);
c00209cc:	c7 04 24 cc 82 03 c0 	movl   $0xc00382cc,(%esp)
c00209d3:	e8 dc 79 00 00       	call   c00283b4 <list_init>
  list_init (&all_list);
c00209d8:	c7 04 24 bc 82 03 c0 	movl   $0xc00382bc,(%esp)
c00209df:	e8 d0 79 00 00       	call   c00283b4 <list_init>
  asm ("mov %%esp, %0" : "=g" (esp));
c00209e4:	89 e0                	mov    %esp,%eax
  return (void *) ((uintptr_t) va & ~PGMASK);
c00209e6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  initial_thread = running_thread ();
c00209eb:	a3 b4 82 03 c0       	mov    %eax,0xc00382b4
  init_thread (initial_thread, "main", PRI_DEFAULT);
c00209f0:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c00209f5:	ba f0 dc 02 c0       	mov    $0xc002dcf0,%edx
c00209fa:	e8 5f fd ff ff       	call   c002075e <init_thread>
  initial_thread->status = THREAD_RUNNING;
c00209ff:	8b 1d b4 82 03 c0    	mov    0xc00382b4,%ebx
c0020a05:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
allocate_tid (void) 
{
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c0020a0c:	c7 04 24 80 82 03 c0 	movl   $0xc0038280,(%esp)
c0020a13:	e8 5a 21 00 00       	call   c0022b72 <lock_acquire>
  tid = next_tid++;
c0020a18:	8b 35 70 7c 03 c0    	mov    0xc0037c70,%esi
c0020a1e:	8d 46 01             	lea    0x1(%esi),%eax
c0020a21:	a3 70 7c 03 c0       	mov    %eax,0xc0037c70
  lock_release (&tid_lock);
c0020a26:	c7 04 24 80 82 03 c0 	movl   $0xc0038280,(%esp)
c0020a2d:	e8 dd 22 00 00       	call   c0022d0f <lock_release>
  initial_thread->tid = allocate_tid ();
c0020a32:	89 73 04             	mov    %esi,0x4(%ebx)
}
c0020a35:	83 c4 14             	add    $0x14,%esp
c0020a38:	5b                   	pop    %ebx
c0020a39:	5e                   	pop    %esi
c0020a3a:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0020a3b:	83 ec 0c             	sub    $0xc,%esp
c0020a3e:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0020a43:	68 3f d9 02 c0       	push   $0xc002d93f
c0020a48:	68 1c c3 02 c0       	push   $0xc002c31c
c0020a4d:	6a 77                	push   $0x77
c0020a4f:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020a54:	e8 b4 78 00 00       	call   c002830d <debug_panic>

c0020a59 <thread_print_stats>:
{
c0020a59:	83 ec 10             	sub    $0x10,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020a5c:	6a 00                	push   $0x0
c0020a5e:	6a 00                	push   $0x0
c0020a60:	ff 35 6c 82 03 c0    	pushl  0xc003826c
c0020a66:	ff 35 68 82 03 c0    	pushl  0xc0038268
c0020a6c:	ff 35 74 82 03 c0    	pushl  0xc0038274
c0020a72:	ff 35 70 82 03 c0    	pushl  0xc0038270
c0020a78:	68 e4 dd 02 c0       	push   $0xc002dde4
c0020a7d:	e8 dd 5d 00 00       	call   c002685f <printf>
}
c0020a82:	83 c4 2c             	add    $0x2c,%esp
c0020a85:	c3                   	ret    

c0020a86 <thread_current>:
{
c0020a86:	53                   	push   %ebx
c0020a87:	83 ec 08             	sub    $0x8,%esp
  asm ("mov %%esp, %0" : "=g" (esp));
c0020a8a:	89 e3                	mov    %esp,%ebx
c0020a8c:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  ASSERT (is_thread (t));
c0020a92:	89 d8                	mov    %ebx,%eax
c0020a94:	e8 0d fe ff ff       	call   c00208a6 <is_thread>
c0020a99:	84 c0                	test   %al,%al
c0020a9b:	74 0d                	je     c0020aaa <thread_current+0x24>
  ASSERT (t->status == THREAD_RUNNING);
c0020a9d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c0020aa1:	75 28                	jne    c0020acb <thread_current+0x45>
}
c0020aa3:	89 d8                	mov    %ebx,%eax
c0020aa5:	83 c4 08             	add    $0x8,%esp
c0020aa8:	5b                   	pop    %ebx
c0020aa9:	c3                   	ret    
  ASSERT (is_thread (t));
c0020aaa:	83 ec 0c             	sub    $0xc,%esp
c0020aad:	68 a6 dc 02 c0       	push   $0xc002dca6
c0020ab2:	68 3f d9 02 c0       	push   $0xc002d93f
c0020ab7:	68 a8 c2 02 c0       	push   $0xc002c2a8
c0020abc:	68 44 01 00 00       	push   $0x144
c0020ac1:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020ac6:	e8 42 78 00 00       	call   c002830d <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020acb:	83 ec 0c             	sub    $0xc,%esp
c0020ace:	68 f5 dc 02 c0       	push   $0xc002dcf5
c0020ad3:	68 3f d9 02 c0       	push   $0xc002d93f
c0020ad8:	68 a8 c2 02 c0       	push   $0xc002c2a8
c0020add:	68 45 01 00 00       	push   $0x145
c0020ae2:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020ae7:	e8 21 78 00 00       	call   c002830d <debug_panic>

c0020aec <thread_tick>:
{
c0020aec:	83 ec 0c             	sub    $0xc,%esp
  struct thread *t = thread_current ();
c0020aef:	e8 92 ff ff ff       	call   c0020a86 <thread_current>
  if (t == idle_thread)
c0020af4:	3b 05 b8 82 03 c0    	cmp    0xc00382b8,%eax
c0020afa:	74 22                	je     c0020b1e <thread_tick+0x32>
    kernel_ticks++;
c0020afc:	83 05 68 82 03 c0 01 	addl   $0x1,0xc0038268
c0020b03:	83 15 6c 82 03 c0 00 	adcl   $0x0,0xc003826c
  if (++thread_ticks >= TIME_SLICE)
c0020b0a:	a1 60 82 03 c0       	mov    0xc0038260,%eax
c0020b0f:	40                   	inc    %eax
c0020b10:	a3 60 82 03 c0       	mov    %eax,0xc0038260
c0020b15:	83 f8 03             	cmp    $0x3,%eax
c0020b18:	77 14                	ja     c0020b2e <thread_tick+0x42>
}
c0020b1a:	83 c4 0c             	add    $0xc,%esp
c0020b1d:	c3                   	ret    
    idle_ticks++;
c0020b1e:	83 05 70 82 03 c0 01 	addl   $0x1,0xc0038270
c0020b25:	83 15 74 82 03 c0 00 	adcl   $0x0,0xc0038274
c0020b2c:	eb dc                	jmp    c0020b0a <thread_tick+0x1e>
    intr_yield_on_return ();
c0020b2e:	e8 ea 0d 00 00       	call   c002191d <intr_yield_on_return>
}
c0020b33:	eb e5                	jmp    c0020b1a <thread_tick+0x2e>

c0020b35 <thread_name>:
{
c0020b35:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->name;
c0020b38:	e8 49 ff ff ff       	call   c0020a86 <thread_current>
c0020b3d:	83 c0 0c             	add    $0xc,%eax
}
c0020b40:	83 c4 0c             	add    $0xc,%esp
c0020b43:	c3                   	ret    

c0020b44 <thread_tid>:
{
c0020b44:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->tid;
c0020b47:	e8 3a ff ff ff       	call   c0020a86 <thread_current>
c0020b4c:	8b 40 04             	mov    0x4(%eax),%eax
}
c0020b4f:	83 c4 0c             	add    $0xc,%esp
c0020b52:	c3                   	ret    

c0020b53 <thread_foreach>:
{
c0020b53:	57                   	push   %edi
c0020b54:	56                   	push   %esi
c0020b55:	53                   	push   %ebx
c0020b56:	8b 74 24 10          	mov    0x10(%esp),%esi
c0020b5a:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c0020b5e:	e8 56 0b 00 00       	call   c00216b9 <intr_get_level>
c0020b63:	85 c0                	test   %eax,%eax
c0020b65:	75 14                	jne    c0020b7b <thread_foreach+0x28>
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020b67:	83 ec 0c             	sub    $0xc,%esp
c0020b6a:	68 bc 82 03 c0       	push   $0xc00382bc
c0020b6f:	e8 83 78 00 00       	call   c00283f7 <list_begin>
c0020b74:	89 c3                	mov    %eax,%ebx
c0020b76:	83 c4 10             	add    $0x10,%esp
c0020b79:	eb 38                	jmp    c0020bb3 <thread_foreach+0x60>
  ASSERT (intr_get_level () == INTR_OFF);
c0020b7b:	83 ec 0c             	sub    $0xc,%esp
c0020b7e:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0020b83:	68 3f d9 02 c0       	push   $0xc002d93f
c0020b88:	68 7c c2 02 c0       	push   $0xc002c27c
c0020b8d:	68 88 01 00 00       	push   $0x188
c0020b92:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020b97:	e8 71 77 00 00       	call   c002830d <debug_panic>
      func (t, aux);
c0020b9c:	83 ec 08             	sub    $0x8,%esp
c0020b9f:	57                   	push   %edi
      struct thread *t = list_entry (e, struct thread, allelem);
c0020ba0:	8d 43 ac             	lea    -0x54(%ebx),%eax
      func (t, aux);
c0020ba3:	50                   	push   %eax
c0020ba4:	ff d6                	call   *%esi
       e = list_next (e))
c0020ba6:	89 1c 24             	mov    %ebx,(%esp)
c0020ba9:	e8 79 78 00 00       	call   c0028427 <list_next>
c0020bae:	89 c3                	mov    %eax,%ebx
c0020bb0:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020bb3:	83 ec 0c             	sub    $0xc,%esp
c0020bb6:	68 bc 82 03 c0       	push   $0xc00382bc
c0020bbb:	e8 af 78 00 00       	call   c002846f <list_end>
c0020bc0:	83 c4 10             	add    $0x10,%esp
c0020bc3:	39 c3                	cmp    %eax,%ebx
c0020bc5:	75 d5                	jne    c0020b9c <thread_foreach+0x49>
}
c0020bc7:	5b                   	pop    %ebx
c0020bc8:	5e                   	pop    %esi
c0020bc9:	5f                   	pop    %edi
c0020bca:	c3                   	ret    

c0020bcb <thread_ready_list_get_min>:
thread_ready_list_get_min() {
c0020bcb:	83 ec 18             	sub    $0x18,%esp
  ASSERT (! list_empty(&ready_list));
c0020bce:	68 cc 82 03 c0       	push   $0xc00382cc
c0020bd3:	e8 d0 7c 00 00       	call   c00288a8 <list_empty>
c0020bd8:	83 c4 10             	add    $0x10,%esp
c0020bdb:	84 c0                	test   %al,%al
c0020bdd:	75 18                	jne    c0020bf7 <thread_ready_list_get_min+0x2c>
  struct list_elem* e = list_min(&ready_list, thread_priority_greater, NULL);
c0020bdf:	83 ec 04             	sub    $0x4,%esp
c0020be2:	6a 00                	push   $0x0
c0020be4:	68 74 0d 02 c0       	push   $0xc0020d74
c0020be9:	68 cc 82 03 c0       	push   $0xc00382cc
c0020bee:	e8 01 83 00 00       	call   c0028ef4 <list_min>
}
c0020bf3:	83 c4 1c             	add    $0x1c,%esp
c0020bf6:	c3                   	ret    
  ASSERT (! list_empty(&ready_list));
c0020bf7:	83 ec 0c             	sub    $0xc,%esp
c0020bfa:	68 11 dd 02 c0       	push   $0xc002dd11
c0020bff:	68 3f d9 02 c0       	push   $0xc002d93f
c0020c04:	68 60 c2 02 c0       	push   $0xc002c260
c0020c09:	68 95 01 00 00       	push   $0x195
c0020c0e:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020c13:	e8 f5 76 00 00       	call   c002830d <debug_panic>

c0020c18 <thread_insert_ready_list>:
thread_insert_ready_list(struct list_elem* elem) {
c0020c18:	83 ec 14             	sub    $0x14,%esp
    list_push_back(&ready_list, elem);
c0020c1b:	ff 74 24 18          	pushl  0x18(%esp)
c0020c1f:	68 cc 82 03 c0       	push   $0xc00382cc
c0020c24:	e8 d7 7b 00 00       	call   c0028800 <list_push_back>
}
c0020c29:	83 c4 1c             	add    $0x1c,%esp
c0020c2c:	c3                   	ret    

c0020c2d <thread_unblock>:
{
c0020c2d:	56                   	push   %esi
c0020c2e:	53                   	push   %ebx
c0020c2f:	83 ec 04             	sub    $0x4,%esp
c0020c32:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (is_thread (t));
c0020c36:	89 d8                	mov    %ebx,%eax
c0020c38:	e8 69 fc ff ff       	call   c00208a6 <is_thread>
c0020c3d:	84 c0                	test   %al,%al
c0020c3f:	74 2e                	je     c0020c6f <thread_unblock+0x42>
  old_level = intr_disable ();
c0020c41:	e8 b0 0a 00 00       	call   c00216f6 <intr_disable>
c0020c46:	89 c6                	mov    %eax,%esi
  ASSERT (t->status == THREAD_BLOCKED);
c0020c48:	83 7b 08 02          	cmpl   $0x2,0x8(%ebx)
c0020c4c:	75 42                	jne    c0020c90 <thread_unblock+0x63>
  thread_insert_ready_list(&t->elem);
c0020c4e:	83 ec 0c             	sub    $0xc,%esp
c0020c51:	8d 43 5c             	lea    0x5c(%ebx),%eax
c0020c54:	50                   	push   %eax
c0020c55:	e8 be ff ff ff       	call   c0020c18 <thread_insert_ready_list>
  t->status = THREAD_READY;
c0020c5a:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
  intr_set_level (old_level);
c0020c61:	89 34 24             	mov    %esi,(%esp)
c0020c64:	e8 94 0a 00 00       	call   c00216fd <intr_set_level>
}
c0020c69:	83 c4 14             	add    $0x14,%esp
c0020c6c:	5b                   	pop    %ebx
c0020c6d:	5e                   	pop    %esi
c0020c6e:	c3                   	ret    
  ASSERT (is_thread (t));
c0020c6f:	83 ec 0c             	sub    $0xc,%esp
c0020c72:	68 a6 dc 02 c0       	push   $0xc002dca6
c0020c77:	68 3f d9 02 c0       	push   $0xc002d93f
c0020c7c:	68 b8 c2 02 c0       	push   $0xc002c2b8
c0020c81:	68 19 01 00 00       	push   $0x119
c0020c86:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020c8b:	e8 7d 76 00 00       	call   c002830d <debug_panic>
  ASSERT (t->status == THREAD_BLOCKED);
c0020c90:	83 ec 0c             	sub    $0xc,%esp
c0020c93:	68 2b dd 02 c0       	push   $0xc002dd2b
c0020c98:	68 3f d9 02 c0       	push   $0xc002d93f
c0020c9d:	68 b8 c2 02 c0       	push   $0xc002c2b8
c0020ca2:	68 1c 01 00 00       	push   $0x11c
c0020ca7:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020cac:	e8 5c 76 00 00       	call   c002830d <debug_panic>

c0020cb1 <thread_update_sleep>:
{
c0020cb1:	53                   	push   %ebx
c0020cb2:	83 ec 08             	sub    $0x8,%esp
c0020cb5:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (is_thread(t));
c0020cb9:	89 d8                	mov    %ebx,%eax
c0020cbb:	e8 e6 fb ff ff       	call   c00208a6 <is_thread>
c0020cc0:	84 c0                	test   %al,%al
c0020cc2:	74 14                	je     c0020cd8 <thread_update_sleep+0x27>
  if (t->sleep_remain > 0) {
c0020cc4:	8b 43 24             	mov    0x24(%ebx),%eax
c0020cc7:	85 c0                	test   %eax,%eax
c0020cc9:	7e 08                	jle    c0020cd3 <thread_update_sleep+0x22>
    if (!--(t->sleep_remain)) {
c0020ccb:	48                   	dec    %eax
c0020ccc:	89 43 24             	mov    %eax,0x24(%ebx)
c0020ccf:	85 c0                	test   %eax,%eax
c0020cd1:	74 26                	je     c0020cf9 <thread_update_sleep+0x48>
}
c0020cd3:	83 c4 08             	add    $0x8,%esp
c0020cd6:	5b                   	pop    %ebx
c0020cd7:	c3                   	ret    
  ASSERT (is_thread(t));
c0020cd8:	83 ec 0c             	sub    $0xc,%esp
c0020cdb:	68 47 dd 02 c0       	push   $0xc002dd47
c0020ce0:	68 3f d9 02 c0       	push   $0xc002d93f
c0020ce5:	68 08 c2 02 c0       	push   $0xc002c208
c0020cea:	68 33 02 00 00       	push   $0x233
c0020cef:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020cf4:	e8 14 76 00 00       	call   c002830d <debug_panic>
      thread_unblock (t);
c0020cf9:	83 ec 0c             	sub    $0xc,%esp
c0020cfc:	53                   	push   %ebx
c0020cfd:	e8 2b ff ff ff       	call   c0020c2d <thread_unblock>
c0020d02:	83 c4 10             	add    $0x10,%esp
}
c0020d05:	eb cc                	jmp    c0020cd3 <thread_update_sleep+0x22>

c0020d07 <thread_set_nice>:
{
c0020d07:	83 ec 0c             	sub    $0xc,%esp
  thread_current()->nice = nice;
c0020d0a:	e8 77 fd ff ff       	call   c0020a86 <thread_current>
c0020d0f:	8b 54 24 10          	mov    0x10(%esp),%edx
c0020d13:	89 50 28             	mov    %edx,0x28(%eax)
  if (thread_mlfqs) {
c0020d16:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0020d1d:	75 04                	jne    c0020d23 <thread_set_nice+0x1c>
}
c0020d1f:	83 c4 0c             	add    $0xc,%esp
c0020d22:	c3                   	ret    
    thread_update_priority(thread_current(), NULL);
c0020d23:	e8 5e fd ff ff       	call   c0020a86 <thread_current>
c0020d28:	83 ec 08             	sub    $0x8,%esp
c0020d2b:	6a 00                	push   $0x0
c0020d2d:	50                   	push   %eax
c0020d2e:	e8 38 fc ff ff       	call   c002096b <thread_update_priority>
c0020d33:	83 c4 10             	add    $0x10,%esp
}
c0020d36:	eb e7                	jmp    c0020d1f <thread_set_nice+0x18>

c0020d38 <thread_get_nice>:
{
c0020d38:	83 ec 0c             	sub    $0xc,%esp
  return thread_current()->nice;
c0020d3b:	e8 46 fd ff ff       	call   c0020a86 <thread_current>
c0020d40:	8b 40 28             	mov    0x28(%eax),%eax
}
c0020d43:	83 c4 0c             	add    $0xc,%esp
c0020d46:	c3                   	ret    

c0020d47 <thread_get_certain_priority>:
{
c0020d47:	8b 54 24 04          	mov    0x4(%esp),%edx
  if (thread_mlfqs) {
c0020d4b:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0020d52:	75 07                	jne    c0020d5b <thread_get_certain_priority+0x14>
    return t->max_donate_delta + t->priority;
c0020d54:	8b 42 20             	mov    0x20(%edx),%eax
c0020d57:	03 42 40             	add    0x40(%edx),%eax
}
c0020d5a:	c3                   	ret    
    return t->priority;
c0020d5b:	8b 42 20             	mov    0x20(%edx),%eax
c0020d5e:	c3                   	ret    

c0020d5f <thread_get_priority>:
{
c0020d5f:	83 ec 0c             	sub    $0xc,%esp
  return thread_get_certain_priority (thread_current ());
c0020d62:	e8 1f fd ff ff       	call   c0020a86 <thread_current>
c0020d67:	83 ec 0c             	sub    $0xc,%esp
c0020d6a:	50                   	push   %eax
c0020d6b:	e8 d7 ff ff ff       	call   c0020d47 <thread_get_certain_priority>
}
c0020d70:	83 c4 1c             	add    $0x1c,%esp
c0020d73:	c3                   	ret    

c0020d74 <thread_priority_greater>:
{
c0020d74:	53                   	push   %ebx
  return thread_get_certain_priority (list_entry (a_, struct thread, elem))
c0020d75:	8b 44 24 08          	mov    0x8(%esp),%eax
c0020d79:	83 e8 5c             	sub    $0x5c,%eax
c0020d7c:	50                   	push   %eax
c0020d7d:	e8 c5 ff ff ff       	call   c0020d47 <thread_get_certain_priority>
c0020d82:	89 c3                	mov    %eax,%ebx
       > thread_get_certain_priority (list_entry (b_, struct thread, elem));
c0020d84:	8b 44 24 10          	mov    0x10(%esp),%eax
c0020d88:	83 e8 5c             	sub    $0x5c,%eax
c0020d8b:	89 04 24             	mov    %eax,(%esp)
c0020d8e:	e8 b4 ff ff ff       	call   c0020d47 <thread_get_certain_priority>
c0020d93:	83 c4 04             	add    $0x4,%esp
c0020d96:	39 c3                	cmp    %eax,%ebx
c0020d98:	0f 9f c0             	setg   %al
}
c0020d9b:	5b                   	pop    %ebx
c0020d9c:	c3                   	ret    

c0020d9d <thread_get_load_avg>:
{
c0020d9d:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT(thread_mlfqs);
c0020da0:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0020da7:	74 22                	je     c0020dcb <thread_get_load_avg+0x2e>
  return fixed32_round(fixed32_mul_int(load_avg, 100));
c0020da9:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020dad:	83 ec 04             	sub    $0x4,%esp
c0020db0:	6a 64                	push   $0x64
c0020db2:	ff 35 dc 82 03 c0    	pushl  0xc00382dc
c0020db8:	50                   	push   %eax
c0020db9:	e8 6d 2d 00 00       	call   c0023b2b <fixed32_mul_int>
c0020dbe:	ff 74 24 18          	pushl  0x18(%esp)
c0020dc2:	e8 1a 2c 00 00       	call   c00239e1 <fixed32_round>
}
c0020dc7:	83 c4 2c             	add    $0x2c,%esp
c0020dca:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0020dcb:	83 ec 0c             	sub    $0xc,%esp
c0020dce:	68 95 f8 02 c0       	push   $0xc002f895
c0020dd3:	68 3f d9 02 c0       	push   $0xc002d93f
c0020dd8:	68 4c c2 02 c0       	push   $0xc002c24c
c0020ddd:	68 f7 01 00 00       	push   $0x1f7
c0020de2:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020de7:	e8 21 75 00 00       	call   c002830d <debug_panic>

c0020dec <thread_update_recent_cpu>:
{
c0020dec:	57                   	push   %edi
c0020ded:	56                   	push   %esi
c0020dee:	53                   	push   %ebx
c0020def:	83 ec 10             	sub    $0x10,%esp
c0020df2:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  ASSERT(thread_mlfqs);
c0020df6:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0020dfd:	74 48                	je     c0020e47 <thread_update_recent_cpu+0x5b>
  int load_avg_2 = thread_get_load_avg() * 2;
c0020dff:	e8 99 ff ff ff       	call   c0020d9d <thread_get_load_avg>
c0020e04:	01 c0                	add    %eax,%eax
  t->recent_cpu = fixed32_add_int(
c0020e06:	8b 7b 28             	mov    0x28(%ebx),%edi
c0020e09:	8d 74 24 0c          	lea    0xc(%esp),%esi
c0020e0d:	83 ec 04             	sub    $0x4,%esp
c0020e10:	8d 50 64             	lea    0x64(%eax),%edx
c0020e13:	52                   	push   %edx
c0020e14:	50                   	push   %eax
c0020e15:	56                   	push   %esi
c0020e16:	e8 68 2d 00 00       	call   c0023b83 <fixed32_div_int_int>
c0020e1b:	83 ec 08             	sub    $0x8,%esp
c0020e1e:	ff 73 2c             	pushl  0x2c(%ebx)
c0020e21:	ff 74 24 24          	pushl  0x24(%esp)
c0020e25:	56                   	push   %esi
c0020e26:	e8 b3 2c 00 00       	call   c0023ade <fixed32_mul>
c0020e2b:	83 c4 08             	add    $0x8,%esp
c0020e2e:	57                   	push   %edi
c0020e2f:	ff 74 24 24          	pushl  0x24(%esp)
c0020e33:	56                   	push   %esi
c0020e34:	e8 6a 2c 00 00       	call   c0023aa3 <fixed32_add_int>
c0020e39:	8b 44 24 28          	mov    0x28(%esp),%eax
c0020e3d:	89 43 2c             	mov    %eax,0x2c(%ebx)
}
c0020e40:	83 c4 2c             	add    $0x2c,%esp
c0020e43:	5b                   	pop    %ebx
c0020e44:	5e                   	pop    %esi
c0020e45:	5f                   	pop    %edi
c0020e46:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0020e47:	83 ec 0c             	sub    $0xc,%esp
c0020e4a:	68 95 f8 02 c0       	push   $0xc002f895
c0020e4f:	68 3f d9 02 c0       	push   $0xc002d93f
c0020e54:	68 ec c1 02 c0       	push   $0xc002c1ec
c0020e59:	68 0a 02 00 00       	push   $0x20a
c0020e5e:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020e63:	e8 a5 74 00 00       	call   c002830d <debug_panic>

c0020e68 <thread_add_recent_cpu>:
{
c0020e68:	53                   	push   %ebx
c0020e69:	83 ec 18             	sub    $0x18,%esp
  ASSERT(thread_mlfqs);
c0020e6c:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0020e73:	74 3b                	je     c0020eb0 <thread_add_recent_cpu+0x48>
  struct thread* t = thread_current();
c0020e75:	e8 0c fc ff ff       	call   c0020a86 <thread_current>
c0020e7a:	89 c3                	mov    %eax,%ebx
  if (t != idle_thread) {
c0020e7c:	3b 05 b8 82 03 c0    	cmp    0xc00382b8,%eax
c0020e82:	74 1c                	je     c0020ea0 <thread_add_recent_cpu+0x38>
    t->recent_cpu = fixed32_add_int(t->recent_cpu, 1);
c0020e84:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020e88:	83 ec 04             	sub    $0x4,%esp
c0020e8b:	6a 01                	push   $0x1
c0020e8d:	ff 73 2c             	pushl  0x2c(%ebx)
c0020e90:	50                   	push   %eax
c0020e91:	e8 0d 2c 00 00       	call   c0023aa3 <fixed32_add_int>
c0020e96:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020e9a:	89 43 2c             	mov    %eax,0x2c(%ebx)
c0020e9d:	83 c4 0c             	add    $0xc,%esp
  thread_update_priority(t, NULL);
c0020ea0:	83 ec 08             	sub    $0x8,%esp
c0020ea3:	6a 00                	push   $0x0
c0020ea5:	53                   	push   %ebx
c0020ea6:	e8 c0 fa ff ff       	call   c002096b <thread_update_priority>
}
c0020eab:	83 c4 28             	add    $0x28,%esp
c0020eae:	5b                   	pop    %ebx
c0020eaf:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0020eb0:	83 ec 0c             	sub    $0xc,%esp
c0020eb3:	68 95 f8 02 c0       	push   $0xc002f895
c0020eb8:	68 3f d9 02 c0       	push   $0xc002d93f
c0020ebd:	68 34 c2 02 c0       	push   $0xc002c234
c0020ec2:	68 fe 01 00 00       	push   $0x1fe
c0020ec7:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020ecc:	e8 3c 74 00 00       	call   c002830d <debug_panic>

c0020ed1 <thread_get_recent_cpu>:
{
c0020ed1:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT(thread_mlfqs);
c0020ed4:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0020edb:	74 24                	je     c0020f01 <thread_get_recent_cpu+0x30>
  return fixed32_trunc(fixed32_mul_int(thread_current()->recent_cpu, 100));
c0020edd:	e8 a4 fb ff ff       	call   c0020a86 <thread_current>
c0020ee2:	8d 54 24 0c          	lea    0xc(%esp),%edx
c0020ee6:	83 ec 04             	sub    $0x4,%esp
c0020ee9:	6a 64                	push   $0x64
c0020eeb:	ff 70 2c             	pushl  0x2c(%eax)
c0020eee:	52                   	push   %edx
c0020eef:	e8 37 2c 00 00       	call   c0023b2b <fixed32_mul_int>
c0020ef4:	ff 74 24 18          	pushl  0x18(%esp)
c0020ef8:	e8 ce 2a 00 00       	call   c00239cb <fixed32_trunc>
}
c0020efd:	83 c4 2c             	add    $0x2c,%esp
c0020f00:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0020f01:	83 ec 0c             	sub    $0xc,%esp
c0020f04:	68 95 f8 02 c0       	push   $0xc002f895
c0020f09:	68 3f d9 02 c0       	push   $0xc002d93f
c0020f0e:	68 1c c2 02 c0       	push   $0xc002c21c
c0020f13:	68 16 02 00 00       	push   $0x216
c0020f18:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020f1d:	e8 eb 73 00 00       	call   c002830d <debug_panic>

c0020f22 <thread_tick_events>:
void thread_tick_events(bool a_second) {
c0020f22:	56                   	push   %esi
c0020f23:	53                   	push   %ebx
c0020f24:	83 ec 14             	sub    $0x14,%esp
c0020f27:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  if (thread_mlfqs) {
c0020f2b:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0020f32:	75 15                	jne    c0020f49 <thread_tick_events+0x27>
  thread_foreach(thread_update_sleep, NULL);
c0020f34:	83 ec 08             	sub    $0x8,%esp
c0020f37:	6a 00                	push   $0x0
c0020f39:	68 b1 0c 02 c0       	push   $0xc0020cb1
c0020f3e:	e8 10 fc ff ff       	call   c0020b53 <thread_foreach>
}
c0020f43:	83 c4 24             	add    $0x24,%esp
c0020f46:	5b                   	pop    %ebx
c0020f47:	5e                   	pop    %esi
c0020f48:	c3                   	ret    
    thread_add_recent_cpu();
c0020f49:	e8 1a ff ff ff       	call   c0020e68 <thread_add_recent_cpu>
    if (a_second) {
c0020f4e:	84 db                	test   %bl,%bl
c0020f50:	74 e2                	je     c0020f34 <thread_tick_events+0x12>
  ASSERT(thread_mlfqs);
c0020f52:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0020f59:	74 19                	je     c0020f74 <thread_tick_events+0x52>
  for (e = list_begin (&all_list); e != list_end (&all_list); e = list_next (e)) {
c0020f5b:	83 ec 0c             	sub    $0xc,%esp
c0020f5e:	68 bc 82 03 c0       	push   $0xc00382bc
c0020f63:	e8 8f 74 00 00       	call   c00283f7 <list_begin>
c0020f68:	89 c3                	mov    %eax,%ebx
c0020f6a:	83 c4 10             	add    $0x10,%esp
  int ready_count = 0;
c0020f6d:	be 00 00 00 00       	mov    $0x0,%esi
c0020f72:	eb 2f                	jmp    c0020fa3 <thread_tick_events+0x81>
  ASSERT(thread_mlfqs);
c0020f74:	83 ec 0c             	sub    $0xc,%esp
c0020f77:	68 95 f8 02 c0       	push   $0xc002f895
c0020f7c:	68 3f d9 02 c0       	push   $0xc002d93f
c0020f81:	68 d4 c1 02 c0       	push   $0xc002c1d4
c0020f86:	68 d0 01 00 00       	push   $0x1d0
c0020f8b:	68 6c dc 02 c0       	push   $0xc002dc6c
c0020f90:	e8 78 73 00 00       	call   c002830d <debug_panic>
  for (e = list_begin (&all_list); e != list_end (&all_list); e = list_next (e)) {
c0020f95:	83 ec 0c             	sub    $0xc,%esp
c0020f98:	53                   	push   %ebx
c0020f99:	e8 89 74 00 00       	call   c0028427 <list_next>
c0020f9e:	89 c3                	mov    %eax,%ebx
c0020fa0:	83 c4 10             	add    $0x10,%esp
c0020fa3:	83 ec 0c             	sub    $0xc,%esp
c0020fa6:	68 bc 82 03 c0       	push   $0xc00382bc
c0020fab:	e8 bf 74 00 00       	call   c002846f <list_end>
c0020fb0:	83 c4 10             	add    $0x10,%esp
c0020fb3:	39 c3                	cmp    %eax,%ebx
c0020fb5:	74 14                	je     c0020fcb <thread_tick_events+0xa9>
    if ((t->status == THREAD_RUNNING || t->status == THREAD_READY) && t != idle_thread) {
c0020fb7:	83 7b b4 01          	cmpl   $0x1,-0x4c(%ebx)
c0020fbb:	77 d8                	ja     c0020f95 <thread_tick_events+0x73>
    struct thread *t = list_entry (e, struct thread, allelem);
c0020fbd:	8d 43 ac             	lea    -0x54(%ebx),%eax
    if ((t->status == THREAD_RUNNING || t->status == THREAD_READY) && t != idle_thread) {
c0020fc0:	39 05 b8 82 03 c0    	cmp    %eax,0xc00382b8
c0020fc6:	74 cd                	je     c0020f95 <thread_tick_events+0x73>
      ready_count++;
c0020fc8:	46                   	inc    %esi
c0020fc9:	eb ca                	jmp    c0020f95 <thread_tick_events+0x73>
  load_avg = fixed32_div_int(
c0020fcb:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
c0020fcf:	83 ec 04             	sub    $0x4,%esp
c0020fd2:	6a 3b                	push   $0x3b
c0020fd4:	ff 35 dc 82 03 c0    	pushl  0xc00382dc
c0020fda:	53                   	push   %ebx
c0020fdb:	e8 4b 2b 00 00       	call   c0023b2b <fixed32_mul_int>
c0020fe0:	83 ec 08             	sub    $0x8,%esp
c0020fe3:	56                   	push   %esi
c0020fe4:	ff 74 24 24          	pushl  0x24(%esp)
c0020fe8:	53                   	push   %ebx
c0020fe9:	e8 b5 2a 00 00       	call   c0023aa3 <fixed32_add_int>
c0020fee:	83 c4 08             	add    $0x8,%esp
c0020ff1:	6a 3c                	push   $0x3c
c0020ff3:	ff 74 24 24          	pushl  0x24(%esp)
c0020ff7:	53                   	push   %ebx
c0020ff8:	e8 72 2b 00 00       	call   c0023b6f <fixed32_div_int>
c0020ffd:	8b 44 24 28          	mov    0x28(%esp),%eax
c0021001:	a3 dc 82 03 c0       	mov    %eax,0xc00382dc
      thread_foreach(thread_update_recent_cpu, NULL);
c0021006:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002100d:	68 ec 0d 02 c0       	push   $0xc0020dec
c0021012:	e8 3c fb ff ff       	call   c0020b53 <thread_foreach>
      thread_foreach(thread_update_priority, NULL);
c0021017:	83 c4 18             	add    $0x18,%esp
c002101a:	6a 00                	push   $0x0
c002101c:	68 6b 09 02 c0       	push   $0xc002096b
c0021021:	e8 2d fb ff ff       	call   c0020b53 <thread_foreach>
c0021026:	83 c4 10             	add    $0x10,%esp
c0021029:	e9 06 ff ff ff       	jmp    c0020f34 <thread_tick_events+0x12>

c002102e <thread_schedule_tail>:
{
c002102e:	56                   	push   %esi
c002102f:	53                   	push   %ebx
c0021030:	83 ec 04             	sub    $0x4,%esp
c0021033:	8b 74 24 10          	mov    0x10(%esp),%esi
  asm ("mov %%esp, %0" : "=g" (esp));
c0021037:	89 e3                	mov    %esp,%ebx
c0021039:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c002103f:	e8 75 06 00 00       	call   c00216b9 <intr_get_level>
c0021044:	85 c0                	test   %eax,%eax
c0021046:	75 21                	jne    c0021069 <thread_schedule_tail+0x3b>
  cur->status = THREAD_RUNNING;
c0021048:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  thread_ticks = 0;
c002104f:	c7 05 60 82 03 c0 00 	movl   $0x0,0xc0038260
c0021056:	00 00 00 
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0021059:	85 f6                	test   %esi,%esi
c002105b:	74 06                	je     c0021063 <thread_schedule_tail+0x35>
c002105d:	83 7e 08 03          	cmpl   $0x3,0x8(%esi)
c0021061:	74 27                	je     c002108a <thread_schedule_tail+0x5c>
}
c0021063:	83 c4 04             	add    $0x4,%esp
c0021066:	5b                   	pop    %ebx
c0021067:	5e                   	pop    %esi
c0021068:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0021069:	83 ec 0c             	sub    $0xc,%esp
c002106c:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0021071:	68 3f d9 02 c0       	push   $0xc002d93f
c0021076:	68 bc c1 02 c0       	push   $0xc002c1bc
c002107b:	68 f2 02 00 00       	push   $0x2f2
c0021080:	68 6c dc 02 c0       	push   $0xc002dc6c
c0021085:	e8 83 72 00 00       	call   c002830d <debug_panic>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c002108a:	3b 35 b4 82 03 c0    	cmp    0xc00382b4,%esi
c0021090:	74 d1                	je     c0021063 <thread_schedule_tail+0x35>
      ASSERT (prev != cur);
c0021092:	39 de                	cmp    %ebx,%esi
c0021094:	74 0e                	je     c00210a4 <thread_schedule_tail+0x76>
      palloc_free_page (prev);
c0021096:	83 ec 0c             	sub    $0xc,%esp
c0021099:	56                   	push   %esi
c002109a:	e8 d8 23 00 00       	call   c0023477 <palloc_free_page>
c002109f:	83 c4 10             	add    $0x10,%esp
}
c00210a2:	eb bf                	jmp    c0021063 <thread_schedule_tail+0x35>
      ASSERT (prev != cur);
c00210a4:	83 ec 0c             	sub    $0xc,%esp
c00210a7:	68 54 dd 02 c0       	push   $0xc002dd54
c00210ac:	68 3f d9 02 c0       	push   $0xc002d93f
c00210b1:	68 bc c1 02 c0       	push   $0xc002c1bc
c00210b6:	68 06 03 00 00       	push   $0x306
c00210bb:	68 6c dc 02 c0       	push   $0xc002dc6c
c00210c0:	e8 48 72 00 00       	call   c002830d <debug_panic>

c00210c5 <schedule>:
{
c00210c5:	56                   	push   %esi
c00210c6:	53                   	push   %ebx
c00210c7:	83 ec 10             	sub    $0x10,%esp
  asm ("mov %%esp, %0" : "=g" (esp));
c00210ca:	89 e3                	mov    %esp,%ebx
c00210cc:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  if (list_empty (&ready_list))
c00210d2:	68 cc 82 03 c0       	push   $0xc00382cc
c00210d7:	e8 cc 77 00 00       	call   c00288a8 <list_empty>
c00210dc:	83 c4 10             	add    $0x10,%esp
c00210df:	84 c0                	test   %al,%al
c00210e1:	74 44                	je     c0021127 <schedule+0x62>
    return idle_thread;
c00210e3:	8b 35 b8 82 03 c0    	mov    0xc00382b8,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c00210e9:	e8 cb 05 00 00       	call   c00216b9 <intr_get_level>
c00210ee:	85 c0                	test   %eax,%eax
c00210f0:	75 4d                	jne    c002113f <schedule+0x7a>
  ASSERT (cur->status != THREAD_RUNNING);
c00210f2:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c00210f6:	74 68                	je     c0021160 <schedule+0x9b>
  ASSERT (is_thread (next));
c00210f8:	89 f0                	mov    %esi,%eax
c00210fa:	e8 a7 f7 ff ff       	call   c00208a6 <is_thread>
c00210ff:	84 c0                	test   %al,%al
c0021101:	74 7e                	je     c0021181 <schedule+0xbc>
  if (cur != next)
c0021103:	39 de                	cmp    %ebx,%esi
c0021105:	0f 84 97 00 00 00    	je     c00211a2 <schedule+0xdd>
    prev = switch_threads (cur, next);
c002110b:	83 ec 08             	sub    $0x8,%esp
c002110e:	56                   	push   %esi
c002110f:	53                   	push   %ebx
c0021110:	e8 53 04 00 00       	call   c0021568 <switch_threads>
c0021115:	83 c4 10             	add    $0x10,%esp
  thread_schedule_tail (prev);
c0021118:	83 ec 0c             	sub    $0xc,%esp
c002111b:	50                   	push   %eax
c002111c:	e8 0d ff ff ff       	call   c002102e <thread_schedule_tail>
}
c0021121:	83 c4 14             	add    $0x14,%esp
c0021124:	5b                   	pop    %ebx
c0021125:	5e                   	pop    %esi
c0021126:	c3                   	ret    
    struct list_elem* e = thread_ready_list_get_min();
c0021127:	e8 9f fa ff ff       	call   c0020bcb <thread_ready_list_get_min>
c002112c:	89 c6                	mov    %eax,%esi
    list_remove(e);
c002112e:	83 ec 0c             	sub    $0xc,%esp
c0021131:	50                   	push   %eax
c0021132:	e8 e6 76 00 00       	call   c002881d <list_remove>
    return list_entry (e, struct thread, elem);
c0021137:	83 ee 5c             	sub    $0x5c,%esi
c002113a:	83 c4 10             	add    $0x10,%esp
c002113d:	eb aa                	jmp    c00210e9 <schedule+0x24>
  ASSERT (intr_get_level () == INTR_OFF);
c002113f:	83 ec 0c             	sub    $0xc,%esp
c0021142:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0021147:	68 3f d9 02 c0       	push   $0xc002d93f
c002114c:	68 c8 c2 02 c0       	push   $0xc002c2c8
c0021151:	68 19 03 00 00       	push   $0x319
c0021156:	68 6c dc 02 c0       	push   $0xc002dc6c
c002115b:	e8 ad 71 00 00       	call   c002830d <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0021160:	83 ec 0c             	sub    $0xc,%esp
c0021163:	68 60 dd 02 c0       	push   $0xc002dd60
c0021168:	68 3f d9 02 c0       	push   $0xc002d93f
c002116d:	68 c8 c2 02 c0       	push   $0xc002c2c8
c0021172:	68 1a 03 00 00       	push   $0x31a
c0021177:	68 6c dc 02 c0       	push   $0xc002dc6c
c002117c:	e8 8c 71 00 00       	call   c002830d <debug_panic>
  ASSERT (is_thread (next));
c0021181:	83 ec 0c             	sub    $0xc,%esp
c0021184:	68 7e dd 02 c0       	push   $0xc002dd7e
c0021189:	68 3f d9 02 c0       	push   $0xc002d93f
c002118e:	68 c8 c2 02 c0       	push   $0xc002c2c8
c0021193:	68 1b 03 00 00       	push   $0x31b
c0021198:	68 6c dc 02 c0       	push   $0xc002dc6c
c002119d:	e8 6b 71 00 00       	call   c002830d <debug_panic>
  struct thread *prev = NULL;
c00211a2:	b8 00 00 00 00       	mov    $0x0,%eax
c00211a7:	e9 6c ff ff ff       	jmp    c0021118 <schedule+0x53>

c00211ac <thread_block>:
{
c00211ac:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (!intr_context ());
c00211af:	e8 63 07 00 00       	call   c0021917 <intr_context>
c00211b4:	84 c0                	test   %al,%al
c00211b6:	75 1e                	jne    c00211d6 <thread_block+0x2a>
  ASSERT (intr_get_level () == INTR_OFF);
c00211b8:	e8 fc 04 00 00       	call   c00216b9 <intr_get_level>
c00211bd:	85 c0                	test   %eax,%eax
c00211bf:	75 36                	jne    c00211f7 <thread_block+0x4b>
  thread_current ()->status = THREAD_BLOCKED;
c00211c1:	e8 c0 f8 ff ff       	call   c0020a86 <thread_current>
c00211c6:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
  schedule ();
c00211cd:	e8 f3 fe ff ff       	call   c00210c5 <schedule>
}
c00211d2:	83 c4 0c             	add    $0xc,%esp
c00211d5:	c3                   	ret    
  ASSERT (!intr_context ());
c00211d6:	83 ec 0c             	sub    $0xc,%esp
c00211d9:	68 8f dd 02 c0       	push   $0xc002dd8f
c00211de:	68 3f d9 02 c0       	push   $0xc002d93f
c00211e3:	68 d4 c2 02 c0       	push   $0xc002c2d4
c00211e8:	68 05 01 00 00       	push   $0x105
c00211ed:	68 6c dc 02 c0       	push   $0xc002dc6c
c00211f2:	e8 16 71 00 00       	call   c002830d <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c00211f7:	83 ec 0c             	sub    $0xc,%esp
c00211fa:	68 d2 dc 02 c0       	push   $0xc002dcd2
c00211ff:	68 3f d9 02 c0       	push   $0xc002d93f
c0021204:	68 d4 c2 02 c0       	push   $0xc002c2d4
c0021209:	68 06 01 00 00       	push   $0x106
c002120e:	68 6c dc 02 c0       	push   $0xc002dc6c
c0021213:	e8 f5 70 00 00       	call   c002830d <debug_panic>

c0021218 <idle>:
{
c0021218:	83 ec 0c             	sub    $0xc,%esp
  idle_thread = thread_current ();
c002121b:	e8 66 f8 ff ff       	call   c0020a86 <thread_current>
c0021220:	a3 b8 82 03 c0       	mov    %eax,0xc00382b8
  sema_up (idle_started);
c0021225:	83 ec 0c             	sub    $0xc,%esp
c0021228:	ff 74 24 1c          	pushl  0x1c(%esp)
c002122c:	e8 42 16 00 00       	call   c0022873 <sema_up>
c0021231:	83 c4 10             	add    $0x10,%esp
      intr_disable ();
c0021234:	e8 bd 04 00 00       	call   c00216f6 <intr_disable>
      thread_block ();
c0021239:	e8 6e ff ff ff       	call   c00211ac <thread_block>
      asm volatile ("sti; hlt" : : : "memory");
c002123e:	fb                   	sti    
c002123f:	f4                   	hlt    
c0021240:	eb f2                	jmp    c0021234 <idle+0x1c>

c0021242 <thread_exit>:
{
c0021242:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (!intr_context ());
c0021245:	e8 cd 06 00 00       	call   c0021917 <intr_context>
c002124a:	84 c0                	test   %al,%al
c002124c:	74 21                	je     c002126f <thread_exit+0x2d>
c002124e:	83 ec 0c             	sub    $0xc,%esp
c0021251:	68 8f dd 02 c0       	push   $0xc002dd8f
c0021256:	68 3f d9 02 c0       	push   $0xc002d93f
c002125b:	68 9c c2 02 c0       	push   $0xc002c29c
c0021260:	68 56 01 00 00       	push   $0x156
c0021265:	68 6c dc 02 c0       	push   $0xc002dc6c
c002126a:	e8 9e 70 00 00       	call   c002830d <debug_panic>
	intr_disable ();
c002126f:	e8 82 04 00 00       	call   c00216f6 <intr_disable>
	list_remove (&thread_current()->allelem);
c0021274:	e8 0d f8 ff ff       	call   c0020a86 <thread_current>
c0021279:	83 ec 0c             	sub    $0xc,%esp
c002127c:	83 c0 54             	add    $0x54,%eax
c002127f:	50                   	push   %eax
c0021280:	e8 98 75 00 00       	call   c002881d <list_remove>
	thread_current ()->status = THREAD_DYING;
c0021285:	e8 fc f7 ff ff       	call   c0020a86 <thread_current>
c002128a:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	schedule ();
c0021291:	e8 2f fe ff ff       	call   c00210c5 <schedule>
	NOT_REACHED ();
c0021296:	68 24 de 02 c0       	push   $0xc002de24
c002129b:	68 9c c2 02 c0       	push   $0xc002c29c
c00212a0:	68 6c 01 00 00       	push   $0x16c
c00212a5:	68 6c dc 02 c0       	push   $0xc002dc6c
c00212aa:	e8 5e 70 00 00       	call   c002830d <debug_panic>

c00212af <kernel_thread>:
{
c00212af:	53                   	push   %ebx
c00212b0:	83 ec 08             	sub    $0x8,%esp
c00212b3:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (function != NULL);
c00212b7:	85 db                	test   %ebx,%ebx
c00212b9:	74 13                	je     c00212ce <kernel_thread+0x1f>
  intr_enable ();       /* The scheduler runs with interrupts off. */
c00212bb:	e8 02 04 00 00       	call   c00216c2 <intr_enable>
  function (aux);       /* Execute the thread function. */
c00212c0:	83 ec 0c             	sub    $0xc,%esp
c00212c3:	ff 74 24 20          	pushl  0x20(%esp)
c00212c7:	ff d3                	call   *%ebx
  thread_exit ();       /* If function() returns, kill the thread. */
c00212c9:	e8 74 ff ff ff       	call   c0021242 <thread_exit>
  ASSERT (function != NULL);
c00212ce:	83 ec 0c             	sub    $0xc,%esp
c00212d1:	68 a0 dd 02 c0       	push   $0xc002dda0
c00212d6:	68 3f d9 02 c0       	push   $0xc002d93f
c00212db:	68 f0 c2 02 c0       	push   $0xc002c2f0
c00212e0:	68 66 02 00 00       	push   $0x266
c00212e5:	68 6c dc 02 c0       	push   $0xc002dc6c
c00212ea:	e8 1e 70 00 00       	call   c002830d <debug_panic>

c00212ef <thread_yield>:
{
c00212ef:	56                   	push   %esi
c00212f0:	53                   	push   %ebx
c00212f1:	83 ec 04             	sub    $0x4,%esp
  struct thread *cur = thread_current ();
c00212f4:	e8 8d f7 ff ff       	call   c0020a86 <thread_current>
c00212f9:	89 c3                	mov    %eax,%ebx
  ASSERT (!intr_context ());
c00212fb:	e8 17 06 00 00       	call   c0021917 <intr_context>
c0021300:	84 c0                	test   %al,%al
c0021302:	75 39                	jne    c002133d <thread_yield+0x4e>
  old_level = intr_disable ();
c0021304:	e8 ed 03 00 00       	call   c00216f6 <intr_disable>
c0021309:	89 c6                	mov    %eax,%esi
  if (cur != idle_thread) 
c002130b:	3b 1d b8 82 03 c0    	cmp    0xc00382b8,%ebx
c0021311:	74 0f                	je     c0021322 <thread_yield+0x33>
    thread_insert_ready_list (&cur->elem);
c0021313:	83 ec 0c             	sub    $0xc,%esp
c0021316:	8d 43 5c             	lea    0x5c(%ebx),%eax
c0021319:	50                   	push   %eax
c002131a:	e8 f9 f8 ff ff       	call   c0020c18 <thread_insert_ready_list>
c002131f:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0021322:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
  schedule ();
c0021329:	e8 97 fd ff ff       	call   c00210c5 <schedule>
  intr_set_level (old_level);
c002132e:	83 ec 0c             	sub    $0xc,%esp
c0021331:	56                   	push   %esi
c0021332:	e8 c6 03 00 00       	call   c00216fd <intr_set_level>
}
c0021337:	83 c4 14             	add    $0x14,%esp
c002133a:	5b                   	pop    %ebx
c002133b:	5e                   	pop    %esi
c002133c:	c3                   	ret    
  ASSERT (!intr_context ());
c002133d:	83 ec 0c             	sub    $0xc,%esp
c0021340:	68 8f dd 02 c0       	push   $0xc002dd8f
c0021345:	68 3f d9 02 c0       	push   $0xc002d93f
c002134a:	68 8c c2 02 c0       	push   $0xc002c28c
c002134f:	68 77 01 00 00       	push   $0x177
c0021354:	68 6c dc 02 c0       	push   $0xc002dc6c
c0021359:	e8 af 6f 00 00       	call   c002830d <debug_panic>

c002135e <thread_check_switch>:
void thread_check_switch() {
c002135e:	56                   	push   %esi
c002135f:	53                   	push   %ebx
c0021360:	83 ec 04             	sub    $0x4,%esp
	enum intr_level old_level = intr_disable();
c0021363:	e8 8e 03 00 00       	call   c00216f6 <intr_disable>
c0021368:	89 c3                	mov    %eax,%ebx
  if (thread_current () != idle_thread &&
c002136a:	e8 17 f7 ff ff       	call   c0020a86 <thread_current>
c002136f:	3b 05 b8 82 03 c0    	cmp    0xc00382b8,%eax
c0021375:	74 14                	je     c002138b <thread_check_switch+0x2d>
   !list_empty (&ready_list) && 
c0021377:	83 ec 0c             	sub    $0xc,%esp
c002137a:	68 cc 82 03 c0       	push   $0xc00382cc
c002137f:	e8 24 75 00 00       	call   c00288a8 <list_empty>
  if (thread_current () != idle_thread &&
c0021384:	83 c4 10             	add    $0x10,%esp
c0021387:	84 c0                	test   %al,%al
c0021389:	74 12                	je     c002139d <thread_check_switch+0x3f>
    intr_set_level (old_level);
c002138b:	83 ec 0c             	sub    $0xc,%esp
c002138e:	53                   	push   %ebx
c002138f:	e8 69 03 00 00       	call   c00216fd <intr_set_level>
c0021394:	83 c4 10             	add    $0x10,%esp
}
c0021397:	83 c4 04             	add    $0x4,%esp
c002139a:	5b                   	pop    %ebx
c002139b:	5e                   	pop    %esi
c002139c:	c3                   	ret    
   thread_get_priority () <
c002139d:	e8 bd f9 ff ff       	call   c0020d5f <thread_get_priority>
c00213a2:	89 c6                	mov    %eax,%esi
   thread_get_certain_priority (list_entry (thread_ready_list_get_min(), struct thread, elem))) {
c00213a4:	e8 22 f8 ff ff       	call   c0020bcb <thread_ready_list_get_min>
c00213a9:	83 ec 0c             	sub    $0xc,%esp
c00213ac:	83 e8 5c             	sub    $0x5c,%eax
c00213af:	50                   	push   %eax
c00213b0:	e8 92 f9 ff ff       	call   c0020d47 <thread_get_certain_priority>
c00213b5:	83 c4 10             	add    $0x10,%esp
   !list_empty (&ready_list) && 
c00213b8:	39 c6                	cmp    %eax,%esi
c00213ba:	7d cf                	jge    c002138b <thread_check_switch+0x2d>
    intr_set_level (old_level);
c00213bc:	83 ec 0c             	sub    $0xc,%esp
c00213bf:	53                   	push   %ebx
c00213c0:	e8 38 03 00 00       	call   c00216fd <intr_set_level>
    thread_yield ();
c00213c5:	e8 25 ff ff ff       	call   c00212ef <thread_yield>
c00213ca:	83 c4 10             	add    $0x10,%esp
c00213cd:	eb c8                	jmp    c0021397 <thread_check_switch+0x39>

c00213cf <thread_create>:
{
c00213cf:	57                   	push   %edi
c00213d0:	56                   	push   %esi
c00213d1:	53                   	push   %ebx
c00213d2:	8b 7c 24 18          	mov    0x18(%esp),%edi
  ASSERT (function != NULL);
c00213d6:	85 ff                	test   %edi,%edi
c00213d8:	0f 84 ac 00 00 00    	je     c002148a <thread_create+0xbb>
  t = palloc_get_page (PAL_ZERO);
c00213de:	83 ec 0c             	sub    $0xc,%esp
c00213e1:	6a 02                	push   $0x2
c00213e3:	e8 65 1f 00 00       	call   c002334d <palloc_get_page>
c00213e8:	89 c3                	mov    %eax,%ebx
  if (t == NULL)
c00213ea:	83 c4 10             	add    $0x10,%esp
c00213ed:	85 c0                	test   %eax,%eax
c00213ef:	0f 84 b6 00 00 00    	je     c00214ab <thread_create+0xdc>
  init_thread (t, name, priority);
c00213f5:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00213f9:	8b 54 24 10          	mov    0x10(%esp),%edx
c00213fd:	e8 5c f3 ff ff       	call   c002075e <init_thread>
  lock_acquire (&tid_lock);
c0021402:	83 ec 0c             	sub    $0xc,%esp
c0021405:	68 80 82 03 c0       	push   $0xc0038280
c002140a:	e8 63 17 00 00       	call   c0022b72 <lock_acquire>
  tid = next_tid++;
c002140f:	8b 35 70 7c 03 c0    	mov    0xc0037c70,%esi
c0021415:	8d 46 01             	lea    0x1(%esi),%eax
c0021418:	a3 70 7c 03 c0       	mov    %eax,0xc0037c70
  lock_release (&tid_lock);
c002141d:	c7 04 24 80 82 03 c0 	movl   $0xc0038280,(%esp)
c0021424:	e8 e6 18 00 00       	call   c0022d0f <lock_release>
  tid = t->tid = allocate_tid ();
c0021429:	89 73 04             	mov    %esi,0x4(%ebx)
  kf = alloc_frame (t, sizeof *kf);
c002142c:	ba 0c 00 00 00       	mov    $0xc,%edx
c0021431:	89 d8                	mov    %ebx,%eax
c0021433:	e8 c9 f4 ff ff       	call   c0020901 <alloc_frame>
  kf->eip = NULL;
c0021438:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c002143e:	89 78 04             	mov    %edi,0x4(%eax)
  kf->aux = aux;
c0021441:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0021445:	89 50 08             	mov    %edx,0x8(%eax)
  ef = alloc_frame (t, sizeof *ef);
c0021448:	ba 04 00 00 00       	mov    $0x4,%edx
c002144d:	89 d8                	mov    %ebx,%eax
c002144f:	e8 ad f4 ff ff       	call   c0020901 <alloc_frame>
  ef->eip = (void (*) (void)) kernel_thread;
c0021454:	c7 00 af 12 02 c0    	movl   $0xc00212af,(%eax)
  sf = alloc_frame (t, sizeof *sf);
c002145a:	ba 1c 00 00 00       	mov    $0x1c,%edx
c002145f:	89 d8                	mov    %ebx,%eax
c0021461:	e8 9b f4 ff ff       	call   c0020901 <alloc_frame>
  sf->eip = switch_entry;
c0021466:	c7 40 10 85 15 02 c0 	movl   $0xc0021585,0x10(%eax)
  sf->ebp = 0;
c002146d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  thread_unblock (t);
c0021474:	89 1c 24             	mov    %ebx,(%esp)
c0021477:	e8 b1 f7 ff ff       	call   c0020c2d <thread_unblock>
  thread_check_switch();
c002147c:	e8 dd fe ff ff       	call   c002135e <thread_check_switch>
	return tid;
c0021481:	83 c4 10             	add    $0x10,%esp
}
c0021484:	89 f0                	mov    %esi,%eax
c0021486:	5b                   	pop    %ebx
c0021487:	5e                   	pop    %esi
c0021488:	5f                   	pop    %edi
c0021489:	c3                   	ret    
  ASSERT (function != NULL);
c002148a:	83 ec 0c             	sub    $0xc,%esp
c002148d:	68 a0 dd 02 c0       	push   $0xc002dda0
c0021492:	68 3f d9 02 c0       	push   $0xc002d93f
c0021497:	68 00 c3 02 c0       	push   $0xc002c300
c002149c:	68 cc 00 00 00       	push   $0xcc
c00214a1:	68 6c dc 02 c0       	push   $0xc002dc6c
c00214a6:	e8 62 6e 00 00       	call   c002830d <debug_panic>
    return TID_ERROR;
c00214ab:	be ff ff ff ff       	mov    $0xffffffff,%esi
c00214b0:	eb d2                	jmp    c0021484 <thread_create+0xb5>

c00214b2 <thread_start>:
{
c00214b2:	53                   	push   %ebx
c00214b3:	83 ec 30             	sub    $0x30,%esp
  sema_init (&idle_started, 0);
c00214b6:	6a 00                	push   $0x0
c00214b8:	8d 5c 24 18          	lea    0x18(%esp),%ebx
c00214bc:	53                   	push   %ebx
c00214bd:	e8 62 12 00 00       	call   c0022724 <sema_init>
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c00214c2:	53                   	push   %ebx
c00214c3:	68 18 12 02 c0       	push   $0xc0021218
c00214c8:	6a 00                	push   $0x0
c00214ca:	68 b1 dd 02 c0       	push   $0xc002ddb1
c00214cf:	e8 fb fe ff ff       	call   c00213cf <thread_create>
  intr_enable ();
c00214d4:	83 c4 20             	add    $0x20,%esp
c00214d7:	e8 e6 01 00 00       	call   c00216c2 <intr_enable>
  sema_down (&idle_started);
c00214dc:	83 ec 0c             	sub    $0xc,%esp
c00214df:	53                   	push   %ebx
c00214e0:	e8 ad 12 00 00       	call   c0022792 <sema_down>
}
c00214e5:	83 c4 38             	add    $0x38,%esp
c00214e8:	5b                   	pop    %ebx
c00214e9:	c3                   	ret    

c00214ea <thread_set_priority>:
  if (thread_mlfqs) {
c00214ea:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c00214f1:	74 01                	je     c00214f4 <thread_set_priority+0xa>
}
c00214f3:	c3                   	ret    
{
c00214f4:	83 ec 0c             	sub    $0xc,%esp
  struct thread* t = thread_current ();
c00214f7:	e8 8a f5 ff ff       	call   c0020a86 <thread_current>
  if (t->max_donate_delta) {
c00214fc:	83 78 40 00          	cmpl   $0x0,0x40(%eax)
c0021500:	74 0c                	je     c002150e <thread_set_priority+0x24>
    t->priority_to_set = new_priority;
c0021502:	8b 54 24 10          	mov    0x10(%esp),%edx
c0021506:	89 50 44             	mov    %edx,0x44(%eax)
}
c0021509:	83 c4 0c             	add    $0xc,%esp
c002150c:	eb e5                	jmp    c00214f3 <thread_set_priority+0x9>
    t->priority = new_priority;
c002150e:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0021512:	89 48 20             	mov    %ecx,0x20(%eax)
    thread_check_switch();
c0021515:	e8 44 fe ff ff       	call   c002135e <thread_check_switch>
c002151a:	eb ed                	jmp    c0021509 <thread_set_priority+0x1f>

c002151c <get_child_by_tid>:
/* Offset of `stack' member within `struct thread'.
   Used by switch.S, which can't figure it out on its own. */
uint32_t thread_stack_ofs = offsetof (struct thread, stack);

struct child_process *
get_child_by_tid(struct list* children, tid_t tid) {
c002151c:	57                   	push   %edi
c002151d:	56                   	push   %esi
c002151e:	53                   	push   %ebx
c002151f:	8b 74 24 10          	mov    0x10(%esp),%esi
c0021523:	8b 7c 24 14          	mov    0x14(%esp),%edi
//	ASSERT (intr_get_level () == INTR_OFF);
	struct child_process *ch;
	for (struct list_elem *e = list_begin(children); e != list_end(children); e = list_next(e)) {
c0021527:	83 ec 0c             	sub    $0xc,%esp
c002152a:	56                   	push   %esi
c002152b:	e8 c7 6e 00 00       	call   c00283f7 <list_begin>
c0021530:	89 c3                	mov    %eax,%ebx
c0021532:	83 c4 10             	add    $0x10,%esp
c0021535:	83 ec 0c             	sub    $0xc,%esp
c0021538:	56                   	push   %esi
c0021539:	e8 31 6f 00 00       	call   c002846f <list_end>
c002153e:	83 c4 10             	add    $0x10,%esp
c0021541:	39 c3                	cmp    %eax,%ebx
c0021543:	74 1a                	je     c002155f <get_child_by_tid+0x43>
		ch = list_entry(e, struct child_process, elem);
		if (ch->tid == tid)
c0021545:	39 7b f4             	cmp    %edi,-0xc(%ebx)
c0021548:	74 10                	je     c002155a <get_child_by_tid+0x3e>
	for (struct list_elem *e = list_begin(children); e != list_end(children); e = list_next(e)) {
c002154a:	83 ec 0c             	sub    $0xc,%esp
c002154d:	53                   	push   %ebx
c002154e:	e8 d4 6e 00 00       	call   c0028427 <list_next>
c0021553:	89 c3                	mov    %eax,%ebx
c0021555:	83 c4 10             	add    $0x10,%esp
c0021558:	eb db                	jmp    c0021535 <get_child_by_tid+0x19>
		ch = list_entry(e, struct child_process, elem);
c002155a:	8d 43 f4             	lea    -0xc(%ebx),%eax
c002155d:	eb 05                	jmp    c0021564 <get_child_by_tid+0x48>
			return ch;
	}
	return NULL;
c002155f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0021564:	5b                   	pop    %ebx
c0021565:	5e                   	pop    %esi
c0021566:	5f                   	pop    %edi
c0021567:	c3                   	ret    

c0021568 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021568:	53                   	push   %ebx
	pushl %ebp
c0021569:	55                   	push   %ebp
	pushl %esi
c002156a:	56                   	push   %esi
	pushl %edi
c002156b:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c002156c:	8b 15 74 7c 03 c0    	mov    0xc0037c74,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021572:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021576:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021579:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c002157d:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021580:	5f                   	pop    %edi
	popl %esi
c0021581:	5e                   	pop    %esi
	popl %ebp
c0021582:	5d                   	pop    %ebp
	popl %ebx
c0021583:	5b                   	pop    %ebx
        ret
c0021584:	c3                   	ret    

c0021585 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021585:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021588:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021589:	e8 a0 fa ff ff       	call   c002102e <thread_schedule_tail>
	addl $4, %esp
c002158e:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021591:	c3                   	ret    

c0021592 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c0021592:	83 ec 0c             	sub    $0xc,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c0021595:	85 c0                	test   %eax,%eax
c0021597:	74 2b                	je     c00215c4 <make_gate+0x32>
  ASSERT (dpl >= 0 && dpl <= 3);
c0021599:	83 fa 03             	cmp    $0x3,%edx
c002159c:	77 47                	ja     c00215e5 <make_gate+0x53>
  ASSERT (type >= 0 && type <= 15);
c002159e:	83 f9 0f             	cmp    $0xf,%ecx
c00215a1:	77 63                	ja     c0021606 <make_gate+0x74>

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c00215a3:	c1 e1 08             	shl    $0x8,%ecx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00215a6:	80 cd 80             	or     $0x80,%ch
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c00215a9:	c1 e2 0d             	shl    $0xd,%edx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00215ac:	09 ca                	or     %ecx,%edx
c00215ae:	89 c1                	mov    %eax,%ecx
c00215b0:	81 e1 00 00 ff ff    	and    $0xffff0000,%ecx
c00215b6:	09 ca                	or     %ecx,%edx
  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c00215b8:	0f b7 c0             	movzwl %ax,%eax
c00215bb:	0d 00 00 08 00       	or     $0x80000,%eax

  return e0 | ((uint64_t) e1 << 32);
}
c00215c0:	83 c4 0c             	add    $0xc,%esp
c00215c3:	c3                   	ret    
  ASSERT (function != NULL);
c00215c4:	83 ec 0c             	sub    $0xc,%esp
c00215c7:	68 a0 dd 02 c0       	push   $0xc002dda0
c00215cc:	68 3f d9 02 c0       	push   $0xc002d93f
c00215d1:	68 a4 c3 02 c0       	push   $0xc002c3a4
c00215d6:	68 2a 01 00 00       	push   $0x12a
c00215db:	68 46 de 02 c0       	push   $0xc002de46
c00215e0:	e8 28 6d 00 00       	call   c002830d <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c00215e5:	83 ec 0c             	sub    $0xc,%esp
c00215e8:	68 60 de 02 c0       	push   $0xc002de60
c00215ed:	68 3f d9 02 c0       	push   $0xc002d93f
c00215f2:	68 a4 c3 02 c0       	push   $0xc002c3a4
c00215f7:	68 2b 01 00 00       	push   $0x12b
c00215fc:	68 46 de 02 c0       	push   $0xc002de46
c0021601:	e8 07 6d 00 00       	call   c002830d <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021606:	83 ec 0c             	sub    $0xc,%esp
c0021609:	68 75 de 02 c0       	push   $0xc002de75
c002160e:	68 3f d9 02 c0       	push   $0xc002d93f
c0021613:	68 a4 c3 02 c0       	push   $0xc002c3a4
c0021618:	68 2c 01 00 00       	push   $0x12c
c002161d:	68 46 de 02 c0       	push   $0xc002de46
c0021622:	e8 e6 6c 00 00       	call   c002830d <debug_panic>

c0021627 <register_handler>:
{
c0021627:	53                   	push   %ebx
c0021628:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_handlers[vec_no] == NULL);
c002162b:	0f b6 d8             	movzbl %al,%ebx
c002162e:	83 3c 9d 00 8b 03 c0 	cmpl   $0x0,-0x3ffc7500(,%ebx,4)
c0021635:	00 
c0021636:	75 3f                	jne    c0021677 <register_handler+0x50>
  if (level == INTR_ON)
c0021638:	83 f9 01             	cmp    $0x1,%ecx
c002163b:	74 5b                	je     c0021698 <register_handler+0x71>
/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 14);
c002163d:	8b 04 9d 78 7c 03 c0 	mov    -0x3ffc8388(,%ebx,4),%eax
c0021644:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021649:	e8 44 ff ff ff       	call   c0021592 <make_gate>
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c002164e:	89 04 dd 00 8f 03 c0 	mov    %eax,-0x3ffc7100(,%ebx,8)
c0021655:	89 14 dd 04 8f 03 c0 	mov    %edx,-0x3ffc70fc(,%ebx,8)
  intr_handlers[vec_no] = handler;
c002165c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021660:	89 04 9d 00 8b 03 c0 	mov    %eax,-0x3ffc7500(,%ebx,4)
  intr_names[vec_no] = name;
c0021667:	8b 44 24 14          	mov    0x14(%esp),%eax
c002166b:	89 04 9d 00 87 03 c0 	mov    %eax,-0x3ffc7900(,%ebx,4)
}
c0021672:	83 c4 08             	add    $0x8,%esp
c0021675:	5b                   	pop    %ebx
c0021676:	c3                   	ret    
  ASSERT (intr_handlers[vec_no] == NULL);
c0021677:	83 ec 0c             	sub    $0xc,%esp
c002167a:	68 8d de 02 c0       	push   $0xc002de8d
c002167f:	68 3f d9 02 c0       	push   $0xc002d93f
c0021684:	68 7c c3 02 c0       	push   $0xc002c37c
c0021689:	68 a8 00 00 00       	push   $0xa8
c002168e:	68 46 de 02 c0       	push   $0xc002de46
c0021693:	e8 75 6c 00 00       	call   c002830d <debug_panic>
/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 15);
c0021698:	8b 04 9d 78 7c 03 c0 	mov    -0x3ffc8388(,%ebx,4),%eax
c002169f:	b9 0f 00 00 00       	mov    $0xf,%ecx
c00216a4:	e8 e9 fe ff ff       	call   c0021592 <make_gate>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c00216a9:	89 04 dd 00 8f 03 c0 	mov    %eax,-0x3ffc7100(,%ebx,8)
c00216b0:	89 14 dd 04 8f 03 c0 	mov    %edx,-0x3ffc70fc(,%ebx,8)
c00216b7:	eb a3                	jmp    c002165c <register_handler+0x35>

c00216b9 <intr_get_level>:
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c00216b9:	9c                   	pushf  
c00216ba:	58                   	pop    %eax
  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c00216bb:	c1 e8 09             	shr    $0x9,%eax
c00216be:	83 e0 01             	and    $0x1,%eax
}
c00216c1:	c3                   	ret    

c00216c2 <intr_enable>:
{
c00216c2:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_get_level ();
c00216c5:	e8 ef ff ff ff       	call   c00216b9 <intr_get_level>
  ASSERT (!intr_context ());
c00216ca:	80 3d e1 82 03 c0 00 	cmpb   $0x0,0xc00382e1
c00216d1:	75 05                	jne    c00216d8 <intr_enable+0x16>
  asm volatile ("sti");
c00216d3:	fb                   	sti    
}
c00216d4:	83 c4 0c             	add    $0xc,%esp
c00216d7:	c3                   	ret    
  ASSERT (!intr_context ());
c00216d8:	83 ec 0c             	sub    $0xc,%esp
c00216db:	68 8f dd 02 c0       	push   $0xc002dd8f
c00216e0:	68 3f d9 02 c0       	push   $0xc002d93f
c00216e5:	68 b0 c3 02 c0       	push   $0xc002c3b0
c00216ea:	6a 5b                	push   $0x5b
c00216ec:	68 46 de 02 c0       	push   $0xc002de46
c00216f1:	e8 17 6c 00 00       	call   c002830d <debug_panic>

c00216f6 <intr_disable>:
  enum intr_level old_level = intr_get_level ();
c00216f6:	e8 be ff ff ff       	call   c00216b9 <intr_get_level>
  asm volatile ("cli" : : : "memory");
c00216fb:	fa                   	cli    
}
c00216fc:	c3                   	ret    

c00216fd <intr_set_level>:
{
c00216fd:	83 ec 0c             	sub    $0xc,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021700:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021705:	74 09                	je     c0021710 <intr_set_level+0x13>
c0021707:	e8 ea ff ff ff       	call   c00216f6 <intr_disable>
}
c002170c:	83 c4 0c             	add    $0xc,%esp
c002170f:	c3                   	ret    
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021710:	e8 ad ff ff ff       	call   c00216c2 <intr_enable>
c0021715:	eb f5                	jmp    c002170c <intr_set_level+0xf>

c0021717 <intr_init>:
{
c0021717:	53                   	push   %ebx
c0021718:	83 ec 18             	sub    $0x18,%esp
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002171b:	b0 ff                	mov    $0xff,%al
c002171d:	e6 21                	out    %al,$0x21
c002171f:	e6 a1                	out    %al,$0xa1
c0021721:	b0 11                	mov    $0x11,%al
c0021723:	e6 20                	out    %al,$0x20
c0021725:	b0 20                	mov    $0x20,%al
c0021727:	e6 21                	out    %al,$0x21
c0021729:	b0 04                	mov    $0x4,%al
c002172b:	e6 21                	out    %al,$0x21
c002172d:	b0 01                	mov    $0x1,%al
c002172f:	e6 21                	out    %al,$0x21
c0021731:	b0 11                	mov    $0x11,%al
c0021733:	e6 a0                	out    %al,$0xa0
c0021735:	b0 28                	mov    $0x28,%al
c0021737:	e6 a1                	out    %al,$0xa1
c0021739:	b0 02                	mov    $0x2,%al
c002173b:	e6 a1                	out    %al,$0xa1
c002173d:	b0 01                	mov    $0x1,%al
c002173f:	e6 a1                	out    %al,$0xa1
c0021741:	b0 00                	mov    $0x0,%al
c0021743:	e6 21                	out    %al,$0x21
c0021745:	e6 a1                	out    %al,$0xa1
c0021747:	bb 00 00 00 00       	mov    $0x0,%ebx
  return make_gate (function, dpl, 14);
c002174c:	8b 83 78 7c 03 c0    	mov    -0x3ffc8388(%ebx),%eax
c0021752:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021757:	ba 00 00 00 00       	mov    $0x0,%edx
c002175c:	e8 31 fe ff ff       	call   c0021592 <make_gate>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021761:	89 84 1b 00 8f 03 c0 	mov    %eax,-0x3ffc7100(%ebx,%ebx,1)
c0021768:	89 94 1b 04 8f 03 c0 	mov    %edx,-0x3ffc70fc(%ebx,%ebx,1)
c002176f:	83 c3 04             	add    $0x4,%ebx
  for (i = 0; i < INTR_CNT; i++)
c0021772:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
c0021778:	75 d2                	jne    c002174c <intr_init+0x35>
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
c002177a:	b8 00 8f 03 c0       	mov    $0xc0038f00,%eax
c002177f:	ba 00 00 00 00       	mov    $0x0,%edx
c0021784:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021788:	c1 e0 10             	shl    $0x10,%eax
c002178b:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021790:	89 44 24 08          	mov    %eax,0x8(%esp)
c0021794:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021798:	0f 01 5c 24 08       	lidtl  0x8(%esp)
c002179d:	b8 00 87 03 c0       	mov    $0xc0038700,%eax
c00217a2:	ba 00 8b 03 c0       	mov    $0xc0038b00,%edx
    intr_names[i] = "unknown";
c00217a7:	c7 00 ab de 02 c0    	movl   $0xc002deab,(%eax)
c00217ad:	83 c0 04             	add    $0x4,%eax
  for (i = 0; i < INTR_CNT; i++)
c00217b0:	39 c2                	cmp    %eax,%edx
c00217b2:	75 f3                	jne    c00217a7 <intr_init+0x90>
  intr_names[0] = "#DE Divide Error";
c00217b4:	c7 05 00 87 03 c0 b3 	movl   $0xc002deb3,0xc0038700
c00217bb:	de 02 c0 
  intr_names[1] = "#DB Debug Exception";
c00217be:	c7 05 04 87 03 c0 c4 	movl   $0xc002dec4,0xc0038704
c00217c5:	de 02 c0 
  intr_names[2] = "NMI Interrupt";
c00217c8:	c7 05 08 87 03 c0 d8 	movl   $0xc002ded8,0xc0038708
c00217cf:	de 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c00217d2:	c7 05 0c 87 03 c0 e6 	movl   $0xc002dee6,0xc003870c
c00217d9:	de 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c00217dc:	c7 05 10 87 03 c0 ff 	movl   $0xc002deff,0xc0038710
c00217e3:	de 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c00217e6:	c7 05 14 87 03 c0 3c 	movl   $0xc002e03c,0xc0038714
c00217ed:	e0 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c00217f0:	c7 05 18 87 03 c0 16 	movl   $0xc002df16,0xc0038718
c00217f7:	df 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c00217fa:	c7 05 1c 87 03 c0 60 	movl   $0xc002e060,0xc003871c
c0021801:	e0 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c0021804:	c7 05 20 87 03 c0 33 	movl   $0xc002df33,0xc0038720
c002180b:	df 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c002180e:	c7 05 24 87 03 c0 4e 	movl   $0xc002df4e,0xc0038724
c0021815:	df 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c0021818:	c7 05 28 87 03 c0 6a 	movl   $0xc002df6a,0xc0038728
c002181f:	df 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c0021822:	c7 05 2c 87 03 c0 84 	movl   $0xc002df84,0xc003872c
c0021829:	df 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c002182c:	c7 05 30 87 03 c0 9c 	movl   $0xc002df9c,0xc0038730
c0021833:	df 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c0021836:	c7 05 34 87 03 c0 84 	movl   $0xc002e084,0xc0038734
c002183d:	e0 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c0021840:	c7 05 38 87 03 c0 b6 	movl   $0xc002dfb6,0xc0038738
c0021847:	df 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c002184a:	c7 05 40 87 03 c0 a8 	movl   $0xc002e0a8,0xc0038740
c0021851:	e0 02 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c0021854:	c7 05 44 87 03 c0 cf 	movl   $0xc002dfcf,0xc0038744
c002185b:	df 02 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c002185e:	c7 05 48 87 03 c0 ed 	movl   $0xc002dfed,0xc0038748
c0021865:	df 02 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021868:	c7 05 4c 87 03 c0 cc 	movl   $0xc002e0cc,0xc003874c
c002186f:	e0 02 c0 
}
c0021872:	83 c4 18             	add    $0x18,%esp
c0021875:	5b                   	pop    %ebx
c0021876:	c3                   	ret    

c0021877 <intr_register_ext>:
{
c0021877:	83 ec 0c             	sub    $0xc,%esp
c002187a:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c002187e:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021881:	80 fa 0f             	cmp    $0xf,%dl
c0021884:	77 21                	ja     c00218a7 <intr_register_ext+0x30>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021886:	0f b6 c0             	movzbl %al,%eax
c0021889:	83 ec 08             	sub    $0x8,%esp
c002188c:	ff 74 24 20          	pushl  0x20(%esp)
c0021890:	ff 74 24 20          	pushl  0x20(%esp)
c0021894:	b9 00 00 00 00       	mov    $0x0,%ecx
c0021899:	ba 00 00 00 00       	mov    $0x0,%edx
c002189e:	e8 84 fd ff ff       	call   c0021627 <register_handler>
}
c00218a3:	83 c4 1c             	add    $0x1c,%esp
c00218a6:	c3                   	ret    
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c00218a7:	83 ec 0c             	sub    $0xc,%esp
c00218aa:	68 f0 e0 02 c0       	push   $0xc002e0f0
c00218af:	68 3f d9 02 c0       	push   $0xc002d93f
c00218b4:	68 90 c3 02 c0       	push   $0xc002c390
c00218b9:	68 b8 00 00 00       	push   $0xb8
c00218be:	68 46 de 02 c0       	push   $0xc002de46
c00218c3:	e8 45 6a 00 00       	call   c002830d <debug_panic>

c00218c8 <intr_register_int>:
{
c00218c8:	83 ec 0c             	sub    $0xc,%esp
c00218cb:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c00218cf:	8d 50 e0             	lea    -0x20(%eax),%edx
c00218d2:	80 fa 0f             	cmp    $0xf,%dl
c00218d5:	76 1f                	jbe    c00218f6 <intr_register_int+0x2e>
  register_handler (vec_no, dpl, level, handler, name);
c00218d7:	0f b6 c0             	movzbl %al,%eax
c00218da:	83 ec 08             	sub    $0x8,%esp
c00218dd:	ff 74 24 28          	pushl  0x28(%esp)
c00218e1:	ff 74 24 28          	pushl  0x28(%esp)
c00218e5:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c00218e9:	8b 54 24 24          	mov    0x24(%esp),%edx
c00218ed:	e8 35 fd ff ff       	call   c0021627 <register_handler>
}
c00218f2:	83 c4 1c             	add    $0x1c,%esp
c00218f5:	c3                   	ret    
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c00218f6:	83 ec 0c             	sub    $0xc,%esp
c00218f9:	68 14 e1 02 c0       	push   $0xc002e114
c00218fe:	68 3f d9 02 c0       	push   $0xc002d93f
c0021903:	68 68 c3 02 c0       	push   $0xc002c368
c0021908:	68 cd 00 00 00       	push   $0xcd
c002190d:	68 46 de 02 c0       	push   $0xc002de46
c0021912:	e8 f6 69 00 00       	call   c002830d <debug_panic>

c0021917 <intr_context>:
}
c0021917:	a0 e1 82 03 c0       	mov    0xc00382e1,%al
c002191c:	c3                   	ret    

c002191d <intr_yield_on_return>:
  ASSERT (intr_context ());
c002191d:	80 3d e1 82 03 c0 00 	cmpb   $0x0,0xc00382e1
c0021924:	74 08                	je     c002192e <intr_yield_on_return+0x11>
  yield_on_return = true;
c0021926:	c6 05 e0 82 03 c0 01 	movb   $0x1,0xc00382e0
c002192d:	c3                   	ret    
{
c002192e:	83 ec 18             	sub    $0x18,%esp
  ASSERT (intr_context ());
c0021931:	68 90 dd 02 c0       	push   $0xc002dd90
c0021936:	68 3f d9 02 c0       	push   $0xc002d93f
c002193b:	68 50 c3 02 c0       	push   $0xc002c350
c0021940:	68 e0 00 00 00       	push   $0xe0
c0021945:	68 46 de 02 c0       	push   $0xc002de46
c002194a:	e8 be 69 00 00       	call   c002830d <debug_panic>

c002194f <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c002194f:	56                   	push   %esi
c0021950:	53                   	push   %ebx
c0021951:	83 ec 04             	sub    $0x4,%esp
c0021954:	8b 74 24 10          	mov    0x10(%esp),%esi

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021958:	8b 46 30             	mov    0x30(%esi),%eax
c002195b:	8d 58 e0             	lea    -0x20(%eax),%ebx
  if (external) 
c002195e:	83 fb 0f             	cmp    $0xf,%ebx
c0021961:	76 26                	jbe    c0021989 <intr_handler+0x3a>
	else
    thread_current()->esp = frame->esp;
#endif

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021963:	8b 56 30             	mov    0x30(%esi),%edx
c0021966:	8b 04 95 00 8b 03 c0 	mov    -0x3ffc7500(,%edx,4),%eax
  if (handler != NULL)
c002196d:	85 c0                	test   %eax,%eax
c002196f:	74 7c                	je     c00219ed <intr_handler+0x9e>
    handler (frame);
c0021971:	83 ec 0c             	sub    $0xc,%esp
c0021974:	56                   	push   %esi
c0021975:	ff d0                	call   *%eax
c0021977:	83 c4 10             	add    $0x10,%esp
    }
  else
    unexpected_interrupt (frame);

  /* Complete the processing of an external interrupt. */
  if (external) 
c002197a:	83 fb 0f             	cmp    $0xf,%ebx
c002197d:	0f 86 aa 00 00 00    	jbe    c0021a2d <intr_handler+0xde>
      pic_end_of_interrupt (frame->vec_no); 

      if (yield_on_return) 
        thread_yield (); 
    }
}
c0021983:	83 c4 04             	add    $0x4,%esp
c0021986:	5b                   	pop    %ebx
c0021987:	5e                   	pop    %esi
c0021988:	c3                   	ret    
      ASSERT (intr_get_level () == INTR_OFF);
c0021989:	e8 2b fd ff ff       	call   c00216b9 <intr_get_level>
c002198e:	85 c0                	test   %eax,%eax
c0021990:	75 19                	jne    c00219ab <intr_handler+0x5c>
      ASSERT (!intr_context ());
c0021992:	80 3d e1 82 03 c0 00 	cmpb   $0x0,0xc00382e1
c0021999:	75 31                	jne    c00219cc <intr_handler+0x7d>
      in_external_intr = true;
c002199b:	c6 05 e1 82 03 c0 01 	movb   $0x1,0xc00382e1
      yield_on_return = false;
c00219a2:	c6 05 e0 82 03 c0 00 	movb   $0x0,0xc00382e0
c00219a9:	eb b8                	jmp    c0021963 <intr_handler+0x14>
      ASSERT (intr_get_level () == INTR_OFF);
c00219ab:	83 ec 0c             	sub    $0xc,%esp
c00219ae:	68 d2 dc 02 c0       	push   $0xc002dcd2
c00219b3:	68 3f d9 02 c0       	push   $0xc002d93f
c00219b8:	68 40 c3 02 c0       	push   $0xc002c340
c00219bd:	68 65 01 00 00       	push   $0x165
c00219c2:	68 46 de 02 c0       	push   $0xc002de46
c00219c7:	e8 41 69 00 00       	call   c002830d <debug_panic>
      ASSERT (!intr_context ());
c00219cc:	83 ec 0c             	sub    $0xc,%esp
c00219cf:	68 8f dd 02 c0       	push   $0xc002dd8f
c00219d4:	68 3f d9 02 c0       	push   $0xc002d93f
c00219d9:	68 40 c3 02 c0       	push   $0xc002c340
c00219de:	68 66 01 00 00       	push   $0x166
c00219e3:	68 46 de 02 c0       	push   $0xc002de46
c00219e8:	e8 20 69 00 00       	call   c002830d <debug_panic>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c00219ed:	89 d0                	mov    %edx,%eax
c00219ef:	83 e0 f7             	and    $0xfffffff7,%eax
c00219f2:	83 f8 27             	cmp    $0x27,%eax
c00219f5:	74 83                	je     c002197a <intr_handler+0x2b>
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c00219f7:	8b 0c 95 00 83 03 c0 	mov    -0x3ffc7d00(,%edx,4),%ecx
c00219fe:	8d 41 01             	lea    0x1(%ecx),%eax
c0021a01:	89 04 95 00 83 03 c0 	mov    %eax,-0x3ffc7d00(,%edx,4)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021a08:	85 c1                	test   %eax,%ecx
c0021a0a:	0f 85 6a ff ff ff    	jne    c002197a <intr_handler+0x2b>
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021a10:	83 ec 04             	sub    $0x4,%esp
c0021a13:	ff 34 95 00 87 03 c0 	pushl  -0x3ffc7900(,%edx,4)
c0021a1a:	52                   	push   %edx
c0021a1b:	68 34 e1 02 c0       	push   $0xc002e134
c0021a20:	e8 3a 4e 00 00       	call   c002685f <printf>
c0021a25:	83 c4 10             	add    $0x10,%esp
c0021a28:	e9 4d ff ff ff       	jmp    c002197a <intr_handler+0x2b>
      ASSERT (intr_get_level () == INTR_OFF);
c0021a2d:	e8 87 fc ff ff       	call   c00216b9 <intr_get_level>
c0021a32:	85 c0                	test   %eax,%eax
c0021a34:	75 3d                	jne    c0021a73 <intr_handler+0x124>
      ASSERT (intr_context ());
c0021a36:	80 3d e1 82 03 c0 00 	cmpb   $0x0,0xc00382e1
c0021a3d:	74 55                	je     c0021a94 <intr_handler+0x145>
      in_external_intr = false;
c0021a3f:	c6 05 e1 82 03 c0 00 	movb   $0x0,0xc00382e1
      pic_end_of_interrupt (frame->vec_no); 
c0021a46:	8b 56 30             	mov    0x30(%esi),%edx
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021a49:	8d 42 e0             	lea    -0x20(%edx),%eax
c0021a4c:	83 f8 0f             	cmp    $0xf,%eax
c0021a4f:	77 64                	ja     c0021ab5 <intr_handler+0x166>
c0021a51:	b0 20                	mov    $0x20,%al
c0021a53:	e6 20                	out    %al,$0x20
  if (irq >= 0x28)
c0021a55:	83 fa 27             	cmp    $0x27,%edx
c0021a58:	7e 02                	jle    c0021a5c <intr_handler+0x10d>
c0021a5a:	e6 a0                	out    %al,$0xa0
      if (yield_on_return) 
c0021a5c:	80 3d e0 82 03 c0 00 	cmpb   $0x0,0xc00382e0
c0021a63:	0f 84 1a ff ff ff    	je     c0021983 <intr_handler+0x34>
        thread_yield (); 
c0021a69:	e8 81 f8 ff ff       	call   c00212ef <thread_yield>
}
c0021a6e:	e9 10 ff ff ff       	jmp    c0021983 <intr_handler+0x34>
      ASSERT (intr_get_level () == INTR_OFF);
c0021a73:	83 ec 0c             	sub    $0xc,%esp
c0021a76:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0021a7b:	68 3f d9 02 c0       	push   $0xc002d93f
c0021a80:	68 40 c3 02 c0       	push   $0xc002c340
c0021a85:	68 80 01 00 00       	push   $0x180
c0021a8a:	68 46 de 02 c0       	push   $0xc002de46
c0021a8f:	e8 79 68 00 00       	call   c002830d <debug_panic>
      ASSERT (intr_context ());
c0021a94:	83 ec 0c             	sub    $0xc,%esp
c0021a97:	68 90 dd 02 c0       	push   $0xc002dd90
c0021a9c:	68 3f d9 02 c0       	push   $0xc002d93f
c0021aa1:	68 40 c3 02 c0       	push   $0xc002c340
c0021aa6:	68 81 01 00 00       	push   $0x181
c0021aab:	68 46 de 02 c0       	push   $0xc002de46
c0021ab0:	e8 58 68 00 00       	call   c002830d <debug_panic>
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021ab5:	83 ec 0c             	sub    $0xc,%esp
c0021ab8:	68 09 e0 02 c0       	push   $0xc002e009
c0021abd:	68 3f d9 02 c0       	push   $0xc002d93f
c0021ac2:	68 28 c3 02 c0       	push   $0xc002c328
c0021ac7:	68 0b 01 00 00       	push   $0x10b
c0021acc:	68 46 de 02 c0       	push   $0xc002de46
c0021ad1:	e8 37 68 00 00       	call   c002830d <debug_panic>

c0021ad6 <intr_dump_frame>:
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021ad6:	56                   	push   %esi
c0021ad7:	53                   	push   %ebx
c0021ad8:	83 ec 04             	sub    $0x4,%esp
c0021adb:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021adf:	0f 20 d6             	mov    %cr2,%esi

  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021ae2:	8b 43 30             	mov    0x30(%ebx),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021ae5:	ff 73 3c             	pushl  0x3c(%ebx)
c0021ae8:	ff 34 85 00 87 03 c0 	pushl  -0x3ffc7900(,%eax,4)
c0021aef:	50                   	push   %eax
c0021af0:	68 58 e1 02 c0       	push   $0xc002e158
c0021af5:	e8 65 4d 00 00       	call   c002685f <printf>
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021afa:	83 c4 0c             	add    $0xc,%esp
c0021afd:	ff 73 34             	pushl  0x34(%ebx)
c0021b00:	56                   	push   %esi
c0021b01:	68 23 e0 02 c0       	push   $0xc002e023
c0021b06:	e8 54 4d 00 00       	call   c002685f <printf>
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021b0b:	83 c4 04             	add    $0x4,%esp
c0021b0e:	ff 73 14             	pushl  0x14(%ebx)
c0021b11:	ff 73 18             	pushl  0x18(%ebx)
c0021b14:	ff 73 10             	pushl  0x10(%ebx)
c0021b17:	ff 73 1c             	pushl  0x1c(%ebx)
c0021b1a:	68 78 e1 02 c0       	push   $0xc002e178
c0021b1f:	e8 3b 4d 00 00       	call   c002685f <printf>
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021b24:	83 c4 14             	add    $0x14,%esp
c0021b27:	ff 73 08             	pushl  0x8(%ebx)
c0021b2a:	ff 73 48             	pushl  0x48(%ebx)
c0021b2d:	ff 33                	pushl  (%ebx)
c0021b2f:	ff 73 04             	pushl  0x4(%ebx)
c0021b32:	68 a0 e1 02 c0       	push   $0xc002e1a0
c0021b37:	e8 23 4d 00 00       	call   c002685f <printf>
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021b3c:	83 c4 14             	add    $0x14,%esp
c0021b3f:	0f b7 43 4c          	movzwl 0x4c(%ebx),%eax
c0021b43:	50                   	push   %eax
c0021b44:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
c0021b48:	50                   	push   %eax
c0021b49:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
c0021b4d:	50                   	push   %eax
c0021b4e:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
c0021b52:	50                   	push   %eax
c0021b53:	68 c8 e1 02 c0       	push   $0xc002e1c8
c0021b58:	e8 02 4d 00 00       	call   c002685f <printf>
          f->cs, f->ds, f->es, f->ss);
}
c0021b5d:	83 c4 24             	add    $0x24,%esp
c0021b60:	5b                   	pop    %ebx
c0021b61:	5e                   	pop    %esi
c0021b62:	c3                   	ret    

c0021b63 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
  return intr_names[vec];
c0021b63:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0021b68:	8b 04 85 00 87 03 c0 	mov    -0x3ffc7900(,%eax,4),%eax
}
c0021b6f:	c3                   	ret    

c0021b70 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021b70:	1e                   	push   %ds
	pushl %es
c0021b71:	06                   	push   %es
	pushl %fs
c0021b72:	0f a0                	push   %fs
	pushl %gs
c0021b74:	0f a8                	push   %gs
	pushal
c0021b76:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021b77:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021b78:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021b7d:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021b7f:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021b81:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021b85:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021b86:	e8 c4 fd ff ff       	call   c002194f <intr_handler>
	addl $4, %esp
c0021b8b:	83 c4 04             	add    $0x4,%esp

c0021b8e <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021b8e:	61                   	popa   
	popl %gs
c0021b8f:	0f a9                	pop    %gs
	popl %fs
c0021b91:	0f a1                	pop    %fs
	popl %es
c0021b93:	07                   	pop    %es
	popl %ds
c0021b94:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021b95:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021b98:	cf                   	iret   

c0021b99 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021b99:	55                   	push   %ebp
c0021b9a:	6a 00                	push   $0x0
c0021b9c:	6a 00                	push   $0x0
c0021b9e:	eb d0                	jmp    c0021b70 <intr_entry>

c0021ba0 <intr01_stub>:
c0021ba0:	55                   	push   %ebp
c0021ba1:	6a 00                	push   $0x0
c0021ba3:	6a 01                	push   $0x1
c0021ba5:	eb c9                	jmp    c0021b70 <intr_entry>

c0021ba7 <intr02_stub>:
c0021ba7:	55                   	push   %ebp
c0021ba8:	6a 00                	push   $0x0
c0021baa:	6a 02                	push   $0x2
c0021bac:	eb c2                	jmp    c0021b70 <intr_entry>

c0021bae <intr03_stub>:
c0021bae:	55                   	push   %ebp
c0021baf:	6a 00                	push   $0x0
c0021bb1:	6a 03                	push   $0x3
c0021bb3:	eb bb                	jmp    c0021b70 <intr_entry>

c0021bb5 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021bb5:	55                   	push   %ebp
c0021bb6:	6a 00                	push   $0x0
c0021bb8:	6a 04                	push   $0x4
c0021bba:	eb b4                	jmp    c0021b70 <intr_entry>

c0021bbc <intr05_stub>:
c0021bbc:	55                   	push   %ebp
c0021bbd:	6a 00                	push   $0x0
c0021bbf:	6a 05                	push   $0x5
c0021bc1:	eb ad                	jmp    c0021b70 <intr_entry>

c0021bc3 <intr06_stub>:
c0021bc3:	55                   	push   %ebp
c0021bc4:	6a 00                	push   $0x0
c0021bc6:	6a 06                	push   $0x6
c0021bc8:	eb a6                	jmp    c0021b70 <intr_entry>

c0021bca <intr07_stub>:
c0021bca:	55                   	push   %ebp
c0021bcb:	6a 00                	push   $0x0
c0021bcd:	6a 07                	push   $0x7
c0021bcf:	eb 9f                	jmp    c0021b70 <intr_entry>

c0021bd1 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021bd1:	ff 34 24             	pushl  (%esp)
c0021bd4:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021bd8:	6a 08                	push   $0x8
c0021bda:	eb 94                	jmp    c0021b70 <intr_entry>

c0021bdc <intr09_stub>:
c0021bdc:	55                   	push   %ebp
c0021bdd:	6a 00                	push   $0x0
c0021bdf:	6a 09                	push   $0x9
c0021be1:	eb 8d                	jmp    c0021b70 <intr_entry>

c0021be3 <intr0a_stub>:
c0021be3:	ff 34 24             	pushl  (%esp)
c0021be6:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021bea:	6a 0a                	push   $0xa
c0021bec:	eb 82                	jmp    c0021b70 <intr_entry>

c0021bee <intr0b_stub>:
c0021bee:	ff 34 24             	pushl  (%esp)
c0021bf1:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021bf5:	6a 0b                	push   $0xb
c0021bf7:	e9 74 ff ff ff       	jmp    c0021b70 <intr_entry>

c0021bfc <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021bfc:	55                   	push   %ebp
c0021bfd:	6a 00                	push   $0x0
c0021bff:	6a 0c                	push   $0xc
c0021c01:	e9 6a ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c06 <intr0d_stub>:
c0021c06:	ff 34 24             	pushl  (%esp)
c0021c09:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c0d:	6a 0d                	push   $0xd
c0021c0f:	e9 5c ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c14 <intr0e_stub>:
c0021c14:	ff 34 24             	pushl  (%esp)
c0021c17:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c1b:	6a 0e                	push   $0xe
c0021c1d:	e9 4e ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c22 <intr0f_stub>:
c0021c22:	55                   	push   %ebp
c0021c23:	6a 00                	push   $0x0
c0021c25:	6a 0f                	push   $0xf
c0021c27:	e9 44 ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c2c <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021c2c:	55                   	push   %ebp
c0021c2d:	6a 00                	push   $0x0
c0021c2f:	6a 10                	push   $0x10
c0021c31:	e9 3a ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c36 <intr11_stub>:
c0021c36:	ff 34 24             	pushl  (%esp)
c0021c39:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c3d:	6a 11                	push   $0x11
c0021c3f:	e9 2c ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c44 <intr12_stub>:
c0021c44:	55                   	push   %ebp
c0021c45:	6a 00                	push   $0x0
c0021c47:	6a 12                	push   $0x12
c0021c49:	e9 22 ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c4e <intr13_stub>:
c0021c4e:	55                   	push   %ebp
c0021c4f:	6a 00                	push   $0x0
c0021c51:	6a 13                	push   $0x13
c0021c53:	e9 18 ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c58 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021c58:	55                   	push   %ebp
c0021c59:	6a 00                	push   $0x0
c0021c5b:	6a 14                	push   $0x14
c0021c5d:	e9 0e ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c62 <intr15_stub>:
c0021c62:	55                   	push   %ebp
c0021c63:	6a 00                	push   $0x0
c0021c65:	6a 15                	push   $0x15
c0021c67:	e9 04 ff ff ff       	jmp    c0021b70 <intr_entry>

c0021c6c <intr16_stub>:
c0021c6c:	55                   	push   %ebp
c0021c6d:	6a 00                	push   $0x0
c0021c6f:	6a 16                	push   $0x16
c0021c71:	e9 fa fe ff ff       	jmp    c0021b70 <intr_entry>

c0021c76 <intr17_stub>:
c0021c76:	55                   	push   %ebp
c0021c77:	6a 00                	push   $0x0
c0021c79:	6a 17                	push   $0x17
c0021c7b:	e9 f0 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021c80 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021c80:	ff 34 24             	pushl  (%esp)
c0021c83:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c87:	6a 18                	push   $0x18
c0021c89:	e9 e2 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021c8e <intr19_stub>:
c0021c8e:	55                   	push   %ebp
c0021c8f:	6a 00                	push   $0x0
c0021c91:	6a 19                	push   $0x19
c0021c93:	e9 d8 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021c98 <intr1a_stub>:
c0021c98:	ff 34 24             	pushl  (%esp)
c0021c9b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c9f:	6a 1a                	push   $0x1a
c0021ca1:	e9 ca fe ff ff       	jmp    c0021b70 <intr_entry>

c0021ca6 <intr1b_stub>:
c0021ca6:	ff 34 24             	pushl  (%esp)
c0021ca9:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021cad:	6a 1b                	push   $0x1b
c0021caf:	e9 bc fe ff ff       	jmp    c0021b70 <intr_entry>

c0021cb4 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0021cb4:	55                   	push   %ebp
c0021cb5:	6a 00                	push   $0x0
c0021cb7:	6a 1c                	push   $0x1c
c0021cb9:	e9 b2 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021cbe <intr1d_stub>:
c0021cbe:	ff 34 24             	pushl  (%esp)
c0021cc1:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021cc5:	6a 1d                	push   $0x1d
c0021cc7:	e9 a4 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021ccc <intr1e_stub>:
c0021ccc:	ff 34 24             	pushl  (%esp)
c0021ccf:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021cd3:	6a 1e                	push   $0x1e
c0021cd5:	e9 96 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021cda <intr1f_stub>:
c0021cda:	55                   	push   %ebp
c0021cdb:	6a 00                	push   $0x0
c0021cdd:	6a 1f                	push   $0x1f
c0021cdf:	e9 8c fe ff ff       	jmp    c0021b70 <intr_entry>

c0021ce4 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0021ce4:	55                   	push   %ebp
c0021ce5:	6a 00                	push   $0x0
c0021ce7:	6a 20                	push   $0x20
c0021ce9:	e9 82 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021cee <intr21_stub>:
c0021cee:	55                   	push   %ebp
c0021cef:	6a 00                	push   $0x0
c0021cf1:	6a 21                	push   $0x21
c0021cf3:	e9 78 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021cf8 <intr22_stub>:
c0021cf8:	55                   	push   %ebp
c0021cf9:	6a 00                	push   $0x0
c0021cfb:	6a 22                	push   $0x22
c0021cfd:	e9 6e fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d02 <intr23_stub>:
c0021d02:	55                   	push   %ebp
c0021d03:	6a 00                	push   $0x0
c0021d05:	6a 23                	push   $0x23
c0021d07:	e9 64 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d0c <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0021d0c:	55                   	push   %ebp
c0021d0d:	6a 00                	push   $0x0
c0021d0f:	6a 24                	push   $0x24
c0021d11:	e9 5a fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d16 <intr25_stub>:
c0021d16:	55                   	push   %ebp
c0021d17:	6a 00                	push   $0x0
c0021d19:	6a 25                	push   $0x25
c0021d1b:	e9 50 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d20 <intr26_stub>:
c0021d20:	55                   	push   %ebp
c0021d21:	6a 00                	push   $0x0
c0021d23:	6a 26                	push   $0x26
c0021d25:	e9 46 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d2a <intr27_stub>:
c0021d2a:	55                   	push   %ebp
c0021d2b:	6a 00                	push   $0x0
c0021d2d:	6a 27                	push   $0x27
c0021d2f:	e9 3c fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d34 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0021d34:	55                   	push   %ebp
c0021d35:	6a 00                	push   $0x0
c0021d37:	6a 28                	push   $0x28
c0021d39:	e9 32 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d3e <intr29_stub>:
c0021d3e:	55                   	push   %ebp
c0021d3f:	6a 00                	push   $0x0
c0021d41:	6a 29                	push   $0x29
c0021d43:	e9 28 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d48 <intr2a_stub>:
c0021d48:	55                   	push   %ebp
c0021d49:	6a 00                	push   $0x0
c0021d4b:	6a 2a                	push   $0x2a
c0021d4d:	e9 1e fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d52 <intr2b_stub>:
c0021d52:	55                   	push   %ebp
c0021d53:	6a 00                	push   $0x0
c0021d55:	6a 2b                	push   $0x2b
c0021d57:	e9 14 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d5c <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0021d5c:	55                   	push   %ebp
c0021d5d:	6a 00                	push   $0x0
c0021d5f:	6a 2c                	push   $0x2c
c0021d61:	e9 0a fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d66 <intr2d_stub>:
c0021d66:	55                   	push   %ebp
c0021d67:	6a 00                	push   $0x0
c0021d69:	6a 2d                	push   $0x2d
c0021d6b:	e9 00 fe ff ff       	jmp    c0021b70 <intr_entry>

c0021d70 <intr2e_stub>:
c0021d70:	55                   	push   %ebp
c0021d71:	6a 00                	push   $0x0
c0021d73:	6a 2e                	push   $0x2e
c0021d75:	e9 f6 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021d7a <intr2f_stub>:
c0021d7a:	55                   	push   %ebp
c0021d7b:	6a 00                	push   $0x0
c0021d7d:	6a 2f                	push   $0x2f
c0021d7f:	e9 ec fd ff ff       	jmp    c0021b70 <intr_entry>

c0021d84 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c0021d84:	55                   	push   %ebp
c0021d85:	6a 00                	push   $0x0
c0021d87:	6a 30                	push   $0x30
c0021d89:	e9 e2 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021d8e <intr31_stub>:
c0021d8e:	55                   	push   %ebp
c0021d8f:	6a 00                	push   $0x0
c0021d91:	6a 31                	push   $0x31
c0021d93:	e9 d8 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021d98 <intr32_stub>:
c0021d98:	55                   	push   %ebp
c0021d99:	6a 00                	push   $0x0
c0021d9b:	6a 32                	push   $0x32
c0021d9d:	e9 ce fd ff ff       	jmp    c0021b70 <intr_entry>

c0021da2 <intr33_stub>:
c0021da2:	55                   	push   %ebp
c0021da3:	6a 00                	push   $0x0
c0021da5:	6a 33                	push   $0x33
c0021da7:	e9 c4 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021dac <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0021dac:	55                   	push   %ebp
c0021dad:	6a 00                	push   $0x0
c0021daf:	6a 34                	push   $0x34
c0021db1:	e9 ba fd ff ff       	jmp    c0021b70 <intr_entry>

c0021db6 <intr35_stub>:
c0021db6:	55                   	push   %ebp
c0021db7:	6a 00                	push   $0x0
c0021db9:	6a 35                	push   $0x35
c0021dbb:	e9 b0 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021dc0 <intr36_stub>:
c0021dc0:	55                   	push   %ebp
c0021dc1:	6a 00                	push   $0x0
c0021dc3:	6a 36                	push   $0x36
c0021dc5:	e9 a6 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021dca <intr37_stub>:
c0021dca:	55                   	push   %ebp
c0021dcb:	6a 00                	push   $0x0
c0021dcd:	6a 37                	push   $0x37
c0021dcf:	e9 9c fd ff ff       	jmp    c0021b70 <intr_entry>

c0021dd4 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0021dd4:	55                   	push   %ebp
c0021dd5:	6a 00                	push   $0x0
c0021dd7:	6a 38                	push   $0x38
c0021dd9:	e9 92 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021dde <intr39_stub>:
c0021dde:	55                   	push   %ebp
c0021ddf:	6a 00                	push   $0x0
c0021de1:	6a 39                	push   $0x39
c0021de3:	e9 88 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021de8 <intr3a_stub>:
c0021de8:	55                   	push   %ebp
c0021de9:	6a 00                	push   $0x0
c0021deb:	6a 3a                	push   $0x3a
c0021ded:	e9 7e fd ff ff       	jmp    c0021b70 <intr_entry>

c0021df2 <intr3b_stub>:
c0021df2:	55                   	push   %ebp
c0021df3:	6a 00                	push   $0x0
c0021df5:	6a 3b                	push   $0x3b
c0021df7:	e9 74 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021dfc <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0021dfc:	55                   	push   %ebp
c0021dfd:	6a 00                	push   $0x0
c0021dff:	6a 3c                	push   $0x3c
c0021e01:	e9 6a fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e06 <intr3d_stub>:
c0021e06:	55                   	push   %ebp
c0021e07:	6a 00                	push   $0x0
c0021e09:	6a 3d                	push   $0x3d
c0021e0b:	e9 60 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e10 <intr3e_stub>:
c0021e10:	55                   	push   %ebp
c0021e11:	6a 00                	push   $0x0
c0021e13:	6a 3e                	push   $0x3e
c0021e15:	e9 56 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e1a <intr3f_stub>:
c0021e1a:	55                   	push   %ebp
c0021e1b:	6a 00                	push   $0x0
c0021e1d:	6a 3f                	push   $0x3f
c0021e1f:	e9 4c fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e24 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0021e24:	55                   	push   %ebp
c0021e25:	6a 00                	push   $0x0
c0021e27:	6a 40                	push   $0x40
c0021e29:	e9 42 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e2e <intr41_stub>:
c0021e2e:	55                   	push   %ebp
c0021e2f:	6a 00                	push   $0x0
c0021e31:	6a 41                	push   $0x41
c0021e33:	e9 38 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e38 <intr42_stub>:
c0021e38:	55                   	push   %ebp
c0021e39:	6a 00                	push   $0x0
c0021e3b:	6a 42                	push   $0x42
c0021e3d:	e9 2e fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e42 <intr43_stub>:
c0021e42:	55                   	push   %ebp
c0021e43:	6a 00                	push   $0x0
c0021e45:	6a 43                	push   $0x43
c0021e47:	e9 24 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e4c <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0021e4c:	55                   	push   %ebp
c0021e4d:	6a 00                	push   $0x0
c0021e4f:	6a 44                	push   $0x44
c0021e51:	e9 1a fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e56 <intr45_stub>:
c0021e56:	55                   	push   %ebp
c0021e57:	6a 00                	push   $0x0
c0021e59:	6a 45                	push   $0x45
c0021e5b:	e9 10 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e60 <intr46_stub>:
c0021e60:	55                   	push   %ebp
c0021e61:	6a 00                	push   $0x0
c0021e63:	6a 46                	push   $0x46
c0021e65:	e9 06 fd ff ff       	jmp    c0021b70 <intr_entry>

c0021e6a <intr47_stub>:
c0021e6a:	55                   	push   %ebp
c0021e6b:	6a 00                	push   $0x0
c0021e6d:	6a 47                	push   $0x47
c0021e6f:	e9 fc fc ff ff       	jmp    c0021b70 <intr_entry>

c0021e74 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c0021e74:	55                   	push   %ebp
c0021e75:	6a 00                	push   $0x0
c0021e77:	6a 48                	push   $0x48
c0021e79:	e9 f2 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021e7e <intr49_stub>:
c0021e7e:	55                   	push   %ebp
c0021e7f:	6a 00                	push   $0x0
c0021e81:	6a 49                	push   $0x49
c0021e83:	e9 e8 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021e88 <intr4a_stub>:
c0021e88:	55                   	push   %ebp
c0021e89:	6a 00                	push   $0x0
c0021e8b:	6a 4a                	push   $0x4a
c0021e8d:	e9 de fc ff ff       	jmp    c0021b70 <intr_entry>

c0021e92 <intr4b_stub>:
c0021e92:	55                   	push   %ebp
c0021e93:	6a 00                	push   $0x0
c0021e95:	6a 4b                	push   $0x4b
c0021e97:	e9 d4 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021e9c <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c0021e9c:	55                   	push   %ebp
c0021e9d:	6a 00                	push   $0x0
c0021e9f:	6a 4c                	push   $0x4c
c0021ea1:	e9 ca fc ff ff       	jmp    c0021b70 <intr_entry>

c0021ea6 <intr4d_stub>:
c0021ea6:	55                   	push   %ebp
c0021ea7:	6a 00                	push   $0x0
c0021ea9:	6a 4d                	push   $0x4d
c0021eab:	e9 c0 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021eb0 <intr4e_stub>:
c0021eb0:	55                   	push   %ebp
c0021eb1:	6a 00                	push   $0x0
c0021eb3:	6a 4e                	push   $0x4e
c0021eb5:	e9 b6 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021eba <intr4f_stub>:
c0021eba:	55                   	push   %ebp
c0021ebb:	6a 00                	push   $0x0
c0021ebd:	6a 4f                	push   $0x4f
c0021ebf:	e9 ac fc ff ff       	jmp    c0021b70 <intr_entry>

c0021ec4 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0021ec4:	55                   	push   %ebp
c0021ec5:	6a 00                	push   $0x0
c0021ec7:	6a 50                	push   $0x50
c0021ec9:	e9 a2 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021ece <intr51_stub>:
c0021ece:	55                   	push   %ebp
c0021ecf:	6a 00                	push   $0x0
c0021ed1:	6a 51                	push   $0x51
c0021ed3:	e9 98 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021ed8 <intr52_stub>:
c0021ed8:	55                   	push   %ebp
c0021ed9:	6a 00                	push   $0x0
c0021edb:	6a 52                	push   $0x52
c0021edd:	e9 8e fc ff ff       	jmp    c0021b70 <intr_entry>

c0021ee2 <intr53_stub>:
c0021ee2:	55                   	push   %ebp
c0021ee3:	6a 00                	push   $0x0
c0021ee5:	6a 53                	push   $0x53
c0021ee7:	e9 84 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021eec <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0021eec:	55                   	push   %ebp
c0021eed:	6a 00                	push   $0x0
c0021eef:	6a 54                	push   $0x54
c0021ef1:	e9 7a fc ff ff       	jmp    c0021b70 <intr_entry>

c0021ef6 <intr55_stub>:
c0021ef6:	55                   	push   %ebp
c0021ef7:	6a 00                	push   $0x0
c0021ef9:	6a 55                	push   $0x55
c0021efb:	e9 70 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f00 <intr56_stub>:
c0021f00:	55                   	push   %ebp
c0021f01:	6a 00                	push   $0x0
c0021f03:	6a 56                	push   $0x56
c0021f05:	e9 66 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f0a <intr57_stub>:
c0021f0a:	55                   	push   %ebp
c0021f0b:	6a 00                	push   $0x0
c0021f0d:	6a 57                	push   $0x57
c0021f0f:	e9 5c fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f14 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0021f14:	55                   	push   %ebp
c0021f15:	6a 00                	push   $0x0
c0021f17:	6a 58                	push   $0x58
c0021f19:	e9 52 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f1e <intr59_stub>:
c0021f1e:	55                   	push   %ebp
c0021f1f:	6a 00                	push   $0x0
c0021f21:	6a 59                	push   $0x59
c0021f23:	e9 48 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f28 <intr5a_stub>:
c0021f28:	55                   	push   %ebp
c0021f29:	6a 00                	push   $0x0
c0021f2b:	6a 5a                	push   $0x5a
c0021f2d:	e9 3e fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f32 <intr5b_stub>:
c0021f32:	55                   	push   %ebp
c0021f33:	6a 00                	push   $0x0
c0021f35:	6a 5b                	push   $0x5b
c0021f37:	e9 34 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f3c <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0021f3c:	55                   	push   %ebp
c0021f3d:	6a 00                	push   $0x0
c0021f3f:	6a 5c                	push   $0x5c
c0021f41:	e9 2a fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f46 <intr5d_stub>:
c0021f46:	55                   	push   %ebp
c0021f47:	6a 00                	push   $0x0
c0021f49:	6a 5d                	push   $0x5d
c0021f4b:	e9 20 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f50 <intr5e_stub>:
c0021f50:	55                   	push   %ebp
c0021f51:	6a 00                	push   $0x0
c0021f53:	6a 5e                	push   $0x5e
c0021f55:	e9 16 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f5a <intr5f_stub>:
c0021f5a:	55                   	push   %ebp
c0021f5b:	6a 00                	push   $0x0
c0021f5d:	6a 5f                	push   $0x5f
c0021f5f:	e9 0c fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f64 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c0021f64:	55                   	push   %ebp
c0021f65:	6a 00                	push   $0x0
c0021f67:	6a 60                	push   $0x60
c0021f69:	e9 02 fc ff ff       	jmp    c0021b70 <intr_entry>

c0021f6e <intr61_stub>:
c0021f6e:	55                   	push   %ebp
c0021f6f:	6a 00                	push   $0x0
c0021f71:	6a 61                	push   $0x61
c0021f73:	e9 f8 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021f78 <intr62_stub>:
c0021f78:	55                   	push   %ebp
c0021f79:	6a 00                	push   $0x0
c0021f7b:	6a 62                	push   $0x62
c0021f7d:	e9 ee fb ff ff       	jmp    c0021b70 <intr_entry>

c0021f82 <intr63_stub>:
c0021f82:	55                   	push   %ebp
c0021f83:	6a 00                	push   $0x0
c0021f85:	6a 63                	push   $0x63
c0021f87:	e9 e4 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021f8c <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c0021f8c:	55                   	push   %ebp
c0021f8d:	6a 00                	push   $0x0
c0021f8f:	6a 64                	push   $0x64
c0021f91:	e9 da fb ff ff       	jmp    c0021b70 <intr_entry>

c0021f96 <intr65_stub>:
c0021f96:	55                   	push   %ebp
c0021f97:	6a 00                	push   $0x0
c0021f99:	6a 65                	push   $0x65
c0021f9b:	e9 d0 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021fa0 <intr66_stub>:
c0021fa0:	55                   	push   %ebp
c0021fa1:	6a 00                	push   $0x0
c0021fa3:	6a 66                	push   $0x66
c0021fa5:	e9 c6 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021faa <intr67_stub>:
c0021faa:	55                   	push   %ebp
c0021fab:	6a 00                	push   $0x0
c0021fad:	6a 67                	push   $0x67
c0021faf:	e9 bc fb ff ff       	jmp    c0021b70 <intr_entry>

c0021fb4 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c0021fb4:	55                   	push   %ebp
c0021fb5:	6a 00                	push   $0x0
c0021fb7:	6a 68                	push   $0x68
c0021fb9:	e9 b2 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021fbe <intr69_stub>:
c0021fbe:	55                   	push   %ebp
c0021fbf:	6a 00                	push   $0x0
c0021fc1:	6a 69                	push   $0x69
c0021fc3:	e9 a8 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021fc8 <intr6a_stub>:
c0021fc8:	55                   	push   %ebp
c0021fc9:	6a 00                	push   $0x0
c0021fcb:	6a 6a                	push   $0x6a
c0021fcd:	e9 9e fb ff ff       	jmp    c0021b70 <intr_entry>

c0021fd2 <intr6b_stub>:
c0021fd2:	55                   	push   %ebp
c0021fd3:	6a 00                	push   $0x0
c0021fd5:	6a 6b                	push   $0x6b
c0021fd7:	e9 94 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021fdc <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0021fdc:	55                   	push   %ebp
c0021fdd:	6a 00                	push   $0x0
c0021fdf:	6a 6c                	push   $0x6c
c0021fe1:	e9 8a fb ff ff       	jmp    c0021b70 <intr_entry>

c0021fe6 <intr6d_stub>:
c0021fe6:	55                   	push   %ebp
c0021fe7:	6a 00                	push   $0x0
c0021fe9:	6a 6d                	push   $0x6d
c0021feb:	e9 80 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021ff0 <intr6e_stub>:
c0021ff0:	55                   	push   %ebp
c0021ff1:	6a 00                	push   $0x0
c0021ff3:	6a 6e                	push   $0x6e
c0021ff5:	e9 76 fb ff ff       	jmp    c0021b70 <intr_entry>

c0021ffa <intr6f_stub>:
c0021ffa:	55                   	push   %ebp
c0021ffb:	6a 00                	push   $0x0
c0021ffd:	6a 6f                	push   $0x6f
c0021fff:	e9 6c fb ff ff       	jmp    c0021b70 <intr_entry>

c0022004 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c0022004:	55                   	push   %ebp
c0022005:	6a 00                	push   $0x0
c0022007:	6a 70                	push   $0x70
c0022009:	e9 62 fb ff ff       	jmp    c0021b70 <intr_entry>

c002200e <intr71_stub>:
c002200e:	55                   	push   %ebp
c002200f:	6a 00                	push   $0x0
c0022011:	6a 71                	push   $0x71
c0022013:	e9 58 fb ff ff       	jmp    c0021b70 <intr_entry>

c0022018 <intr72_stub>:
c0022018:	55                   	push   %ebp
c0022019:	6a 00                	push   $0x0
c002201b:	6a 72                	push   $0x72
c002201d:	e9 4e fb ff ff       	jmp    c0021b70 <intr_entry>

c0022022 <intr73_stub>:
c0022022:	55                   	push   %ebp
c0022023:	6a 00                	push   $0x0
c0022025:	6a 73                	push   $0x73
c0022027:	e9 44 fb ff ff       	jmp    c0021b70 <intr_entry>

c002202c <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c002202c:	55                   	push   %ebp
c002202d:	6a 00                	push   $0x0
c002202f:	6a 74                	push   $0x74
c0022031:	e9 3a fb ff ff       	jmp    c0021b70 <intr_entry>

c0022036 <intr75_stub>:
c0022036:	55                   	push   %ebp
c0022037:	6a 00                	push   $0x0
c0022039:	6a 75                	push   $0x75
c002203b:	e9 30 fb ff ff       	jmp    c0021b70 <intr_entry>

c0022040 <intr76_stub>:
c0022040:	55                   	push   %ebp
c0022041:	6a 00                	push   $0x0
c0022043:	6a 76                	push   $0x76
c0022045:	e9 26 fb ff ff       	jmp    c0021b70 <intr_entry>

c002204a <intr77_stub>:
c002204a:	55                   	push   %ebp
c002204b:	6a 00                	push   $0x0
c002204d:	6a 77                	push   $0x77
c002204f:	e9 1c fb ff ff       	jmp    c0021b70 <intr_entry>

c0022054 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c0022054:	55                   	push   %ebp
c0022055:	6a 00                	push   $0x0
c0022057:	6a 78                	push   $0x78
c0022059:	e9 12 fb ff ff       	jmp    c0021b70 <intr_entry>

c002205e <intr79_stub>:
c002205e:	55                   	push   %ebp
c002205f:	6a 00                	push   $0x0
c0022061:	6a 79                	push   $0x79
c0022063:	e9 08 fb ff ff       	jmp    c0021b70 <intr_entry>

c0022068 <intr7a_stub>:
c0022068:	55                   	push   %ebp
c0022069:	6a 00                	push   $0x0
c002206b:	6a 7a                	push   $0x7a
c002206d:	e9 fe fa ff ff       	jmp    c0021b70 <intr_entry>

c0022072 <intr7b_stub>:
c0022072:	55                   	push   %ebp
c0022073:	6a 00                	push   $0x0
c0022075:	6a 7b                	push   $0x7b
c0022077:	e9 f4 fa ff ff       	jmp    c0021b70 <intr_entry>

c002207c <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c002207c:	55                   	push   %ebp
c002207d:	6a 00                	push   $0x0
c002207f:	6a 7c                	push   $0x7c
c0022081:	e9 ea fa ff ff       	jmp    c0021b70 <intr_entry>

c0022086 <intr7d_stub>:
c0022086:	55                   	push   %ebp
c0022087:	6a 00                	push   $0x0
c0022089:	6a 7d                	push   $0x7d
c002208b:	e9 e0 fa ff ff       	jmp    c0021b70 <intr_entry>

c0022090 <intr7e_stub>:
c0022090:	55                   	push   %ebp
c0022091:	6a 00                	push   $0x0
c0022093:	6a 7e                	push   $0x7e
c0022095:	e9 d6 fa ff ff       	jmp    c0021b70 <intr_entry>

c002209a <intr7f_stub>:
c002209a:	55                   	push   %ebp
c002209b:	6a 00                	push   $0x0
c002209d:	6a 7f                	push   $0x7f
c002209f:	e9 cc fa ff ff       	jmp    c0021b70 <intr_entry>

c00220a4 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c00220a4:	55                   	push   %ebp
c00220a5:	6a 00                	push   $0x0
c00220a7:	68 80 00 00 00       	push   $0x80
c00220ac:	e9 bf fa ff ff       	jmp    c0021b70 <intr_entry>

c00220b1 <intr81_stub>:
c00220b1:	55                   	push   %ebp
c00220b2:	6a 00                	push   $0x0
c00220b4:	68 81 00 00 00       	push   $0x81
c00220b9:	e9 b2 fa ff ff       	jmp    c0021b70 <intr_entry>

c00220be <intr82_stub>:
c00220be:	55                   	push   %ebp
c00220bf:	6a 00                	push   $0x0
c00220c1:	68 82 00 00 00       	push   $0x82
c00220c6:	e9 a5 fa ff ff       	jmp    c0021b70 <intr_entry>

c00220cb <intr83_stub>:
c00220cb:	55                   	push   %ebp
c00220cc:	6a 00                	push   $0x0
c00220ce:	68 83 00 00 00       	push   $0x83
c00220d3:	e9 98 fa ff ff       	jmp    c0021b70 <intr_entry>

c00220d8 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c00220d8:	55                   	push   %ebp
c00220d9:	6a 00                	push   $0x0
c00220db:	68 84 00 00 00       	push   $0x84
c00220e0:	e9 8b fa ff ff       	jmp    c0021b70 <intr_entry>

c00220e5 <intr85_stub>:
c00220e5:	55                   	push   %ebp
c00220e6:	6a 00                	push   $0x0
c00220e8:	68 85 00 00 00       	push   $0x85
c00220ed:	e9 7e fa ff ff       	jmp    c0021b70 <intr_entry>

c00220f2 <intr86_stub>:
c00220f2:	55                   	push   %ebp
c00220f3:	6a 00                	push   $0x0
c00220f5:	68 86 00 00 00       	push   $0x86
c00220fa:	e9 71 fa ff ff       	jmp    c0021b70 <intr_entry>

c00220ff <intr87_stub>:
c00220ff:	55                   	push   %ebp
c0022100:	6a 00                	push   $0x0
c0022102:	68 87 00 00 00       	push   $0x87
c0022107:	e9 64 fa ff ff       	jmp    c0021b70 <intr_entry>

c002210c <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c002210c:	55                   	push   %ebp
c002210d:	6a 00                	push   $0x0
c002210f:	68 88 00 00 00       	push   $0x88
c0022114:	e9 57 fa ff ff       	jmp    c0021b70 <intr_entry>

c0022119 <intr89_stub>:
c0022119:	55                   	push   %ebp
c002211a:	6a 00                	push   $0x0
c002211c:	68 89 00 00 00       	push   $0x89
c0022121:	e9 4a fa ff ff       	jmp    c0021b70 <intr_entry>

c0022126 <intr8a_stub>:
c0022126:	55                   	push   %ebp
c0022127:	6a 00                	push   $0x0
c0022129:	68 8a 00 00 00       	push   $0x8a
c002212e:	e9 3d fa ff ff       	jmp    c0021b70 <intr_entry>

c0022133 <intr8b_stub>:
c0022133:	55                   	push   %ebp
c0022134:	6a 00                	push   $0x0
c0022136:	68 8b 00 00 00       	push   $0x8b
c002213b:	e9 30 fa ff ff       	jmp    c0021b70 <intr_entry>

c0022140 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c0022140:	55                   	push   %ebp
c0022141:	6a 00                	push   $0x0
c0022143:	68 8c 00 00 00       	push   $0x8c
c0022148:	e9 23 fa ff ff       	jmp    c0021b70 <intr_entry>

c002214d <intr8d_stub>:
c002214d:	55                   	push   %ebp
c002214e:	6a 00                	push   $0x0
c0022150:	68 8d 00 00 00       	push   $0x8d
c0022155:	e9 16 fa ff ff       	jmp    c0021b70 <intr_entry>

c002215a <intr8e_stub>:
c002215a:	55                   	push   %ebp
c002215b:	6a 00                	push   $0x0
c002215d:	68 8e 00 00 00       	push   $0x8e
c0022162:	e9 09 fa ff ff       	jmp    c0021b70 <intr_entry>

c0022167 <intr8f_stub>:
c0022167:	55                   	push   %ebp
c0022168:	6a 00                	push   $0x0
c002216a:	68 8f 00 00 00       	push   $0x8f
c002216f:	e9 fc f9 ff ff       	jmp    c0021b70 <intr_entry>

c0022174 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c0022174:	55                   	push   %ebp
c0022175:	6a 00                	push   $0x0
c0022177:	68 90 00 00 00       	push   $0x90
c002217c:	e9 ef f9 ff ff       	jmp    c0021b70 <intr_entry>

c0022181 <intr91_stub>:
c0022181:	55                   	push   %ebp
c0022182:	6a 00                	push   $0x0
c0022184:	68 91 00 00 00       	push   $0x91
c0022189:	e9 e2 f9 ff ff       	jmp    c0021b70 <intr_entry>

c002218e <intr92_stub>:
c002218e:	55                   	push   %ebp
c002218f:	6a 00                	push   $0x0
c0022191:	68 92 00 00 00       	push   $0x92
c0022196:	e9 d5 f9 ff ff       	jmp    c0021b70 <intr_entry>

c002219b <intr93_stub>:
c002219b:	55                   	push   %ebp
c002219c:	6a 00                	push   $0x0
c002219e:	68 93 00 00 00       	push   $0x93
c00221a3:	e9 c8 f9 ff ff       	jmp    c0021b70 <intr_entry>

c00221a8 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c00221a8:	55                   	push   %ebp
c00221a9:	6a 00                	push   $0x0
c00221ab:	68 94 00 00 00       	push   $0x94
c00221b0:	e9 bb f9 ff ff       	jmp    c0021b70 <intr_entry>

c00221b5 <intr95_stub>:
c00221b5:	55                   	push   %ebp
c00221b6:	6a 00                	push   $0x0
c00221b8:	68 95 00 00 00       	push   $0x95
c00221bd:	e9 ae f9 ff ff       	jmp    c0021b70 <intr_entry>

c00221c2 <intr96_stub>:
c00221c2:	55                   	push   %ebp
c00221c3:	6a 00                	push   $0x0
c00221c5:	68 96 00 00 00       	push   $0x96
c00221ca:	e9 a1 f9 ff ff       	jmp    c0021b70 <intr_entry>

c00221cf <intr97_stub>:
c00221cf:	55                   	push   %ebp
c00221d0:	6a 00                	push   $0x0
c00221d2:	68 97 00 00 00       	push   $0x97
c00221d7:	e9 94 f9 ff ff       	jmp    c0021b70 <intr_entry>

c00221dc <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c00221dc:	55                   	push   %ebp
c00221dd:	6a 00                	push   $0x0
c00221df:	68 98 00 00 00       	push   $0x98
c00221e4:	e9 87 f9 ff ff       	jmp    c0021b70 <intr_entry>

c00221e9 <intr99_stub>:
c00221e9:	55                   	push   %ebp
c00221ea:	6a 00                	push   $0x0
c00221ec:	68 99 00 00 00       	push   $0x99
c00221f1:	e9 7a f9 ff ff       	jmp    c0021b70 <intr_entry>

c00221f6 <intr9a_stub>:
c00221f6:	55                   	push   %ebp
c00221f7:	6a 00                	push   $0x0
c00221f9:	68 9a 00 00 00       	push   $0x9a
c00221fe:	e9 6d f9 ff ff       	jmp    c0021b70 <intr_entry>

c0022203 <intr9b_stub>:
c0022203:	55                   	push   %ebp
c0022204:	6a 00                	push   $0x0
c0022206:	68 9b 00 00 00       	push   $0x9b
c002220b:	e9 60 f9 ff ff       	jmp    c0021b70 <intr_entry>

c0022210 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c0022210:	55                   	push   %ebp
c0022211:	6a 00                	push   $0x0
c0022213:	68 9c 00 00 00       	push   $0x9c
c0022218:	e9 53 f9 ff ff       	jmp    c0021b70 <intr_entry>

c002221d <intr9d_stub>:
c002221d:	55                   	push   %ebp
c002221e:	6a 00                	push   $0x0
c0022220:	68 9d 00 00 00       	push   $0x9d
c0022225:	e9 46 f9 ff ff       	jmp    c0021b70 <intr_entry>

c002222a <intr9e_stub>:
c002222a:	55                   	push   %ebp
c002222b:	6a 00                	push   $0x0
c002222d:	68 9e 00 00 00       	push   $0x9e
c0022232:	e9 39 f9 ff ff       	jmp    c0021b70 <intr_entry>

c0022237 <intr9f_stub>:
c0022237:	55                   	push   %ebp
c0022238:	6a 00                	push   $0x0
c002223a:	68 9f 00 00 00       	push   $0x9f
c002223f:	e9 2c f9 ff ff       	jmp    c0021b70 <intr_entry>

c0022244 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c0022244:	55                   	push   %ebp
c0022245:	6a 00                	push   $0x0
c0022247:	68 a0 00 00 00       	push   $0xa0
c002224c:	e9 1f f9 ff ff       	jmp    c0021b70 <intr_entry>

c0022251 <intra1_stub>:
c0022251:	55                   	push   %ebp
c0022252:	6a 00                	push   $0x0
c0022254:	68 a1 00 00 00       	push   $0xa1
c0022259:	e9 12 f9 ff ff       	jmp    c0021b70 <intr_entry>

c002225e <intra2_stub>:
c002225e:	55                   	push   %ebp
c002225f:	6a 00                	push   $0x0
c0022261:	68 a2 00 00 00       	push   $0xa2
c0022266:	e9 05 f9 ff ff       	jmp    c0021b70 <intr_entry>

c002226b <intra3_stub>:
c002226b:	55                   	push   %ebp
c002226c:	6a 00                	push   $0x0
c002226e:	68 a3 00 00 00       	push   $0xa3
c0022273:	e9 f8 f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022278 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c0022278:	55                   	push   %ebp
c0022279:	6a 00                	push   $0x0
c002227b:	68 a4 00 00 00       	push   $0xa4
c0022280:	e9 eb f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022285 <intra5_stub>:
c0022285:	55                   	push   %ebp
c0022286:	6a 00                	push   $0x0
c0022288:	68 a5 00 00 00       	push   $0xa5
c002228d:	e9 de f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022292 <intra6_stub>:
c0022292:	55                   	push   %ebp
c0022293:	6a 00                	push   $0x0
c0022295:	68 a6 00 00 00       	push   $0xa6
c002229a:	e9 d1 f8 ff ff       	jmp    c0021b70 <intr_entry>

c002229f <intra7_stub>:
c002229f:	55                   	push   %ebp
c00222a0:	6a 00                	push   $0x0
c00222a2:	68 a7 00 00 00       	push   $0xa7
c00222a7:	e9 c4 f8 ff ff       	jmp    c0021b70 <intr_entry>

c00222ac <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c00222ac:	55                   	push   %ebp
c00222ad:	6a 00                	push   $0x0
c00222af:	68 a8 00 00 00       	push   $0xa8
c00222b4:	e9 b7 f8 ff ff       	jmp    c0021b70 <intr_entry>

c00222b9 <intra9_stub>:
c00222b9:	55                   	push   %ebp
c00222ba:	6a 00                	push   $0x0
c00222bc:	68 a9 00 00 00       	push   $0xa9
c00222c1:	e9 aa f8 ff ff       	jmp    c0021b70 <intr_entry>

c00222c6 <intraa_stub>:
c00222c6:	55                   	push   %ebp
c00222c7:	6a 00                	push   $0x0
c00222c9:	68 aa 00 00 00       	push   $0xaa
c00222ce:	e9 9d f8 ff ff       	jmp    c0021b70 <intr_entry>

c00222d3 <intrab_stub>:
c00222d3:	55                   	push   %ebp
c00222d4:	6a 00                	push   $0x0
c00222d6:	68 ab 00 00 00       	push   $0xab
c00222db:	e9 90 f8 ff ff       	jmp    c0021b70 <intr_entry>

c00222e0 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c00222e0:	55                   	push   %ebp
c00222e1:	6a 00                	push   $0x0
c00222e3:	68 ac 00 00 00       	push   $0xac
c00222e8:	e9 83 f8 ff ff       	jmp    c0021b70 <intr_entry>

c00222ed <intrad_stub>:
c00222ed:	55                   	push   %ebp
c00222ee:	6a 00                	push   $0x0
c00222f0:	68 ad 00 00 00       	push   $0xad
c00222f5:	e9 76 f8 ff ff       	jmp    c0021b70 <intr_entry>

c00222fa <intrae_stub>:
c00222fa:	55                   	push   %ebp
c00222fb:	6a 00                	push   $0x0
c00222fd:	68 ae 00 00 00       	push   $0xae
c0022302:	e9 69 f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022307 <intraf_stub>:
c0022307:	55                   	push   %ebp
c0022308:	6a 00                	push   $0x0
c002230a:	68 af 00 00 00       	push   $0xaf
c002230f:	e9 5c f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022314 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022314:	55                   	push   %ebp
c0022315:	6a 00                	push   $0x0
c0022317:	68 b0 00 00 00       	push   $0xb0
c002231c:	e9 4f f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022321 <intrb1_stub>:
c0022321:	55                   	push   %ebp
c0022322:	6a 00                	push   $0x0
c0022324:	68 b1 00 00 00       	push   $0xb1
c0022329:	e9 42 f8 ff ff       	jmp    c0021b70 <intr_entry>

c002232e <intrb2_stub>:
c002232e:	55                   	push   %ebp
c002232f:	6a 00                	push   $0x0
c0022331:	68 b2 00 00 00       	push   $0xb2
c0022336:	e9 35 f8 ff ff       	jmp    c0021b70 <intr_entry>

c002233b <intrb3_stub>:
c002233b:	55                   	push   %ebp
c002233c:	6a 00                	push   $0x0
c002233e:	68 b3 00 00 00       	push   $0xb3
c0022343:	e9 28 f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022348 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c0022348:	55                   	push   %ebp
c0022349:	6a 00                	push   $0x0
c002234b:	68 b4 00 00 00       	push   $0xb4
c0022350:	e9 1b f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022355 <intrb5_stub>:
c0022355:	55                   	push   %ebp
c0022356:	6a 00                	push   $0x0
c0022358:	68 b5 00 00 00       	push   $0xb5
c002235d:	e9 0e f8 ff ff       	jmp    c0021b70 <intr_entry>

c0022362 <intrb6_stub>:
c0022362:	55                   	push   %ebp
c0022363:	6a 00                	push   $0x0
c0022365:	68 b6 00 00 00       	push   $0xb6
c002236a:	e9 01 f8 ff ff       	jmp    c0021b70 <intr_entry>

c002236f <intrb7_stub>:
c002236f:	55                   	push   %ebp
c0022370:	6a 00                	push   $0x0
c0022372:	68 b7 00 00 00       	push   $0xb7
c0022377:	e9 f4 f7 ff ff       	jmp    c0021b70 <intr_entry>

c002237c <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c002237c:	55                   	push   %ebp
c002237d:	6a 00                	push   $0x0
c002237f:	68 b8 00 00 00       	push   $0xb8
c0022384:	e9 e7 f7 ff ff       	jmp    c0021b70 <intr_entry>

c0022389 <intrb9_stub>:
c0022389:	55                   	push   %ebp
c002238a:	6a 00                	push   $0x0
c002238c:	68 b9 00 00 00       	push   $0xb9
c0022391:	e9 da f7 ff ff       	jmp    c0021b70 <intr_entry>

c0022396 <intrba_stub>:
c0022396:	55                   	push   %ebp
c0022397:	6a 00                	push   $0x0
c0022399:	68 ba 00 00 00       	push   $0xba
c002239e:	e9 cd f7 ff ff       	jmp    c0021b70 <intr_entry>

c00223a3 <intrbb_stub>:
c00223a3:	55                   	push   %ebp
c00223a4:	6a 00                	push   $0x0
c00223a6:	68 bb 00 00 00       	push   $0xbb
c00223ab:	e9 c0 f7 ff ff       	jmp    c0021b70 <intr_entry>

c00223b0 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c00223b0:	55                   	push   %ebp
c00223b1:	6a 00                	push   $0x0
c00223b3:	68 bc 00 00 00       	push   $0xbc
c00223b8:	e9 b3 f7 ff ff       	jmp    c0021b70 <intr_entry>

c00223bd <intrbd_stub>:
c00223bd:	55                   	push   %ebp
c00223be:	6a 00                	push   $0x0
c00223c0:	68 bd 00 00 00       	push   $0xbd
c00223c5:	e9 a6 f7 ff ff       	jmp    c0021b70 <intr_entry>

c00223ca <intrbe_stub>:
c00223ca:	55                   	push   %ebp
c00223cb:	6a 00                	push   $0x0
c00223cd:	68 be 00 00 00       	push   $0xbe
c00223d2:	e9 99 f7 ff ff       	jmp    c0021b70 <intr_entry>

c00223d7 <intrbf_stub>:
c00223d7:	55                   	push   %ebp
c00223d8:	6a 00                	push   $0x0
c00223da:	68 bf 00 00 00       	push   $0xbf
c00223df:	e9 8c f7 ff ff       	jmp    c0021b70 <intr_entry>

c00223e4 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c00223e4:	55                   	push   %ebp
c00223e5:	6a 00                	push   $0x0
c00223e7:	68 c0 00 00 00       	push   $0xc0
c00223ec:	e9 7f f7 ff ff       	jmp    c0021b70 <intr_entry>

c00223f1 <intrc1_stub>:
c00223f1:	55                   	push   %ebp
c00223f2:	6a 00                	push   $0x0
c00223f4:	68 c1 00 00 00       	push   $0xc1
c00223f9:	e9 72 f7 ff ff       	jmp    c0021b70 <intr_entry>

c00223fe <intrc2_stub>:
c00223fe:	55                   	push   %ebp
c00223ff:	6a 00                	push   $0x0
c0022401:	68 c2 00 00 00       	push   $0xc2
c0022406:	e9 65 f7 ff ff       	jmp    c0021b70 <intr_entry>

c002240b <intrc3_stub>:
c002240b:	55                   	push   %ebp
c002240c:	6a 00                	push   $0x0
c002240e:	68 c3 00 00 00       	push   $0xc3
c0022413:	e9 58 f7 ff ff       	jmp    c0021b70 <intr_entry>

c0022418 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022418:	55                   	push   %ebp
c0022419:	6a 00                	push   $0x0
c002241b:	68 c4 00 00 00       	push   $0xc4
c0022420:	e9 4b f7 ff ff       	jmp    c0021b70 <intr_entry>

c0022425 <intrc5_stub>:
c0022425:	55                   	push   %ebp
c0022426:	6a 00                	push   $0x0
c0022428:	68 c5 00 00 00       	push   $0xc5
c002242d:	e9 3e f7 ff ff       	jmp    c0021b70 <intr_entry>

c0022432 <intrc6_stub>:
c0022432:	55                   	push   %ebp
c0022433:	6a 00                	push   $0x0
c0022435:	68 c6 00 00 00       	push   $0xc6
c002243a:	e9 31 f7 ff ff       	jmp    c0021b70 <intr_entry>

c002243f <intrc7_stub>:
c002243f:	55                   	push   %ebp
c0022440:	6a 00                	push   $0x0
c0022442:	68 c7 00 00 00       	push   $0xc7
c0022447:	e9 24 f7 ff ff       	jmp    c0021b70 <intr_entry>

c002244c <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c002244c:	55                   	push   %ebp
c002244d:	6a 00                	push   $0x0
c002244f:	68 c8 00 00 00       	push   $0xc8
c0022454:	e9 17 f7 ff ff       	jmp    c0021b70 <intr_entry>

c0022459 <intrc9_stub>:
c0022459:	55                   	push   %ebp
c002245a:	6a 00                	push   $0x0
c002245c:	68 c9 00 00 00       	push   $0xc9
c0022461:	e9 0a f7 ff ff       	jmp    c0021b70 <intr_entry>

c0022466 <intrca_stub>:
c0022466:	55                   	push   %ebp
c0022467:	6a 00                	push   $0x0
c0022469:	68 ca 00 00 00       	push   $0xca
c002246e:	e9 fd f6 ff ff       	jmp    c0021b70 <intr_entry>

c0022473 <intrcb_stub>:
c0022473:	55                   	push   %ebp
c0022474:	6a 00                	push   $0x0
c0022476:	68 cb 00 00 00       	push   $0xcb
c002247b:	e9 f0 f6 ff ff       	jmp    c0021b70 <intr_entry>

c0022480 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022480:	55                   	push   %ebp
c0022481:	6a 00                	push   $0x0
c0022483:	68 cc 00 00 00       	push   $0xcc
c0022488:	e9 e3 f6 ff ff       	jmp    c0021b70 <intr_entry>

c002248d <intrcd_stub>:
c002248d:	55                   	push   %ebp
c002248e:	6a 00                	push   $0x0
c0022490:	68 cd 00 00 00       	push   $0xcd
c0022495:	e9 d6 f6 ff ff       	jmp    c0021b70 <intr_entry>

c002249a <intrce_stub>:
c002249a:	55                   	push   %ebp
c002249b:	6a 00                	push   $0x0
c002249d:	68 ce 00 00 00       	push   $0xce
c00224a2:	e9 c9 f6 ff ff       	jmp    c0021b70 <intr_entry>

c00224a7 <intrcf_stub>:
c00224a7:	55                   	push   %ebp
c00224a8:	6a 00                	push   $0x0
c00224aa:	68 cf 00 00 00       	push   $0xcf
c00224af:	e9 bc f6 ff ff       	jmp    c0021b70 <intr_entry>

c00224b4 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c00224b4:	55                   	push   %ebp
c00224b5:	6a 00                	push   $0x0
c00224b7:	68 d0 00 00 00       	push   $0xd0
c00224bc:	e9 af f6 ff ff       	jmp    c0021b70 <intr_entry>

c00224c1 <intrd1_stub>:
c00224c1:	55                   	push   %ebp
c00224c2:	6a 00                	push   $0x0
c00224c4:	68 d1 00 00 00       	push   $0xd1
c00224c9:	e9 a2 f6 ff ff       	jmp    c0021b70 <intr_entry>

c00224ce <intrd2_stub>:
c00224ce:	55                   	push   %ebp
c00224cf:	6a 00                	push   $0x0
c00224d1:	68 d2 00 00 00       	push   $0xd2
c00224d6:	e9 95 f6 ff ff       	jmp    c0021b70 <intr_entry>

c00224db <intrd3_stub>:
c00224db:	55                   	push   %ebp
c00224dc:	6a 00                	push   $0x0
c00224de:	68 d3 00 00 00       	push   $0xd3
c00224e3:	e9 88 f6 ff ff       	jmp    c0021b70 <intr_entry>

c00224e8 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c00224e8:	55                   	push   %ebp
c00224e9:	6a 00                	push   $0x0
c00224eb:	68 d4 00 00 00       	push   $0xd4
c00224f0:	e9 7b f6 ff ff       	jmp    c0021b70 <intr_entry>

c00224f5 <intrd5_stub>:
c00224f5:	55                   	push   %ebp
c00224f6:	6a 00                	push   $0x0
c00224f8:	68 d5 00 00 00       	push   $0xd5
c00224fd:	e9 6e f6 ff ff       	jmp    c0021b70 <intr_entry>

c0022502 <intrd6_stub>:
c0022502:	55                   	push   %ebp
c0022503:	6a 00                	push   $0x0
c0022505:	68 d6 00 00 00       	push   $0xd6
c002250a:	e9 61 f6 ff ff       	jmp    c0021b70 <intr_entry>

c002250f <intrd7_stub>:
c002250f:	55                   	push   %ebp
c0022510:	6a 00                	push   $0x0
c0022512:	68 d7 00 00 00       	push   $0xd7
c0022517:	e9 54 f6 ff ff       	jmp    c0021b70 <intr_entry>

c002251c <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c002251c:	55                   	push   %ebp
c002251d:	6a 00                	push   $0x0
c002251f:	68 d8 00 00 00       	push   $0xd8
c0022524:	e9 47 f6 ff ff       	jmp    c0021b70 <intr_entry>

c0022529 <intrd9_stub>:
c0022529:	55                   	push   %ebp
c002252a:	6a 00                	push   $0x0
c002252c:	68 d9 00 00 00       	push   $0xd9
c0022531:	e9 3a f6 ff ff       	jmp    c0021b70 <intr_entry>

c0022536 <intrda_stub>:
c0022536:	55                   	push   %ebp
c0022537:	6a 00                	push   $0x0
c0022539:	68 da 00 00 00       	push   $0xda
c002253e:	e9 2d f6 ff ff       	jmp    c0021b70 <intr_entry>

c0022543 <intrdb_stub>:
c0022543:	55                   	push   %ebp
c0022544:	6a 00                	push   $0x0
c0022546:	68 db 00 00 00       	push   $0xdb
c002254b:	e9 20 f6 ff ff       	jmp    c0021b70 <intr_entry>

c0022550 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022550:	55                   	push   %ebp
c0022551:	6a 00                	push   $0x0
c0022553:	68 dc 00 00 00       	push   $0xdc
c0022558:	e9 13 f6 ff ff       	jmp    c0021b70 <intr_entry>

c002255d <intrdd_stub>:
c002255d:	55                   	push   %ebp
c002255e:	6a 00                	push   $0x0
c0022560:	68 dd 00 00 00       	push   $0xdd
c0022565:	e9 06 f6 ff ff       	jmp    c0021b70 <intr_entry>

c002256a <intrde_stub>:
c002256a:	55                   	push   %ebp
c002256b:	6a 00                	push   $0x0
c002256d:	68 de 00 00 00       	push   $0xde
c0022572:	e9 f9 f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022577 <intrdf_stub>:
c0022577:	55                   	push   %ebp
c0022578:	6a 00                	push   $0x0
c002257a:	68 df 00 00 00       	push   $0xdf
c002257f:	e9 ec f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022584 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022584:	55                   	push   %ebp
c0022585:	6a 00                	push   $0x0
c0022587:	68 e0 00 00 00       	push   $0xe0
c002258c:	e9 df f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022591 <intre1_stub>:
c0022591:	55                   	push   %ebp
c0022592:	6a 00                	push   $0x0
c0022594:	68 e1 00 00 00       	push   $0xe1
c0022599:	e9 d2 f5 ff ff       	jmp    c0021b70 <intr_entry>

c002259e <intre2_stub>:
c002259e:	55                   	push   %ebp
c002259f:	6a 00                	push   $0x0
c00225a1:	68 e2 00 00 00       	push   $0xe2
c00225a6:	e9 c5 f5 ff ff       	jmp    c0021b70 <intr_entry>

c00225ab <intre3_stub>:
c00225ab:	55                   	push   %ebp
c00225ac:	6a 00                	push   $0x0
c00225ae:	68 e3 00 00 00       	push   $0xe3
c00225b3:	e9 b8 f5 ff ff       	jmp    c0021b70 <intr_entry>

c00225b8 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c00225b8:	55                   	push   %ebp
c00225b9:	6a 00                	push   $0x0
c00225bb:	68 e4 00 00 00       	push   $0xe4
c00225c0:	e9 ab f5 ff ff       	jmp    c0021b70 <intr_entry>

c00225c5 <intre5_stub>:
c00225c5:	55                   	push   %ebp
c00225c6:	6a 00                	push   $0x0
c00225c8:	68 e5 00 00 00       	push   $0xe5
c00225cd:	e9 9e f5 ff ff       	jmp    c0021b70 <intr_entry>

c00225d2 <intre6_stub>:
c00225d2:	55                   	push   %ebp
c00225d3:	6a 00                	push   $0x0
c00225d5:	68 e6 00 00 00       	push   $0xe6
c00225da:	e9 91 f5 ff ff       	jmp    c0021b70 <intr_entry>

c00225df <intre7_stub>:
c00225df:	55                   	push   %ebp
c00225e0:	6a 00                	push   $0x0
c00225e2:	68 e7 00 00 00       	push   $0xe7
c00225e7:	e9 84 f5 ff ff       	jmp    c0021b70 <intr_entry>

c00225ec <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c00225ec:	55                   	push   %ebp
c00225ed:	6a 00                	push   $0x0
c00225ef:	68 e8 00 00 00       	push   $0xe8
c00225f4:	e9 77 f5 ff ff       	jmp    c0021b70 <intr_entry>

c00225f9 <intre9_stub>:
c00225f9:	55                   	push   %ebp
c00225fa:	6a 00                	push   $0x0
c00225fc:	68 e9 00 00 00       	push   $0xe9
c0022601:	e9 6a f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022606 <intrea_stub>:
c0022606:	55                   	push   %ebp
c0022607:	6a 00                	push   $0x0
c0022609:	68 ea 00 00 00       	push   $0xea
c002260e:	e9 5d f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022613 <intreb_stub>:
c0022613:	55                   	push   %ebp
c0022614:	6a 00                	push   $0x0
c0022616:	68 eb 00 00 00       	push   $0xeb
c002261b:	e9 50 f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022620 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022620:	55                   	push   %ebp
c0022621:	6a 00                	push   $0x0
c0022623:	68 ec 00 00 00       	push   $0xec
c0022628:	e9 43 f5 ff ff       	jmp    c0021b70 <intr_entry>

c002262d <intred_stub>:
c002262d:	55                   	push   %ebp
c002262e:	6a 00                	push   $0x0
c0022630:	68 ed 00 00 00       	push   $0xed
c0022635:	e9 36 f5 ff ff       	jmp    c0021b70 <intr_entry>

c002263a <intree_stub>:
c002263a:	55                   	push   %ebp
c002263b:	6a 00                	push   $0x0
c002263d:	68 ee 00 00 00       	push   $0xee
c0022642:	e9 29 f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022647 <intref_stub>:
c0022647:	55                   	push   %ebp
c0022648:	6a 00                	push   $0x0
c002264a:	68 ef 00 00 00       	push   $0xef
c002264f:	e9 1c f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022654 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022654:	55                   	push   %ebp
c0022655:	6a 00                	push   $0x0
c0022657:	68 f0 00 00 00       	push   $0xf0
c002265c:	e9 0f f5 ff ff       	jmp    c0021b70 <intr_entry>

c0022661 <intrf1_stub>:
c0022661:	55                   	push   %ebp
c0022662:	6a 00                	push   $0x0
c0022664:	68 f1 00 00 00       	push   $0xf1
c0022669:	e9 02 f5 ff ff       	jmp    c0021b70 <intr_entry>

c002266e <intrf2_stub>:
c002266e:	55                   	push   %ebp
c002266f:	6a 00                	push   $0x0
c0022671:	68 f2 00 00 00       	push   $0xf2
c0022676:	e9 f5 f4 ff ff       	jmp    c0021b70 <intr_entry>

c002267b <intrf3_stub>:
c002267b:	55                   	push   %ebp
c002267c:	6a 00                	push   $0x0
c002267e:	68 f3 00 00 00       	push   $0xf3
c0022683:	e9 e8 f4 ff ff       	jmp    c0021b70 <intr_entry>

c0022688 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022688:	55                   	push   %ebp
c0022689:	6a 00                	push   $0x0
c002268b:	68 f4 00 00 00       	push   $0xf4
c0022690:	e9 db f4 ff ff       	jmp    c0021b70 <intr_entry>

c0022695 <intrf5_stub>:
c0022695:	55                   	push   %ebp
c0022696:	6a 00                	push   $0x0
c0022698:	68 f5 00 00 00       	push   $0xf5
c002269d:	e9 ce f4 ff ff       	jmp    c0021b70 <intr_entry>

c00226a2 <intrf6_stub>:
c00226a2:	55                   	push   %ebp
c00226a3:	6a 00                	push   $0x0
c00226a5:	68 f6 00 00 00       	push   $0xf6
c00226aa:	e9 c1 f4 ff ff       	jmp    c0021b70 <intr_entry>

c00226af <intrf7_stub>:
c00226af:	55                   	push   %ebp
c00226b0:	6a 00                	push   $0x0
c00226b2:	68 f7 00 00 00       	push   $0xf7
c00226b7:	e9 b4 f4 ff ff       	jmp    c0021b70 <intr_entry>

c00226bc <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c00226bc:	55                   	push   %ebp
c00226bd:	6a 00                	push   $0x0
c00226bf:	68 f8 00 00 00       	push   $0xf8
c00226c4:	e9 a7 f4 ff ff       	jmp    c0021b70 <intr_entry>

c00226c9 <intrf9_stub>:
c00226c9:	55                   	push   %ebp
c00226ca:	6a 00                	push   $0x0
c00226cc:	68 f9 00 00 00       	push   $0xf9
c00226d1:	e9 9a f4 ff ff       	jmp    c0021b70 <intr_entry>

c00226d6 <intrfa_stub>:
c00226d6:	55                   	push   %ebp
c00226d7:	6a 00                	push   $0x0
c00226d9:	68 fa 00 00 00       	push   $0xfa
c00226de:	e9 8d f4 ff ff       	jmp    c0021b70 <intr_entry>

c00226e3 <intrfb_stub>:
c00226e3:	55                   	push   %ebp
c00226e4:	6a 00                	push   $0x0
c00226e6:	68 fb 00 00 00       	push   $0xfb
c00226eb:	e9 80 f4 ff ff       	jmp    c0021b70 <intr_entry>

c00226f0 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c00226f0:	55                   	push   %ebp
c00226f1:	6a 00                	push   $0x0
c00226f3:	68 fc 00 00 00       	push   $0xfc
c00226f8:	e9 73 f4 ff ff       	jmp    c0021b70 <intr_entry>

c00226fd <intrfd_stub>:
c00226fd:	55                   	push   %ebp
c00226fe:	6a 00                	push   $0x0
c0022700:	68 fd 00 00 00       	push   $0xfd
c0022705:	e9 66 f4 ff ff       	jmp    c0021b70 <intr_entry>

c002270a <intrfe_stub>:
c002270a:	55                   	push   %ebp
c002270b:	6a 00                	push   $0x0
c002270d:	68 fe 00 00 00       	push   $0xfe
c0022712:	e9 59 f4 ff ff       	jmp    c0021b70 <intr_entry>

c0022717 <intrff_stub>:
c0022717:	55                   	push   %ebp
c0022718:	6a 00                	push   $0x0
c002271a:	68 ff 00 00 00       	push   $0xff
c002271f:	e9 4c f4 ff ff       	jmp    c0021b70 <intr_entry>

c0022724 <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c0022724:	53                   	push   %ebx
c0022725:	83 ec 08             	sub    $0x8,%esp
c0022728:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (sema != NULL);
c002272c:	85 c0                	test   %eax,%eax
c002272e:	74 26                	je     c0022756 <sema_init+0x32>

  sema->value = value;
c0022730:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022734:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c0022736:	8d 58 04             	lea    0x4(%eax),%ebx
c0022739:	83 ec 0c             	sub    $0xc,%esp
c002273c:	53                   	push   %ebx
c002273d:	e8 72 5c 00 00       	call   c00283b4 <list_init>
  ASSERT (list_empty(&sema->waiters));
c0022742:	89 1c 24             	mov    %ebx,(%esp)
c0022745:	e8 5e 61 00 00       	call   c00288a8 <list_empty>
c002274a:	83 c4 10             	add    $0x10,%esp
c002274d:	84 c0                	test   %al,%al
c002274f:	74 23                	je     c0022774 <sema_init+0x50>
}
c0022751:	83 c4 08             	add    $0x8,%esp
c0022754:	5b                   	pop    %ebx
c0022755:	c3                   	ret    
  ASSERT (sema != NULL);
c0022756:	83 ec 0c             	sub    $0xc,%esp
c0022759:	68 ee e1 02 c0       	push   $0xc002e1ee
c002275e:	68 3f d9 02 c0       	push   $0xc002d93f
c0022763:	68 68 c4 02 c0       	push   $0xc002c468
c0022768:	6a 31                	push   $0x31
c002276a:	68 fb e1 02 c0       	push   $0xc002e1fb
c002276f:	e8 99 5b 00 00       	call   c002830d <debug_panic>
  ASSERT (list_empty(&sema->waiters));
c0022774:	83 ec 0c             	sub    $0xc,%esp
c0022777:	68 11 e2 02 c0       	push   $0xc002e211
c002277c:	68 3f d9 02 c0       	push   $0xc002d93f
c0022781:	68 68 c4 02 c0       	push   $0xc002c468
c0022786:	6a 35                	push   $0x35
c0022788:	68 fb e1 02 c0       	push   $0xc002e1fb
c002278d:	e8 7b 5b 00 00       	call   c002830d <debug_panic>

c0022792 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c0022792:	57                   	push   %edi
c0022793:	56                   	push   %esi
c0022794:	53                   	push   %ebx
c0022795:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022799:	85 db                	test   %ebx,%ebx
c002279b:	74 4c                	je     c00227e9 <sema_down+0x57>
  ASSERT (!intr_context ());
c002279d:	e8 75 f1 ff ff       	call   c0021917 <intr_context>
c00227a2:	84 c0                	test   %al,%al
c00227a4:	75 61                	jne    c0022807 <sema_down+0x75>

  old_level = intr_disable ();
c00227a6:	e8 4b ef ff ff       	call   c00216f6 <intr_disable>
c00227ab:	89 c7                	mov    %eax,%edi
  while (sema->value == 0) 
c00227ad:	8b 03                	mov    (%ebx),%eax
c00227af:	85 c0                	test   %eax,%eax
c00227b1:	75 23                	jne    c00227d6 <sema_down+0x44>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c00227b3:	8d 73 04             	lea    0x4(%ebx),%esi
c00227b6:	e8 cb e2 ff ff       	call   c0020a86 <thread_current>
c00227bb:	83 ec 08             	sub    $0x8,%esp
c00227be:	83 c0 5c             	add    $0x5c,%eax
c00227c1:	50                   	push   %eax
c00227c2:	56                   	push   %esi
c00227c3:	e8 38 60 00 00       	call   c0028800 <list_push_back>
      thread_block ();
c00227c8:	e8 df e9 ff ff       	call   c00211ac <thread_block>
  while (sema->value == 0) 
c00227cd:	8b 03                	mov    (%ebx),%eax
c00227cf:	83 c4 10             	add    $0x10,%esp
c00227d2:	85 c0                	test   %eax,%eax
c00227d4:	74 e0                	je     c00227b6 <sema_down+0x24>
    }
  sema->value--;
c00227d6:	48                   	dec    %eax
c00227d7:	89 03                	mov    %eax,(%ebx)
  intr_set_level (old_level);
c00227d9:	83 ec 0c             	sub    $0xc,%esp
c00227dc:	57                   	push   %edi
c00227dd:	e8 1b ef ff ff       	call   c00216fd <intr_set_level>
}
c00227e2:	83 c4 10             	add    $0x10,%esp
c00227e5:	5b                   	pop    %ebx
c00227e6:	5e                   	pop    %esi
c00227e7:	5f                   	pop    %edi
c00227e8:	c3                   	ret    
  ASSERT (sema != NULL);
c00227e9:	83 ec 0c             	sub    $0xc,%esp
c00227ec:	68 ee e1 02 c0       	push   $0xc002e1ee
c00227f1:	68 3f d9 02 c0       	push   $0xc002d93f
c00227f6:	68 5c c4 02 c0       	push   $0xc002c45c
c00227fb:	6a 44                	push   $0x44
c00227fd:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022802:	e8 06 5b 00 00       	call   c002830d <debug_panic>
  ASSERT (!intr_context ());
c0022807:	83 ec 0c             	sub    $0xc,%esp
c002280a:	68 8f dd 02 c0       	push   $0xc002dd8f
c002280f:	68 3f d9 02 c0       	push   $0xc002d93f
c0022814:	68 5c c4 02 c0       	push   $0xc002c45c
c0022819:	6a 45                	push   $0x45
c002281b:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022820:	e8 e8 5a 00 00       	call   c002830d <debug_panic>

c0022825 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022825:	53                   	push   %ebx
c0022826:	83 ec 08             	sub    $0x8,%esp
c0022829:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c002282d:	85 db                	test   %ebx,%ebx
c002282f:	74 20                	je     c0022851 <sema_try_down+0x2c>

  old_level = intr_disable ();
c0022831:	e8 c0 ee ff ff       	call   c00216f6 <intr_disable>
  if (sema->value > 0) 
c0022836:	8b 13                	mov    (%ebx),%edx
c0022838:	85 d2                	test   %edx,%edx
c002283a:	74 33                	je     c002286f <sema_try_down+0x4a>
    {
      sema->value--;
c002283c:	4a                   	dec    %edx
c002283d:	89 13                	mov    %edx,(%ebx)
      success = true; 
c002283f:	b3 01                	mov    $0x1,%bl
    }
  else
    success = false;
  intr_set_level (old_level);
c0022841:	83 ec 0c             	sub    $0xc,%esp
c0022844:	50                   	push   %eax
c0022845:	e8 b3 ee ff ff       	call   c00216fd <intr_set_level>

  return success;
}
c002284a:	88 d8                	mov    %bl,%al
c002284c:	83 c4 18             	add    $0x18,%esp
c002284f:	5b                   	pop    %ebx
c0022850:	c3                   	ret    
  ASSERT (sema != NULL);
c0022851:	83 ec 0c             	sub    $0xc,%esp
c0022854:	68 ee e1 02 c0       	push   $0xc002e1ee
c0022859:	68 3f d9 02 c0       	push   $0xc002d93f
c002285e:	68 4c c4 02 c0       	push   $0xc002c44c
c0022863:	6a 5c                	push   $0x5c
c0022865:	68 fb e1 02 c0       	push   $0xc002e1fb
c002286a:	e8 9e 5a 00 00       	call   c002830d <debug_panic>
    success = false;
c002286f:	b3 00                	mov    $0x0,%bl
c0022871:	eb ce                	jmp    c0022841 <sema_try_down+0x1c>

c0022873 <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0022873:	55                   	push   %ebp
c0022874:	57                   	push   %edi
c0022875:	56                   	push   %esi
c0022876:	53                   	push   %ebx
c0022877:	83 ec 1c             	sub    $0x1c,%esp
c002287a:	8b 74 24 30          	mov    0x30(%esp),%esi
  enum intr_level old_level = intr_disable ();
c002287e:	e8 73 ee ff ff       	call   c00216f6 <intr_disable>
c0022883:	89 44 24 0c          	mov    %eax,0xc(%esp)
  sema->value++;
c0022887:	ff 06                	incl   (%esi)

  if (!list_empty (&sema->waiters)) {
c0022889:	83 c6 04             	add    $0x4,%esi
c002288c:	83 ec 0c             	sub    $0xc,%esp
c002288f:	56                   	push   %esi
c0022890:	e8 13 60 00 00       	call   c00288a8 <list_empty>
c0022895:	83 c4 10             	add    $0x10,%esp
c0022898:	84 c0                	test   %al,%al
c002289a:	74 14                	je     c00228b0 <sema_up+0x3d>
      }
    }
  }
  //  thread_unblock (list_entry (list_pop_front (&sema->waiters), struct thread, elem));
  
  intr_set_level (old_level);
c002289c:	83 ec 0c             	sub    $0xc,%esp
c002289f:	ff 74 24 18          	pushl  0x18(%esp)
c00228a3:	e8 55 ee ff ff       	call   c00216fd <intr_set_level>
}
c00228a8:	83 c4 2c             	add    $0x2c,%esp
c00228ab:	5b                   	pop    %ebx
c00228ac:	5e                   	pop    %esi
c00228ad:	5f                   	pop    %edi
c00228ae:	5d                   	pop    %ebp
c00228af:	c3                   	ret    
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c00228b0:	83 ec 0c             	sub    $0xc,%esp
c00228b3:	56                   	push   %esi
c00228b4:	e8 3e 5b 00 00       	call   c00283f7 <list_begin>
c00228b9:	89 c3                	mov    %eax,%ebx
c00228bb:	83 c4 10             	add    $0x10,%esp
    int maxp = -1, tmpp;
c00228be:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c00228c3:	eb 0e                	jmp    c00228d3 <sema_up+0x60>
              e = list_next (e)) {
c00228c5:	83 ec 0c             	sub    $0xc,%esp
c00228c8:	53                   	push   %ebx
c00228c9:	e8 59 5b 00 00       	call   c0028427 <list_next>
c00228ce:	89 c3                	mov    %eax,%ebx
c00228d0:	83 c4 10             	add    $0x10,%esp
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c00228d3:	83 ec 0c             	sub    $0xc,%esp
c00228d6:	56                   	push   %esi
c00228d7:	e8 93 5b 00 00       	call   c002846f <list_end>
c00228dc:	83 c4 10             	add    $0x10,%esp
c00228df:	39 c3                	cmp    %eax,%ebx
c00228e1:	74 17                	je     c00228fa <sema_up+0x87>
      tmpp = thread_get_certain_priority(t);
c00228e3:	83 ec 0c             	sub    $0xc,%esp
      struct thread *t = list_entry (e, struct thread, elem);
c00228e6:	8d 43 a4             	lea    -0x5c(%ebx),%eax
      tmpp = thread_get_certain_priority(t);
c00228e9:	50                   	push   %eax
c00228ea:	e8 58 e4 ff ff       	call   c0020d47 <thread_get_certain_priority>
c00228ef:	83 c4 10             	add    $0x10,%esp
c00228f2:	39 c7                	cmp    %eax,%edi
c00228f4:	7d cf                	jge    c00228c5 <sema_up+0x52>
c00228f6:	89 c7                	mov    %eax,%edi
c00228f8:	eb cb                	jmp    c00228c5 <sema_up+0x52>
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c00228fa:	83 ec 0c             	sub    $0xc,%esp
c00228fd:	56                   	push   %esi
c00228fe:	e8 f4 5a 00 00       	call   c00283f7 <list_begin>
c0022903:	89 c3                	mov    %eax,%ebx
c0022905:	83 c4 10             	add    $0x10,%esp
c0022908:	83 ec 0c             	sub    $0xc,%esp
c002290b:	56                   	push   %esi
c002290c:	e8 5e 5b 00 00       	call   c002846f <list_end>
c0022911:	83 c4 10             	add    $0x10,%esp
c0022914:	39 c3                	cmp    %eax,%ebx
c0022916:	74 84                	je     c002289c <sema_up+0x29>
      struct thread *t = list_entry (e, struct thread, elem);
c0022918:	8d 6b a4             	lea    -0x5c(%ebx),%ebp
      tmpp = thread_get_certain_priority(t);
c002291b:	83 ec 0c             	sub    $0xc,%esp
c002291e:	55                   	push   %ebp
c002291f:	e8 23 e4 ff ff       	call   c0020d47 <thread_get_certain_priority>
      if (tmpp == maxp) {
c0022924:	83 c4 10             	add    $0x10,%esp
c0022927:	39 c7                	cmp    %eax,%edi
c0022929:	74 10                	je     c002293b <sema_up+0xc8>
              e = list_next (e)) {
c002292b:	83 ec 0c             	sub    $0xc,%esp
c002292e:	53                   	push   %ebx
c002292f:	e8 f3 5a 00 00       	call   c0028427 <list_next>
c0022934:	89 c3                	mov    %eax,%ebx
c0022936:	83 c4 10             	add    $0x10,%esp
c0022939:	eb cd                	jmp    c0022908 <sema_up+0x95>
        list_remove(e);
c002293b:	83 ec 0c             	sub    $0xc,%esp
c002293e:	53                   	push   %ebx
c002293f:	e8 d9 5e 00 00       	call   c002881d <list_remove>
        thread_unblock (t);
c0022944:	89 2c 24             	mov    %ebp,(%esp)
c0022947:	e8 e1 e2 ff ff       	call   c0020c2d <thread_unblock>
        thread_check_switch ();
c002294c:	e8 0d ea ff ff       	call   c002135e <thread_check_switch>
        break;
c0022951:	83 c4 10             	add    $0x10,%esp
c0022954:	e9 43 ff ff ff       	jmp    c002289c <sema_up+0x29>

c0022959 <sema_test_helper>:
}

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022959:	57                   	push   %edi
c002295a:	56                   	push   %esi
c002295b:	53                   	push   %ebx
c002295c:	8b 74 24 10          	mov    0x10(%esp),%esi
c0022960:	bb 0a 00 00 00       	mov    $0xa,%ebx
  int i;

  for (i = 0; i < 10; i++) 
    {
      sema_down (&sema[0]);
      sema_up (&sema[1]);
c0022965:	8d 7e 14             	lea    0x14(%esi),%edi
      sema_down (&sema[0]);
c0022968:	83 ec 0c             	sub    $0xc,%esp
c002296b:	56                   	push   %esi
c002296c:	e8 21 fe ff ff       	call   c0022792 <sema_down>
      sema_up (&sema[1]);
c0022971:	89 3c 24             	mov    %edi,(%esp)
c0022974:	e8 fa fe ff ff       	call   c0022873 <sema_up>
  for (i = 0; i < 10; i++) 
c0022979:	83 c4 10             	add    $0x10,%esp
c002297c:	4b                   	dec    %ebx
c002297d:	75 e9                	jne    c0022968 <sema_test_helper+0xf>
    }
}
c002297f:	5b                   	pop    %ebx
c0022980:	5e                   	pop    %esi
c0022981:	5f                   	pop    %edi
c0022982:	c3                   	ret    

c0022983 <sema_self_test>:
{
c0022983:	57                   	push   %edi
c0022984:	56                   	push   %esi
c0022985:	53                   	push   %ebx
c0022986:	83 ec 3c             	sub    $0x3c,%esp
  printf ("Testing semaphores...");
c0022989:	68 2c e2 02 c0       	push   $0xc002e22c
c002298e:	e8 cc 3e 00 00       	call   c002685f <printf>
  sema_init (&sema[0], 0);
c0022993:	83 c4 08             	add    $0x8,%esp
c0022996:	6a 00                	push   $0x0
c0022998:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c002299c:	53                   	push   %ebx
c002299d:	e8 82 fd ff ff       	call   c0022724 <sema_init>
  sema_init (&sema[1], 0);
c00229a2:	83 c4 08             	add    $0x8,%esp
c00229a5:	6a 00                	push   $0x0
c00229a7:	8d 44 24 28          	lea    0x28(%esp),%eax
c00229ab:	50                   	push   %eax
c00229ac:	e8 73 fd ff ff       	call   c0022724 <sema_init>
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c00229b1:	53                   	push   %ebx
c00229b2:	68 59 29 02 c0       	push   $0xc0022959
c00229b7:	6a 1f                	push   $0x1f
c00229b9:	68 42 e2 02 c0       	push   $0xc002e242
c00229be:	e8 0c ea ff ff       	call   c00213cf <thread_create>
c00229c3:	83 c4 20             	add    $0x20,%esp
c00229c6:	bb 0a 00 00 00       	mov    $0xa,%ebx
      sema_up (&sema[0]);
c00229cb:	8d 7c 24 08          	lea    0x8(%esp),%edi
      sema_down (&sema[1]);
c00229cf:	8d 74 24 1c          	lea    0x1c(%esp),%esi
      sema_up (&sema[0]);
c00229d3:	83 ec 0c             	sub    $0xc,%esp
c00229d6:	57                   	push   %edi
c00229d7:	e8 97 fe ff ff       	call   c0022873 <sema_up>
      sema_down (&sema[1]);
c00229dc:	89 34 24             	mov    %esi,(%esp)
c00229df:	e8 ae fd ff ff       	call   c0022792 <sema_down>
  for (i = 0; i < 10; i++) 
c00229e4:	83 c4 10             	add    $0x10,%esp
c00229e7:	4b                   	dec    %ebx
c00229e8:	75 e9                	jne    c00229d3 <sema_self_test+0x50>
  printf ("done.\n");
c00229ea:	83 ec 0c             	sub    $0xc,%esp
c00229ed:	68 4c e2 02 c0       	push   $0xc002e24c
c00229f2:	e8 5d 73 00 00       	call   c0029d54 <puts>
}
c00229f7:	83 c4 40             	add    $0x40,%esp
c00229fa:	5b                   	pop    %ebx
c00229fb:	5e                   	pop    %esi
c00229fc:	5f                   	pop    %edi
c00229fd:	c3                   	ret    

c00229fe <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c00229fe:	53                   	push   %ebx
c00229ff:	83 ec 08             	sub    $0x8,%esp
c0022a02:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022a06:	85 db                	test   %ebx,%ebx
c0022a08:	74 2c                	je     c0022a36 <lock_init+0x38>

  lock->holder = NULL;
c0022a0a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  lock->max_donate_delta = 0;
c0022a10:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
  list_init (&lock->donaters);
c0022a17:	83 ec 0c             	sub    $0xc,%esp
c0022a1a:	8d 43 1c             	lea    0x1c(%ebx),%eax
c0022a1d:	50                   	push   %eax
c0022a1e:	e8 91 59 00 00       	call   c00283b4 <list_init>
  sema_init (&lock->semaphore, 1);
c0022a23:	83 c4 08             	add    $0x8,%esp
c0022a26:	6a 01                	push   $0x1
c0022a28:	83 c3 04             	add    $0x4,%ebx
c0022a2b:	53                   	push   %ebx
c0022a2c:	e8 f3 fc ff ff       	call   c0022724 <sema_init>
}
c0022a31:	83 c4 18             	add    $0x18,%esp
c0022a34:	5b                   	pop    %ebx
c0022a35:	c3                   	ret    
  ASSERT (lock != NULL);
c0022a36:	83 ec 0c             	sub    $0xc,%esp
c0022a39:	68 52 e2 02 c0       	push   $0xc002e252
c0022a3e:	68 3f d9 02 c0       	push   $0xc002d93f
c0022a43:	68 40 c4 02 c0       	push   $0xc002c440
c0022a48:	68 c8 00 00 00       	push   $0xc8
c0022a4d:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022a52:	e8 b6 58 00 00       	call   c002830d <debug_panic>

c0022a57 <notify_donation>:

/* Update donation when lock status changes. */
void
notify_donation(struct thread *t) {
c0022a57:	55                   	push   %ebp
c0022a58:	57                   	push   %edi
c0022a59:	56                   	push   %esi
c0022a5a:	53                   	push   %ebx
c0022a5b:	83 ec 1c             	sub    $0x1c,%esp
c0022a5e:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  if (t == NULL || t->father == NULL) {
c0022a62:	85 ed                	test   %ebp,%ebp
c0022a64:	0f 84 c2 00 00 00    	je     c0022b2c <notify_donation+0xd5>
c0022a6a:	8b 45 48             	mov    0x48(%ebp),%eax
c0022a6d:	85 c0                	test   %eax,%eax
c0022a6f:	0f 84 b7 00 00 00    	je     c0022b2c <notify_donation+0xd5>
    return;
  }
  int max_donate_delta = 0;

  struct list_elem *lock_elem, *donater_elem;
  for (lock_elem = list_begin (&t->father->lock_list);
c0022a75:	83 ec 0c             	sub    $0xc,%esp
c0022a78:	83 c0 30             	add    $0x30,%eax
c0022a7b:	50                   	push   %eax
c0022a7c:	e8 76 59 00 00       	call   c00283f7 <list_begin>
c0022a81:	89 c6                	mov    %eax,%esi
c0022a83:	83 c4 10             	add    $0x10,%esp
  int max_donate_delta = 0;
c0022a86:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0022a8d:	00 
  for (lock_elem = list_begin (&t->father->lock_list);
c0022a8e:	eb 4f                	jmp    c0022adf <notify_donation+0x88>
      lock_elem = list_next (lock_elem)) {
    struct lock* l = list_entry (lock_elem, struct lock, elem);
    l->max_donate_delta = 0;
    for (donater_elem = list_begin (&l->donaters);
        donater_elem != list_end (&l->donaters);
        donater_elem = list_next (donater_elem)) {
c0022a90:	83 ec 0c             	sub    $0xc,%esp
c0022a93:	53                   	push   %ebx
c0022a94:	e8 8e 59 00 00       	call   c0028427 <list_next>
c0022a99:	89 c3                	mov    %eax,%ebx
c0022a9b:	83 c4 10             	add    $0x10,%esp
        donater_elem != list_end (&l->donaters);
c0022a9e:	83 ec 0c             	sub    $0xc,%esp
c0022aa1:	57                   	push   %edi
c0022aa2:	e8 c8 59 00 00       	call   c002846f <list_end>
    for (donater_elem = list_begin (&l->donaters);
c0022aa7:	83 c4 10             	add    $0x10,%esp
c0022aaa:	39 c3                	cmp    %eax,%ebx
c0022aac:	74 16                	je     c0022ac4 <notify_donation+0x6d>
        struct thread *tmp = list_entry (donater_elem, struct thread, donate_elem);
        if (tmp->priority + tmp->max_donate_delta - t->father->priority > l->max_donate_delta) {
c0022aae:	8b 43 f4             	mov    -0xc(%ebx),%eax
c0022ab1:	03 43 d4             	add    -0x2c(%ebx),%eax
c0022ab4:	8b 55 48             	mov    0x48(%ebp),%edx
c0022ab7:	2b 42 20             	sub    0x20(%edx),%eax
c0022aba:	3b 46 ec             	cmp    -0x14(%esi),%eax
c0022abd:	7e d1                	jle    c0022a90 <notify_donation+0x39>
          l->max_donate_delta = tmp->priority + tmp->max_donate_delta - t->father->priority;
c0022abf:	89 46 ec             	mov    %eax,-0x14(%esi)
c0022ac2:	eb cc                	jmp    c0022a90 <notify_donation+0x39>
c0022ac4:	8b 46 ec             	mov    -0x14(%esi),%eax
c0022ac7:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c0022acb:	7d 04                	jge    c0022ad1 <notify_donation+0x7a>
c0022acd:	89 44 24 0c          	mov    %eax,0xc(%esp)
      lock_elem = list_next (lock_elem)) {
c0022ad1:	83 ec 0c             	sub    $0xc,%esp
c0022ad4:	56                   	push   %esi
c0022ad5:	e8 4d 59 00 00       	call   c0028427 <list_next>
c0022ada:	89 c6                	mov    %eax,%esi
c0022adc:	83 c4 10             	add    $0x10,%esp
      lock_elem != list_end (&t->father->lock_list);
c0022adf:	83 ec 0c             	sub    $0xc,%esp
c0022ae2:	8b 45 48             	mov    0x48(%ebp),%eax
c0022ae5:	83 c0 30             	add    $0x30,%eax
c0022ae8:	50                   	push   %eax
c0022ae9:	e8 81 59 00 00       	call   c002846f <list_end>
  for (lock_elem = list_begin (&t->father->lock_list);
c0022aee:	83 c4 10             	add    $0x10,%esp
c0022af1:	39 c6                	cmp    %eax,%esi
c0022af3:	74 1a                	je     c0022b0f <notify_donation+0xb8>
    l->max_donate_delta = 0;
c0022af5:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
    for (donater_elem = list_begin (&l->donaters);
c0022afc:	8d 7e f0             	lea    -0x10(%esi),%edi
c0022aff:	83 ec 0c             	sub    $0xc,%esp
c0022b02:	57                   	push   %edi
c0022b03:	e8 ef 58 00 00       	call   c00283f7 <list_begin>
c0022b08:	89 c3                	mov    %eax,%ebx
c0022b0a:	83 c4 10             	add    $0x10,%esp
c0022b0d:	eb 8f                	jmp    c0022a9e <notify_donation+0x47>
      }
    if (l->max_donate_delta > max_donate_delta) {
      max_donate_delta = l->max_donate_delta;
    }
  }
  if (t->father->max_donate_delta != max_donate_delta) {
c0022b0f:	8b 45 48             	mov    0x48(%ebp),%eax
c0022b12:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0022b16:	3b 48 40             	cmp    0x40(%eax),%ecx
c0022b19:	74 11                	je     c0022b2c <notify_donation+0xd5>
    t->father->max_donate_delta = max_donate_delta;
c0022b1b:	89 48 40             	mov    %ecx,0x40(%eax)
    notify_donation(t->father);
c0022b1e:	83 ec 0c             	sub    $0xc,%esp
c0022b21:	ff 75 48             	pushl  0x48(%ebp)
c0022b24:	e8 2e ff ff ff       	call   c0022a57 <notify_donation>
c0022b29:	83 c4 10             	add    $0x10,%esp
  }
}
c0022b2c:	83 c4 1c             	add    $0x1c,%esp
c0022b2f:	5b                   	pop    %ebx
c0022b30:	5e                   	pop    %esi
c0022b31:	5f                   	pop    %edi
c0022b32:	5d                   	pop    %ebp
c0022b33:	c3                   	ret    

c0022b34 <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022b34:	53                   	push   %ebx
c0022b35:	83 ec 08             	sub    $0x8,%esp
c0022b38:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c0022b3c:	85 c0                	test   %eax,%eax
c0022b3e:	74 11                	je     c0022b51 <lock_held_by_current_thread+0x1d>

  return lock->holder == thread_current ();
c0022b40:	8b 18                	mov    (%eax),%ebx
c0022b42:	e8 3f df ff ff       	call   c0020a86 <thread_current>
c0022b47:	39 c3                	cmp    %eax,%ebx
c0022b49:	0f 94 c0             	sete   %al
}
c0022b4c:	83 c4 08             	add    $0x8,%esp
c0022b4f:	5b                   	pop    %ebx
c0022b50:	c3                   	ret    
  ASSERT (lock != NULL);
c0022b51:	83 ec 0c             	sub    $0xc,%esp
c0022b54:	68 52 e2 02 c0       	push   $0xc002e252
c0022b59:	68 3f d9 02 c0       	push   $0xc002d93f
c0022b5e:	68 f0 c3 02 c0       	push   $0xc002c3f0
c0022b63:	68 5b 01 00 00       	push   $0x15b
c0022b68:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022b6d:	e8 9b 57 00 00       	call   c002830d <debug_panic>

c0022b72 <lock_acquire>:
{
c0022b72:	56                   	push   %esi
c0022b73:	53                   	push   %ebx
c0022b74:	83 ec 04             	sub    $0x4,%esp
c0022b77:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022b7b:	85 db                	test   %ebx,%ebx
c0022b7d:	0f 84 8f 00 00 00    	je     c0022c12 <lock_acquire+0xa0>
  ASSERT (!intr_context ());
c0022b83:	e8 8f ed ff ff       	call   c0021917 <intr_context>
c0022b88:	84 c0                	test   %al,%al
c0022b8a:	0f 85 a3 00 00 00    	jne    c0022c33 <lock_acquire+0xc1>
  ASSERT (!lock_held_by_current_thread (lock));
c0022b90:	83 ec 0c             	sub    $0xc,%esp
c0022b93:	53                   	push   %ebx
c0022b94:	e8 9b ff ff ff       	call   c0022b34 <lock_held_by_current_thread>
c0022b99:	83 c4 10             	add    $0x10,%esp
c0022b9c:	84 c0                	test   %al,%al
c0022b9e:	0f 85 b0 00 00 00    	jne    c0022c54 <lock_acquire+0xe2>
  if (lock->holder != NULL) {
c0022ba4:	83 3b 00             	cmpl   $0x0,(%ebx)
c0022ba7:	74 40                	je     c0022be9 <lock_acquire+0x77>
    int delta = thread_get_priority () - lock->holder->priority;
c0022ba9:	e8 b1 e1 ff ff       	call   c0020d5f <thread_get_priority>
c0022bae:	8b 13                	mov    (%ebx),%edx
c0022bb0:	2b 42 20             	sub    0x20(%edx),%eax
c0022bb3:	89 c6                	mov    %eax,%esi
    if (delta > 0) {
c0022bb5:	85 c0                	test   %eax,%eax
c0022bb7:	7e 30                	jle    c0022be9 <lock_acquire+0x77>
      struct thread *t = thread_current ();
c0022bb9:	e8 c8 de ff ff       	call   c0020a86 <thread_current>
      t->father = lock->holder;
c0022bbe:	8b 13                	mov    (%ebx),%edx
c0022bc0:	89 50 48             	mov    %edx,0x48(%eax)
      list_push_back(&lock->donaters, &t->donate_elem);
c0022bc3:	83 ec 08             	sub    $0x8,%esp
c0022bc6:	83 c0 4c             	add    $0x4c,%eax
c0022bc9:	50                   	push   %eax
c0022bca:	8d 43 1c             	lea    0x1c(%ebx),%eax
c0022bcd:	50                   	push   %eax
c0022bce:	e8 2d 5c 00 00       	call   c0028800 <list_push_back>
      if (delta > lock->max_donate_delta) {
c0022bd3:	83 c4 10             	add    $0x10,%esp
c0022bd6:	3b 73 18             	cmp    0x18(%ebx),%esi
c0022bd9:	7e 03                	jle    c0022bde <lock_acquire+0x6c>
        lock->max_donate_delta = delta;
c0022bdb:	89 73 18             	mov    %esi,0x18(%ebx)
      if (delta > lock->holder->max_donate_delta) {
c0022bde:	8b 03                	mov    (%ebx),%eax
c0022be0:	3b 70 40             	cmp    0x40(%eax),%esi
c0022be3:	0f 8f 8c 00 00 00    	jg     c0022c75 <lock_acquire+0x103>
  sema_down (&lock->semaphore);
c0022be9:	83 ec 0c             	sub    $0xc,%esp
c0022bec:	8d 43 04             	lea    0x4(%ebx),%eax
c0022bef:	50                   	push   %eax
c0022bf0:	e8 9d fb ff ff       	call   c0022792 <sema_down>
  lock->holder = thread_current ();
c0022bf5:	e8 8c de ff ff       	call   c0020a86 <thread_current>
c0022bfa:	89 03                	mov    %eax,(%ebx)
  list_push_back (&lock->holder->lock_list, &lock->elem);
c0022bfc:	83 c4 08             	add    $0x8,%esp
c0022bff:	83 c3 2c             	add    $0x2c,%ebx
c0022c02:	53                   	push   %ebx
c0022c03:	83 c0 30             	add    $0x30,%eax
c0022c06:	50                   	push   %eax
c0022c07:	e8 f4 5b 00 00       	call   c0028800 <list_push_back>
}
c0022c0c:	83 c4 14             	add    $0x14,%esp
c0022c0f:	5b                   	pop    %ebx
c0022c10:	5e                   	pop    %esi
c0022c11:	c3                   	ret    
  ASSERT (lock != NULL);
c0022c12:	83 ec 0c             	sub    $0xc,%esp
c0022c15:	68 52 e2 02 c0       	push   $0xc002e252
c0022c1a:	68 3f d9 02 c0       	push   $0xc002d93f
c0022c1f:	68 30 c4 02 c0       	push   $0xc002c430
c0022c24:	68 fc 00 00 00       	push   $0xfc
c0022c29:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022c2e:	e8 da 56 00 00       	call   c002830d <debug_panic>
  ASSERT (!intr_context ());
c0022c33:	83 ec 0c             	sub    $0xc,%esp
c0022c36:	68 8f dd 02 c0       	push   $0xc002dd8f
c0022c3b:	68 3f d9 02 c0       	push   $0xc002d93f
c0022c40:	68 30 c4 02 c0       	push   $0xc002c430
c0022c45:	68 fd 00 00 00       	push   $0xfd
c0022c4a:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022c4f:	e8 b9 56 00 00       	call   c002830d <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022c54:	83 ec 0c             	sub    $0xc,%esp
c0022c57:	68 6c e2 02 c0       	push   $0xc002e26c
c0022c5c:	68 3f d9 02 c0       	push   $0xc002d93f
c0022c61:	68 30 c4 02 c0       	push   $0xc002c430
c0022c66:	68 fe 00 00 00       	push   $0xfe
c0022c6b:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022c70:	e8 98 56 00 00       	call   c002830d <debug_panic>
        lock->holder->max_donate_delta = delta;
c0022c75:	89 70 40             	mov    %esi,0x40(%eax)
        notify_donation (lock->holder);
c0022c78:	83 ec 0c             	sub    $0xc,%esp
c0022c7b:	ff 33                	pushl  (%ebx)
c0022c7d:	e8 d5 fd ff ff       	call   c0022a57 <notify_donation>
c0022c82:	83 c4 10             	add    $0x10,%esp
c0022c85:	e9 5f ff ff ff       	jmp    c0022be9 <lock_acquire+0x77>

c0022c8a <lock_try_acquire>:
{
c0022c8a:	56                   	push   %esi
c0022c8b:	53                   	push   %ebx
c0022c8c:	83 ec 04             	sub    $0x4,%esp
c0022c8f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022c93:	85 db                	test   %ebx,%ebx
c0022c95:	74 2d                	je     c0022cc4 <lock_try_acquire+0x3a>
  ASSERT (!lock_held_by_current_thread (lock));
c0022c97:	83 ec 0c             	sub    $0xc,%esp
c0022c9a:	53                   	push   %ebx
c0022c9b:	e8 94 fe ff ff       	call   c0022b34 <lock_held_by_current_thread>
c0022ca0:	83 c4 10             	add    $0x10,%esp
c0022ca3:	84 c0                	test   %al,%al
c0022ca5:	75 3e                	jne    c0022ce5 <lock_try_acquire+0x5b>
  success = sema_try_down (&lock->semaphore);
c0022ca7:	83 ec 0c             	sub    $0xc,%esp
c0022caa:	8d 43 04             	lea    0x4(%ebx),%eax
c0022cad:	50                   	push   %eax
c0022cae:	e8 72 fb ff ff       	call   c0022825 <sema_try_down>
c0022cb3:	89 c6                	mov    %eax,%esi
  if (success)
c0022cb5:	83 c4 10             	add    $0x10,%esp
c0022cb8:	84 c0                	test   %al,%al
c0022cba:	75 4a                	jne    c0022d06 <lock_try_acquire+0x7c>
}
c0022cbc:	89 f0                	mov    %esi,%eax
c0022cbe:	83 c4 04             	add    $0x4,%esp
c0022cc1:	5b                   	pop    %ebx
c0022cc2:	5e                   	pop    %esi
c0022cc3:	c3                   	ret    
  ASSERT (lock != NULL);
c0022cc4:	83 ec 0c             	sub    $0xc,%esp
c0022cc7:	68 52 e2 02 c0       	push   $0xc002e252
c0022ccc:	68 3f d9 02 c0       	push   $0xc002d93f
c0022cd1:	68 1c c4 02 c0       	push   $0xc002c41c
c0022cd6:	68 20 01 00 00       	push   $0x120
c0022cdb:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022ce0:	e8 28 56 00 00       	call   c002830d <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022ce5:	83 ec 0c             	sub    $0xc,%esp
c0022ce8:	68 6c e2 02 c0       	push   $0xc002e26c
c0022ced:	68 3f d9 02 c0       	push   $0xc002d93f
c0022cf2:	68 1c c4 02 c0       	push   $0xc002c41c
c0022cf7:	68 21 01 00 00       	push   $0x121
c0022cfc:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022d01:	e8 07 56 00 00       	call   c002830d <debug_panic>
    lock->holder = thread_current ();
c0022d06:	e8 7b dd ff ff       	call   c0020a86 <thread_current>
c0022d0b:	89 03                	mov    %eax,(%ebx)
  return success;
c0022d0d:	eb ad                	jmp    c0022cbc <lock_try_acquire+0x32>

c0022d0f <lock_release>:
{
c0022d0f:	55                   	push   %ebp
c0022d10:	57                   	push   %edi
c0022d11:	56                   	push   %esi
c0022d12:	53                   	push   %ebx
c0022d13:	83 ec 0c             	sub    $0xc,%esp
c0022d16:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  ASSERT (lock != NULL);
c0022d1a:	85 ed                	test   %ebp,%ebp
c0022d1c:	74 26                	je     c0022d44 <lock_release+0x35>
  ASSERT (lock_held_by_current_thread (lock));
c0022d1e:	83 ec 0c             	sub    $0xc,%esp
c0022d21:	55                   	push   %ebp
c0022d22:	e8 0d fe ff ff       	call   c0022b34 <lock_held_by_current_thread>
c0022d27:	83 c4 10             	add    $0x10,%esp
c0022d2a:	84 c0                	test   %al,%al
c0022d2c:	74 37                	je     c0022d65 <lock_release+0x56>
  struct thread *t = lock->holder;
c0022d2e:	8b 7d 00             	mov    0x0(%ebp),%edi
  for (e = list_begin (&lock->donaters); e != list_end (&lock->donaters); e = list_next (e)) {
c0022d31:	8d 75 1c             	lea    0x1c(%ebp),%esi
c0022d34:	83 ec 0c             	sub    $0xc,%esp
c0022d37:	56                   	push   %esi
c0022d38:	e8 ba 56 00 00       	call   c00283f7 <list_begin>
c0022d3d:	89 c3                	mov    %eax,%ebx
c0022d3f:	83 c4 10             	add    $0x10,%esp
c0022d42:	eb 57                	jmp    c0022d9b <lock_release+0x8c>
  ASSERT (lock != NULL);
c0022d44:	83 ec 0c             	sub    $0xc,%esp
c0022d47:	68 52 e2 02 c0       	push   $0xc002e252
c0022d4c:	68 3f d9 02 c0       	push   $0xc002d93f
c0022d51:	68 0c c4 02 c0       	push   $0xc002c40c
c0022d56:	68 31 01 00 00       	push   $0x131
c0022d5b:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022d60:	e8 a8 55 00 00       	call   c002830d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022d65:	83 ec 0c             	sub    $0xc,%esp
c0022d68:	68 90 e2 02 c0       	push   $0xc002e290
c0022d6d:	68 3f d9 02 c0       	push   $0xc002d93f
c0022d72:	68 0c c4 02 c0       	push   $0xc002c40c
c0022d77:	68 32 01 00 00       	push   $0x132
c0022d7c:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022d81:	e8 87 55 00 00       	call   c002830d <debug_panic>
    list_entry (e, struct thread, donate_elem)->father = NULL;
c0022d86:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
  for (e = list_begin (&lock->donaters); e != list_end (&lock->donaters); e = list_next (e)) {
c0022d8d:	83 ec 0c             	sub    $0xc,%esp
c0022d90:	53                   	push   %ebx
c0022d91:	e8 91 56 00 00       	call   c0028427 <list_next>
c0022d96:	89 c3                	mov    %eax,%ebx
c0022d98:	83 c4 10             	add    $0x10,%esp
c0022d9b:	83 ec 0c             	sub    $0xc,%esp
c0022d9e:	56                   	push   %esi
c0022d9f:	e8 cb 56 00 00       	call   c002846f <list_end>
c0022da4:	83 c4 10             	add    $0x10,%esp
c0022da7:	39 c3                	cmp    %eax,%ebx
c0022da9:	75 db                	jne    c0022d86 <lock_release+0x77>
  list_remove (&lock->elem);
c0022dab:	83 ec 0c             	sub    $0xc,%esp
c0022dae:	8d 45 2c             	lea    0x2c(%ebp),%eax
c0022db1:	50                   	push   %eax
c0022db2:	e8 66 5a 00 00       	call   c002881d <list_remove>
  lock->max_donate_delta = 0;
c0022db7:	c7 45 18 00 00 00 00 	movl   $0x0,0x18(%ebp)
  lock->holder = NULL;
c0022dbe:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
  while (!list_empty (&lock->donaters)) {
c0022dc5:	83 c4 10             	add    $0x10,%esp
c0022dc8:	eb 0c                	jmp    c0022dd6 <lock_release+0xc7>
    list_pop_front (&lock->donaters);
c0022dca:	83 ec 0c             	sub    $0xc,%esp
c0022dcd:	56                   	push   %esi
c0022dce:	e8 37 5b 00 00       	call   c002890a <list_pop_front>
c0022dd3:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&lock->donaters)) {
c0022dd6:	83 ec 0c             	sub    $0xc,%esp
c0022dd9:	56                   	push   %esi
c0022dda:	e8 c9 5a 00 00       	call   c00288a8 <list_empty>
c0022ddf:	83 c4 10             	add    $0x10,%esp
c0022de2:	84 c0                	test   %al,%al
c0022de4:	74 e4                	je     c0022dca <lock_release+0xbb>
  sema_up (&lock->semaphore);
c0022de6:	83 ec 0c             	sub    $0xc,%esp
c0022de9:	83 c5 04             	add    $0x4,%ebp
c0022dec:	55                   	push   %ebp
c0022ded:	e8 81 fa ff ff       	call   c0022873 <sema_up>
  for (e = list_begin (&t->lock_list); e != list_end (&t->lock_list); e = list_next (e)) {
c0022df2:	8d 6f 30             	lea    0x30(%edi),%ebp
c0022df5:	89 2c 24             	mov    %ebp,(%esp)
c0022df8:	e8 fa 55 00 00       	call   c00283f7 <list_begin>
c0022dfd:	89 c3                	mov    %eax,%ebx
c0022dff:	83 c4 10             	add    $0x10,%esp
  int max_donate_delta = 0;
c0022e02:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin (&t->lock_list); e != list_end (&t->lock_list); e = list_next (e)) {
c0022e07:	eb 0e                	jmp    c0022e17 <lock_release+0x108>
c0022e09:	83 ec 0c             	sub    $0xc,%esp
c0022e0c:	53                   	push   %ebx
c0022e0d:	e8 15 56 00 00       	call   c0028427 <list_next>
c0022e12:	89 c3                	mov    %eax,%ebx
c0022e14:	83 c4 10             	add    $0x10,%esp
c0022e17:	83 ec 0c             	sub    $0xc,%esp
c0022e1a:	55                   	push   %ebp
c0022e1b:	e8 4f 56 00 00       	call   c002846f <list_end>
c0022e20:	83 c4 10             	add    $0x10,%esp
c0022e23:	39 c3                	cmp    %eax,%ebx
c0022e25:	74 0b                	je     c0022e32 <lock_release+0x123>
c0022e27:	8b 43 ec             	mov    -0x14(%ebx),%eax
c0022e2a:	39 c6                	cmp    %eax,%esi
c0022e2c:	7d db                	jge    c0022e09 <lock_release+0xfa>
c0022e2e:	89 c6                	mov    %eax,%esi
c0022e30:	eb d7                	jmp    c0022e09 <lock_release+0xfa>
  if (t->max_donate_delta != max_donate_delta) {
c0022e32:	3b 77 40             	cmp    0x40(%edi),%esi
c0022e35:	74 0f                	je     c0022e46 <lock_release+0x137>
    t->max_donate_delta = max_donate_delta;
c0022e37:	89 77 40             	mov    %esi,0x40(%edi)
    notify_donation (t);
c0022e3a:	83 ec 0c             	sub    $0xc,%esp
c0022e3d:	57                   	push   %edi
c0022e3e:	e8 14 fc ff ff       	call   c0022a57 <notify_donation>
c0022e43:	83 c4 10             	add    $0x10,%esp
  if (t->max_donate_delta == 0 && t->priority_to_set > -1) {
c0022e46:	83 7f 40 00          	cmpl   $0x0,0x40(%edi)
c0022e4a:	75 11                	jne    c0022e5d <lock_release+0x14e>
c0022e4c:	8b 47 44             	mov    0x44(%edi),%eax
c0022e4f:	85 c0                	test   %eax,%eax
c0022e51:	78 0a                	js     c0022e5d <lock_release+0x14e>
    t->priority = t->priority_to_set;
c0022e53:	89 47 20             	mov    %eax,0x20(%edi)
    t->priority_to_set = -1;
c0022e56:	c7 47 44 ff ff ff ff 	movl   $0xffffffff,0x44(%edi)
  thread_check_switch();
c0022e5d:	e8 fc e4 ff ff       	call   c002135e <thread_check_switch>
}
c0022e62:	83 c4 0c             	add    $0xc,%esp
c0022e65:	5b                   	pop    %ebx
c0022e66:	5e                   	pop    %esi
c0022e67:	5f                   	pop    %edi
c0022e68:	5d                   	pop    %ebp
c0022e69:	c3                   	ret    

c0022e6a <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0022e6a:	83 ec 0c             	sub    $0xc,%esp
c0022e6d:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (cond != NULL);
c0022e71:	85 c0                	test   %eax,%eax
c0022e73:	74 0d                	je     c0022e82 <cond_init+0x18>

  list_init (&cond->waiters);
c0022e75:	83 ec 0c             	sub    $0xc,%esp
c0022e78:	50                   	push   %eax
c0022e79:	e8 36 55 00 00       	call   c00283b4 <list_init>
}
c0022e7e:	83 c4 1c             	add    $0x1c,%esp
c0022e81:	c3                   	ret    
  ASSERT (cond != NULL);
c0022e82:	83 ec 0c             	sub    $0xc,%esp
c0022e85:	68 5f e2 02 c0       	push   $0xc002e25f
c0022e8a:	68 3f d9 02 c0       	push   $0xc002d93f
c0022e8f:	68 e4 c3 02 c0       	push   $0xc002c3e4
c0022e94:	68 6e 01 00 00       	push   $0x16e
c0022e99:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022e9e:	e8 6a 54 00 00       	call   c002830d <debug_panic>

c0022ea3 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0022ea3:	55                   	push   %ebp
c0022ea4:	57                   	push   %edi
c0022ea5:	56                   	push   %esi
c0022ea6:	53                   	push   %ebx
c0022ea7:	83 ec 2c             	sub    $0x2c,%esp
c0022eaa:	8b 74 24 40          	mov    0x40(%esp),%esi
c0022eae:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0022eb2:	85 f6                	test   %esi,%esi
c0022eb4:	74 6f                	je     c0022f25 <cond_wait+0x82>
  ASSERT (lock != NULL);
c0022eb6:	85 db                	test   %ebx,%ebx
c0022eb8:	0f 84 88 00 00 00    	je     c0022f46 <cond_wait+0xa3>
  ASSERT (!intr_context ());
c0022ebe:	e8 54 ea ff ff       	call   c0021917 <intr_context>
c0022ec3:	84 c0                	test   %al,%al
c0022ec5:	0f 85 9c 00 00 00    	jne    c0022f67 <cond_wait+0xc4>
  ASSERT (lock_held_by_current_thread (lock));
c0022ecb:	83 ec 0c             	sub    $0xc,%esp
c0022ece:	53                   	push   %ebx
c0022ecf:	e8 60 fc ff ff       	call   c0022b34 <lock_held_by_current_thread>
c0022ed4:	83 c4 10             	add    $0x10,%esp
c0022ed7:	84 c0                	test   %al,%al
c0022ed9:	0f 84 a9 00 00 00    	je     c0022f88 <cond_wait+0xe5>
  
  sema_init (&waiter.semaphore, 0);
c0022edf:	83 ec 08             	sub    $0x8,%esp
c0022ee2:	6a 00                	push   $0x0
c0022ee4:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c0022ee8:	8d 7c 24 14          	lea    0x14(%esp),%edi
c0022eec:	57                   	push   %edi
c0022eed:	e8 32 f8 ff ff       	call   c0022724 <sema_init>
  list_push_back (&cond->waiters, &waiter.elem);
c0022ef2:	83 c4 08             	add    $0x8,%esp
c0022ef5:	55                   	push   %ebp
c0022ef6:	56                   	push   %esi
c0022ef7:	e8 04 59 00 00       	call   c0028800 <list_push_back>
  lock_release (lock);
c0022efc:	89 1c 24             	mov    %ebx,(%esp)
c0022eff:	e8 0b fe ff ff       	call   c0022d0f <lock_release>
  waiter.pthread = thread_current();
c0022f04:	e8 7d db ff ff       	call   c0020a86 <thread_current>
c0022f09:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  sema_down (&waiter.semaphore);
c0022f0d:	89 3c 24             	mov    %edi,(%esp)
c0022f10:	e8 7d f8 ff ff       	call   c0022792 <sema_down>
  lock_acquire (lock);
c0022f15:	89 1c 24             	mov    %ebx,(%esp)
c0022f18:	e8 55 fc ff ff       	call   c0022b72 <lock_acquire>
}
c0022f1d:	83 c4 3c             	add    $0x3c,%esp
c0022f20:	5b                   	pop    %ebx
c0022f21:	5e                   	pop    %esi
c0022f22:	5f                   	pop    %edi
c0022f23:	5d                   	pop    %ebp
c0022f24:	c3                   	ret    
  ASSERT (cond != NULL);
c0022f25:	83 ec 0c             	sub    $0xc,%esp
c0022f28:	68 5f e2 02 c0       	push   $0xc002e25f
c0022f2d:	68 3f d9 02 c0       	push   $0xc002d93f
c0022f32:	68 d8 c3 02 c0       	push   $0xc002c3d8
c0022f37:	68 8c 01 00 00       	push   $0x18c
c0022f3c:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022f41:	e8 c7 53 00 00       	call   c002830d <debug_panic>
  ASSERT (lock != NULL);
c0022f46:	83 ec 0c             	sub    $0xc,%esp
c0022f49:	68 52 e2 02 c0       	push   $0xc002e252
c0022f4e:	68 3f d9 02 c0       	push   $0xc002d93f
c0022f53:	68 d8 c3 02 c0       	push   $0xc002c3d8
c0022f58:	68 8d 01 00 00       	push   $0x18d
c0022f5d:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022f62:	e8 a6 53 00 00       	call   c002830d <debug_panic>
  ASSERT (!intr_context ());
c0022f67:	83 ec 0c             	sub    $0xc,%esp
c0022f6a:	68 8f dd 02 c0       	push   $0xc002dd8f
c0022f6f:	68 3f d9 02 c0       	push   $0xc002d93f
c0022f74:	68 d8 c3 02 c0       	push   $0xc002c3d8
c0022f79:	68 8e 01 00 00       	push   $0x18e
c0022f7e:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022f83:	e8 85 53 00 00       	call   c002830d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022f88:	83 ec 0c             	sub    $0xc,%esp
c0022f8b:	68 90 e2 02 c0       	push   $0xc002e290
c0022f90:	68 3f d9 02 c0       	push   $0xc002d93f
c0022f95:	68 d8 c3 02 c0       	push   $0xc002c3d8
c0022f9a:	68 8f 01 00 00       	push   $0x18f
c0022f9f:	68 fb e1 02 c0       	push   $0xc002e1fb
c0022fa4:	e8 64 53 00 00       	call   c002830d <debug_panic>

c0022fa9 <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0022fa9:	55                   	push   %ebp
c0022faa:	57                   	push   %edi
c0022fab:	56                   	push   %esi
c0022fac:	53                   	push   %ebx
c0022fad:	83 ec 0c             	sub    $0xc,%esp
c0022fb0:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0022fb4:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  ASSERT (cond != NULL);
c0022fb8:	85 ed                	test   %ebp,%ebp
c0022fba:	74 3f                	je     c0022ffb <cond_signal+0x52>
  ASSERT (lock != NULL);
c0022fbc:	85 db                	test   %ebx,%ebx
c0022fbe:	74 5c                	je     c002301c <cond_signal+0x73>
  ASSERT (!intr_context ());
c0022fc0:	e8 52 e9 ff ff       	call   c0021917 <intr_context>
c0022fc5:	84 c0                	test   %al,%al
c0022fc7:	75 74                	jne    c002303d <cond_signal+0x94>
  ASSERT (lock_held_by_current_thread (lock));
c0022fc9:	83 ec 0c             	sub    $0xc,%esp
c0022fcc:	53                   	push   %ebx
c0022fcd:	e8 62 fb ff ff       	call   c0022b34 <lock_held_by_current_thread>
c0022fd2:	83 c4 10             	add    $0x10,%esp
c0022fd5:	84 c0                	test   %al,%al
c0022fd7:	0f 84 81 00 00 00    	je     c002305e <cond_signal+0xb5>

  if (!list_empty (&cond->waiters)) {
c0022fdd:	89 ef                	mov    %ebp,%edi
c0022fdf:	83 ec 0c             	sub    $0xc,%esp
c0022fe2:	55                   	push   %ebp
c0022fe3:	e8 c0 58 00 00       	call   c00288a8 <list_empty>
c0022fe8:	83 c4 10             	add    $0x10,%esp
c0022feb:	84 c0                	test   %al,%al
c0022fed:	0f 84 8c 00 00 00    	je     c002307f <cond_signal+0xd6>
        sema_up (&t->semaphore);
        break;
      }
    }
  }
}
c0022ff3:	83 c4 0c             	add    $0xc,%esp
c0022ff6:	5b                   	pop    %ebx
c0022ff7:	5e                   	pop    %esi
c0022ff8:	5f                   	pop    %edi
c0022ff9:	5d                   	pop    %ebp
c0022ffa:	c3                   	ret    
  ASSERT (cond != NULL);
c0022ffb:	83 ec 0c             	sub    $0xc,%esp
c0022ffe:	68 5f e2 02 c0       	push   $0xc002e25f
c0023003:	68 3f d9 02 c0       	push   $0xc002d93f
c0023008:	68 cc c3 02 c0       	push   $0xc002c3cc
c002300d:	68 a3 01 00 00       	push   $0x1a3
c0023012:	68 fb e1 02 c0       	push   $0xc002e1fb
c0023017:	e8 f1 52 00 00       	call   c002830d <debug_panic>
  ASSERT (lock != NULL);
c002301c:	83 ec 0c             	sub    $0xc,%esp
c002301f:	68 52 e2 02 c0       	push   $0xc002e252
c0023024:	68 3f d9 02 c0       	push   $0xc002d93f
c0023029:	68 cc c3 02 c0       	push   $0xc002c3cc
c002302e:	68 a4 01 00 00       	push   $0x1a4
c0023033:	68 fb e1 02 c0       	push   $0xc002e1fb
c0023038:	e8 d0 52 00 00       	call   c002830d <debug_panic>
  ASSERT (!intr_context ());
c002303d:	83 ec 0c             	sub    $0xc,%esp
c0023040:	68 8f dd 02 c0       	push   $0xc002dd8f
c0023045:	68 3f d9 02 c0       	push   $0xc002d93f
c002304a:	68 cc c3 02 c0       	push   $0xc002c3cc
c002304f:	68 a5 01 00 00       	push   $0x1a5
c0023054:	68 fb e1 02 c0       	push   $0xc002e1fb
c0023059:	e8 af 52 00 00       	call   c002830d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c002305e:	83 ec 0c             	sub    $0xc,%esp
c0023061:	68 90 e2 02 c0       	push   $0xc002e290
c0023066:	68 3f d9 02 c0       	push   $0xc002d93f
c002306b:	68 cc c3 02 c0       	push   $0xc002c3cc
c0023070:	68 a6 01 00 00       	push   $0x1a6
c0023075:	68 fb e1 02 c0       	push   $0xc002e1fb
c002307a:	e8 8e 52 00 00       	call   c002830d <debug_panic>
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c002307f:	83 ec 0c             	sub    $0xc,%esp
c0023082:	55                   	push   %ebp
c0023083:	e8 6f 53 00 00       	call   c00283f7 <list_begin>
c0023088:	89 c3                	mov    %eax,%ebx
c002308a:	83 c4 10             	add    $0x10,%esp
    int maxp = -1, tmpp;
c002308d:	be ff ff ff ff       	mov    $0xffffffff,%esi
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c0023092:	eb 0e                	jmp    c00230a2 <cond_signal+0xf9>
              e = list_next (e)) {
c0023094:	83 ec 0c             	sub    $0xc,%esp
c0023097:	53                   	push   %ebx
c0023098:	e8 8a 53 00 00       	call   c0028427 <list_next>
c002309d:	89 c3                	mov    %eax,%ebx
c002309f:	83 c4 10             	add    $0x10,%esp
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c00230a2:	83 ec 0c             	sub    $0xc,%esp
c00230a5:	57                   	push   %edi
c00230a6:	e8 c4 53 00 00       	call   c002846f <list_end>
c00230ab:	83 c4 10             	add    $0x10,%esp
c00230ae:	39 c3                	cmp    %eax,%ebx
c00230b0:	74 16                	je     c00230c8 <cond_signal+0x11f>
      tmpp = thread_get_certain_priority(t->pthread);
c00230b2:	83 ec 0c             	sub    $0xc,%esp
c00230b5:	ff 73 1c             	pushl  0x1c(%ebx)
c00230b8:	e8 8a dc ff ff       	call   c0020d47 <thread_get_certain_priority>
c00230bd:	83 c4 10             	add    $0x10,%esp
c00230c0:	39 c6                	cmp    %eax,%esi
c00230c2:	7d d0                	jge    c0023094 <cond_signal+0xeb>
c00230c4:	89 c6                	mov    %eax,%esi
c00230c6:	eb cc                	jmp    c0023094 <cond_signal+0xeb>
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c00230c8:	83 ec 0c             	sub    $0xc,%esp
c00230cb:	55                   	push   %ebp
c00230cc:	e8 26 53 00 00       	call   c00283f7 <list_begin>
c00230d1:	89 c3                	mov    %eax,%ebx
c00230d3:	83 c4 10             	add    $0x10,%esp
c00230d6:	83 ec 0c             	sub    $0xc,%esp
c00230d9:	57                   	push   %edi
c00230da:	e8 90 53 00 00       	call   c002846f <list_end>
c00230df:	83 c4 10             	add    $0x10,%esp
c00230e2:	39 c3                	cmp    %eax,%ebx
c00230e4:	0f 84 09 ff ff ff    	je     c0022ff3 <cond_signal+0x4a>
      tmpp = thread_get_certain_priority(t->pthread);
c00230ea:	83 ec 0c             	sub    $0xc,%esp
c00230ed:	ff 73 1c             	pushl  0x1c(%ebx)
c00230f0:	e8 52 dc ff ff       	call   c0020d47 <thread_get_certain_priority>
      if (tmpp == maxp) {
c00230f5:	83 c4 10             	add    $0x10,%esp
c00230f8:	39 c6                	cmp    %eax,%esi
c00230fa:	74 10                	je     c002310c <cond_signal+0x163>
              e = list_next (e)) {
c00230fc:	83 ec 0c             	sub    $0xc,%esp
c00230ff:	53                   	push   %ebx
c0023100:	e8 22 53 00 00       	call   c0028427 <list_next>
c0023105:	89 c3                	mov    %eax,%ebx
c0023107:	83 c4 10             	add    $0x10,%esp
c002310a:	eb ca                	jmp    c00230d6 <cond_signal+0x12d>
        list_remove (e);
c002310c:	83 ec 0c             	sub    $0xc,%esp
c002310f:	53                   	push   %ebx
c0023110:	e8 08 57 00 00       	call   c002881d <list_remove>
        sema_up (&t->semaphore);
c0023115:	83 c3 08             	add    $0x8,%ebx
c0023118:	89 1c 24             	mov    %ebx,(%esp)
c002311b:	e8 53 f7 ff ff       	call   c0022873 <sema_up>
        break;
c0023120:	83 c4 10             	add    $0x10,%esp
c0023123:	e9 cb fe ff ff       	jmp    c0022ff3 <cond_signal+0x4a>

c0023128 <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0023128:	56                   	push   %esi
c0023129:	53                   	push   %ebx
c002312a:	83 ec 04             	sub    $0x4,%esp
c002312d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0023131:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (cond != NULL);
c0023135:	85 db                	test   %ebx,%ebx
c0023137:	74 25                	je     c002315e <cond_broadcast+0x36>
  ASSERT (lock != NULL);
c0023139:	85 f6                	test   %esi,%esi
c002313b:	75 4f                	jne    c002318c <cond_broadcast+0x64>
c002313d:	83 ec 0c             	sub    $0xc,%esp
c0023140:	68 52 e2 02 c0       	push   $0xc002e252
c0023145:	68 3f d9 02 c0       	push   $0xc002d93f
c002314a:	68 bc c3 02 c0       	push   $0xc002c3bc
c002314f:	68 ca 01 00 00       	push   $0x1ca
c0023154:	68 fb e1 02 c0       	push   $0xc002e1fb
c0023159:	e8 af 51 00 00       	call   c002830d <debug_panic>
  ASSERT (cond != NULL);
c002315e:	83 ec 0c             	sub    $0xc,%esp
c0023161:	68 5f e2 02 c0       	push   $0xc002e25f
c0023166:	68 3f d9 02 c0       	push   $0xc002d93f
c002316b:	68 bc c3 02 c0       	push   $0xc002c3bc
c0023170:	68 c9 01 00 00       	push   $0x1c9
c0023175:	68 fb e1 02 c0       	push   $0xc002e1fb
c002317a:	e8 8e 51 00 00       	call   c002830d <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c002317f:	83 ec 08             	sub    $0x8,%esp
c0023182:	56                   	push   %esi
c0023183:	53                   	push   %ebx
c0023184:	e8 20 fe ff ff       	call   c0022fa9 <cond_signal>
c0023189:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c002318c:	83 ec 0c             	sub    $0xc,%esp
c002318f:	53                   	push   %ebx
c0023190:	e8 13 57 00 00       	call   c00288a8 <list_empty>
c0023195:	83 c4 10             	add    $0x10,%esp
c0023198:	84 c0                	test   %al,%al
c002319a:	74 e3                	je     c002317f <cond_broadcast+0x57>
}
c002319c:	83 c4 04             	add    $0x4,%esp
c002319f:	5b                   	pop    %ebx
c00231a0:	5e                   	pop    %esi
c00231a1:	c3                   	ret    

c00231a2 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c00231a2:	55                   	push   %ebp
c00231a3:	57                   	push   %edi
c00231a4:	56                   	push   %esi
c00231a5:	53                   	push   %ebx
c00231a6:	83 ec 18             	sub    $0x18,%esp
c00231a9:	89 c5                	mov    %eax,%ebp
c00231ab:	89 d7                	mov    %edx,%edi
c00231ad:	89 ce                	mov    %ecx,%esi
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c00231af:	51                   	push   %ecx
c00231b0:	e8 b4 5d 00 00       	call   c0028f69 <bitmap_buf_size>
c00231b5:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
c00231bb:	89 d8                	mov    %ebx,%eax
c00231bd:	c1 e8 0c             	shr    $0xc,%eax
  if (bm_pages > page_cnt)
c00231c0:	83 c4 10             	add    $0x10,%esp
c00231c3:	39 c6                	cmp    %eax,%esi
c00231c5:	72 3d                	jb     c0023204 <init_pool+0x62>
    PANIC ("Not enough memory in %s for bitmap.", name);
  page_cnt -= bm_pages;
c00231c7:	29 c6                	sub    %eax,%esi

  printf ("%zu pages available in %s.\n", page_cnt, name);
c00231c9:	83 ec 04             	sub    $0x4,%esp
c00231cc:	ff 74 24 24          	pushl  0x24(%esp)
c00231d0:	56                   	push   %esi
c00231d1:	68 1f e3 02 c0       	push   $0xc002e31f
c00231d6:	e8 84 36 00 00       	call   c002685f <printf>

  /* Initialize the pool. */
  lock_init (&p->lock);
c00231db:	89 2c 24             	mov    %ebp,(%esp)
c00231de:	e8 1b f8 ff ff       	call   c00229fe <lock_init>
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c00231e3:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c00231e9:	83 c4 0c             	add    $0xc,%esp
c00231ec:	53                   	push   %ebx
c00231ed:	57                   	push   %edi
c00231ee:	56                   	push   %esi
c00231ef:	e8 4e 60 00 00       	call   c0029242 <bitmap_create_in_buf>
c00231f4:	89 45 34             	mov    %eax,0x34(%ebp)
  p->base = base + bm_pages * PGSIZE;
c00231f7:	01 df                	add    %ebx,%edi
c00231f9:	89 7d 38             	mov    %edi,0x38(%ebp)
}
c00231fc:	83 c4 1c             	add    $0x1c,%esp
c00231ff:	5b                   	pop    %ebx
c0023200:	5e                   	pop    %esi
c0023201:	5f                   	pop    %edi
c0023202:	5d                   	pop    %ebp
c0023203:	c3                   	ret    
    PANIC ("Not enough memory in %s for bitmap.", name);
c0023204:	83 ec 0c             	sub    $0xc,%esp
c0023207:	ff 74 24 2c          	pushl  0x2c(%esp)
c002320b:	68 b4 e2 02 c0       	push   $0xc002e2b4
c0023210:	68 a0 c4 02 c0       	push   $0xc002c4a0
c0023215:	68 a1 00 00 00       	push   $0xa1
c002321a:	68 08 e3 02 c0       	push   $0xc002e308
c002321f:	e8 e9 50 00 00       	call   c002830d <debug_panic>

c0023224 <palloc_init>:
{
c0023224:	56                   	push   %esi
c0023225:	53                   	push   %ebx
c0023226:	83 ec 04             	sub    $0x4,%esp
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c0023229:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c002322e:	c1 e0 0c             	shl    $0xc,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c0023231:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0023236:	77 5b                	ja     c0023293 <palloc_init+0x6f>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0023238:	2d 00 00 10 00       	sub    $0x100000,%eax
c002323d:	89 c3                	mov    %eax,%ebx
c002323f:	85 c0                	test   %eax,%eax
c0023241:	78 6e                	js     c00232b1 <palloc_init+0x8d>
c0023243:	c1 fb 0c             	sar    $0xc,%ebx
  size_t user_pages = free_pages / 2;
c0023246:	89 d8                	mov    %ebx,%eax
c0023248:	d1 e8                	shr    %eax
c002324a:	89 c6                	mov    %eax,%esi
c002324c:	3b 44 24 10          	cmp    0x10(%esp),%eax
c0023250:	76 04                	jbe    c0023256 <palloc_init+0x32>
c0023252:	8b 74 24 10          	mov    0x10(%esp),%esi
  kernel_pages = free_pages - user_pages;
c0023256:	29 f3                	sub    %esi,%ebx
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023258:	83 ec 0c             	sub    $0xc,%esp
c002325b:	68 56 e3 02 c0       	push   $0xc002e356
c0023260:	89 d9                	mov    %ebx,%ecx
c0023262:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c0023267:	b8 40 97 03 c0       	mov    $0xc0039740,%eax
c002326c:	e8 31 ff ff ff       	call   c00231a2 <init_pool>
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c0023271:	c1 e3 0c             	shl    $0xc,%ebx
c0023274:	8d 93 00 00 10 c0    	lea    -0x3ff00000(%ebx),%edx
c002327a:	c7 04 24 62 e3 02 c0 	movl   $0xc002e362,(%esp)
c0023281:	89 f1                	mov    %esi,%ecx
c0023283:	b8 00 97 03 c0       	mov    $0xc0039700,%eax
c0023288:	e8 15 ff ff ff       	call   c00231a2 <init_pool>
}
c002328d:	83 c4 14             	add    $0x14,%esp
c0023290:	5b                   	pop    %ebx
c0023291:	5e                   	pop    %esi
c0023292:	c3                   	ret    
c0023293:	83 ec 0c             	sub    $0xc,%esp
c0023296:	68 3b e3 02 c0       	push   $0xc002e33b
c002329b:	68 3f d9 02 c0       	push   $0xc002d93f
c00232a0:	68 ac c4 02 c0       	push   $0xc002c4ac
c00232a5:	6a 4a                	push   $0x4a
c00232a7:	68 82 d9 02 c0       	push   $0xc002d982
c00232ac:	e8 5c 50 00 00       	call   c002830d <debug_panic>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c00232b1:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
c00232b7:	eb 8a                	jmp    c0023243 <palloc_init+0x1f>

c00232b9 <palloc_get_multiple>:
{
c00232b9:	57                   	push   %edi
c00232ba:	56                   	push   %esi
c00232bb:	53                   	push   %ebx
c00232bc:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c00232c0:	f6 44 24 10 04       	testb  $0x4,0x10(%esp)
c00232c5:	75 47                	jne    c002330e <palloc_get_multiple+0x55>
c00232c7:	bb 40 97 03 c0       	mov    $0xc0039740,%ebx
  if (page_cnt == 0)
c00232cc:	85 ff                	test   %edi,%edi
c00232ce:	74 76                	je     c0023346 <palloc_get_multiple+0x8d>
  lock_acquire (&pool->lock);
c00232d0:	83 ec 0c             	sub    $0xc,%esp
c00232d3:	53                   	push   %ebx
c00232d4:	e8 99 f8 ff ff       	call   c0022b72 <lock_acquire>
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c00232d9:	6a 00                	push   $0x0
c00232db:	57                   	push   %edi
c00232dc:	6a 00                	push   $0x0
c00232de:	ff 73 34             	pushl  0x34(%ebx)
c00232e1:	e8 2b 62 00 00       	call   c0029511 <bitmap_scan_and_flip>
c00232e6:	89 c6                	mov    %eax,%esi
  lock_release (&pool->lock);
c00232e8:	83 c4 14             	add    $0x14,%esp
c00232eb:	53                   	push   %ebx
c00232ec:	e8 1e fa ff ff       	call   c0022d0f <lock_release>
  if (page_idx != BITMAP_ERROR)
c00232f1:	83 c4 10             	add    $0x10,%esp
c00232f4:	83 fe ff             	cmp    $0xffffffff,%esi
c00232f7:	74 29                	je     c0023322 <palloc_get_multiple+0x69>
    pages = pool->base + PGSIZE * page_idx;
c00232f9:	c1 e6 0c             	shl    $0xc,%esi
  if (pages != NULL) 
c00232fc:	03 73 38             	add    0x38(%ebx),%esi
c00232ff:	74 21                	je     c0023322 <palloc_get_multiple+0x69>
      if (flags & PAL_ZERO)
c0023301:	f6 44 24 10 02       	testb  $0x2,0x10(%esp)
c0023306:	75 0d                	jne    c0023315 <palloc_get_multiple+0x5c>
}
c0023308:	89 f0                	mov    %esi,%eax
c002330a:	5b                   	pop    %ebx
c002330b:	5e                   	pop    %esi
c002330c:	5f                   	pop    %edi
c002330d:	c3                   	ret    
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c002330e:	bb 00 97 03 c0       	mov    $0xc0039700,%ebx
c0023313:	eb b7                	jmp    c00232cc <palloc_get_multiple+0x13>
        memset (pages, 0, PGSIZE * page_cnt);
c0023315:	89 f9                	mov    %edi,%ecx
c0023317:	c1 e1 0c             	shl    $0xc,%ecx
c002331a:	b0 00                	mov    $0x0,%al
c002331c:	89 f7                	mov    %esi,%edi
c002331e:	f3 aa                	rep stos %al,%es:(%edi)
c0023320:	eb e6                	jmp    c0023308 <palloc_get_multiple+0x4f>
      if (flags & PAL_ASSERT)
c0023322:	f6 44 24 10 01       	testb  $0x1,0x10(%esp)
c0023327:	75 07                	jne    c0023330 <palloc_get_multiple+0x77>
  return pages;
c0023329:	be 00 00 00 00       	mov    $0x0,%esi
c002332e:	eb d8                	jmp    c0023308 <palloc_get_multiple+0x4f>
        PANIC ("palloc_get: out of pages");
c0023330:	68 6c e3 02 c0       	push   $0xc002e36c
c0023335:	68 8c c4 02 c0       	push   $0xc002c48c
c002333a:	6a 61                	push   $0x61
c002333c:	68 08 e3 02 c0       	push   $0xc002e308
c0023341:	e8 c7 4f 00 00       	call   c002830d <debug_panic>
    return NULL;
c0023346:	be 00 00 00 00       	mov    $0x0,%esi
c002334b:	eb bb                	jmp    c0023308 <palloc_get_multiple+0x4f>

c002334d <palloc_get_page>:
{
c002334d:	83 ec 14             	sub    $0x14,%esp
  return palloc_get_multiple (flags, 1);
c0023350:	6a 01                	push   $0x1
c0023352:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023356:	e8 5e ff ff ff       	call   c00232b9 <palloc_get_multiple>
}
c002335b:	83 c4 1c             	add    $0x1c,%esp
c002335e:	c3                   	ret    

c002335f <palloc_free_multiple>:
{
c002335f:	55                   	push   %ebp
c0023360:	57                   	push   %edi
c0023361:	56                   	push   %esi
c0023362:	53                   	push   %ebx
c0023363:	83 ec 0c             	sub    $0xc,%esp
c0023366:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  ASSERT (pg_ofs (pages) == 0);
c002336a:	f7 44 24 20 ff 0f 00 	testl  $0xfff,0x20(%esp)
c0023371:	00 
c0023372:	75 13                	jne    c0023387 <palloc_free_multiple+0x28>
  if (pages == NULL || page_cnt == 0)
c0023374:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0023379:	74 04                	je     c002337f <palloc_free_multiple+0x20>
c002337b:	85 db                	test   %ebx,%ebx
c002337d:	75 26                	jne    c00233a5 <palloc_free_multiple+0x46>
}
c002337f:	83 c4 0c             	add    $0xc,%esp
c0023382:	5b                   	pop    %ebx
c0023383:	5e                   	pop    %esi
c0023384:	5f                   	pop    %edi
c0023385:	5d                   	pop    %ebp
c0023386:	c3                   	ret    
  ASSERT (pg_ofs (pages) == 0);
c0023387:	83 ec 0c             	sub    $0xc,%esp
c002338a:	68 85 e3 02 c0       	push   $0xc002e385
c002338f:	68 3f d9 02 c0       	push   $0xc002d93f
c0023394:	68 74 c4 02 c0       	push   $0xc002c474
c0023399:	6a 7b                	push   $0x7b
c002339b:	68 08 e3 02 c0       	push   $0xc002e308
c00233a0:	e8 68 4f 00 00       	call   c002830d <debug_panic>
  return (uintptr_t) va >> PGBITS;
c00233a5:	8b 74 24 20          	mov    0x20(%esp),%esi
c00233a9:	c1 ee 0c             	shr    $0xc,%esi
c00233ac:	8b 2d 78 97 03 c0    	mov    0xc0039778,%ebp
c00233b2:	c1 ed 0c             	shr    $0xc,%ebp
static bool
page_from_pool (const struct pool *pool, void *page) 
{
  size_t page_no = pg_no (page);
  size_t start_page = pg_no (pool->base);
  size_t end_page = start_page + bitmap_size (pool->used_map);
c00233b5:	83 ec 0c             	sub    $0xc,%esp
c00233b8:	ff 35 74 97 03 c0    	pushl  0xc0039774
c00233be:	e8 df 5b 00 00       	call   c0028fa2 <bitmap_size>

  return page_no >= start_page && page_no < end_page;
c00233c3:	83 c4 10             	add    $0x10,%esp
c00233c6:	39 ee                	cmp    %ebp,%esi
c00233c8:	72 06                	jb     c00233d0 <palloc_free_multiple+0x71>
  size_t end_page = start_page + bitmap_size (pool->used_map);
c00233ca:	01 c5                	add    %eax,%ebp
  return page_no >= start_page && page_no < end_page;
c00233cc:	39 ee                	cmp    %ebp,%esi
c00233ce:	72 44                	jb     c0023414 <palloc_free_multiple+0xb5>
c00233d0:	8b 2d 38 97 03 c0    	mov    0xc0039738,%ebp
c00233d6:	c1 ed 0c             	shr    $0xc,%ebp
  size_t end_page = start_page + bitmap_size (pool->used_map);
c00233d9:	83 ec 0c             	sub    $0xc,%esp
c00233dc:	ff 35 34 97 03 c0    	pushl  0xc0039734
c00233e2:	e8 bb 5b 00 00       	call   c0028fa2 <bitmap_size>
  return page_no >= start_page && page_no < end_page;
c00233e7:	83 c4 10             	add    $0x10,%esp
c00233ea:	39 ee                	cmp    %ebp,%esi
c00233ec:	73 19                	jae    c0023407 <palloc_free_multiple+0xa8>
    NOT_REACHED ();
c00233ee:	68 24 de 02 c0       	push   $0xc002de24
c00233f3:	68 74 c4 02 c0       	push   $0xc002c474
c00233f8:	68 84 00 00 00       	push   $0x84
c00233fd:	68 08 e3 02 c0       	push   $0xc002e308
c0023402:	e8 06 4f 00 00       	call   c002830d <debug_panic>
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023407:	01 e8                	add    %ebp,%eax
  return page_no >= start_page && page_no < end_page;
c0023409:	39 c6                	cmp    %eax,%esi
c002340b:	73 e1                	jae    c00233ee <palloc_free_multiple+0x8f>
    pool = &user_pool;
c002340d:	bd 00 97 03 c0       	mov    $0xc0039700,%ebp
c0023412:	eb 05                	jmp    c0023419 <palloc_free_multiple+0xba>
    pool = &kernel_pool;
c0023414:	bd 40 97 03 c0       	mov    $0xc0039740,%ebp
c0023419:	8b 45 38             	mov    0x38(%ebp),%eax
c002341c:	c1 e8 0c             	shr    $0xc,%eax
  page_idx = pg_no (pages) - pg_no (pool->base);
c002341f:	29 c6                	sub    %eax,%esi
  memset (pages, 0xcc, PGSIZE * page_cnt);
c0023421:	89 d9                	mov    %ebx,%ecx
c0023423:	c1 e1 0c             	shl    $0xc,%ecx
c0023426:	b0 cc                	mov    $0xcc,%al
c0023428:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002342c:	f3 aa                	rep stos %al,%es:(%edi)
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c002342e:	83 ec 04             	sub    $0x4,%esp
c0023431:	53                   	push   %ebx
c0023432:	56                   	push   %esi
c0023433:	ff 75 34             	pushl  0x34(%ebp)
c0023436:	e8 09 60 00 00       	call   c0029444 <bitmap_all>
c002343b:	83 c4 10             	add    $0x10,%esp
c002343e:	84 c0                	test   %al,%al
c0023440:	74 14                	je     c0023456 <palloc_free_multiple+0xf7>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c0023442:	6a 00                	push   $0x0
c0023444:	53                   	push   %ebx
c0023445:	56                   	push   %esi
c0023446:	ff 75 34             	pushl  0x34(%ebp)
c0023449:	e8 a1 5c 00 00       	call   c00290ef <bitmap_set_multiple>
c002344e:	83 c4 10             	add    $0x10,%esp
c0023451:	e9 29 ff ff ff       	jmp    c002337f <palloc_free_multiple+0x20>
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023456:	83 ec 0c             	sub    $0xc,%esp
c0023459:	68 d8 e2 02 c0       	push   $0xc002e2d8
c002345e:	68 3f d9 02 c0       	push   $0xc002d93f
c0023463:	68 74 c4 02 c0       	push   $0xc002c474
c0023468:	68 8c 00 00 00       	push   $0x8c
c002346d:	68 08 e3 02 c0       	push   $0xc002e308
c0023472:	e8 96 4e 00 00       	call   c002830d <debug_panic>

c0023477 <palloc_free_page>:
{
c0023477:	83 ec 14             	sub    $0x14,%esp
  palloc_free_multiple (page, 1);
c002347a:	6a 01                	push   $0x1
c002347c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023480:	e8 da fe ff ff       	call   c002335f <palloc_free_multiple>
}
c0023485:	83 c4 1c             	add    $0x1c,%esp
c0023488:	c3                   	ret    

c0023489 <arena_to_block>:
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c0023489:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (a != NULL);
c002348c:	85 c0                	test   %eax,%eax
c002348e:	74 1b                	je     c00234ab <arena_to_block+0x22>
  ASSERT (a->magic == ARENA_MAGIC);
c0023490:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c0023496:	75 34                	jne    c00234cc <arena_to_block+0x43>
  ASSERT (idx < a->desc->blocks_per_arena);
c0023498:	8b 48 04             	mov    0x4(%eax),%ecx
c002349b:	39 51 04             	cmp    %edx,0x4(%ecx)
c002349e:	76 4d                	jbe    c00234ed <arena_to_block+0x64>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c00234a0:	0f af 11             	imul   (%ecx),%edx
  return (struct block *) ((uint8_t *) a
c00234a3:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c00234a7:	83 c4 0c             	add    $0xc,%esp
c00234aa:	c3                   	ret    
  ASSERT (a != NULL);
c00234ab:	83 ec 0c             	sub    $0xc,%esp
c00234ae:	68 f1 e1 02 c0       	push   $0xc002e1f1
c00234b3:	68 3f d9 02 c0       	push   $0xc002d93f
c00234b8:	68 cc c4 02 c0       	push   $0xc002c4cc
c00234bd:	68 20 01 00 00       	push   $0x120
c00234c2:	68 99 e3 02 c0       	push   $0xc002e399
c00234c7:	e8 41 4e 00 00       	call   c002830d <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00234cc:	83 ec 0c             	sub    $0xc,%esp
c00234cf:	68 b0 e3 02 c0       	push   $0xc002e3b0
c00234d4:	68 3f d9 02 c0       	push   $0xc002d93f
c00234d9:	68 cc c4 02 c0       	push   $0xc002c4cc
c00234de:	68 21 01 00 00       	push   $0x121
c00234e3:	68 99 e3 02 c0       	push   $0xc002e399
c00234e8:	e8 20 4e 00 00       	call   c002830d <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c00234ed:	83 ec 0c             	sub    $0xc,%esp
c00234f0:	68 c8 e3 02 c0       	push   $0xc002e3c8
c00234f5:	68 3f d9 02 c0       	push   $0xc002d93f
c00234fa:	68 cc c4 02 c0       	push   $0xc002c4cc
c00234ff:	68 22 01 00 00       	push   $0x122
c0023504:	68 99 e3 02 c0       	push   $0xc002e399
c0023509:	e8 ff 4d 00 00       	call   c002830d <debug_panic>

c002350e <block_to_arena>:
{
c002350e:	53                   	push   %ebx
c002350f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0023512:	89 c1                	mov    %eax,%ecx
c0023514:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c002351a:	74 29                	je     c0023545 <block_to_arena+0x37>
  ASSERT (a->magic == ARENA_MAGIC);
c002351c:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0023522:	75 42                	jne    c0023566 <block_to_arena+0x58>
  ASSERT (a->desc == NULL
c0023524:	8b 59 04             	mov    0x4(%ecx),%ebx
c0023527:	85 db                	test   %ebx,%ebx
c0023529:	74 7d                	je     c00235a8 <block_to_arena+0x9a>
  return (uintptr_t) va & PGMASK;
c002352b:	25 ff 0f 00 00       	and    $0xfff,%eax
c0023530:	83 e8 0c             	sub    $0xc,%eax
c0023533:	ba 00 00 00 00       	mov    $0x0,%edx
c0023538:	f7 33                	divl   (%ebx)
c002353a:	85 d2                	test   %edx,%edx
c002353c:	75 49                	jne    c0023587 <block_to_arena+0x79>
}
c002353e:	89 c8                	mov    %ecx,%eax
c0023540:	83 c4 08             	add    $0x8,%esp
c0023543:	5b                   	pop    %ebx
c0023544:	c3                   	ret    
  ASSERT (a != NULL);
c0023545:	83 ec 0c             	sub    $0xc,%esp
c0023548:	68 f1 e1 02 c0       	push   $0xc002e1f1
c002354d:	68 3f d9 02 c0       	push   $0xc002d93f
c0023552:	68 bc c4 02 c0       	push   $0xc002c4bc
c0023557:	68 11 01 00 00       	push   $0x111
c002355c:	68 99 e3 02 c0       	push   $0xc002e399
c0023561:	e8 a7 4d 00 00       	call   c002830d <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023566:	83 ec 0c             	sub    $0xc,%esp
c0023569:	68 b0 e3 02 c0       	push   $0xc002e3b0
c002356e:	68 3f d9 02 c0       	push   $0xc002d93f
c0023573:	68 bc c4 02 c0       	push   $0xc002c4bc
c0023578:	68 12 01 00 00       	push   $0x112
c002357d:	68 99 e3 02 c0       	push   $0xc002e399
c0023582:	e8 86 4d 00 00       	call   c002830d <debug_panic>
  ASSERT (a->desc == NULL
c0023587:	83 ec 0c             	sub    $0xc,%esp
c002358a:	68 e8 e3 02 c0       	push   $0xc002e3e8
c002358f:	68 3f d9 02 c0       	push   $0xc002d93f
c0023594:	68 bc c4 02 c0       	push   $0xc002c4bc
c0023599:	68 16 01 00 00       	push   $0x116
c002359e:	68 99 e3 02 c0       	push   $0xc002e399
c00235a3:	e8 65 4d 00 00       	call   c002830d <debug_panic>
c00235a8:	25 ff 0f 00 00       	and    $0xfff,%eax
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c00235ad:	83 f8 0c             	cmp    $0xc,%eax
c00235b0:	74 8c                	je     c002353e <block_to_arena+0x30>
c00235b2:	83 ec 0c             	sub    $0xc,%esp
c00235b5:	68 30 e4 02 c0       	push   $0xc002e430
c00235ba:	68 3f d9 02 c0       	push   $0xc002d93f
c00235bf:	68 bc c4 02 c0       	push   $0xc002c4bc
c00235c4:	68 17 01 00 00       	push   $0x117
c00235c9:	68 99 e3 02 c0       	push   $0xc002e399
c00235ce:	e8 3a 4d 00 00       	call   c002830d <debug_panic>

c00235d3 <malloc_init>:
{
c00235d3:	55                   	push   %ebp
c00235d4:	57                   	push   %edi
c00235d5:	56                   	push   %esi
c00235d6:	53                   	push   %ebx
c00235d7:	83 ec 0c             	sub    $0xc,%esp
      struct desc *d = &descs[desc_cnt++];
c00235da:	a1 80 97 03 c0       	mov    0xc0039780,%eax
c00235df:	8d 50 01             	lea    0x1(%eax),%edx
c00235e2:	89 15 80 97 03 c0    	mov    %edx,0xc0039780
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00235e8:	83 fa 0a             	cmp    $0xa,%edx
c00235eb:	0f 87 b4 00 00 00    	ja     c00236a5 <malloc_init+0xd2>
      d->block_size = block_size;
c00235f1:	8d 1c c0             	lea    (%eax,%eax,8),%ebx
c00235f4:	01 db                	add    %ebx,%ebx
c00235f6:	8d 14 03             	lea    (%ebx,%eax,1),%edx
c00235f9:	c1 e2 02             	shl    $0x2,%edx
c00235fc:	c7 82 a0 97 03 c0 10 	movl   $0x10,-0x3ffc6860(%edx)
c0023603:	00 00 00 
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023606:	c7 82 a4 97 03 c0 ff 	movl   $0xff,-0x3ffc685c(%edx)
c002360d:	00 00 00 
c0023610:	89 d3                	mov    %edx,%ebx
      list_init (&d->free_list);
c0023612:	83 ec 0c             	sub    $0xc,%esp
c0023615:	8d 82 a8 97 03 c0    	lea    -0x3ffc6858(%edx),%eax
c002361b:	50                   	push   %eax
c002361c:	e8 93 4d 00 00       	call   c00283b4 <list_init>
      lock_init (&d->lock);
c0023621:	81 c3 b8 97 03 c0    	add    $0xc00397b8,%ebx
c0023627:	89 1c 24             	mov    %ebx,(%esp)
c002362a:	e8 cf f3 ff ff       	call   c00229fe <lock_init>
c002362f:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023632:	be 20 00 00 00       	mov    $0x20,%esi
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023637:	bf f4 0f 00 00       	mov    $0xff4,%edi
      struct desc *d = &descs[desc_cnt++];
c002363c:	8b 0d 80 97 03 c0    	mov    0xc0039780,%ecx
c0023642:	8d 41 01             	lea    0x1(%ecx),%eax
c0023645:	a3 80 97 03 c0       	mov    %eax,0xc0039780
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c002364a:	83 f8 0a             	cmp    $0xa,%eax
c002364d:	77 56                	ja     c00236a5 <malloc_init+0xd2>
      d->block_size = block_size;
c002364f:	8d 1c c9             	lea    (%ecx,%ecx,8),%ebx
c0023652:	01 db                	add    %ebx,%ebx
c0023654:	8d 2c 0b             	lea    (%ebx,%ecx,1),%ebp
c0023657:	c1 e5 02             	shl    $0x2,%ebp
c002365a:	89 b5 a0 97 03 c0    	mov    %esi,-0x3ffc6860(%ebp)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023660:	89 f8                	mov    %edi,%eax
c0023662:	ba 00 00 00 00       	mov    $0x0,%edx
c0023667:	f7 f6                	div    %esi
c0023669:	89 85 a4 97 03 c0    	mov    %eax,-0x3ffc685c(%ebp)
c002366f:	89 eb                	mov    %ebp,%ebx
      list_init (&d->free_list);
c0023671:	83 ec 0c             	sub    $0xc,%esp
c0023674:	8d 85 a8 97 03 c0    	lea    -0x3ffc6858(%ebp),%eax
c002367a:	50                   	push   %eax
c002367b:	e8 34 4d 00 00       	call   c00283b4 <list_init>
      lock_init (&d->lock);
c0023680:	81 c3 b8 97 03 c0    	add    $0xc00397b8,%ebx
c0023686:	89 1c 24             	mov    %ebx,(%esp)
c0023689:	e8 70 f3 ff ff       	call   c00229fe <lock_init>
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c002368e:	8d 04 36             	lea    (%esi,%esi,1),%eax
c0023691:	89 c6                	mov    %eax,%esi
c0023693:	83 c4 10             	add    $0x10,%esp
c0023696:	3d ff 07 00 00       	cmp    $0x7ff,%eax
c002369b:	76 9f                	jbe    c002363c <malloc_init+0x69>
}
c002369d:	83 c4 0c             	add    $0xc,%esp
c00236a0:	5b                   	pop    %ebx
c00236a1:	5e                   	pop    %esi
c00236a2:	5f                   	pop    %edi
c00236a3:	5d                   	pop    %ebp
c00236a4:	c3                   	ret    
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00236a5:	83 ec 0c             	sub    $0xc,%esp
c00236a8:	68 5c e4 02 c0       	push   $0xc002e45c
c00236ad:	68 3f d9 02 c0       	push   $0xc002d93f
c00236b2:	68 dc c4 02 c0       	push   $0xc002c4dc
c00236b7:	6a 4f                	push   $0x4f
c00236b9:	68 99 e3 02 c0       	push   $0xc002e399
c00236be:	e8 4a 4c 00 00       	call   c002830d <debug_panic>

c00236c3 <malloc>:
{
c00236c3:	55                   	push   %ebp
c00236c4:	57                   	push   %edi
c00236c5:	56                   	push   %esi
c00236c6:	53                   	push   %ebx
c00236c7:	83 ec 1c             	sub    $0x1c,%esp
c00236ca:	8b 44 24 30          	mov    0x30(%esp),%eax
  if (size == 0)
c00236ce:	85 c0                	test   %eax,%eax
c00236d0:	0f 84 2e 01 00 00    	je     c0023804 <malloc+0x141>
  for (d = descs; d < descs + desc_cnt; d++)
c00236d6:	8b 0d 80 97 03 c0    	mov    0xc0039780,%ecx
c00236dc:	8d 14 c9             	lea    (%ecx,%ecx,8),%edx
c00236df:	01 d2                	add    %edx,%edx
c00236e1:	01 ca                	add    %ecx,%edx
c00236e3:	8d 14 95 a0 97 03 c0 	lea    -0x3ffc6860(,%edx,4),%edx
c00236ea:	81 fa a0 97 03 c0    	cmp    $0xc00397a0,%edx
c00236f0:	0f 86 bb 00 00 00    	jbe    c00237b1 <malloc+0xee>
    if (d->block_size >= size)
c00236f6:	3b 05 a0 97 03 c0    	cmp    0xc00397a0,%eax
c00236fc:	0f 86 10 01 00 00    	jbe    c0023812 <malloc+0x14f>
c0023702:	bb a0 97 03 c0       	mov    $0xc00397a0,%ebx
  for (d = descs; d < descs + desc_cnt; d++)
c0023707:	83 c3 4c             	add    $0x4c,%ebx
c002370a:	39 d3                	cmp    %edx,%ebx
c002370c:	0f 83 a4 00 00 00    	jae    c00237b6 <malloc+0xf3>
    if (d->block_size >= size)
c0023712:	3b 03                	cmp    (%ebx),%eax
c0023714:	77 f1                	ja     c0023707 <malloc+0x44>
  lock_acquire (&d->lock);
c0023716:	8d 43 18             	lea    0x18(%ebx),%eax
c0023719:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002371d:	83 ec 0c             	sub    $0xc,%esp
c0023720:	50                   	push   %eax
c0023721:	e8 4c f4 ff ff       	call   c0022b72 <lock_acquire>
  if (list_empty (&d->free_list))
c0023726:	8d 7b 08             	lea    0x8(%ebx),%edi
c0023729:	89 3c 24             	mov    %edi,(%esp)
c002372c:	e8 77 51 00 00       	call   c00288a8 <list_empty>
c0023731:	83 c4 10             	add    $0x10,%esp
c0023734:	84 c0                	test   %al,%al
c0023736:	74 4d                	je     c0023785 <malloc+0xc2>
      a = palloc_get_page (0);
c0023738:	83 ec 0c             	sub    $0xc,%esp
c002373b:	6a 00                	push   $0x0
c002373d:	e8 0b fc ff ff       	call   c002334d <palloc_get_page>
c0023742:	89 c5                	mov    %eax,%ebp
      if (a == NULL) 
c0023744:	83 c4 10             	add    $0x10,%esp
c0023747:	85 c0                	test   %eax,%eax
c0023749:	0f 84 9f 00 00 00    	je     c00237ee <malloc+0x12b>
      a->magic = ARENA_MAGIC;
c002374f:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c0023755:	89 58 04             	mov    %ebx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c0023758:	8b 43 04             	mov    0x4(%ebx),%eax
c002375b:	89 45 08             	mov    %eax,0x8(%ebp)
      for (i = 0; i < d->blocks_per_arena; i++) 
c002375e:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0023762:	74 21                	je     c0023785 <malloc+0xc2>
c0023764:	be 00 00 00 00       	mov    $0x0,%esi
          struct block *b = arena_to_block (a, i);
c0023769:	89 f2                	mov    %esi,%edx
c002376b:	89 e8                	mov    %ebp,%eax
c002376d:	e8 17 fd ff ff       	call   c0023489 <arena_to_block>
          list_push_back (&d->free_list, &b->free_elem);
c0023772:	83 ec 08             	sub    $0x8,%esp
c0023775:	50                   	push   %eax
c0023776:	57                   	push   %edi
c0023777:	e8 84 50 00 00       	call   c0028800 <list_push_back>
      for (i = 0; i < d->blocks_per_arena; i++) 
c002377c:	46                   	inc    %esi
c002377d:	83 c4 10             	add    $0x10,%esp
c0023780:	39 73 04             	cmp    %esi,0x4(%ebx)
c0023783:	77 e4                	ja     c0023769 <malloc+0xa6>
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023785:	83 ec 0c             	sub    $0xc,%esp
c0023788:	57                   	push   %edi
c0023789:	e8 7c 51 00 00       	call   c002890a <list_pop_front>
c002378e:	89 c3                	mov    %eax,%ebx
  a = block_to_arena (b);
c0023790:	e8 79 fd ff ff       	call   c002350e <block_to_arena>
  a->free_cnt--;
c0023795:	ff 48 08             	decl   0x8(%eax)
  lock_release (&d->lock);
c0023798:	83 c4 04             	add    $0x4,%esp
c002379b:	ff 74 24 18          	pushl  0x18(%esp)
c002379f:	e8 6b f5 ff ff       	call   c0022d0f <lock_release>
  return b;
c00237a4:	83 c4 10             	add    $0x10,%esp
c00237a7:	89 d8                	mov    %ebx,%eax
}
c00237a9:	83 c4 1c             	add    $0x1c,%esp
c00237ac:	5b                   	pop    %ebx
c00237ad:	5e                   	pop    %esi
c00237ae:	5f                   	pop    %edi
c00237af:	5d                   	pop    %ebp
c00237b0:	c3                   	ret    
  for (d = descs; d < descs + desc_cnt; d++)
c00237b1:	bb a0 97 03 c0       	mov    $0xc00397a0,%ebx
  if (d == descs + desc_cnt) 
c00237b6:	39 da                	cmp    %ebx,%edx
c00237b8:	0f 85 58 ff ff ff    	jne    c0023716 <malloc+0x53>
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c00237be:	8d 98 0b 10 00 00    	lea    0x100b(%eax),%ebx
c00237c4:	c1 eb 0c             	shr    $0xc,%ebx
      a = palloc_get_multiple (0, page_cnt);
c00237c7:	83 ec 08             	sub    $0x8,%esp
c00237ca:	53                   	push   %ebx
c00237cb:	6a 00                	push   $0x0
c00237cd:	e8 e7 fa ff ff       	call   c00232b9 <palloc_get_multiple>
      if (a == NULL)
c00237d2:	83 c4 10             	add    $0x10,%esp
c00237d5:	85 c0                	test   %eax,%eax
c00237d7:	74 32                	je     c002380b <malloc+0x148>
      a->magic = ARENA_MAGIC;
c00237d9:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c00237df:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c00237e6:	89 58 08             	mov    %ebx,0x8(%eax)
      return a + 1;
c00237e9:	83 c0 0c             	add    $0xc,%eax
c00237ec:	eb bb                	jmp    c00237a9 <malloc+0xe6>
          lock_release (&d->lock);
c00237ee:	83 ec 0c             	sub    $0xc,%esp
c00237f1:	ff 74 24 18          	pushl  0x18(%esp)
c00237f5:	e8 15 f5 ff ff       	call   c0022d0f <lock_release>
          return NULL; 
c00237fa:	83 c4 10             	add    $0x10,%esp
c00237fd:	b8 00 00 00 00       	mov    $0x0,%eax
c0023802:	eb a5                	jmp    c00237a9 <malloc+0xe6>
    return NULL;
c0023804:	b8 00 00 00 00       	mov    $0x0,%eax
c0023809:	eb 9e                	jmp    c00237a9 <malloc+0xe6>
        return NULL;
c002380b:	b8 00 00 00 00       	mov    $0x0,%eax
c0023810:	eb 97                	jmp    c00237a9 <malloc+0xe6>
    if (d->block_size >= size)
c0023812:	bb a0 97 03 c0       	mov    $0xc00397a0,%ebx
c0023817:	e9 fa fe ff ff       	jmp    c0023716 <malloc+0x53>

c002381c <calloc>:
{
c002381c:	57                   	push   %edi
c002381d:	53                   	push   %ebx
c002381e:	83 ec 04             	sub    $0x4,%esp
c0023821:	8b 44 24 10          	mov    0x10(%esp),%eax
  size = a * b;
c0023825:	89 c3                	mov    %eax,%ebx
c0023827:	0f af 5c 24 14       	imul   0x14(%esp),%ebx
  if (size < a || size < b)
c002382c:	39 d8                	cmp    %ebx,%eax
c002382e:	77 28                	ja     c0023858 <calloc+0x3c>
c0023830:	39 5c 24 14          	cmp    %ebx,0x14(%esp)
c0023834:	77 29                	ja     c002385f <calloc+0x43>
  p = malloc (size);
c0023836:	83 ec 0c             	sub    $0xc,%esp
c0023839:	53                   	push   %ebx
c002383a:	e8 84 fe ff ff       	call   c00236c3 <malloc>
c002383f:	89 c2                	mov    %eax,%edx
  if (p != NULL)
c0023841:	83 c4 10             	add    $0x10,%esp
c0023844:	85 c0                	test   %eax,%eax
c0023846:	74 08                	je     c0023850 <calloc+0x34>
    memset (p, 0, size);
c0023848:	b0 00                	mov    $0x0,%al
c002384a:	89 d7                	mov    %edx,%edi
c002384c:	89 d9                	mov    %ebx,%ecx
c002384e:	f3 aa                	rep stos %al,%es:(%edi)
}
c0023850:	89 d0                	mov    %edx,%eax
c0023852:	83 c4 04             	add    $0x4,%esp
c0023855:	5b                   	pop    %ebx
c0023856:	5f                   	pop    %edi
c0023857:	c3                   	ret    
    return NULL;
c0023858:	ba 00 00 00 00       	mov    $0x0,%edx
c002385d:	eb f1                	jmp    c0023850 <calloc+0x34>
c002385f:	ba 00 00 00 00       	mov    $0x0,%edx
c0023864:	eb ea                	jmp    c0023850 <calloc+0x34>

c0023866 <free>:
{
c0023866:	55                   	push   %ebp
c0023867:	57                   	push   %edi
c0023868:	56                   	push   %esi
c0023869:	53                   	push   %ebx
c002386a:	83 ec 0c             	sub    $0xc,%esp
c002386d:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  if (p != NULL)
c0023871:	85 ed                	test   %ebp,%ebp
c0023873:	0f 84 86 00 00 00    	je     c00238ff <free+0x99>
      struct arena *a = block_to_arena (b);
c0023879:	89 e8                	mov    %ebp,%eax
c002387b:	e8 8e fc ff ff       	call   c002350e <block_to_arena>
c0023880:	89 c6                	mov    %eax,%esi
      struct desc *d = a->desc;
c0023882:	8b 58 04             	mov    0x4(%eax),%ebx
      if (d != NULL) 
c0023885:	85 db                	test   %ebx,%ebx
c0023887:	0f 84 9b 00 00 00    	je     c0023928 <free+0xc2>
          memset (b, 0xcc, d->block_size);
c002388d:	8b 0b                	mov    (%ebx),%ecx
c002388f:	b0 cc                	mov    $0xcc,%al
c0023891:	89 ef                	mov    %ebp,%edi
c0023893:	f3 aa                	rep stos %al,%es:(%edi)
          lock_acquire (&d->lock);
c0023895:	8d 7b 18             	lea    0x18(%ebx),%edi
c0023898:	83 ec 0c             	sub    $0xc,%esp
c002389b:	57                   	push   %edi
c002389c:	e8 d1 f2 ff ff       	call   c0022b72 <lock_acquire>
          list_push_front (&d->free_list, &b->free_elem);
c00238a1:	83 c4 08             	add    $0x8,%esp
c00238a4:	55                   	push   %ebp
c00238a5:	8d 43 08             	lea    0x8(%ebx),%eax
c00238a8:	50                   	push   %eax
c00238a9:	e8 35 4f 00 00       	call   c00287e3 <list_push_front>
          if (++a->free_cnt >= d->blocks_per_arena) 
c00238ae:	8b 46 08             	mov    0x8(%esi),%eax
c00238b1:	40                   	inc    %eax
c00238b2:	89 46 08             	mov    %eax,0x8(%esi)
c00238b5:	8b 53 04             	mov    0x4(%ebx),%edx
c00238b8:	83 c4 10             	add    $0x10,%esp
c00238bb:	39 d0                	cmp    %edx,%eax
c00238bd:	72 34                	jb     c00238f3 <free+0x8d>
              ASSERT (a->free_cnt == d->blocks_per_arena);
c00238bf:	39 d0                	cmp    %edx,%eax
c00238c1:	75 44                	jne    c0023907 <free+0xa1>
              for (i = 0; i < d->blocks_per_arena; i++) 
c00238c3:	bd 00 00 00 00       	mov    $0x0,%ebp
c00238c8:	85 c0                	test   %eax,%eax
c00238ca:	74 1b                	je     c00238e7 <free+0x81>
                  struct block *b = arena_to_block (a, i);
c00238cc:	89 ea                	mov    %ebp,%edx
c00238ce:	89 f0                	mov    %esi,%eax
c00238d0:	e8 b4 fb ff ff       	call   c0023489 <arena_to_block>
                  list_remove (&b->free_elem);
c00238d5:	83 ec 0c             	sub    $0xc,%esp
c00238d8:	50                   	push   %eax
c00238d9:	e8 3f 4f 00 00       	call   c002881d <list_remove>
              for (i = 0; i < d->blocks_per_arena; i++) 
c00238de:	45                   	inc    %ebp
c00238df:	83 c4 10             	add    $0x10,%esp
c00238e2:	39 6b 04             	cmp    %ebp,0x4(%ebx)
c00238e5:	77 e5                	ja     c00238cc <free+0x66>
              palloc_free_page (a);
c00238e7:	83 ec 0c             	sub    $0xc,%esp
c00238ea:	56                   	push   %esi
c00238eb:	e8 87 fb ff ff       	call   c0023477 <palloc_free_page>
c00238f0:	83 c4 10             	add    $0x10,%esp
          lock_release (&d->lock);
c00238f3:	83 ec 0c             	sub    $0xc,%esp
c00238f6:	57                   	push   %edi
c00238f7:	e8 13 f4 ff ff       	call   c0022d0f <lock_release>
c00238fc:	83 c4 10             	add    $0x10,%esp
}
c00238ff:	83 c4 0c             	add    $0xc,%esp
c0023902:	5b                   	pop    %ebx
c0023903:	5e                   	pop    %esi
c0023904:	5f                   	pop    %edi
c0023905:	5d                   	pop    %ebp
c0023906:	c3                   	ret    
              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023907:	83 ec 0c             	sub    $0xc,%esp
c002390a:	68 88 e4 02 c0       	push   $0xc002e488
c002390f:	68 3f d9 02 c0       	push   $0xc002d93f
c0023914:	68 b4 c4 02 c0       	push   $0xc002c4b4
c0023919:	68 f6 00 00 00       	push   $0xf6
c002391e:	68 99 e3 02 c0       	push   $0xc002e399
c0023923:	e8 e5 49 00 00       	call   c002830d <debug_panic>
          palloc_free_multiple (a, a->free_cnt);
c0023928:	83 ec 08             	sub    $0x8,%esp
c002392b:	ff 70 08             	pushl  0x8(%eax)
c002392e:	50                   	push   %eax
c002392f:	e8 2b fa ff ff       	call   c002335f <palloc_free_multiple>
          return;
c0023934:	83 c4 10             	add    $0x10,%esp
c0023937:	eb c6                	jmp    c00238ff <free+0x99>

c0023939 <realloc>:
{
c0023939:	55                   	push   %ebp
c002393a:	57                   	push   %edi
c002393b:	56                   	push   %esi
c002393c:	53                   	push   %ebx
c002393d:	83 ec 0c             	sub    $0xc,%esp
c0023940:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0023944:	8b 74 24 24          	mov    0x24(%esp),%esi
  if (new_size == 0) 
c0023948:	85 f6                	test   %esi,%esi
c002394a:	74 4a                	je     c0023996 <realloc+0x5d>
      void *new_block = malloc (new_size);
c002394c:	83 ec 0c             	sub    $0xc,%esp
c002394f:	56                   	push   %esi
c0023950:	e8 6e fd ff ff       	call   c00236c3 <malloc>
c0023955:	89 c5                	mov    %eax,%ebp
      if (old_block != NULL && new_block != NULL)
c0023957:	83 c4 10             	add    $0x10,%esp
c002395a:	85 db                	test   %ebx,%ebx
c002395c:	74 2e                	je     c002398c <realloc+0x53>
c002395e:	85 c0                	test   %eax,%eax
c0023960:	74 2a                	je     c002398c <realloc+0x53>
  struct arena *a = block_to_arena (b);
c0023962:	89 d8                	mov    %ebx,%eax
c0023964:	e8 a5 fb ff ff       	call   c002350e <block_to_arena>
  struct desc *d = a->desc;
c0023969:	8b 50 04             	mov    0x4(%eax),%edx
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c002396c:	85 d2                	test   %edx,%edx
c002396e:	74 39                	je     c00239a9 <realloc+0x70>
c0023970:	8b 02                	mov    (%edx),%eax
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023972:	89 f1                	mov    %esi,%ecx
c0023974:	39 c6                	cmp    %eax,%esi
c0023976:	76 02                	jbe    c002397a <realloc+0x41>
c0023978:	89 c1                	mov    %eax,%ecx
          memcpy (new_block, old_block, min_size);
c002397a:	89 ef                	mov    %ebp,%edi
c002397c:	89 de                	mov    %ebx,%esi
c002397e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
          free (old_block);
c0023980:	83 ec 0c             	sub    $0xc,%esp
c0023983:	53                   	push   %ebx
c0023984:	e8 dd fe ff ff       	call   c0023866 <free>
c0023989:	83 c4 10             	add    $0x10,%esp
}
c002398c:	89 e8                	mov    %ebp,%eax
c002398e:	83 c4 0c             	add    $0xc,%esp
c0023991:	5b                   	pop    %ebx
c0023992:	5e                   	pop    %esi
c0023993:	5f                   	pop    %edi
c0023994:	5d                   	pop    %ebp
c0023995:	c3                   	ret    
      free (old_block);
c0023996:	83 ec 0c             	sub    $0xc,%esp
c0023999:	53                   	push   %ebx
c002399a:	e8 c7 fe ff ff       	call   c0023866 <free>
      return NULL;
c002399f:	83 c4 10             	add    $0x10,%esp
c00239a2:	bd 00 00 00 00       	mov    $0x0,%ebp
c00239a7:	eb e3                	jmp    c002398c <realloc+0x53>
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c00239a9:	8b 40 08             	mov    0x8(%eax),%eax
c00239ac:	c1 e0 0c             	shl    $0xc,%eax
c00239af:	89 da                	mov    %ebx,%edx
c00239b1:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c00239b7:	29 d0                	sub    %edx,%eax
c00239b9:	eb b7                	jmp    c0023972 <realloc+0x39>

c00239bb <fixed32_init>:

#include "fixed_point.h"
const int FLOAT_POINT = 1 << 14;

struct fixed32 fixed32_init(int32_t x) {
c00239bb:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {x * FLOAT_POINT};
c00239bf:	8b 54 24 08          	mov    0x8(%esp),%edx
c00239c3:	c1 e2 0e             	shl    $0xe,%edx
c00239c6:	89 10                	mov    %edx,(%eax)
  return res;
}
c00239c8:	c2 04 00             	ret    $0x4

c00239cb <fixed32_trunc>:
  } else {
    printf("-%d.%03d", -num / 1000, -num % 1000);
  }
}

int32_t fixed32_trunc(struct fixed32 a) {
c00239cb:	8b 54 24 04          	mov    0x4(%esp),%edx
  return a.num / FLOAT_POINT;
c00239cf:	89 d0                	mov    %edx,%eax
c00239d1:	85 d2                	test   %edx,%edx
c00239d3:	78 04                	js     c00239d9 <fixed32_trunc+0xe>
c00239d5:	c1 f8 0e             	sar    $0xe,%eax
}
c00239d8:	c3                   	ret    
  return a.num / FLOAT_POINT;
c00239d9:	8d 82 ff 3f 00 00    	lea    0x3fff(%edx),%eax
c00239df:	eb f4                	jmp    c00239d5 <fixed32_trunc+0xa>

c00239e1 <fixed32_round>:

int32_t fixed32_round(struct fixed32 a) {
c00239e1:	8b 54 24 04          	mov    0x4(%esp),%edx
  /* int div round to zero */
  return (a.num + ((a.num >= 0) ? 1 : -1) * (FLOAT_POINT >> 1)) / FLOAT_POINT;
c00239e5:	89 d0                	mov    %edx,%eax
c00239e7:	c1 f8 1f             	sar    $0x1f,%eax
c00239ea:	25 00 c0 ff ff       	and    $0xffffc000,%eax
c00239ef:	8d 94 10 00 20 00 00 	lea    0x2000(%eax,%edx,1),%edx
c00239f6:	89 d0                	mov    %edx,%eax
c00239f8:	85 d2                	test   %edx,%edx
c00239fa:	78 04                	js     c0023a00 <fixed32_round+0x1f>
c00239fc:	c1 f8 0e             	sar    $0xe,%eax
}
c00239ff:	c3                   	ret    
  return (a.num + ((a.num >= 0) ? 1 : -1) * (FLOAT_POINT >> 1)) / FLOAT_POINT;
c0023a00:	8d 82 ff 3f 00 00    	lea    0x3fff(%edx),%eax
c0023a06:	eb f4                	jmp    c00239fc <fixed32_round+0x1b>

c0023a08 <fixed32_print>:
void fixed32_print(struct fixed32 a) {
c0023a08:	53                   	push   %ebx
c0023a09:	83 ec 08             	sub    $0x8,%esp
c0023a0c:	8b 44 24 10          	mov    0x10(%esp),%eax
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
  return res;
}

struct fixed32 fixed32_mul_int(struct fixed32 a, int32_t b) {
  struct fixed32 res = {a.num * b};
c0023a10:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023a13:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023a16:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023a19:	c1 e0 03             	shl    $0x3,%eax
  int num = fixed32_round(fixed32_mul_int(a, 1000));
c0023a1c:	50                   	push   %eax
c0023a1d:	e8 bf ff ff ff       	call   c00239e1 <fixed32_round>
c0023a22:	83 c4 04             	add    $0x4,%esp
c0023a25:	89 c1                	mov    %eax,%ecx
  if (num >= 0) {
c0023a27:	85 c0                	test   %eax,%eax
c0023a29:	78 30                	js     c0023a5b <fixed32_print+0x53>
    printf("%d.%03d", num / 1000, num % 1000);
c0023a2b:	83 ec 04             	sub    $0x4,%esp
c0023a2e:	bb e8 03 00 00       	mov    $0x3e8,%ebx
c0023a33:	99                   	cltd   
c0023a34:	f7 fb                	idiv   %ebx
c0023a36:	52                   	push   %edx
c0023a37:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c0023a3c:	f7 e9                	imul   %ecx
c0023a3e:	89 d0                	mov    %edx,%eax
c0023a40:	c1 f8 06             	sar    $0x6,%eax
c0023a43:	c1 f9 1f             	sar    $0x1f,%ecx
c0023a46:	29 c8                	sub    %ecx,%eax
c0023a48:	50                   	push   %eax
c0023a49:	68 ac e4 02 c0       	push   $0xc002e4ac
c0023a4e:	e8 0c 2e 00 00       	call   c002685f <printf>
c0023a53:	83 c4 10             	add    $0x10,%esp
}
c0023a56:	83 c4 08             	add    $0x8,%esp
c0023a59:	5b                   	pop    %ebx
c0023a5a:	c3                   	ret    
    printf("-%d.%03d", -num / 1000, -num % 1000);
c0023a5b:	f7 d9                	neg    %ecx
c0023a5d:	83 ec 04             	sub    $0x4,%esp
c0023a60:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c0023a65:	f7 e9                	imul   %ecx
c0023a67:	89 d0                	mov    %edx,%eax
c0023a69:	c1 f8 06             	sar    $0x6,%eax
c0023a6c:	89 ca                	mov    %ecx,%edx
c0023a6e:	c1 fa 1f             	sar    $0x1f,%edx
c0023a71:	29 d0                	sub    %edx,%eax
c0023a73:	8d 14 80             	lea    (%eax,%eax,4),%edx
c0023a76:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0023a79:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0023a7c:	c1 e2 03             	shl    $0x3,%edx
c0023a7f:	29 d1                	sub    %edx,%ecx
c0023a81:	51                   	push   %ecx
c0023a82:	50                   	push   %eax
c0023a83:	68 ab e4 02 c0       	push   $0xc002e4ab
c0023a88:	e8 d2 2d 00 00       	call   c002685f <printf>
c0023a8d:	83 c4 10             	add    $0x10,%esp
}
c0023a90:	eb c4                	jmp    c0023a56 <fixed32_print+0x4e>

c0023a92 <fixed32_add>:
struct fixed32 fixed32_add(struct fixed32 a, struct fixed32 b) {
c0023a92:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num + b.num};
c0023a96:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023a9a:	03 54 24 08          	add    0x8(%esp),%edx
c0023a9e:	89 10                	mov    %edx,(%eax)
}
c0023aa0:	c2 04 00             	ret    $0x4

c0023aa3 <fixed32_add_int>:
struct fixed32 fixed32_add_int(struct fixed32 a, int32_t b) {
c0023aa3:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num + b * FLOAT_POINT};
c0023aa7:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023aab:	c1 e2 0e             	shl    $0xe,%edx
c0023aae:	03 54 24 08          	add    0x8(%esp),%edx
c0023ab2:	89 10                	mov    %edx,(%eax)
}
c0023ab4:	c2 04 00             	ret    $0x4

c0023ab7 <fixed32_sub>:
struct fixed32 fixed32_sub(struct fixed32 a, struct fixed32 b) {
c0023ab7:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num - b.num};
c0023abb:	8b 54 24 08          	mov    0x8(%esp),%edx
c0023abf:	2b 54 24 0c          	sub    0xc(%esp),%edx
c0023ac3:	89 10                	mov    %edx,(%eax)
}
c0023ac5:	c2 04 00             	ret    $0x4

c0023ac8 <fixed32_sub_int>:
struct fixed32 fixed32_sub_int(struct fixed32 a, int32_t b) {
c0023ac8:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num - b * FLOAT_POINT};
c0023acc:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023ad0:	c1 e2 0e             	shl    $0xe,%edx
c0023ad3:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0023ad7:	29 d1                	sub    %edx,%ecx
c0023ad9:	89 08                	mov    %ecx,(%eax)
}
c0023adb:	c2 04 00             	ret    $0x4

c0023ade <fixed32_mul>:
struct fixed32 fixed32_mul(struct fixed32 a, struct fixed32 b) {
c0023ade:	55                   	push   %ebp
c0023adf:	57                   	push   %edi
c0023ae0:	56                   	push   %esi
c0023ae1:	53                   	push   %ebx
c0023ae2:	8b 54 24 18          	mov    0x18(%esp),%edx
c0023ae6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
c0023aea:	89 d3                	mov    %edx,%ebx
c0023aec:	c1 fb 1f             	sar    $0x1f,%ebx
c0023aef:	89 c7                	mov    %eax,%edi
c0023af1:	c1 ff 1f             	sar    $0x1f,%edi
c0023af4:	89 dd                	mov    %ebx,%ebp
c0023af6:	0f af e8             	imul   %eax,%ebp
c0023af9:	89 fe                	mov    %edi,%esi
c0023afb:	0f af f2             	imul   %edx,%esi
c0023afe:	01 ee                	add    %ebp,%esi
c0023b00:	f7 e2                	mul    %edx
c0023b02:	01 f2                	add    %esi,%edx
c0023b04:	89 c6                	mov    %eax,%esi
c0023b06:	89 d7                	mov    %edx,%edi
c0023b08:	85 d2                	test   %edx,%edx
c0023b0a:	78 11                	js     c0023b1d <fixed32_mul+0x3f>
c0023b0c:	0f ac fe 0e          	shrd   $0xe,%edi,%esi
c0023b10:	8b 44 24 14          	mov    0x14(%esp),%eax
c0023b14:	89 30                	mov    %esi,(%eax)
}
c0023b16:	5b                   	pop    %ebx
c0023b17:	5e                   	pop    %esi
c0023b18:	5f                   	pop    %edi
c0023b19:	5d                   	pop    %ebp
c0023b1a:	c2 04 00             	ret    $0x4
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
c0023b1d:	05 ff 3f 00 00       	add    $0x3fff,%eax
c0023b22:	83 d2 00             	adc    $0x0,%edx
c0023b25:	89 c6                	mov    %eax,%esi
c0023b27:	89 d7                	mov    %edx,%edi
c0023b29:	eb e1                	jmp    c0023b0c <fixed32_mul+0x2e>

c0023b2b <fixed32_mul_int>:
struct fixed32 fixed32_mul_int(struct fixed32 a, int32_t b) {
c0023b2b:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num * b};
c0023b2f:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023b33:	0f af 54 24 08       	imul   0x8(%esp),%edx
  return res;
c0023b38:	89 10                	mov    %edx,(%eax)
}
c0023b3a:	c2 04 00             	ret    $0x4

c0023b3d <fixed32_div>:

struct fixed32 fixed32_div(struct fixed32 a, struct fixed32 b) {
c0023b3d:	57                   	push   %edi
c0023b3e:	56                   	push   %esi
c0023b3f:	53                   	push   %ebx
c0023b40:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  struct fixed32 res = {(int64_t)a.num * FLOAT_POINT / b.num};
c0023b44:	8b 44 24 14          	mov    0x14(%esp),%eax
c0023b48:	99                   	cltd   
c0023b49:	0f a4 c2 0e          	shld   $0xe,%eax,%edx
c0023b4d:	c1 e0 0e             	shl    $0xe,%eax
c0023b50:	8b 74 24 18          	mov    0x18(%esp),%esi
c0023b54:	89 f7                	mov    %esi,%edi
c0023b56:	c1 ff 1f             	sar    $0x1f,%edi
c0023b59:	57                   	push   %edi
c0023b5a:	56                   	push   %esi
c0023b5b:	52                   	push   %edx
c0023b5c:	50                   	push   %eax
c0023b5d:	e8 c5 41 00 00       	call   c0027d27 <__divdi3>
c0023b62:	83 c4 10             	add    $0x10,%esp
c0023b65:	89 03                	mov    %eax,(%ebx)
  return res;
}
c0023b67:	89 d8                	mov    %ebx,%eax
c0023b69:	5b                   	pop    %ebx
c0023b6a:	5e                   	pop    %esi
c0023b6b:	5f                   	pop    %edi
c0023b6c:	c2 04 00             	ret    $0x4

c0023b6f <fixed32_div_int>:

struct fixed32 fixed32_div_int(struct fixed32 a, int32_t b) {
c0023b6f:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0023b73:	8b 44 24 08          	mov    0x8(%esp),%eax
  struct fixed32 res = {a.num / b};
c0023b77:	99                   	cltd   
c0023b78:	f7 7c 24 0c          	idivl  0xc(%esp)
  return res;
c0023b7c:	89 01                	mov    %eax,(%ecx)
}
c0023b7e:	89 c8                	mov    %ecx,%eax
c0023b80:	c2 04 00             	ret    $0x4

c0023b83 <fixed32_div_int_int>:

struct fixed32 fixed32_div_int_int(int32_t a, int32_t b) {
c0023b83:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  struct fixed32 res = {a * FLOAT_POINT / b};
c0023b87:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023b8b:	c1 e0 0e             	shl    $0xe,%eax
c0023b8e:	99                   	cltd   
c0023b8f:	f7 7c 24 0c          	idivl  0xc(%esp)
  return res;
c0023b93:	89 01                	mov    %eax,(%ecx)
}
c0023b95:	89 c8                	mov    %ecx,%eax
c0023b97:	c2 04 00             	ret    $0x4

c0023b9a <fixed32_less_than>:

bool fixed32_less_than(struct fixed32 a, struct fixed32 b) {
  return a.num < b.num;
c0023b9a:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023b9e:	39 44 24 04          	cmp    %eax,0x4(%esp)
c0023ba2:	0f 9c c0             	setl   %al
c0023ba5:	c3                   	ret    

c0023ba6 <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023ba6:	57                   	push   %edi
c0023ba7:	56                   	push   %esi
c0023ba8:	53                   	push   %ebx
c0023ba9:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023bad:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0023bb1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023bb5:	f7 c6 fd ff ff ff    	test   $0xfffffffd,%esi
c0023bbb:	74 1e                	je     c0023bdb <pit_configure_channel+0x35>
c0023bbd:	83 ec 0c             	sub    $0xc,%esp
c0023bc0:	68 b4 e4 02 c0       	push   $0xc002e4b4
c0023bc5:	68 3f d9 02 c0       	push   $0xc002d93f
c0023bca:	68 ec c4 02 c0       	push   $0xc002c4ec
c0023bcf:	6a 33                	push   $0x33
c0023bd1:	68 d1 e4 02 c0       	push   $0xc002e4d1
c0023bd6:	e8 32 47 00 00       	call   c002830d <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023bdb:	8d 43 fe             	lea    -0x2(%ebx),%eax
c0023bde:	83 f8 01             	cmp    $0x1,%eax
c0023be1:	77 22                	ja     c0023c05 <pit_configure_channel+0x5f>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023be3:	83 f9 12             	cmp    $0x12,%ecx
c0023be6:	7e 3b                	jle    c0023c23 <pit_configure_channel+0x7d>
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
    }
  else if (frequency > PIT_HZ)
c0023be8:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c0023bee:	7f 6b                	jg     c0023c5b <pit_configure_channel+0xb5>
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023bf0:	89 c8                	mov    %ecx,%eax
c0023bf2:	c1 e8 1f             	shr    $0x1f,%eax
c0023bf5:	01 c8                	add    %ecx,%eax
c0023bf7:	d1 f8                	sar    %eax
c0023bf9:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023bfe:	99                   	cltd   
c0023bff:	f7 f9                	idiv   %ecx
c0023c01:	89 c7                	mov    %eax,%edi
c0023c03:	eb 23                	jmp    c0023c28 <pit_configure_channel+0x82>
  ASSERT (mode == 2 || mode == 3);
c0023c05:	83 ec 0c             	sub    $0xc,%esp
c0023c08:	68 e5 e4 02 c0       	push   $0xc002e4e5
c0023c0d:	68 3f d9 02 c0       	push   $0xc002d93f
c0023c12:	68 ec c4 02 c0       	push   $0xc002c4ec
c0023c17:	6a 34                	push   $0x34
c0023c19:	68 d1 e4 02 c0       	push   $0xc002e4d1
c0023c1e:	e8 ea 46 00 00       	call   c002830d <debug_panic>
      count = 0;
c0023c23:	bf 00 00 00 00       	mov    $0x0,%edi

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023c28:	e8 c9 da ff ff       	call   c00216f6 <intr_disable>
c0023c2d:	89 c1                	mov    %eax,%ecx
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023c2f:	8d 04 1b             	lea    (%ebx,%ebx,1),%eax
c0023c32:	83 c8 30             	or     $0x30,%eax
c0023c35:	89 f3                	mov    %esi,%ebx
c0023c37:	c1 e3 06             	shl    $0x6,%ebx
c0023c3a:	09 d8                	or     %ebx,%eax
c0023c3c:	e6 43                	out    %al,$0x43
  outb (PIT_PORT_COUNTER (channel), count);
c0023c3e:	8d 56 40             	lea    0x40(%esi),%edx
c0023c41:	89 f8                	mov    %edi,%eax
c0023c43:	ee                   	out    %al,(%dx)
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023c44:	89 f8                	mov    %edi,%eax
c0023c46:	66 c1 e8 08          	shr    $0x8,%ax
c0023c4a:	ee                   	out    %al,(%dx)
  intr_set_level (old_level);
c0023c4b:	83 ec 0c             	sub    $0xc,%esp
c0023c4e:	51                   	push   %ecx
c0023c4f:	e8 a9 da ff ff       	call   c00216fd <intr_set_level>
}
c0023c54:	83 c4 10             	add    $0x10,%esp
c0023c57:	5b                   	pop    %ebx
c0023c58:	5e                   	pop    %esi
c0023c59:	5f                   	pop    %edi
c0023c5a:	c3                   	ret    
      count = 2;
c0023c5b:	bf 02 00 00 00       	mov    $0x2,%edi
c0023c60:	eb c6                	jmp    c0023c28 <pit_configure_channel+0x82>

c0023c62 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0023c62:	53                   	push   %ebx
  while (loops-- > 0)
c0023c63:	89 c1                	mov    %eax,%ecx
c0023c65:	89 d3                	mov    %edx,%ebx
c0023c67:	83 c1 ff             	add    $0xffffffff,%ecx
c0023c6a:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023c6d:	85 d2                	test   %edx,%edx
c0023c6f:	78 13                	js     c0023c84 <busy_wait+0x22>
c0023c71:	85 d2                	test   %edx,%edx
c0023c73:	7e 11                	jle    c0023c86 <busy_wait+0x24>
c0023c75:	83 c1 ff             	add    $0xffffffff,%ecx
c0023c78:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023c7b:	89 d8                	mov    %ebx,%eax
c0023c7d:	21 c8                	and    %ecx,%eax
c0023c7f:	83 f8 ff             	cmp    $0xffffffff,%eax
c0023c82:	75 f1                	jne    c0023c75 <busy_wait+0x13>
    barrier ();
}
c0023c84:	5b                   	pop    %ebx
c0023c85:	c3                   	ret    
  while (loops-- > 0)
c0023c86:	83 f8 00             	cmp    $0x0,%eax
c0023c89:	76 f9                	jbe    c0023c84 <busy_wait+0x22>
c0023c8b:	eb e8                	jmp    c0023c75 <busy_wait+0x13>

c0023c8d <too_many_loops>:
{
c0023c8d:	55                   	push   %ebp
c0023c8e:	57                   	push   %edi
c0023c8f:	56                   	push   %esi
c0023c90:	53                   	push   %ebx
c0023c91:	83 ec 04             	sub    $0x4,%esp
  int64_t start = ticks;
c0023c94:	8b 2d a0 9a 03 c0    	mov    0xc0039aa0,%ebp
c0023c9a:	8b 3d a4 9a 03 c0    	mov    0xc0039aa4,%edi
  while (ticks == start)
c0023ca0:	8b 35 a0 9a 03 c0    	mov    0xc0039aa0,%esi
c0023ca6:	8b 1d a4 9a 03 c0    	mov    0xc0039aa4,%ebx
c0023cac:	89 ea                	mov    %ebp,%edx
c0023cae:	31 f2                	xor    %esi,%edx
c0023cb0:	89 f9                	mov    %edi,%ecx
c0023cb2:	31 d9                	xor    %ebx,%ecx
c0023cb4:	09 d1                	or     %edx,%ecx
c0023cb6:	74 e8                	je     c0023ca0 <too_many_loops+0x13>
  busy_wait (loops);
c0023cb8:	ba 00 00 00 00       	mov    $0x0,%edx
c0023cbd:	e8 a0 ff ff ff       	call   c0023c62 <busy_wait>
  return start != ticks;
c0023cc2:	33 35 a0 9a 03 c0    	xor    0xc0039aa0,%esi
c0023cc8:	33 1d a4 9a 03 c0    	xor    0xc0039aa4,%ebx
c0023cce:	09 de                	or     %ebx,%esi
c0023cd0:	0f 95 c0             	setne  %al
}
c0023cd3:	83 c4 04             	add    $0x4,%esp
c0023cd6:	5b                   	pop    %ebx
c0023cd7:	5e                   	pop    %esi
c0023cd8:	5f                   	pop    %edi
c0023cd9:	5d                   	pop    %ebp
c0023cda:	c3                   	ret    

c0023cdb <timer_interrupt>:
{
c0023cdb:	83 ec 0c             	sub    $0xc,%esp
  ticks++;
c0023cde:	83 05 a0 9a 03 c0 01 	addl   $0x1,0xc0039aa0
c0023ce5:	83 15 a4 9a 03 c0 00 	adcl   $0x0,0xc0039aa4
  thread_tick ();
c0023cec:	e8 fb cd ff ff       	call   c0020aec <thread_tick>
  thread_tick_events(ticks % TIMER_FREQ == 0);
c0023cf1:	83 ec 10             	sub    $0x10,%esp
c0023cf4:	6a 00                	push   $0x0
c0023cf6:	6a 64                	push   $0x64
c0023cf8:	ff 35 a4 9a 03 c0    	pushl  0xc0039aa4
c0023cfe:	ff 35 a0 9a 03 c0    	pushl  0xc0039aa0
c0023d04:	e8 3a 40 00 00       	call   c0027d43 <__moddi3>
c0023d09:	83 c4 14             	add    $0x14,%esp
c0023d0c:	09 d0                	or     %edx,%eax
c0023d0e:	0f 94 c0             	sete   %al
c0023d11:	0f b6 c0             	movzbl %al,%eax
c0023d14:	50                   	push   %eax
c0023d15:	e8 08 d2 ff ff       	call   c0020f22 <thread_tick_events>
}
c0023d1a:	83 c4 1c             	add    $0x1c,%esp
c0023d1d:	c3                   	ret    

c0023d1e <real_time_delay>:
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0023d1e:	57                   	push   %edi
c0023d1f:	56                   	push   %esi
c0023d20:	53                   	push   %ebx
c0023d21:	89 c6                	mov    %eax,%esi
c0023d23:	89 d7                	mov    %edx,%edi
c0023d25:	89 cb                	mov    %ecx,%ebx
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c0023d27:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0023d2c:	89 d8                	mov    %ebx,%eax
c0023d2e:	99                   	cltd   
c0023d2f:	f7 f9                	idiv   %ecx
c0023d31:	85 d2                	test   %edx,%edx
c0023d33:	75 5c                	jne    c0023d91 <real_time_delay+0x73>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c0023d35:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0023d3a:	0f af f8             	imul   %eax,%edi
c0023d3d:	f7 e6                	mul    %esi
c0023d3f:	01 fa                	add    %edi,%edx
c0023d41:	6a 00                	push   $0x0
c0023d43:	68 e8 03 00 00       	push   $0x3e8
c0023d48:	52                   	push   %edx
c0023d49:	50                   	push   %eax
c0023d4a:	e8 d8 3f 00 00       	call   c0027d27 <__divdi3>
c0023d4f:	83 c4 10             	add    $0x10,%esp
c0023d52:	89 c6                	mov    %eax,%esi
c0023d54:	6b ca 64             	imul   $0x64,%edx,%ecx
c0023d57:	bf 64 00 00 00       	mov    $0x64,%edi
c0023d5c:	89 f8                	mov    %edi,%eax
c0023d5e:	f7 e6                	mul    %esi
c0023d60:	89 c6                	mov    %eax,%esi
c0023d62:	89 d7                	mov    %edx,%edi
c0023d64:	01 cf                	add    %ecx,%edi
c0023d66:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
c0023d6b:	89 c8                	mov    %ecx,%eax
c0023d6d:	f7 eb                	imul   %ebx
c0023d6f:	89 d1                	mov    %edx,%ecx
c0023d71:	89 c8                	mov    %ecx,%eax
c0023d73:	c1 f8 06             	sar    $0x6,%eax
c0023d76:	c1 fb 1f             	sar    $0x1f,%ebx
c0023d79:	29 d8                	sub    %ebx,%eax
c0023d7b:	99                   	cltd   
c0023d7c:	52                   	push   %edx
c0023d7d:	50                   	push   %eax
c0023d7e:	57                   	push   %edi
c0023d7f:	56                   	push   %esi
c0023d80:	e8 a2 3f 00 00       	call   c0027d27 <__divdi3>
c0023d85:	83 c4 10             	add    $0x10,%esp
c0023d88:	e8 d5 fe ff ff       	call   c0023c62 <busy_wait>
}
c0023d8d:	5b                   	pop    %ebx
c0023d8e:	5e                   	pop    %esi
c0023d8f:	5f                   	pop    %edi
c0023d90:	c3                   	ret    
  ASSERT (denom % 1000 == 0);
c0023d91:	83 ec 0c             	sub    $0xc,%esp
c0023d94:	68 fc e4 02 c0       	push   $0xc002e4fc
c0023d99:	68 3f d9 02 c0       	push   $0xc002d93f
c0023d9e:	68 04 c5 02 c0       	push   $0xc002c504
c0023da3:	68 f9 00 00 00       	push   $0xf9
c0023da8:	68 0e e5 02 c0       	push   $0xc002e50e
c0023dad:	e8 5b 45 00 00       	call   c002830d <debug_panic>

c0023db2 <timer_init>:
{
c0023db2:	83 ec 10             	sub    $0x10,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c0023db5:	6a 64                	push   $0x64
c0023db7:	6a 02                	push   $0x2
c0023db9:	6a 00                	push   $0x0
c0023dbb:	e8 e6 fd ff ff       	call   c0023ba6 <pit_configure_channel>
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0023dc0:	83 c4 0c             	add    $0xc,%esp
c0023dc3:	68 24 e5 02 c0       	push   $0xc002e524
c0023dc8:	68 db 3c 02 c0       	push   $0xc0023cdb
c0023dcd:	6a 20                	push   $0x20
c0023dcf:	e8 a3 da ff ff       	call   c0021877 <intr_register_ext>
}
c0023dd4:	83 c4 1c             	add    $0x1c,%esp
c0023dd7:	c3                   	ret    

c0023dd8 <timer_calibrate>:
{
c0023dd8:	57                   	push   %edi
c0023dd9:	56                   	push   %esi
c0023dda:	53                   	push   %ebx
  ASSERT (intr_get_level () == INTR_ON);
c0023ddb:	e8 d9 d8 ff ff       	call   c00216b9 <intr_get_level>
c0023de0:	83 f8 01             	cmp    $0x1,%eax
c0023de3:	75 56                	jne    c0023e3b <timer_calibrate+0x63>
  printf ("Calibrating timer...  ");
c0023de5:	83 ec 0c             	sub    $0xc,%esp
c0023de8:	68 4c e5 02 c0       	push   $0xc002e54c
c0023ded:	e8 6d 2a 00 00       	call   c002685f <printf>
  loops_per_tick = 1u << 10;
c0023df2:	c7 05 98 9a 03 c0 00 	movl   $0x400,0xc0039a98
c0023df9:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0023dfc:	83 c4 10             	add    $0x10,%esp
c0023dff:	8b 35 98 9a 03 c0    	mov    0xc0039a98,%esi
c0023e05:	8d 1c 36             	lea    (%esi,%esi,1),%ebx
c0023e08:	89 d8                	mov    %ebx,%eax
c0023e0a:	e8 7e fe ff ff       	call   c0023c8d <too_many_loops>
c0023e0f:	84 c0                	test   %al,%al
c0023e11:	75 46                	jne    c0023e59 <timer_calibrate+0x81>
      loops_per_tick <<= 1;
c0023e13:	89 1d 98 9a 03 c0    	mov    %ebx,0xc0039a98
      ASSERT (loops_per_tick != 0);
c0023e19:	85 db                	test   %ebx,%ebx
c0023e1b:	75 e2                	jne    c0023dff <timer_calibrate+0x27>
c0023e1d:	83 ec 0c             	sub    $0xc,%esp
c0023e20:	68 63 e5 02 c0       	push   $0xc002e563
c0023e25:	68 3f d9 02 c0       	push   $0xc002d93f
c0023e2a:	68 30 c5 02 c0       	push   $0xc002c530
c0023e2f:	6a 39                	push   $0x39
c0023e31:	68 0e e5 02 c0       	push   $0xc002e50e
c0023e36:	e8 d2 44 00 00       	call   c002830d <debug_panic>
  ASSERT (intr_get_level () == INTR_ON);
c0023e3b:	83 ec 0c             	sub    $0xc,%esp
c0023e3e:	68 2f e5 02 c0       	push   $0xc002e52f
c0023e43:	68 3f d9 02 c0       	push   $0xc002d93f
c0023e48:	68 30 c5 02 c0       	push   $0xc002c530
c0023e4d:	6a 30                	push   $0x30
c0023e4f:	68 0e e5 02 c0       	push   $0xc002e50e
c0023e54:	e8 b4 44 00 00       	call   c002830d <debug_panic>
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023e59:	89 f3                	mov    %esi,%ebx
c0023e5b:	d1 eb                	shr    %ebx
c0023e5d:	89 f7                	mov    %esi,%edi
c0023e5f:	c1 ef 0a             	shr    $0xa,%edi
c0023e62:	39 df                	cmp    %ebx,%edi
c0023e64:	75 27                	jne    c0023e8d <timer_calibrate+0xb5>
  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0023e66:	83 ec 04             	sub    $0x4,%esp
c0023e69:	b8 64 00 00 00       	mov    $0x64,%eax
c0023e6e:	f7 25 98 9a 03 c0    	mull   0xc0039a98
c0023e74:	52                   	push   %edx
c0023e75:	50                   	push   %eax
c0023e76:	68 77 e5 02 c0       	push   $0xc002e577
c0023e7b:	e8 df 29 00 00       	call   c002685f <printf>
}
c0023e80:	83 c4 10             	add    $0x10,%esp
c0023e83:	5b                   	pop    %ebx
c0023e84:	5e                   	pop    %esi
c0023e85:	5f                   	pop    %edi
c0023e86:	c3                   	ret    
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023e87:	d1 eb                	shr    %ebx
c0023e89:	39 df                	cmp    %ebx,%edi
c0023e8b:	74 d9                	je     c0023e66 <timer_calibrate+0x8e>
    if (!too_many_loops (high_bit | test_bit))
c0023e8d:	89 f0                	mov    %esi,%eax
c0023e8f:	09 d8                	or     %ebx,%eax
c0023e91:	e8 f7 fd ff ff       	call   c0023c8d <too_many_loops>
c0023e96:	84 c0                	test   %al,%al
c0023e98:	75 ed                	jne    c0023e87 <timer_calibrate+0xaf>
      loops_per_tick |= test_bit;
c0023e9a:	09 1d 98 9a 03 c0    	or     %ebx,0xc0039a98
c0023ea0:	eb e5                	jmp    c0023e87 <timer_calibrate+0xaf>

c0023ea2 <timer_ticks>:
{
c0023ea2:	57                   	push   %edi
c0023ea3:	56                   	push   %esi
c0023ea4:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level = intr_disable ();
c0023ea7:	e8 4a d8 ff ff       	call   c00216f6 <intr_disable>
  int64_t t = ticks;
c0023eac:	8b 35 a0 9a 03 c0    	mov    0xc0039aa0,%esi
c0023eb2:	8b 3d a4 9a 03 c0    	mov    0xc0039aa4,%edi
  intr_set_level (old_level);
c0023eb8:	83 ec 0c             	sub    $0xc,%esp
c0023ebb:	50                   	push   %eax
c0023ebc:	e8 3c d8 ff ff       	call   c00216fd <intr_set_level>
}
c0023ec1:	89 f0                	mov    %esi,%eax
c0023ec3:	89 fa                	mov    %edi,%edx
c0023ec5:	83 c4 14             	add    $0x14,%esp
c0023ec8:	5e                   	pop    %esi
c0023ec9:	5f                   	pop    %edi
c0023eca:	c3                   	ret    

c0023ecb <timer_elapsed>:
{
c0023ecb:	57                   	push   %edi
c0023ecc:	56                   	push   %esi
c0023ecd:	83 ec 04             	sub    $0x4,%esp
c0023ed0:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023ed4:	8b 7c 24 14          	mov    0x14(%esp),%edi
  return timer_ticks () - then;
c0023ed8:	e8 c5 ff ff ff       	call   c0023ea2 <timer_ticks>
c0023edd:	29 f0                	sub    %esi,%eax
c0023edf:	19 fa                	sbb    %edi,%edx
}
c0023ee1:	83 c4 04             	add    $0x4,%esp
c0023ee4:	5e                   	pop    %esi
c0023ee5:	5f                   	pop    %edi
c0023ee6:	c3                   	ret    

c0023ee7 <timer_sleep>:
{
c0023ee7:	56                   	push   %esi
c0023ee8:	53                   	push   %ebx
c0023ee9:	83 ec 04             	sub    $0x4,%esp
c0023eec:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023ef0:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (intr_get_level () == INTR_ON);  
c0023ef4:	e8 c0 d7 ff ff       	call   c00216b9 <intr_get_level>
c0023ef9:	83 f8 01             	cmp    $0x1,%eax
c0023efc:	75 2e                	jne    c0023f2c <timer_sleep+0x45>
  if (ticks <= 0) return;
c0023efe:	85 db                	test   %ebx,%ebx
c0023f00:	78 24                	js     c0023f26 <timer_sleep+0x3f>
c0023f02:	85 db                	test   %ebx,%ebx
c0023f04:	7e 44                	jle    c0023f4a <timer_sleep+0x63>
  struct thread *t = thread_current();
c0023f06:	e8 7b cb ff ff       	call   c0020a86 <thread_current>
  t->sleep_remain = ticks;
c0023f0b:	89 70 24             	mov    %esi,0x24(%eax)
  enum intr_level old_level = intr_disable();
c0023f0e:	e8 e3 d7 ff ff       	call   c00216f6 <intr_disable>
c0023f13:	89 c3                	mov    %eax,%ebx
  thread_block();
c0023f15:	e8 92 d2 ff ff       	call   c00211ac <thread_block>
  intr_set_level(old_level);
c0023f1a:	83 ec 0c             	sub    $0xc,%esp
c0023f1d:	53                   	push   %ebx
c0023f1e:	e8 da d7 ff ff       	call   c00216fd <intr_set_level>
c0023f23:	83 c4 10             	add    $0x10,%esp
}
c0023f26:	83 c4 04             	add    $0x4,%esp
c0023f29:	5b                   	pop    %ebx
c0023f2a:	5e                   	pop    %esi
c0023f2b:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);  
c0023f2c:	83 ec 0c             	sub    $0xc,%esp
c0023f2f:	68 2f e5 02 c0       	push   $0xc002e52f
c0023f34:	68 3f d9 02 c0       	push   $0xc002d93f
c0023f39:	68 24 c5 02 c0       	push   $0xc002c524
c0023f3e:	6a 5c                	push   $0x5c
c0023f40:	68 0e e5 02 c0       	push   $0xc002e50e
c0023f45:	e8 c3 43 00 00       	call   c002830d <debug_panic>
  if (ticks <= 0) return;
c0023f4a:	83 fe 00             	cmp    $0x0,%esi
c0023f4d:	76 d7                	jbe    c0023f26 <timer_sleep+0x3f>
c0023f4f:	eb b5                	jmp    c0023f06 <timer_sleep+0x1f>

c0023f51 <real_time_sleep>:
{
c0023f51:	55                   	push   %ebp
c0023f52:	57                   	push   %edi
c0023f53:	56                   	push   %esi
c0023f54:	53                   	push   %ebx
c0023f55:	83 ec 1c             	sub    $0x1c,%esp
c0023f58:	89 c6                	mov    %eax,%esi
c0023f5a:	89 44 24 08          	mov    %eax,0x8(%esp)
c0023f5e:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0023f62:	89 cd                	mov    %ecx,%ebp
  int64_t ticks = num * TIMER_FREQ / denom;
c0023f64:	6b fa 64             	imul   $0x64,%edx,%edi
c0023f67:	b9 64 00 00 00       	mov    $0x64,%ecx
c0023f6c:	89 c8                	mov    %ecx,%eax
c0023f6e:	f7 e6                	mul    %esi
c0023f70:	89 c1                	mov    %eax,%ecx
c0023f72:	89 d3                	mov    %edx,%ebx
c0023f74:	01 fb                	add    %edi,%ebx
c0023f76:	89 e8                	mov    %ebp,%eax
c0023f78:	99                   	cltd   
c0023f79:	52                   	push   %edx
c0023f7a:	55                   	push   %ebp
c0023f7b:	53                   	push   %ebx
c0023f7c:	51                   	push   %ecx
c0023f7d:	e8 a5 3d 00 00       	call   c0027d27 <__divdi3>
c0023f82:	83 c4 10             	add    $0x10,%esp
c0023f85:	89 c6                	mov    %eax,%esi
c0023f87:	89 d7                	mov    %edx,%edi
  ASSERT (intr_get_level () == INTR_ON);
c0023f89:	e8 2b d7 ff ff       	call   c00216b9 <intr_get_level>
c0023f8e:	83 f8 01             	cmp    $0x1,%eax
c0023f91:	75 1d                	jne    c0023fb0 <real_time_sleep+0x5f>
  if (ticks > 0)
c0023f93:	85 ff                	test   %edi,%edi
c0023f95:	78 3f                	js     c0023fd6 <real_time_sleep+0x85>
c0023f97:	85 ff                	test   %edi,%edi
c0023f99:	7e 36                	jle    c0023fd1 <real_time_sleep+0x80>
      timer_sleep (ticks); 
c0023f9b:	83 ec 08             	sub    $0x8,%esp
c0023f9e:	57                   	push   %edi
c0023f9f:	56                   	push   %esi
c0023fa0:	e8 42 ff ff ff       	call   c0023ee7 <timer_sleep>
c0023fa5:	83 c4 10             	add    $0x10,%esp
}
c0023fa8:	83 c4 1c             	add    $0x1c,%esp
c0023fab:	5b                   	pop    %ebx
c0023fac:	5e                   	pop    %esi
c0023fad:	5f                   	pop    %edi
c0023fae:	5d                   	pop    %ebp
c0023faf:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c0023fb0:	83 ec 0c             	sub    $0xc,%esp
c0023fb3:	68 2f e5 02 c0       	push   $0xc002e52f
c0023fb8:	68 3f d9 02 c0       	push   $0xc002d93f
c0023fbd:	68 14 c5 02 c0       	push   $0xc002c514
c0023fc2:	68 e3 00 00 00       	push   $0xe3
c0023fc7:	68 0e e5 02 c0       	push   $0xc002e50e
c0023fcc:	e8 3c 43 00 00       	call   c002830d <debug_panic>
  if (ticks > 0)
c0023fd1:	83 fe 00             	cmp    $0x0,%esi
c0023fd4:	77 c5                	ja     c0023f9b <real_time_sleep+0x4a>
      real_time_delay (num, denom); 
c0023fd6:	89 e9                	mov    %ebp,%ecx
c0023fd8:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023fdc:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023fe0:	e8 39 fd ff ff       	call   c0023d1e <real_time_delay>
}
c0023fe5:	eb c1                	jmp    c0023fa8 <real_time_sleep+0x57>

c0023fe7 <timer_msleep>:
{
c0023fe7:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ms, 1000);
c0023fea:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0023fef:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023ff3:	8b 54 24 14          	mov    0x14(%esp),%edx
c0023ff7:	e8 55 ff ff ff       	call   c0023f51 <real_time_sleep>
}
c0023ffc:	83 c4 0c             	add    $0xc,%esp
c0023fff:	c3                   	ret    

c0024000 <timer_usleep>:
{
c0024000:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (us, 1000 * 1000);
c0024003:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024008:	8b 44 24 10          	mov    0x10(%esp),%eax
c002400c:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024010:	e8 3c ff ff ff       	call   c0023f51 <real_time_sleep>
}
c0024015:	83 c4 0c             	add    $0xc,%esp
c0024018:	c3                   	ret    

c0024019 <timer_nsleep>:
{
c0024019:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ns, 1000 * 1000 * 1000);
c002401c:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024021:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024025:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024029:	e8 23 ff ff ff       	call   c0023f51 <real_time_sleep>
}
c002402e:	83 c4 0c             	add    $0xc,%esp
c0024031:	c3                   	ret    

c0024032 <timer_mdelay>:
{
c0024032:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ms, 1000);
c0024035:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c002403a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002403e:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024042:	e8 d7 fc ff ff       	call   c0023d1e <real_time_delay>
}
c0024047:	83 c4 0c             	add    $0xc,%esp
c002404a:	c3                   	ret    

c002404b <timer_udelay>:
{
c002404b:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (us, 1000 * 1000);
c002404e:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024053:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024057:	8b 54 24 14          	mov    0x14(%esp),%edx
c002405b:	e8 be fc ff ff       	call   c0023d1e <real_time_delay>
}
c0024060:	83 c4 0c             	add    $0xc,%esp
c0024063:	c3                   	ret    

c0024064 <timer_ndelay>:
{
c0024064:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ns, 1000 * 1000 * 1000);
c0024067:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c002406c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024070:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024074:	e8 a5 fc ff ff       	call   c0023d1e <real_time_delay>
}
c0024079:	83 c4 0c             	add    $0xc,%esp
c002407c:	c3                   	ret    

c002407d <timer_print_stats>:
{
c002407d:	83 ec 0c             	sub    $0xc,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0024080:	e8 1d fe ff ff       	call   c0023ea2 <timer_ticks>
c0024085:	83 ec 04             	sub    $0x4,%esp
c0024088:	52                   	push   %edx
c0024089:	50                   	push   %eax
c002408a:	68 87 e5 02 c0       	push   $0xc002e587
c002408f:	e8 cb 27 00 00       	call   c002685f <printf>
}
c0024094:	83 c4 1c             	add    $0x1c,%esp
c0024097:	c3                   	ret    

c0024098 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c0024098:	55                   	push   %ebp
c0024099:	57                   	push   %edi
c002409a:	56                   	push   %esi
c002409b:	53                   	push   %ebx
c002409c:	83 ec 08             	sub    $0x8,%esp
c002409f:	89 0c 24             	mov    %ecx,(%esp)
  for (; k->first_scancode != 0; k++)
c00240a2:	8a 18                	mov    (%eax),%bl
c00240a4:	84 db                	test   %bl,%bl
c00240a6:	74 49                	je     c00240f1 <map_key+0x59>
c00240a8:	89 c6                	mov    %eax,%esi
    if (scancode >= k->first_scancode
        && scancode < k->first_scancode + strlen (k->chars)) 
c00240aa:	b0 00                	mov    $0x0,%al
c00240ac:	eb 09                	jmp    c00240b7 <map_key+0x1f>
  for (; k->first_scancode != 0; k++)
c00240ae:	83 c6 08             	add    $0x8,%esi
c00240b1:	8a 1e                	mov    (%esi),%bl
c00240b3:	84 db                	test   %bl,%bl
c00240b5:	74 30                	je     c00240e7 <map_key+0x4f>
    if (scancode >= k->first_scancode
c00240b7:	0f b6 db             	movzbl %bl,%ebx
c00240ba:	39 d3                	cmp    %edx,%ebx
c00240bc:	77 f0                	ja     c00240ae <map_key+0x16>
        && scancode < k->first_scancode + strlen (k->chars)) 
c00240be:	8b 6e 04             	mov    0x4(%esi),%ebp
c00240c1:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00240c6:	89 ef                	mov    %ebp,%edi
c00240c8:	f2 ae                	repnz scas %es:(%edi),%al
c00240ca:	f7 d1                	not    %ecx
c00240cc:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c00240d0:	39 ca                	cmp    %ecx,%edx
c00240d2:	73 da                	jae    c00240ae <map_key+0x16>
      {
        *c = k->chars[scancode - k->first_scancode];
c00240d4:	29 da                	sub    %ebx,%edx
c00240d6:	8a 44 15 00          	mov    0x0(%ebp,%edx,1),%al
c00240da:	88 44 24 07          	mov    %al,0x7(%esp)
c00240de:	8b 3c 24             	mov    (%esp),%edi
c00240e1:	88 07                	mov    %al,(%edi)
        return true; 
c00240e3:	b0 01                	mov    $0x1,%al
c00240e5:	eb 02                	jmp    c00240e9 <map_key+0x51>
      }

  return false;
c00240e7:	b0 00                	mov    $0x0,%al
}
c00240e9:	83 c4 08             	add    $0x8,%esp
c00240ec:	5b                   	pop    %ebx
c00240ed:	5e                   	pop    %esi
c00240ee:	5f                   	pop    %edi
c00240ef:	5d                   	pop    %ebp
c00240f0:	c3                   	ret    
  return false;
c00240f1:	b0 00                	mov    $0x0,%al
c00240f3:	eb f4                	jmp    c00240e9 <map_key+0x51>

c00240f5 <keyboard_interrupt>:
{
c00240f5:	55                   	push   %ebp
c00240f6:	57                   	push   %edi
c00240f7:	56                   	push   %esi
c00240f8:	53                   	push   %ebx
c00240f9:	83 ec 2c             	sub    $0x2c,%esp
  bool shift = left_shift || right_shift;
c00240fc:	a0 b6 9a 03 c0       	mov    0xc0039ab6,%al
c0024101:	89 c7                	mov    %eax,%edi
c0024103:	84 c0                	test   %al,%al
c0024105:	75 07                	jne    c002410e <keyboard_interrupt+0x19>
c0024107:	a0 b5 9a 03 c0       	mov    0xc0039ab5,%al
c002410c:	89 c7                	mov    %eax,%edi
  bool alt = left_alt || right_alt;
c002410e:	a0 b4 9a 03 c0       	mov    0xc0039ab4,%al
c0024113:	89 c5                	mov    %eax,%ebp
c0024115:	84 c0                	test   %al,%al
c0024117:	75 07                	jne    c0024120 <keyboard_interrupt+0x2b>
c0024119:	a0 b3 9a 03 c0       	mov    0xc0039ab3,%al
c002411e:	89 c5                	mov    %eax,%ebp
  bool ctrl = left_ctrl || right_ctrl;
c0024120:	a0 b2 9a 03 c0       	mov    0xc0039ab2,%al
c0024125:	88 44 24 0f          	mov    %al,0xf(%esp)
c0024129:	84 c0                	test   %al,%al
c002412b:	75 09                	jne    c0024136 <keyboard_interrupt+0x41>
c002412d:	a0 b1 9a 03 c0       	mov    0xc0039ab1,%al
c0024132:	88 44 24 0f          	mov    %al,0xf(%esp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024136:	e4 60                	in     $0x60,%al
  code = inb (DATA_REG);
c0024138:	0f b6 d8             	movzbl %al,%ebx
  if (code == 0xe0)
c002413b:	81 fb e0 00 00 00    	cmp    $0xe0,%ebx
c0024141:	74 63                	je     c00241a6 <keyboard_interrupt+0xb1>
  release = (code & 0x80) != 0;
c0024143:	89 de                	mov    %ebx,%esi
c0024145:	81 e6 80 00 00 00    	and    $0x80,%esi
  code &= ~0x80u;
c002414b:	80 e3 7f             	and    $0x7f,%bl
  if (code == 0x3a) 
c002414e:	83 fb 3a             	cmp    $0x3a,%ebx
c0024151:	74 5d                	je     c00241b0 <keyboard_interrupt+0xbb>
  else if (map_key (invariant_keymap, code, &c)
c0024153:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024157:	89 da                	mov    %ebx,%edx
c0024159:	b8 00 c6 02 c0       	mov    $0xc002c600,%eax
c002415e:	e8 35 ff ff ff       	call   c0024098 <map_key>
c0024163:	84 c0                	test   %al,%al
c0024165:	75 70                	jne    c00241d7 <keyboard_interrupt+0xe2>
           || (!shift && map_key (unshifted_keymap, code, &c))
c0024167:	89 f8                	mov    %edi,%eax
c0024169:	84 c0                	test   %al,%al
c002416b:	74 56                	je     c00241c3 <keyboard_interrupt+0xce>
           || (shift && map_key (shifted_keymap, code, &c)))
c002416d:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024171:	89 da                	mov    %ebx,%edx
c0024173:	b8 80 c5 02 c0       	mov    $0xc002c580,%eax
c0024178:	e8 1b ff ff ff       	call   c0024098 <map_key>
c002417d:	84 c0                	test   %al,%al
c002417f:	75 56                	jne    c00241d7 <keyboard_interrupt+0xe2>
        if (key->scancode == code)
c0024181:	83 fb 2a             	cmp    $0x2a,%ebx
c0024184:	0f 84 e2 00 00 00    	je     c002426c <keyboard_interrupt+0x177>
c002418a:	b8 40 c5 02 c0       	mov    $0xc002c540,%eax
      for (key = shift_keys; key->scancode != 0; key++) 
c002418f:	83 c0 08             	add    $0x8,%eax
c0024192:	8b 10                	mov    (%eax),%edx
c0024194:	85 d2                	test   %edx,%edx
c0024196:	74 23                	je     c00241bb <keyboard_interrupt+0xc6>
        if (key->scancode == code)
c0024198:	39 d3                	cmp    %edx,%ebx
c002419a:	75 f3                	jne    c002418f <keyboard_interrupt+0x9a>
            *key->state_var = !release;
c002419c:	8b 40 04             	mov    0x4(%eax),%eax
c002419f:	85 f6                	test   %esi,%esi
c00241a1:	0f 94 00             	sete   (%eax)
            break;
c00241a4:	eb 15                	jmp    c00241bb <keyboard_interrupt+0xc6>
c00241a6:	e4 60                	in     $0x60,%al
    code = (code << 8) | inb (DATA_REG);
c00241a8:	0f b6 d8             	movzbl %al,%ebx
c00241ab:	80 cf e0             	or     $0xe0,%bh
c00241ae:	eb 93                	jmp    c0024143 <keyboard_interrupt+0x4e>
      if (!release)
c00241b0:	85 f6                	test   %esi,%esi
c00241b2:	75 07                	jne    c00241bb <keyboard_interrupt+0xc6>
        caps_lock = !caps_lock;
c00241b4:	80 35 b0 9a 03 c0 01 	xorb   $0x1,0xc0039ab0
}
c00241bb:	83 c4 2c             	add    $0x2c,%esp
c00241be:	5b                   	pop    %ebx
c00241bf:	5e                   	pop    %esi
c00241c0:	5f                   	pop    %edi
c00241c1:	5d                   	pop    %ebp
c00241c2:	c3                   	ret    
           || (!shift && map_key (unshifted_keymap, code, &c))
c00241c3:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00241c7:	89 da                	mov    %ebx,%edx
c00241c9:	b8 c0 c5 02 c0       	mov    $0xc002c5c0,%eax
c00241ce:	e8 c5 fe ff ff       	call   c0024098 <map_key>
c00241d3:	84 c0                	test   %al,%al
c00241d5:	74 aa                	je     c0024181 <keyboard_interrupt+0x8c>
      if (!release) 
c00241d7:	85 f6                	test   %esi,%esi
c00241d9:	75 e0                	jne    c00241bb <keyboard_interrupt+0xc6>
          if (c == 0177 && ctrl && alt)
c00241db:	8a 44 24 1f          	mov    0x1f(%esp),%al
c00241df:	3c 7f                	cmp    $0x7f,%al
c00241e1:	74 4e                	je     c0024231 <keyboard_interrupt+0x13c>
          if (ctrl && c >= 0x40 && c < 0x60) 
c00241e3:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00241e8:	74 08                	je     c00241f2 <keyboard_interrupt+0xfd>
c00241ea:	8d 50 c0             	lea    -0x40(%eax),%edx
c00241ed:	80 fa 1f             	cmp    $0x1f,%dl
c00241f0:	76 60                	jbe    c0024252 <keyboard_interrupt+0x15d>
          else if (shift == caps_lock)
c00241f2:	89 f9                	mov    %edi,%ecx
c00241f4:	38 0d b0 9a 03 c0    	cmp    %cl,0xc0039ab0
c00241fa:	74 5c                	je     c0024258 <keyboard_interrupt+0x163>
          if (alt)
c00241fc:	89 e8                	mov    %ebp,%eax
c00241fe:	84 c0                	test   %al,%al
c0024200:	74 05                	je     c0024207 <keyboard_interrupt+0x112>
            c += 0x80;
c0024202:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
          if (!input_full ())
c0024207:	e8 c3 18 00 00       	call   c0025acf <input_full>
c002420c:	84 c0                	test   %al,%al
c002420e:	75 ab                	jne    c00241bb <keyboard_interrupt+0xc6>
              key_cnt++;
c0024210:	83 05 a8 9a 03 c0 01 	addl   $0x1,0xc0039aa8
c0024217:	83 15 ac 9a 03 c0 00 	adcl   $0x0,0xc0039aac
              input_putc (c);
c002421e:	83 ec 0c             	sub    $0xc,%esp
c0024221:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c0024226:	50                   	push   %eax
c0024227:	e8 f7 17 00 00       	call   c0025a23 <input_putc>
c002422c:	83 c4 10             	add    $0x10,%esp
c002422f:	eb 8a                	jmp    c00241bb <keyboard_interrupt+0xc6>
          if (c == 0177 && ctrl && alt)
c0024231:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0024236:	74 06                	je     c002423e <keyboard_interrupt+0x149>
c0024238:	89 e9                	mov    %ebp,%ecx
c002423a:	84 c9                	test   %cl,%cl
c002423c:	75 0f                	jne    c002424d <keyboard_interrupt+0x158>
          else if (shift == caps_lock)
c002423e:	89 f9                	mov    %edi,%ecx
c0024240:	38 0d b0 9a 03 c0    	cmp    %cl,0xc0039ab0
c0024246:	75 b4                	jne    c00241fc <keyboard_interrupt+0x107>
            c = tolower (c);
c0024248:	0f b6 c0             	movzbl %al,%eax
c002424b:	eb 19                	jmp    c0024266 <keyboard_interrupt+0x171>
            shutdown_reboot ();
c002424d:	e8 64 1e 00 00       	call   c00260b6 <shutdown_reboot>
              c -= 0x40; 
c0024252:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c0024256:	eb a4                	jmp    c00241fc <keyboard_interrupt+0x107>
            c = tolower (c);
c0024258:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c002425b:	8d 50 bf             	lea    -0x41(%eax),%edx
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c002425e:	83 fa 19             	cmp    $0x19,%edx
c0024261:	77 03                	ja     c0024266 <keyboard_interrupt+0x171>
c0024263:	83 c0 20             	add    $0x20,%eax
c0024266:	88 44 24 1f          	mov    %al,0x1f(%esp)
c002426a:	eb 90                	jmp    c00241fc <keyboard_interrupt+0x107>
      for (key = shift_keys; key->scancode != 0; key++) 
c002426c:	b8 40 c5 02 c0       	mov    $0xc002c540,%eax
c0024271:	e9 26 ff ff ff       	jmp    c002419c <keyboard_interrupt+0xa7>

c0024276 <kbd_init>:
{
c0024276:	83 ec 10             	sub    $0x10,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c0024279:	68 9a e5 02 c0       	push   $0xc002e59a
c002427e:	68 f5 40 02 c0       	push   $0xc00240f5
c0024283:	6a 21                	push   $0x21
c0024285:	e8 ed d5 ff ff       	call   c0021877 <intr_register_ext>
}
c002428a:	83 c4 1c             	add    $0x1c,%esp
c002428d:	c3                   	ret    

c002428e <kbd_print_stats>:
{
c002428e:	83 ec 10             	sub    $0x10,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c0024291:	ff 35 ac 9a 03 c0    	pushl  0xc0039aac
c0024297:	ff 35 a8 9a 03 c0    	pushl  0xc0039aa8
c002429d:	68 a8 e5 02 c0       	push   $0xc002e5a8
c00242a2:	e8 b8 25 00 00       	call   c002685f <printf>
}
c00242a7:	83 c4 1c             	add    $0x1c,%esp
c00242aa:	c3                   	ret    

c00242ab <move_cursor>:
/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c00242ab:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c00242b0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c00242b7:	01 c1                	add    %eax,%ecx
c00242b9:	c1 e1 04             	shl    $0x4,%ecx
c00242bc:	03 0d c4 9a 03 c0    	add    0xc0039ac4,%ecx
  outw (0x3d4, 0x0e | (cp & 0xff00));
c00242c2:	89 c8                	mov    %ecx,%eax
c00242c4:	b0 00                	mov    $0x0,%al
c00242c6:	83 c8 0e             	or     $0xe,%eax
/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00242c9:	ba d4 03 00 00       	mov    $0x3d4,%edx
c00242ce:	66 ef                	out    %ax,(%dx)
  outw (0x3d4, 0x0f | (cp << 8));
c00242d0:	89 c8                	mov    %ecx,%eax
c00242d2:	c1 e0 08             	shl    $0x8,%eax
c00242d5:	83 c8 0f             	or     $0xf,%eax
c00242d8:	66 ef                	out    %ax,(%dx)
c00242da:	c3                   	ret    

c00242db <newline>:
  cx = 0;
c00242db:	c7 05 c4 9a 03 c0 00 	movl   $0x0,0xc0039ac4
c00242e2:	00 00 00 
  cy++;
c00242e5:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c00242ea:	40                   	inc    %eax
  if (cy >= ROW_CNT)
c00242eb:	83 f8 18             	cmp    $0x18,%eax
c00242ee:	77 06                	ja     c00242f6 <newline+0x1b>
  cy++;
c00242f0:	a3 c0 9a 03 c0       	mov    %eax,0xc0039ac0
c00242f5:	c3                   	ret    
{
c00242f6:	53                   	push   %ebx
c00242f7:	83 ec 0c             	sub    $0xc,%esp
      cy = ROW_CNT - 1;
c00242fa:	c7 05 c0 9a 03 c0 18 	movl   $0x18,0xc0039ac0
c0024301:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024304:	8b 1d bc 9a 03 c0    	mov    0xc0039abc,%ebx
c002430a:	68 00 0f 00 00       	push   $0xf00
c002430f:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0024315:	50                   	push   %eax
c0024316:	53                   	push   %ebx
c0024317:	e8 0c 33 00 00       	call   c0027628 <memmove>
c002431c:	8d 83 00 0f 00 00    	lea    0xf00(%ebx),%eax
c0024322:	8d 93 a0 0f 00 00    	lea    0xfa0(%ebx),%edx
c0024328:	83 c4 10             	add    $0x10,%esp
      fb[y][x][0] = ' ';
c002432b:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c002432e:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024332:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0024335:	39 d0                	cmp    %edx,%eax
c0024337:	75 f2                	jne    c002432b <newline+0x50>
}
c0024339:	83 c4 08             	add    $0x8,%esp
c002433c:	5b                   	pop    %ebx
c002433d:	c3                   	ret    

c002433e <vga_putc>:
{
c002433e:	56                   	push   %esi
c002433f:	53                   	push   %ebx
c0024340:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level = intr_disable ();
c0024343:	e8 ae d3 ff ff       	call   c00216f6 <intr_disable>
c0024348:	89 c3                	mov    %eax,%ebx
  if (!inited)
c002434a:	80 3d b8 9a 03 c0 00 	cmpb   $0x0,0xc0039ab8
c0024351:	74 17                	je     c002436a <vga_putc+0x2c>
  switch (c) 
c0024353:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024357:	83 e8 07             	sub    $0x7,%eax
c002435a:	83 f8 06             	cmp    $0x6,%eax
c002435d:	0f 87 23 01 00 00    	ja     c0024486 <vga_putc+0x148>
c0024363:	ff 24 85 50 c6 02 c0 	jmp    *-0x3ffd39b0(,%eax,4)
      fb = ptov (0xb8000);
c002436a:	c7 05 bc 9a 03 c0 00 	movl   $0xc00b8000,0xc0039abc
c0024371:	80 0b c0 
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024374:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0024379:	b0 0e                	mov    $0xe,%al
c002437b:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002437c:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c0024381:	89 ca                	mov    %ecx,%edx
c0024383:	ec                   	in     (%dx),%al
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
  cp = inb (0x3d5) << 8;
c0024384:	89 c6                	mov    %eax,%esi
c0024386:	c1 e6 08             	shl    $0x8,%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024389:	ba d4 03 00 00       	mov    $0x3d4,%edx
c002438e:	b0 0f                	mov    $0xf,%al
c0024390:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024391:	89 ca                	mov    %ecx,%edx
c0024393:	ec                   	in     (%dx),%al

  outb (0x3d4, 0x0f);
  cp |= inb (0x3d5);
c0024394:	0f b6 c0             	movzbl %al,%eax
c0024397:	09 f0                	or     %esi,%eax
c0024399:	89 c1                	mov    %eax,%ecx

  *x = cp % COL_CNT;
c002439b:	be 50 00 00 00       	mov    $0x50,%esi
c00243a0:	ba 00 00 00 00       	mov    $0x0,%edx
c00243a5:	66 f7 f6             	div    %si
c00243a8:	0f b7 d2             	movzwl %dx,%edx
c00243ab:	89 15 c4 9a 03 c0    	mov    %edx,0xc0039ac4
  *y = cp / COL_CNT;
c00243b1:	0f b7 c1             	movzwl %cx,%eax
c00243b4:	8d 14 80             	lea    (%eax,%eax,4),%edx
c00243b7:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00243ba:	01 d2                	add    %edx,%edx
c00243bc:	01 c2                	add    %eax,%edx
c00243be:	89 d1                	mov    %edx,%ecx
c00243c0:	c1 e1 08             	shl    $0x8,%ecx
c00243c3:	01 ca                	add    %ecx,%edx
c00243c5:	8d 04 90             	lea    (%eax,%edx,4),%eax
c00243c8:	c1 e8 16             	shr    $0x16,%eax
c00243cb:	a3 c0 9a 03 c0       	mov    %eax,0xc0039ac0
      inited = true; 
c00243d0:	c6 05 b8 9a 03 c0 01 	movb   $0x1,0xc0039ab8
c00243d7:	e9 77 ff ff ff       	jmp    c0024353 <vga_putc+0x15>
      fb[y][x][0] = ' ';
c00243dc:	a1 bc 9a 03 c0       	mov    0xc0039abc,%eax
c00243e1:	8d 88 a0 0f 00 00    	lea    0xfa0(%eax),%ecx
c00243e7:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00243ed:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c00243f0:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c00243f4:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c00243f7:	39 d0                	cmp    %edx,%eax
c00243f9:	75 f2                	jne    c00243ed <vga_putc+0xaf>
c00243fb:	89 d0                	mov    %edx,%eax
  for (y = 0; y < ROW_CNT; y++)
c00243fd:	39 d1                	cmp    %edx,%ecx
c00243ff:	75 e6                	jne    c00243e7 <vga_putc+0xa9>
  cx = cy = 0;
c0024401:	c7 05 c0 9a 03 c0 00 	movl   $0x0,0xc0039ac0
c0024408:	00 00 00 
c002440b:	c7 05 c4 9a 03 c0 00 	movl   $0x0,0xc0039ac4
c0024412:	00 00 00 
  move_cursor ();
c0024415:	e8 91 fe ff ff       	call   c00242ab <move_cursor>
c002441a:	eb 05                	jmp    c0024421 <vga_putc+0xe3>
      newline ();
c002441c:	e8 ba fe ff ff       	call   c00242db <newline>
  move_cursor ();
c0024421:	e8 85 fe ff ff       	call   c00242ab <move_cursor>
  intr_set_level (old_level);
c0024426:	83 ec 0c             	sub    $0xc,%esp
c0024429:	53                   	push   %ebx
c002442a:	e8 ce d2 ff ff       	call   c00216fd <intr_set_level>
}
c002442f:	83 c4 14             	add    $0x14,%esp
c0024432:	5b                   	pop    %ebx
c0024433:	5e                   	pop    %esi
c0024434:	c3                   	ret    
      if (cx > 0)
c0024435:	a1 c4 9a 03 c0       	mov    0xc0039ac4,%eax
c002443a:	85 c0                	test   %eax,%eax
c002443c:	74 e3                	je     c0024421 <vga_putc+0xe3>
        cx--;
c002443e:	48                   	dec    %eax
c002443f:	a3 c4 9a 03 c0       	mov    %eax,0xc0039ac4
c0024444:	eb db                	jmp    c0024421 <vga_putc+0xe3>
      cx = 0;
c0024446:	c7 05 c4 9a 03 c0 00 	movl   $0x0,0xc0039ac4
c002444d:	00 00 00 
      break;
c0024450:	eb cf                	jmp    c0024421 <vga_putc+0xe3>
      cx = ROUND_UP (cx + 1, 8);
c0024452:	a1 c4 9a 03 c0       	mov    0xc0039ac4,%eax
c0024457:	83 c0 08             	add    $0x8,%eax
c002445a:	83 e0 f8             	and    $0xfffffff8,%eax
c002445d:	a3 c4 9a 03 c0       	mov    %eax,0xc0039ac4
      if (cx >= COL_CNT)
c0024462:	83 f8 4f             	cmp    $0x4f,%eax
c0024465:	76 ba                	jbe    c0024421 <vga_putc+0xe3>
        newline ();
c0024467:	e8 6f fe ff ff       	call   c00242db <newline>
c002446c:	eb b3                	jmp    c0024421 <vga_putc+0xe3>
      intr_set_level (old_level);
c002446e:	83 ec 0c             	sub    $0xc,%esp
c0024471:	53                   	push   %ebx
c0024472:	e8 86 d2 ff ff       	call   c00216fd <intr_set_level>
      speaker_beep ();
c0024477:	e8 a9 1d 00 00       	call   c0026225 <speaker_beep>
      intr_disable ();
c002447c:	e8 75 d2 ff ff       	call   c00216f6 <intr_disable>
      break;
c0024481:	83 c4 10             	add    $0x10,%esp
c0024484:	eb 9b                	jmp    c0024421 <vga_putc+0xe3>
      fb[cy][cx][0] = c;
c0024486:	8b 35 bc 9a 03 c0    	mov    0xc0039abc,%esi
c002448c:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c0024491:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024494:	c1 e0 05             	shl    $0x5,%eax
c0024497:	01 f0                	add    %esi,%eax
c0024499:	8b 0d c4 9a 03 c0    	mov    0xc0039ac4,%ecx
c002449f:	8a 54 24 10          	mov    0x10(%esp),%dl
c00244a3:	88 14 48             	mov    %dl,(%eax,%ecx,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c00244a6:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c00244ab:	8d 04 80             	lea    (%eax,%eax,4),%eax
c00244ae:	c1 e0 05             	shl    $0x5,%eax
c00244b1:	8d 14 06             	lea    (%esi,%eax,1),%edx
c00244b4:	a1 c4 9a 03 c0       	mov    0xc0039ac4,%eax
c00244b9:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c00244be:	a1 c4 9a 03 c0       	mov    0xc0039ac4,%eax
c00244c3:	40                   	inc    %eax
c00244c4:	a3 c4 9a 03 c0       	mov    %eax,0xc0039ac4
c00244c9:	83 f8 4f             	cmp    $0x4f,%eax
c00244cc:	0f 86 4f ff ff ff    	jbe    c0024421 <vga_putc+0xe3>
        newline ();
c00244d2:	e8 04 fe ff ff       	call   c00242db <newline>
c00244d7:	e9 45 ff ff ff       	jmp    c0024421 <vga_putc+0xe3>

c00244dc <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c00244dc:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (mode == UNINIT);
c00244df:	83 3d 64 9b 03 c0 00 	cmpl   $0x0,0xc0039b64
c00244e6:	75 51                	jne    c0024539 <init_poll+0x5d>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00244e8:	ba f9 03 00 00       	mov    $0x3f9,%edx
c00244ed:	b0 00                	mov    $0x0,%al
c00244ef:	ee                   	out    %al,(%dx)
c00244f0:	ba fa 03 00 00       	mov    $0x3fa,%edx
c00244f5:	ee                   	out    %al,(%dx)
c00244f6:	ba fb 03 00 00       	mov    $0x3fb,%edx
c00244fb:	b0 83                	mov    $0x83,%al
c00244fd:	ee                   	out    %al,(%dx)
c00244fe:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024503:	b0 0c                	mov    $0xc,%al
c0024505:	ee                   	out    %al,(%dx)
c0024506:	ba f9 03 00 00       	mov    $0x3f9,%edx
c002450b:	b0 00                	mov    $0x0,%al
c002450d:	ee                   	out    %al,(%dx)
c002450e:	ba fb 03 00 00       	mov    $0x3fb,%edx
c0024513:	b0 03                	mov    $0x3,%al
c0024515:	ee                   	out    %al,(%dx)
c0024516:	ba fc 03 00 00       	mov    $0x3fc,%edx
c002451b:	b0 08                	mov    $0x8,%al
c002451d:	ee                   	out    %al,(%dx)
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
  outb (FCR_REG, 0);                    /* Disable FIFO. */
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
  intq_init (&txq);
c002451e:	83 ec 0c             	sub    $0xc,%esp
c0024521:	68 e0 9a 03 c0       	push   $0xc0039ae0
c0024526:	e8 6b 16 00 00       	call   c0025b96 <intq_init>
  mode = POLL;
c002452b:	c7 05 64 9b 03 c0 01 	movl   $0x1,0xc0039b64
c0024532:	00 00 00 
} 
c0024535:	83 c4 1c             	add    $0x1c,%esp
c0024538:	c3                   	ret    
  ASSERT (mode == UNINIT);
c0024539:	83 ec 0c             	sub    $0xc,%esp
c002453c:	68 1f e6 02 c0       	push   $0xc002e61f
c0024541:	68 3f d9 02 c0       	push   $0xc002d93f
c0024546:	68 94 c6 02 c0       	push   $0xc002c694
c002454b:	6a 45                	push   $0x45
c002454d:	68 2e e6 02 c0       	push   $0xc002e62e
c0024552:	e8 b6 3d 00 00       	call   c002830d <debug_panic>

c0024557 <write_ier>:
}

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024557:	53                   	push   %ebx
c0024558:	83 ec 08             	sub    $0x8,%esp
  uint8_t ier = 0;

  ASSERT (intr_get_level () == INTR_OFF);
c002455b:	e8 59 d1 ff ff       	call   c00216b9 <intr_get_level>
c0024560:	85 c0                	test   %eax,%eax
c0024562:	75 30                	jne    c0024594 <write_ier+0x3d>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024564:	83 ec 0c             	sub    $0xc,%esp
c0024567:	68 e0 9a 03 c0       	push   $0xc0039ae0
c002456c:	e8 57 16 00 00       	call   c0025bc8 <intq_empty>
c0024571:	83 c4 10             	add    $0x10,%esp
c0024574:	84 c0                	test   %al,%al
    ier |= IER_XMIT;
c0024576:	0f 94 c3             	sete   %bl
c0024579:	d1 e3                	shl    %ebx

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c002457b:	e8 4f 15 00 00       	call   c0025acf <input_full>
c0024580:	84 c0                	test   %al,%al
c0024582:	75 03                	jne    c0024587 <write_ier+0x30>
    ier |= IER_RECV;
c0024584:	83 cb 01             	or     $0x1,%ebx
c0024587:	ba f9 03 00 00       	mov    $0x3f9,%edx
c002458c:	88 d8                	mov    %bl,%al
c002458e:	ee                   	out    %al,(%dx)
  
  outb (IER_REG, ier);
}
c002458f:	83 c4 08             	add    $0x8,%esp
c0024592:	5b                   	pop    %ebx
c0024593:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024594:	83 ec 0c             	sub    $0xc,%esp
c0024597:	68 d2 dc 02 c0       	push   $0xc002dcd2
c002459c:	68 3f d9 02 c0       	push   $0xc002d93f
c00245a1:	68 88 c6 02 c0       	push   $0xc002c688
c00245a6:	68 b5 00 00 00       	push   $0xb5
c00245ab:	68 2e e6 02 c0       	push   $0xc002e62e
c00245b0:	e8 58 3d 00 00       	call   c002830d <debug_panic>

c00245b5 <serial_interrupt>:
}

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c00245b5:	56                   	push   %esi
c00245b6:	53                   	push   %ebx
c00245b7:	83 ec 04             	sub    $0x4,%esp
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00245ba:	ba fa 03 00 00       	mov    $0x3fa,%edx
c00245bf:	ec                   	in     (%dx),%al
c00245c0:	bb fd 03 00 00       	mov    $0x3fd,%ebx
c00245c5:	be f8 03 00 00       	mov    $0x3f8,%esi
c00245ca:	eb 12                	jmp    c00245de <serial_interrupt+0x29>
c00245cc:	89 f2                	mov    %esi,%edx
c00245ce:	ec                   	in     (%dx),%al
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));
c00245cf:	83 ec 0c             	sub    $0xc,%esp
c00245d2:	0f b6 c0             	movzbl %al,%eax
c00245d5:	50                   	push   %eax
c00245d6:	e8 48 14 00 00       	call   c0025a23 <input_putc>
c00245db:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c00245de:	e8 ec 14 00 00       	call   c0025acf <input_full>
c00245e3:	84 c0                	test   %al,%al
c00245e5:	75 07                	jne    c00245ee <serial_interrupt+0x39>
c00245e7:	89 da                	mov    %ebx,%edx
c00245e9:	ec                   	in     (%dx),%al
c00245ea:	a8 01                	test   $0x1,%al
c00245ec:	75 de                	jne    c00245cc <serial_interrupt+0x17>
c00245ee:	bb fd 03 00 00       	mov    $0x3fd,%ebx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00245f3:	be f8 03 00 00       	mov    $0x3f8,%esi
c00245f8:	eb 13                	jmp    c002460d <serial_interrupt+0x58>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
    outb (THR_REG, intq_getc (&txq));
c00245fa:	83 ec 0c             	sub    $0xc,%esp
c00245fd:	68 e0 9a 03 c0       	push   $0xc0039ae0
c0024602:	e8 a3 17 00 00       	call   c0025daa <intq_getc>
c0024607:	89 f2                	mov    %esi,%edx
c0024609:	ee                   	out    %al,(%dx)
c002460a:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c002460d:	83 ec 0c             	sub    $0xc,%esp
c0024610:	68 e0 9a 03 c0       	push   $0xc0039ae0
c0024615:	e8 ae 15 00 00       	call   c0025bc8 <intq_empty>
c002461a:	83 c4 10             	add    $0x10,%esp
c002461d:	84 c0                	test   %al,%al
c002461f:	75 07                	jne    c0024628 <serial_interrupt+0x73>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024621:	89 da                	mov    %ebx,%edx
c0024623:	ec                   	in     (%dx),%al
c0024624:	a8 20                	test   $0x20,%al
c0024626:	75 d2                	jne    c00245fa <serial_interrupt+0x45>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024628:	e8 2a ff ff ff       	call   c0024557 <write_ier>
}
c002462d:	83 c4 04             	add    $0x4,%esp
c0024630:	5b                   	pop    %ebx
c0024631:	5e                   	pop    %esi
c0024632:	c3                   	ret    

c0024633 <putc_poll>:
{
c0024633:	53                   	push   %ebx
c0024634:	83 ec 08             	sub    $0x8,%esp
c0024637:	89 c3                	mov    %eax,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0024639:	e8 7b d0 ff ff       	call   c00216b9 <intr_get_level>
c002463e:	85 c0                	test   %eax,%eax
c0024640:	75 17                	jne    c0024659 <putc_poll+0x26>
c0024642:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0024647:	ec                   	in     (%dx),%al
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024648:	a8 20                	test   $0x20,%al
c002464a:	74 fb                	je     c0024647 <putc_poll+0x14>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002464c:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024651:	88 d8                	mov    %bl,%al
c0024653:	ee                   	out    %al,(%dx)
}
c0024654:	83 c4 08             	add    $0x8,%esp
c0024657:	5b                   	pop    %ebx
c0024658:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024659:	83 ec 0c             	sub    $0xc,%esp
c002465c:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0024661:	68 3f d9 02 c0       	push   $0xc002d93f
c0024666:	68 7c c6 02 c0       	push   $0xc002c67c
c002466b:	68 c9 00 00 00       	push   $0xc9
c0024670:	68 2e e6 02 c0       	push   $0xc002e62e
c0024675:	e8 93 3c 00 00       	call   c002830d <debug_panic>

c002467a <serial_init_queue>:
{
c002467a:	53                   	push   %ebx
c002467b:	83 ec 08             	sub    $0x8,%esp
  if (mode == UNINIT)
c002467e:	83 3d 64 9b 03 c0 00 	cmpl   $0x0,0xc0039b64
c0024685:	74 40                	je     c00246c7 <serial_init_queue+0x4d>
  ASSERT (mode == POLL);
c0024687:	83 3d 64 9b 03 c0 01 	cmpl   $0x1,0xc0039b64
c002468e:	75 3e                	jne    c00246ce <serial_init_queue+0x54>
  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024690:	83 ec 04             	sub    $0x4,%esp
c0024693:	68 52 e6 02 c0       	push   $0xc002e652
c0024698:	68 b5 45 02 c0       	push   $0xc00245b5
c002469d:	6a 24                	push   $0x24
c002469f:	e8 d3 d1 ff ff       	call   c0021877 <intr_register_ext>
  mode = QUEUE;
c00246a4:	c7 05 64 9b 03 c0 02 	movl   $0x2,0xc0039b64
c00246ab:	00 00 00 
  old_level = intr_disable ();
c00246ae:	e8 43 d0 ff ff       	call   c00216f6 <intr_disable>
c00246b3:	89 c3                	mov    %eax,%ebx
  write_ier ();
c00246b5:	e8 9d fe ff ff       	call   c0024557 <write_ier>
  intr_set_level (old_level);
c00246ba:	89 1c 24             	mov    %ebx,(%esp)
c00246bd:	e8 3b d0 ff ff       	call   c00216fd <intr_set_level>
}
c00246c2:	83 c4 18             	add    $0x18,%esp
c00246c5:	5b                   	pop    %ebx
c00246c6:	c3                   	ret    
    init_poll ();
c00246c7:	e8 10 fe ff ff       	call   c00244dc <init_poll>
c00246cc:	eb b9                	jmp    c0024687 <serial_init_queue+0xd>
  ASSERT (mode == POLL);
c00246ce:	83 ec 0c             	sub    $0xc,%esp
c00246d1:	68 45 e6 02 c0       	push   $0xc002e645
c00246d6:	68 3f d9 02 c0       	push   $0xc002d93f
c00246db:	68 a0 c6 02 c0       	push   $0xc002c6a0
c00246e0:	6a 58                	push   $0x58
c00246e2:	68 2e e6 02 c0       	push   $0xc002e62e
c00246e7:	e8 21 3c 00 00       	call   c002830d <debug_panic>

c00246ec <serial_putc>:
{
c00246ec:	56                   	push   %esi
c00246ed:	53                   	push   %ebx
c00246ee:	83 ec 04             	sub    $0x4,%esp
c00246f1:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level = intr_disable ();
c00246f5:	e8 fc cf ff ff       	call   c00216f6 <intr_disable>
c00246fa:	89 c6                	mov    %eax,%esi
  if (mode != QUEUE)
c00246fc:	a1 64 9b 03 c0       	mov    0xc0039b64,%eax
c0024701:	83 f8 02             	cmp    $0x2,%eax
c0024704:	74 22                	je     c0024728 <serial_putc+0x3c>
      if (mode == UNINIT)
c0024706:	85 c0                	test   %eax,%eax
c0024708:	74 17                	je     c0024721 <serial_putc+0x35>
      putc_poll (byte); 
c002470a:	0f b6 c3             	movzbl %bl,%eax
c002470d:	e8 21 ff ff ff       	call   c0024633 <putc_poll>
  intr_set_level (old_level);
c0024712:	83 ec 0c             	sub    $0xc,%esp
c0024715:	56                   	push   %esi
c0024716:	e8 e2 cf ff ff       	call   c00216fd <intr_set_level>
}
c002471b:	83 c4 14             	add    $0x14,%esp
c002471e:	5b                   	pop    %ebx
c002471f:	5e                   	pop    %esi
c0024720:	c3                   	ret    
        init_poll ();
c0024721:	e8 b6 fd ff ff       	call   c00244dc <init_poll>
c0024726:	eb e2                	jmp    c002470a <serial_putc+0x1e>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024728:	85 f6                	test   %esi,%esi
c002472a:	74 1b                	je     c0024747 <serial_putc+0x5b>
      intq_putc (&txq, byte); 
c002472c:	83 ec 08             	sub    $0x8,%esp
c002472f:	0f b6 db             	movzbl %bl,%ebx
c0024732:	53                   	push   %ebx
c0024733:	68 e0 9a 03 c0       	push   $0xc0039ae0
c0024738:	e8 28 17 00 00       	call   c0025e65 <intq_putc>
      write_ier ();
c002473d:	e8 15 fe ff ff       	call   c0024557 <write_ier>
c0024742:	83 c4 10             	add    $0x10,%esp
c0024745:	eb cb                	jmp    c0024712 <serial_putc+0x26>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024747:	83 ec 0c             	sub    $0xc,%esp
c002474a:	68 e0 9a 03 c0       	push   $0xc0039ae0
c002474f:	e8 b4 14 00 00       	call   c0025c08 <intq_full>
c0024754:	83 c4 10             	add    $0x10,%esp
c0024757:	84 c0                	test   %al,%al
c0024759:	74 d1                	je     c002472c <serial_putc+0x40>
          putc_poll (intq_getc (&txq)); 
c002475b:	83 ec 0c             	sub    $0xc,%esp
c002475e:	68 e0 9a 03 c0       	push   $0xc0039ae0
c0024763:	e8 42 16 00 00       	call   c0025daa <intq_getc>
c0024768:	0f b6 c0             	movzbl %al,%eax
c002476b:	e8 c3 fe ff ff       	call   c0024633 <putc_poll>
c0024770:	83 c4 10             	add    $0x10,%esp
c0024773:	eb b7                	jmp    c002472c <serial_putc+0x40>

c0024775 <serial_flush>:
{
c0024775:	53                   	push   %ebx
c0024776:	83 ec 08             	sub    $0x8,%esp
  enum intr_level old_level = intr_disable ();
c0024779:	e8 78 cf ff ff       	call   c00216f6 <intr_disable>
c002477e:	89 c3                	mov    %eax,%ebx
  while (!intq_empty (&txq))
c0024780:	eb 18                	jmp    c002479a <serial_flush+0x25>
    putc_poll (intq_getc (&txq));
c0024782:	83 ec 0c             	sub    $0xc,%esp
c0024785:	68 e0 9a 03 c0       	push   $0xc0039ae0
c002478a:	e8 1b 16 00 00       	call   c0025daa <intq_getc>
c002478f:	0f b6 c0             	movzbl %al,%eax
c0024792:	e8 9c fe ff ff       	call   c0024633 <putc_poll>
c0024797:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c002479a:	83 ec 0c             	sub    $0xc,%esp
c002479d:	68 e0 9a 03 c0       	push   $0xc0039ae0
c00247a2:	e8 21 14 00 00       	call   c0025bc8 <intq_empty>
c00247a7:	83 c4 10             	add    $0x10,%esp
c00247aa:	84 c0                	test   %al,%al
c00247ac:	74 d4                	je     c0024782 <serial_flush+0xd>
  intr_set_level (old_level);
c00247ae:	83 ec 0c             	sub    $0xc,%esp
c00247b1:	53                   	push   %ebx
c00247b2:	e8 46 cf ff ff       	call   c00216fd <intr_set_level>
}
c00247b7:	83 c4 18             	add    $0x18,%esp
c00247ba:	5b                   	pop    %ebx
c00247bb:	c3                   	ret    

c00247bc <serial_notify>:
{
c00247bc:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00247bf:	e8 f5 ce ff ff       	call   c00216b9 <intr_get_level>
c00247c4:	85 c0                	test   %eax,%eax
c00247c6:	75 0d                	jne    c00247d5 <serial_notify+0x19>
  if (mode == QUEUE)
c00247c8:	83 3d 64 9b 03 c0 02 	cmpl   $0x2,0xc0039b64
c00247cf:	74 25                	je     c00247f6 <serial_notify+0x3a>
}
c00247d1:	83 c4 0c             	add    $0xc,%esp
c00247d4:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00247d5:	83 ec 0c             	sub    $0xc,%esp
c00247d8:	68 d2 dc 02 c0       	push   $0xc002dcd2
c00247dd:	68 3f d9 02 c0       	push   $0xc002d93f
c00247e2:	68 6c c6 02 c0       	push   $0xc002c66c
c00247e7:	68 96 00 00 00       	push   $0x96
c00247ec:	68 2e e6 02 c0       	push   $0xc002e62e
c00247f1:	e8 17 3b 00 00       	call   c002830d <debug_panic>
    write_ier ();
c00247f6:	e8 5c fd ff ff       	call   c0024557 <write_ier>
}
c00247fb:	eb d4                	jmp    c00247d1 <serial_notify+0x15>

c00247fd <check_sector>:
/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
  if (sector >= block->size)
c00247fd:	8b 48 1c             	mov    0x1c(%eax),%ecx
c0024800:	39 d1                	cmp    %edx,%ecx
c0024802:	76 01                	jbe    c0024805 <check_sector+0x8>
c0024804:	c3                   	ret    
{
c0024805:	83 ec 10             	sub    $0x10,%esp
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024808:	51                   	push   %ecx
c0024809:	52                   	push   %edx

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
  return block->name;
c002480a:	83 c0 08             	add    $0x8,%eax
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c002480d:	50                   	push   %eax
c002480e:	68 5c e6 02 c0       	push   $0xc002e65c
c0024813:	68 d0 c6 02 c0       	push   $0xc002c6d0
c0024818:	6a 70                	push   $0x70
c002481a:	68 ea e6 02 c0       	push   $0xc002e6ea
c002481f:	e8 e9 3a 00 00       	call   c002830d <debug_panic>

c0024824 <block_type_name>:
{
c0024824:	83 ec 0c             	sub    $0xc,%esp
c0024827:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (type < BLOCK_CNT);
c002482b:	83 f8 05             	cmp    $0x5,%eax
c002482e:	77 0b                	ja     c002483b <block_type_name+0x17>
  return block_type_names[type];
c0024830:	8b 04 85 00 c7 02 c0 	mov    -0x3ffd3900(,%eax,4),%eax
}
c0024837:	83 c4 0c             	add    $0xc,%esp
c002483a:	c3                   	ret    
  ASSERT (type < BLOCK_CNT);
c002483b:	83 ec 0c             	sub    $0xc,%esp
c002483e:	68 00 e7 02 c0       	push   $0xc002e700
c0024843:	68 3f d9 02 c0       	push   $0xc002d93f
c0024848:	68 18 c7 02 c0       	push   $0xc002c718
c002484d:	6a 2f                	push   $0x2f
c002484f:	68 ea e6 02 c0       	push   $0xc002e6ea
c0024854:	e8 b4 3a 00 00       	call   c002830d <debug_panic>

c0024859 <block_get_role>:
{
c0024859:	83 ec 0c             	sub    $0xc,%esp
c002485c:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0024860:	83 f8 03             	cmp    $0x3,%eax
c0024863:	77 0b                	ja     c0024870 <block_get_role+0x17>
  return block_by_role[role];
c0024865:	8b 04 85 68 9b 03 c0 	mov    -0x3ffc6498(,%eax,4),%eax
}
c002486c:	83 c4 0c             	add    $0xc,%esp
c002486f:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c0024870:	83 ec 0c             	sub    $0xc,%esp
c0024873:	68 11 e7 02 c0       	push   $0xc002e711
c0024878:	68 3f d9 02 c0       	push   $0xc002d93f
c002487d:	68 f0 c6 02 c0       	push   $0xc002c6f0
c0024882:	6a 38                	push   $0x38
c0024884:	68 ea e6 02 c0       	push   $0xc002e6ea
c0024889:	e8 7f 3a 00 00       	call   c002830d <debug_panic>

c002488e <block_set_role>:
{
c002488e:	83 ec 0c             	sub    $0xc,%esp
c0024891:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0024895:	83 f8 03             	cmp    $0x3,%eax
c0024898:	77 0f                	ja     c00248a9 <block_set_role+0x1b>
  block_by_role[role] = block;
c002489a:	8b 54 24 14          	mov    0x14(%esp),%edx
c002489e:	89 14 85 68 9b 03 c0 	mov    %edx,-0x3ffc6498(,%eax,4)
}
c00248a5:	83 c4 0c             	add    $0xc,%esp
c00248a8:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c00248a9:	83 ec 0c             	sub    $0xc,%esp
c00248ac:	68 11 e7 02 c0       	push   $0xc002e711
c00248b1:	68 3f d9 02 c0       	push   $0xc002d93f
c00248b6:	68 e0 c6 02 c0       	push   $0xc002c6e0
c00248bb:	6a 40                	push   $0x40
c00248bd:	68 ea e6 02 c0       	push   $0xc002e6ea
c00248c2:	e8 46 3a 00 00       	call   c002830d <debug_panic>

c00248c7 <block_first>:
{
c00248c7:	53                   	push   %ebx
c00248c8:	83 ec 14             	sub    $0x14,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c00248cb:	68 78 80 03 c0       	push   $0xc0038078
c00248d0:	e8 22 3b 00 00       	call   c00283f7 <list_begin>
c00248d5:	89 c3                	mov    %eax,%ebx
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c00248d7:	c7 04 24 78 80 03 c0 	movl   $0xc0038078,(%esp)
c00248de:	e8 8c 3b 00 00       	call   c002846f <list_end>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c00248e3:	83 c4 10             	add    $0x10,%esp
c00248e6:	39 c3                	cmp    %eax,%ebx
c00248e8:	74 07                	je     c00248f1 <block_first+0x2a>
c00248ea:	89 d8                	mov    %ebx,%eax
}
c00248ec:	83 c4 08             	add    $0x8,%esp
c00248ef:	5b                   	pop    %ebx
c00248f0:	c3                   	ret    
          : NULL);
c00248f1:	b8 00 00 00 00       	mov    $0x0,%eax
  return list_elem_to_block (list_begin (&all_blocks));
c00248f6:	eb f4                	jmp    c00248ec <block_first+0x25>

c00248f8 <block_next>:
{
c00248f8:	53                   	push   %ebx
c00248f9:	83 ec 14             	sub    $0x14,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c00248fc:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024900:	e8 22 3b 00 00       	call   c0028427 <list_next>
c0024905:	89 c3                	mov    %eax,%ebx
  return (list_elem != list_end (&all_blocks)
c0024907:	c7 04 24 78 80 03 c0 	movl   $0xc0038078,(%esp)
c002490e:	e8 5c 3b 00 00       	call   c002846f <list_end>
          : NULL);
c0024913:	83 c4 10             	add    $0x10,%esp
c0024916:	39 c3                	cmp    %eax,%ebx
c0024918:	74 07                	je     c0024921 <block_next+0x29>
c002491a:	89 d8                	mov    %ebx,%eax
}
c002491c:	83 c4 08             	add    $0x8,%esp
c002491f:	5b                   	pop    %ebx
c0024920:	c3                   	ret    
          : NULL);
c0024921:	b8 00 00 00 00       	mov    $0x0,%eax
  return list_elem_to_block (list_next (&block->list_elem));
c0024926:	eb f4                	jmp    c002491c <block_next+0x24>

c0024928 <block_get_by_name>:
{
c0024928:	56                   	push   %esi
c0024929:	53                   	push   %ebx
c002492a:	83 ec 10             	sub    $0x10,%esp
c002492d:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024931:	68 78 80 03 c0       	push   $0xc0038078
c0024936:	e8 bc 3a 00 00       	call   c00283f7 <list_begin>
c002493b:	89 c3                	mov    %eax,%ebx
c002493d:	83 c4 10             	add    $0x10,%esp
c0024940:	83 ec 0c             	sub    $0xc,%esp
c0024943:	68 78 80 03 c0       	push   $0xc0038078
c0024948:	e8 22 3b 00 00       	call   c002846f <list_end>
c002494d:	83 c4 10             	add    $0x10,%esp
c0024950:	39 c3                	cmp    %eax,%ebx
c0024952:	74 24                	je     c0024978 <block_get_by_name+0x50>
      if (!strcmp (name, block->name))
c0024954:	8d 43 08             	lea    0x8(%ebx),%eax
c0024957:	83 ec 08             	sub    $0x8,%esp
c002495a:	50                   	push   %eax
c002495b:	56                   	push   %esi
c002495c:	e8 61 2d 00 00       	call   c00276c2 <strcmp>
c0024961:	83 c4 10             	add    $0x10,%esp
c0024964:	85 c0                	test   %eax,%eax
c0024966:	74 1b                	je     c0024983 <block_get_by_name+0x5b>
       e = list_next (e))
c0024968:	83 ec 0c             	sub    $0xc,%esp
c002496b:	53                   	push   %ebx
c002496c:	e8 b6 3a 00 00       	call   c0028427 <list_next>
c0024971:	89 c3                	mov    %eax,%ebx
c0024973:	83 c4 10             	add    $0x10,%esp
c0024976:	eb c8                	jmp    c0024940 <block_get_by_name+0x18>
  return NULL;
c0024978:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002497d:	83 c4 04             	add    $0x4,%esp
c0024980:	5b                   	pop    %ebx
c0024981:	5e                   	pop    %esi
c0024982:	c3                   	ret    
c0024983:	89 d8                	mov    %ebx,%eax
c0024985:	eb f6                	jmp    c002497d <block_get_by_name+0x55>

c0024987 <block_read>:
{
c0024987:	56                   	push   %esi
c0024988:	53                   	push   %ebx
c0024989:	83 ec 04             	sub    $0x4,%esp
c002498c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0024990:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c0024994:	89 f2                	mov    %esi,%edx
c0024996:	89 d8                	mov    %ebx,%eax
c0024998:	e8 60 fe ff ff       	call   c00247fd <check_sector>
  block->ops->read (block->aux, sector, buffer);
c002499d:	83 ec 04             	sub    $0x4,%esp
c00249a0:	8b 43 20             	mov    0x20(%ebx),%eax
c00249a3:	ff 74 24 1c          	pushl  0x1c(%esp)
c00249a7:	56                   	push   %esi
c00249a8:	ff 73 24             	pushl  0x24(%ebx)
c00249ab:	ff 10                	call   *(%eax)
  block->read_cnt++;
c00249ad:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c00249b1:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c00249b5:	83 c4 14             	add    $0x14,%esp
c00249b8:	5b                   	pop    %ebx
c00249b9:	5e                   	pop    %esi
c00249ba:	c3                   	ret    

c00249bb <block_write>:
{
c00249bb:	56                   	push   %esi
c00249bc:	53                   	push   %ebx
c00249bd:	83 ec 04             	sub    $0x4,%esp
c00249c0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00249c4:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c00249c8:	89 f2                	mov    %esi,%edx
c00249ca:	89 d8                	mov    %ebx,%eax
c00249cc:	e8 2c fe ff ff       	call   c00247fd <check_sector>
  ASSERT (block->type != BLOCK_FOREIGN);
c00249d1:	83 7b 18 05          	cmpl   $0x5,0x18(%ebx)
c00249d5:	74 1f                	je     c00249f6 <block_write+0x3b>
  block->ops->write (block->aux, sector, buffer);
c00249d7:	83 ec 04             	sub    $0x4,%esp
c00249da:	8b 43 20             	mov    0x20(%ebx),%eax
c00249dd:	ff 74 24 1c          	pushl  0x1c(%esp)
c00249e1:	56                   	push   %esi
c00249e2:	ff 73 24             	pushl  0x24(%ebx)
c00249e5:	ff 50 04             	call   *0x4(%eax)
  block->write_cnt++;
c00249e8:	83 43 30 01          	addl   $0x1,0x30(%ebx)
c00249ec:	83 53 34 00          	adcl   $0x0,0x34(%ebx)
}
c00249f0:	83 c4 14             	add    $0x14,%esp
c00249f3:	5b                   	pop    %ebx
c00249f4:	5e                   	pop    %esi
c00249f5:	c3                   	ret    
  ASSERT (block->type != BLOCK_FOREIGN);
c00249f6:	83 ec 0c             	sub    $0xc,%esp
c00249f9:	68 27 e7 02 c0       	push   $0xc002e727
c00249fe:	68 3f d9 02 c0       	push   $0xc002d93f
c0024a03:	68 c4 c6 02 c0       	push   $0xc002c6c4
c0024a08:	68 89 00 00 00       	push   $0x89
c0024a0d:	68 ea e6 02 c0       	push   $0xc002e6ea
c0024a12:	e8 f6 38 00 00       	call   c002830d <debug_panic>

c0024a17 <block_size>:
  return block->size;
c0024a17:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024a1b:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0024a1e:	c3                   	ret    

c0024a1f <block_name>:
  return block->name;
c0024a1f:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024a23:	83 c0 08             	add    $0x8,%eax
}
c0024a26:	c3                   	ret    

c0024a27 <block_type>:
  return block->type;
c0024a27:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024a2b:	8b 40 18             	mov    0x18(%eax),%eax
}
c0024a2e:	c3                   	ret    

c0024a2f <block_print_stats>:
{
c0024a2f:	57                   	push   %edi
c0024a30:	56                   	push   %esi
c0024a31:	53                   	push   %ebx
c0024a32:	be 68 9b 03 c0       	mov    $0xc0039b68,%esi
c0024a37:	bf 78 9b 03 c0       	mov    $0xc0039b78,%edi
c0024a3c:	eb 07                	jmp    c0024a45 <block_print_stats+0x16>
c0024a3e:	83 c6 04             	add    $0x4,%esi
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0024a41:	39 fe                	cmp    %edi,%esi
c0024a43:	74 34                	je     c0024a79 <block_print_stats+0x4a>
      struct block *block = block_by_role[i];
c0024a45:	8b 1e                	mov    (%esi),%ebx
      if (block != NULL)
c0024a47:	85 db                	test   %ebx,%ebx
c0024a49:	74 f3                	je     c0024a3e <block_print_stats+0xf>
          printf ("%s (%s): %llu reads, %llu writes\n",
c0024a4b:	83 ec 0c             	sub    $0xc,%esp
c0024a4e:	ff 73 18             	pushl  0x18(%ebx)
c0024a51:	e8 ce fd ff ff       	call   c0024824 <block_type_name>
c0024a56:	83 c4 0c             	add    $0xc,%esp
c0024a59:	ff 73 34             	pushl  0x34(%ebx)
c0024a5c:	ff 73 30             	pushl  0x30(%ebx)
c0024a5f:	ff 73 2c             	pushl  0x2c(%ebx)
c0024a62:	ff 73 28             	pushl  0x28(%ebx)
c0024a65:	50                   	push   %eax
c0024a66:	83 c3 08             	add    $0x8,%ebx
c0024a69:	53                   	push   %ebx
c0024a6a:	68 90 e6 02 c0       	push   $0xc002e690
c0024a6f:	e8 eb 1d 00 00       	call   c002685f <printf>
c0024a74:	83 c4 20             	add    $0x20,%esp
c0024a77:	eb c5                	jmp    c0024a3e <block_print_stats+0xf>
}
c0024a79:	5b                   	pop    %ebx
c0024a7a:	5e                   	pop    %esi
c0024a7b:	5f                   	pop    %edi
c0024a7c:	c3                   	ret    

c0024a7d <block_register>:
{
c0024a7d:	55                   	push   %ebp
c0024a7e:	57                   	push   %edi
c0024a7f:	56                   	push   %esi
c0024a80:	53                   	push   %ebx
c0024a81:	83 ec 18             	sub    $0x18,%esp
c0024a84:	8b 74 24 34          	mov    0x34(%esp),%esi
c0024a88:	8b 7c 24 38          	mov    0x38(%esp),%edi
  struct block *block = malloc (sizeof *block);
c0024a8c:	6a 38                	push   $0x38
c0024a8e:	e8 30 ec ff ff       	call   c00236c3 <malloc>
  if (block == NULL)
c0024a93:	83 c4 10             	add    $0x10,%esp
c0024a96:	85 c0                	test   %eax,%eax
c0024a98:	0f 84 b6 00 00 00    	je     c0024b54 <block_register+0xd7>
c0024a9e:	89 c3                	mov    %eax,%ebx
  list_push_back (&all_blocks, &block->list_elem);
c0024aa0:	83 ec 08             	sub    $0x8,%esp
c0024aa3:	50                   	push   %eax
c0024aa4:	68 78 80 03 c0       	push   $0xc0038078
c0024aa9:	e8 52 3d 00 00       	call   c0028800 <list_push_back>
  strlcpy (block->name, name, sizeof block->name);
c0024aae:	8d 6b 08             	lea    0x8(%ebx),%ebp
c0024ab1:	83 c4 0c             	add    $0xc,%esp
c0024ab4:	6a 10                	push   $0x10
c0024ab6:	ff 74 24 28          	pushl  0x28(%esp)
c0024aba:	55                   	push   %ebp
c0024abb:	e8 47 2f 00 00       	call   c0027a07 <strlcpy>
  block->type = type;
c0024ac0:	8b 44 24 34          	mov    0x34(%esp),%eax
c0024ac4:	89 43 18             	mov    %eax,0x18(%ebx)
  block->size = size;
c0024ac7:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  block->ops = ops;
c0024aca:	8b 44 24 40          	mov    0x40(%esp),%eax
c0024ace:	89 43 20             	mov    %eax,0x20(%ebx)
  block->aux = aux;
c0024ad1:	8b 44 24 44          	mov    0x44(%esp),%eax
c0024ad5:	89 43 24             	mov    %eax,0x24(%ebx)
  block->read_cnt = 0;
c0024ad8:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
c0024adf:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  block->write_cnt = 0;
c0024ae6:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
c0024aed:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c0024af4:	83 c4 0c             	add    $0xc,%esp
c0024af7:	57                   	push   %edi
c0024af8:	55                   	push   %ebp
c0024af9:	68 44 e7 02 c0       	push   $0xc002e744
c0024afe:	e8 5c 1d 00 00       	call   c002685f <printf>
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c0024b03:	83 c4 08             	add    $0x8,%esp
c0024b06:	8b 43 1c             	mov    0x1c(%ebx),%eax
c0024b09:	ba 00 00 00 00       	mov    $0x0,%edx
c0024b0e:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c0024b12:	c1 e0 09             	shl    $0x9,%eax
c0024b15:	52                   	push   %edx
c0024b16:	50                   	push   %eax
c0024b17:	e8 e7 26 00 00       	call   c0027203 <print_human_readable_size>
  printf (")");
c0024b1c:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0024b23:	e8 98 52 00 00       	call   c0029dc0 <putchar>
  if (extra_info != NULL)
c0024b28:	83 c4 10             	add    $0x10,%esp
c0024b2b:	85 f6                	test   %esi,%esi
c0024b2d:	74 11                	je     c0024b40 <block_register+0xc3>
    printf (", %s", extra_info);
c0024b2f:	83 ec 08             	sub    $0x8,%esp
c0024b32:	56                   	push   %esi
c0024b33:	68 56 e7 02 c0       	push   $0xc002e756
c0024b38:	e8 22 1d 00 00       	call   c002685f <printf>
c0024b3d:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0024b40:	83 ec 0c             	sub    $0xc,%esp
c0024b43:	6a 0a                	push   $0xa
c0024b45:	e8 76 52 00 00       	call   c0029dc0 <putchar>
}
c0024b4a:	89 d8                	mov    %ebx,%eax
c0024b4c:	83 c4 1c             	add    $0x1c,%esp
c0024b4f:	5b                   	pop    %ebx
c0024b50:	5e                   	pop    %esi
c0024b51:	5f                   	pop    %edi
c0024b52:	5d                   	pop    %ebp
c0024b53:	c3                   	ret    
    PANIC ("Failed to allocate memory for block device descriptor");
c0024b54:	68 b4 e6 02 c0       	push   $0xc002e6b4
c0024b59:	68 b4 c6 02 c0       	push   $0xc002c6b4
c0024b5e:	68 c1 00 00 00       	push   $0xc1
c0024b63:	68 ea e6 02 c0       	push   $0xc002e6ea
c0024b68:	e8 a0 37 00 00       	call   c002830d <debug_panic>

c0024b6d <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0024b6d:	83 ec 10             	sub    $0x10,%esp
c0024b70:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_read (p->block, p->start + sector, buffer);
c0024b74:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024b78:	8b 42 04             	mov    0x4(%edx),%eax
c0024b7b:	03 44 24 1c          	add    0x1c(%esp),%eax
c0024b7f:	50                   	push   %eax
c0024b80:	ff 32                	pushl  (%edx)
c0024b82:	e8 00 fe ff ff       	call   c0024987 <block_read>
}
c0024b87:	83 c4 1c             	add    $0x1c,%esp
c0024b8a:	c3                   	ret    

c0024b8b <read_partition_table>:
{
c0024b8b:	55                   	push   %ebp
c0024b8c:	57                   	push   %edi
c0024b8d:	56                   	push   %esi
c0024b8e:	53                   	push   %ebx
c0024b8f:	81 ec c8 00 00 00    	sub    $0xc8,%esp
c0024b95:	89 c3                	mov    %eax,%ebx
c0024b97:	89 d6                	mov    %edx,%esi
c0024b99:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  if (sector >= block_size (block))
c0024b9d:	50                   	push   %eax
c0024b9e:	e8 74 fe ff ff       	call   c0024a17 <block_size>
c0024ba3:	83 c4 10             	add    $0x10,%esp
c0024ba6:	39 f0                	cmp    %esi,%eax
c0024ba8:	76 6b                	jbe    c0024c15 <read_partition_table+0x8a>
  pt = malloc (sizeof *pt);
c0024baa:	83 ec 0c             	sub    $0xc,%esp
c0024bad:	68 00 02 00 00       	push   $0x200
c0024bb2:	e8 0c eb ff ff       	call   c00236c3 <malloc>
c0024bb7:	89 c7                	mov    %eax,%edi
  if (pt == NULL)
c0024bb9:	83 c4 10             	add    $0x10,%esp
c0024bbc:	85 c0                	test   %eax,%eax
c0024bbe:	74 72                	je     c0024c32 <read_partition_table+0xa7>
  block_read (block, 0, pt);
c0024bc0:	83 ec 04             	sub    $0x4,%esp
c0024bc3:	50                   	push   %eax
c0024bc4:	6a 00                	push   $0x0
c0024bc6:	53                   	push   %ebx
c0024bc7:	e8 bb fd ff ff       	call   c0024987 <block_read>
  if (pt->signature != 0xaa55)
c0024bcc:	83 c4 10             	add    $0x10,%esp
c0024bcf:	66 81 bf fe 01 00 00 	cmpw   $0xaa55,0x1fe(%edi)
c0024bd6:	55 aa 
c0024bd8:	0f 84 87 00 00 00    	je     c0024c65 <read_partition_table+0xda>
      if (primary_extended_sector == 0)
c0024bde:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0024be2:	75 64                	jne    c0024c48 <read_partition_table+0xbd>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c0024be4:	83 ec 0c             	sub    $0xc,%esp
c0024be7:	53                   	push   %ebx
c0024be8:	e8 32 fe ff ff       	call   c0024a1f <block_name>
c0024bed:	83 c4 08             	add    $0x8,%esp
c0024bf0:	50                   	push   %eax
c0024bf1:	68 70 ec 02 c0       	push   $0xc002ec70
c0024bf6:	e8 64 1c 00 00       	call   c002685f <printf>
c0024bfb:	83 c4 10             	add    $0x10,%esp
      free (pt);
c0024bfe:	83 ec 0c             	sub    $0xc,%esp
c0024c01:	57                   	push   %edi
c0024c02:	e8 5f ec ff ff       	call   c0023866 <free>
      return;
c0024c07:	83 c4 10             	add    $0x10,%esp
}
c0024c0a:	81 c4 bc 00 00 00    	add    $0xbc,%esp
c0024c10:	5b                   	pop    %ebx
c0024c11:	5e                   	pop    %esi
c0024c12:	5f                   	pop    %edi
c0024c13:	5d                   	pop    %ebp
c0024c14:	c3                   	ret    
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0024c15:	83 ec 0c             	sub    $0xc,%esp
c0024c18:	53                   	push   %ebx
c0024c19:	e8 01 fe ff ff       	call   c0024a1f <block_name>
c0024c1e:	83 c4 0c             	add    $0xc,%esp
c0024c21:	56                   	push   %esi
c0024c22:	50                   	push   %eax
c0024c23:	68 08 ec 02 c0       	push   $0xc002ec08
c0024c28:	e8 32 1c 00 00       	call   c002685f <printf>
      return;
c0024c2d:	83 c4 10             	add    $0x10,%esp
c0024c30:	eb d8                	jmp    c0024c0a <read_partition_table+0x7f>
    PANIC ("Failed to allocate memory for partition table.");
c0024c32:	68 40 ec 02 c0       	push   $0xc002ec40
c0024c37:	68 50 cb 02 c0       	push   $0xc002cb50
c0024c3c:	6a 5a                	push   $0x5a
c0024c3e:	68 77 e7 02 c0       	push   $0xc002e777
c0024c43:	e8 c5 36 00 00       	call   c002830d <debug_panic>
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c0024c48:	83 ec 0c             	sub    $0xc,%esp
c0024c4b:	53                   	push   %ebx
c0024c4c:	e8 ce fd ff ff       	call   c0024a1f <block_name>
c0024c51:	83 c4 0c             	add    $0xc,%esp
c0024c54:	56                   	push   %esi
c0024c55:	50                   	push   %eax
c0024c56:	68 98 ec 02 c0       	push   $0xc002ec98
c0024c5b:	e8 ff 1b 00 00       	call   c002685f <printf>
c0024c60:	83 c4 10             	add    $0x10,%esp
c0024c63:	eb 99                	jmp    c0024bfe <read_partition_table+0x73>
c0024c65:	8d af c2 01 00 00    	lea    0x1c2(%edi),%ebp
c0024c6b:	8d 87 02 02 00 00    	lea    0x202(%edi),%eax
c0024c71:	89 44 24 04          	mov    %eax,0x4(%esp)
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0024c75:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0024c79:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0024c7d:	89 74 24 10          	mov    %esi,0x10(%esp)
c0024c81:	eb 51                	jmp    c0024cd4 <read_partition_table+0x149>
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0024c83:	83 ec 0c             	sub    $0xc,%esp
c0024c86:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0024c8a:	53                   	push   %ebx
c0024c8b:	e8 8f fd ff ff       	call   c0024a1f <block_name>
c0024c90:	83 c4 0c             	add    $0xc,%esp
c0024c93:	8b 74 24 14          	mov    0x14(%esp),%esi
c0024c97:	56                   	push   %esi
c0024c98:	50                   	push   %eax
c0024c99:	68 cc ec 02 c0       	push   $0xc002eccc
c0024c9e:	e8 bc 1b 00 00       	call   c002685f <printf>
          if (sector == 0)
c0024ca3:	83 c4 10             	add    $0x10,%esp
c0024ca6:	85 f6                	test   %esi,%esi
c0024ca8:	0f 85 33 01 00 00    	jne    c0024de1 <read_partition_table+0x256>
            read_partition_table (block, e->offset, e->offset, part_nr);
c0024cae:	8b 57 04             	mov    0x4(%edi),%edx
c0024cb1:	83 ec 0c             	sub    $0xc,%esp
c0024cb4:	ff b4 24 dc 00 00 00 	pushl  0xdc(%esp)
c0024cbb:	89 d1                	mov    %edx,%ecx
c0024cbd:	89 d8                	mov    %ebx,%eax
c0024cbf:	e8 c7 fe ff ff       	call   c0024b8b <read_partition_table>
c0024cc4:	83 c4 10             	add    $0x10,%esp
c0024cc7:	83 c5 10             	add    $0x10,%ebp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0024cca:	3b 6c 24 04          	cmp    0x4(%esp),%ebp
c0024cce:	0f 84 b1 01 00 00    	je     c0024e85 <read_partition_table+0x2fa>
c0024cd4:	89 ef                	mov    %ebp,%edi
      if (e->size == 0 || e->type == 0)
c0024cd6:	8b 75 08             	mov    0x8(%ebp),%esi
c0024cd9:	85 f6                	test   %esi,%esi
c0024cdb:	74 ea                	je     c0024cc7 <read_partition_table+0x13c>
c0024cdd:	8a 5d 00             	mov    0x0(%ebp),%bl
c0024ce0:	84 db                	test   %bl,%bl
c0024ce2:	74 e3                	je     c0024cc7 <read_partition_table+0x13c>
      else if (e->type == 0x05       /* Extended partition. */
c0024ce4:	88 d8                	mov    %bl,%al
c0024ce6:	83 e0 7f             	and    $0x7f,%eax
c0024ce9:	3c 05                	cmp    $0x5,%al
c0024ceb:	74 96                	je     c0024c83 <read_partition_table+0xf8>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c0024ced:	80 fb 0f             	cmp    $0xf,%bl
c0024cf0:	74 91                	je     c0024c83 <read_partition_table+0xf8>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0024cf2:	80 fb c5             	cmp    $0xc5,%bl
c0024cf5:	74 8c                	je     c0024c83 <read_partition_table+0xf8>
          ++*part_nr;
c0024cf7:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
c0024cfe:	8b 00                	mov    (%eax),%eax
c0024d00:	40                   	inc    %eax
c0024d01:	89 44 24 18          	mov    %eax,0x18(%esp)
c0024d05:	8b 94 24 d0 00 00 00 	mov    0xd0(%esp),%edx
c0024d0c:	89 02                	mov    %eax,(%edx)
          found_partition (block, e->type, e->offset + sector,
c0024d0e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024d12:	03 45 04             	add    0x4(%ebp),%eax
c0024d15:	89 c7                	mov    %eax,%edi
c0024d17:	89 44 24 14          	mov    %eax,0x14(%esp)
  if (start >= block_size (block))
c0024d1b:	83 ec 0c             	sub    $0xc,%esp
c0024d1e:	ff 74 24 14          	pushl  0x14(%esp)
c0024d22:	e8 f0 fc ff ff       	call   c0024a17 <block_size>
c0024d27:	83 c4 10             	add    $0x10,%esp
c0024d2a:	39 c7                	cmp    %eax,%edi
c0024d2c:	0f 83 d2 00 00 00    	jae    c0024e04 <read_partition_table+0x279>
  else if (start + size < start || start + size > block_size (block))
c0024d32:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0024d36:	01 f7                	add    %esi,%edi
c0024d38:	0f 82 ed 00 00 00    	jb     c0024e2b <read_partition_table+0x2a0>
c0024d3e:	83 ec 0c             	sub    $0xc,%esp
c0024d41:	ff 74 24 14          	pushl  0x14(%esp)
c0024d45:	e8 cd fc ff ff       	call   c0024a17 <block_size>
c0024d4a:	83 c4 10             	add    $0x10,%esp
c0024d4d:	39 c7                	cmp    %eax,%edi
c0024d4f:	0f 87 d6 00 00 00    	ja     c0024e2b <read_partition_table+0x2a0>
          found_partition (block, e->type, e->offset + sector,
c0024d55:	0f b6 fb             	movzbl %bl,%edi
                              : part_type == 0x21 ? BLOCK_FILESYS
c0024d58:	80 fb 20             	cmp    $0x20,%bl
c0024d5b:	0f 84 39 01 00 00    	je     c0024e9a <read_partition_table+0x30f>
c0024d61:	80 fb 21             	cmp    $0x21,%bl
c0024d64:	0f 84 c2 01 00 00    	je     c0024f2c <read_partition_table+0x3a1>
c0024d6a:	80 fb 22             	cmp    $0x22,%bl
c0024d6d:	0f 84 c6 01 00 00    	je     c0024f39 <read_partition_table+0x3ae>
c0024d73:	80 fb 23             	cmp    $0x23,%bl
c0024d76:	0f 84 ca 01 00 00    	je     c0024f46 <read_partition_table+0x3bb>
      p = malloc (sizeof *p);
c0024d7c:	83 ec 0c             	sub    $0xc,%esp
c0024d7f:	6a 08                	push   $0x8
c0024d81:	e8 3d e9 ff ff       	call   c00236c3 <malloc>
c0024d86:	89 c3                	mov    %eax,%ebx
      if (p == NULL)
c0024d88:	83 c4 10             	add    $0x10,%esp
c0024d8b:	85 c0                	test   %eax,%eax
c0024d8d:	0f 84 ca 00 00 00    	je     c0024e5d <read_partition_table+0x2d2>
      p->block = block;
c0024d93:	8b 44 24 08          	mov    0x8(%esp),%eax
c0024d97:	89 03                	mov    %eax,(%ebx)
      p->start = start;
c0024d99:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0024d9d:	89 4b 04             	mov    %ecx,0x4(%ebx)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0024da0:	83 ec 0c             	sub    $0xc,%esp
c0024da3:	50                   	push   %eax
c0024da4:	e8 76 fc ff ff       	call   c0024a1f <block_name>
c0024da9:	83 c4 04             	add    $0x4,%esp
c0024dac:	ff 74 24 24          	pushl  0x24(%esp)
c0024db0:	50                   	push   %eax
c0024db1:	68 91 e7 02 c0       	push   $0xc002e791
c0024db6:	6a 10                	push   $0x10
c0024db8:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c0024dbc:	50                   	push   %eax
c0024dbd:	e8 29 22 00 00       	call   c0026feb <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0024dc2:	8b 04 bd 40 c7 02 c0 	mov    -0x3ffd38c0(,%edi,4),%eax
c0024dc9:	83 c4 20             	add    $0x20,%esp
c0024dcc:	85 c0                	test   %eax,%eax
c0024dce:	0f 84 a2 00 00 00    	je     c0024e76 <read_partition_table+0x2eb>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0024dd4:	c7 44 24 1c 05 00 00 	movl   $0x5,0x1c(%esp)
c0024ddb:	00 
c0024ddc:	e9 0d 01 00 00       	jmp    c0024eee <read_partition_table+0x363>
            read_partition_table (block, e->offset + primary_extended_sector,
c0024de1:	8b 0c 24             	mov    (%esp),%ecx
c0024de4:	89 ca                	mov    %ecx,%edx
c0024de6:	03 57 04             	add    0x4(%edi),%edx
c0024de9:	83 ec 0c             	sub    $0xc,%esp
c0024dec:	ff b4 24 dc 00 00 00 	pushl  0xdc(%esp)
c0024df3:	8b 44 24 18          	mov    0x18(%esp),%eax
c0024df7:	e8 8f fd ff ff       	call   c0024b8b <read_partition_table>
c0024dfc:	83 c4 10             	add    $0x10,%esp
c0024dff:	e9 c3 fe ff ff       	jmp    c0024cc7 <read_partition_table+0x13c>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0024e04:	83 ec 0c             	sub    $0xc,%esp
c0024e07:	ff 74 24 14          	pushl  0x14(%esp)
c0024e0b:	e8 0f fc ff ff       	call   c0024a1f <block_name>
c0024e10:	ff 74 24 24          	pushl  0x24(%esp)
c0024e14:	ff 74 24 2c          	pushl  0x2c(%esp)
c0024e18:	50                   	push   %eax
c0024e19:	68 f4 ec 02 c0       	push   $0xc002ecf4
c0024e1e:	e8 3c 1a 00 00       	call   c002685f <printf>
c0024e23:	83 c4 20             	add    $0x20,%esp
c0024e26:	e9 9c fe ff ff       	jmp    c0024cc7 <read_partition_table+0x13c>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0024e2b:	83 ec 0c             	sub    $0xc,%esp
c0024e2e:	8b 74 24 14          	mov    0x14(%esp),%esi
c0024e32:	56                   	push   %esi
c0024e33:	e8 df fb ff ff       	call   c0024a17 <block_size>
c0024e38:	89 c3                	mov    %eax,%ebx
c0024e3a:	89 34 24             	mov    %esi,(%esp)
c0024e3d:	e8 dd fb ff ff       	call   c0024a1f <block_name>
c0024e42:	89 1c 24             	mov    %ebx,(%esp)
c0024e45:	57                   	push   %edi
c0024e46:	ff 74 24 2c          	pushl  0x2c(%esp)
c0024e4a:	50                   	push   %eax
c0024e4b:	68 2c ed 02 c0       	push   $0xc002ed2c
c0024e50:	e8 0a 1a 00 00       	call   c002685f <printf>
c0024e55:	83 c4 20             	add    $0x20,%esp
c0024e58:	e9 6a fe ff ff       	jmp    c0024cc7 <read_partition_table+0x13c>
        PANIC ("Failed to allocate memory for partition descriptor");
c0024e5d:	68 60 ed 02 c0       	push   $0xc002ed60
c0024e62:	68 40 cb 02 c0       	push   $0xc002cb40
c0024e67:	68 b1 00 00 00       	push   $0xb1
c0024e6c:	68 77 e7 02 c0       	push   $0xc002e777
c0024e71:	e8 97 34 00 00       	call   c002830d <debug_panic>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0024e76:	c7 44 24 1c 05 00 00 	movl   $0x5,0x1c(%esp)
c0024e7d:	00 
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0024e7e:	b8 6f e7 02 c0       	mov    $0xc002e76f,%eax
c0024e83:	eb 69                	jmp    c0024eee <read_partition_table+0x363>
c0024e85:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  free (pt);
c0024e89:	83 ec 0c             	sub    $0xc,%esp
c0024e8c:	57                   	push   %edi
c0024e8d:	e8 d4 e9 ff ff       	call   c0023866 <free>
c0024e92:	83 c4 10             	add    $0x10,%esp
c0024e95:	e9 70 fd ff ff       	jmp    c0024c0a <read_partition_table+0x7f>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0024e9a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c0024ea1:	00 
      p = malloc (sizeof *p);
c0024ea2:	83 ec 0c             	sub    $0xc,%esp
c0024ea5:	6a 08                	push   $0x8
c0024ea7:	e8 17 e8 ff ff       	call   c00236c3 <malloc>
c0024eac:	89 c3                	mov    %eax,%ebx
      if (p == NULL)
c0024eae:	83 c4 10             	add    $0x10,%esp
c0024eb1:	85 c0                	test   %eax,%eax
c0024eb3:	74 a8                	je     c0024e5d <read_partition_table+0x2d2>
      p->block = block;
c0024eb5:	8b 44 24 08          	mov    0x8(%esp),%eax
c0024eb9:	89 03                	mov    %eax,(%ebx)
      p->start = start;
c0024ebb:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0024ebf:	89 4b 04             	mov    %ecx,0x4(%ebx)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0024ec2:	83 ec 0c             	sub    $0xc,%esp
c0024ec5:	50                   	push   %eax
c0024ec6:	e8 54 fb ff ff       	call   c0024a1f <block_name>
c0024ecb:	83 c4 04             	add    $0x4,%esp
c0024ece:	ff 74 24 24          	pushl  0x24(%esp)
c0024ed2:	50                   	push   %eax
c0024ed3:	68 91 e7 02 c0       	push   $0xc002e791
c0024ed8:	6a 10                	push   $0x10
c0024eda:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c0024ede:	50                   	push   %eax
c0024edf:	e8 07 21 00 00       	call   c0026feb <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0024ee4:	8b 04 bd 40 c7 02 c0 	mov    -0x3ffd38c0(,%edi,4),%eax
c0024eeb:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0024eee:	83 ec 0c             	sub    $0xc,%esp
c0024ef1:	57                   	push   %edi
c0024ef2:	50                   	push   %eax
c0024ef3:	68 96 e7 02 c0       	push   $0xc002e796
c0024ef8:	68 80 00 00 00       	push   $0x80
c0024efd:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0024f01:	50                   	push   %eax
c0024f02:	e8 e4 20 00 00       	call   c0026feb <snprintf>
      block_register (name, type, extra_info, size, &partition_operations, p);
c0024f07:	83 c4 18             	add    $0x18,%esp
c0024f0a:	53                   	push   %ebx
c0024f0b:	68 88 80 03 c0       	push   $0xc0038088
c0024f10:	56                   	push   %esi
c0024f11:	8d 44 24 44          	lea    0x44(%esp),%eax
c0024f15:	50                   	push   %eax
c0024f16:	ff 74 24 34          	pushl  0x34(%esp)
c0024f1a:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c0024f1e:	50                   	push   %eax
c0024f1f:	e8 59 fb ff ff       	call   c0024a7d <block_register>
c0024f24:	83 c4 20             	add    $0x20,%esp
c0024f27:	e9 9b fd ff ff       	jmp    c0024cc7 <read_partition_table+0x13c>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0024f2c:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
c0024f33:	00 
c0024f34:	e9 69 ff ff ff       	jmp    c0024ea2 <read_partition_table+0x317>
c0024f39:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
c0024f40:	00 
c0024f41:	e9 5c ff ff ff       	jmp    c0024ea2 <read_partition_table+0x317>
c0024f46:	c7 44 24 1c 03 00 00 	movl   $0x3,0x1c(%esp)
c0024f4d:	00 
c0024f4e:	e9 4f ff ff ff       	jmp    c0024ea2 <read_partition_table+0x317>

c0024f53 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c0024f53:	83 ec 10             	sub    $0x10,%esp
c0024f56:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_write (p->block, p->start + sector, buffer);
c0024f5a:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024f5e:	8b 42 04             	mov    0x4(%edx),%eax
c0024f61:	03 44 24 1c          	add    0x1c(%esp),%eax
c0024f65:	50                   	push   %eax
c0024f66:	ff 32                	pushl  (%edx)
c0024f68:	e8 4e fa ff ff       	call   c00249bb <block_write>
}
c0024f6d:	83 c4 1c             	add    $0x1c,%esp
c0024f70:	c3                   	ret    

c0024f71 <partition_scan>:
{
c0024f71:	83 ec 28             	sub    $0x28,%esp
  int part_nr = 0;
c0024f74:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0024f7b:	00 
  read_partition_table (block, 0, 0, &part_nr);
c0024f7c:	8d 44 24 18          	lea    0x18(%esp),%eax
c0024f80:	50                   	push   %eax
c0024f81:	b9 00 00 00 00       	mov    $0x0,%ecx
c0024f86:	ba 00 00 00 00       	mov    $0x0,%edx
c0024f8b:	8b 44 24 30          	mov    0x30(%esp),%eax
c0024f8f:	e8 f7 fb ff ff       	call   c0024b8b <read_partition_table>
  if (part_nr == 0)
c0024f94:	83 c4 10             	add    $0x10,%esp
c0024f97:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0024f9c:	74 04                	je     c0024fa2 <partition_scan+0x31>
}
c0024f9e:	83 c4 1c             	add    $0x1c,%esp
c0024fa1:	c3                   	ret    
    printf ("%s: Device contains no partitions\n", block_name (block));
c0024fa2:	83 ec 0c             	sub    $0xc,%esp
c0024fa5:	ff 74 24 2c          	pushl  0x2c(%esp)
c0024fa9:	e8 71 fa ff ff       	call   c0024a1f <block_name>
c0024fae:	83 c4 08             	add    $0x8,%esp
c0024fb1:	50                   	push   %eax
c0024fb2:	68 94 ed 02 c0       	push   $0xc002ed94
c0024fb7:	e8 a3 18 00 00       	call   c002685f <printf>
c0024fbc:	83 c4 10             	add    $0x10,%esp
}
c0024fbf:	eb dd                	jmp    c0024f9e <partition_scan+0x2d>

c0024fc1 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0024fc1:	57                   	push   %edi
c0024fc2:	56                   	push   %esi
c0024fc3:	53                   	push   %ebx
c0024fc4:	89 d7                	mov    %edx,%edi
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0024fc6:	83 fa 01             	cmp    $0x1,%edx
c0024fc9:	7e 1d                	jle    c0024fe8 <descramble_ata_string+0x27>
c0024fcb:	89 c1                	mov    %eax,%ecx
c0024fcd:	8d 5a fe             	lea    -0x2(%edx),%ebx
c0024fd0:	83 e3 fe             	and    $0xfffffffe,%ebx
c0024fd3:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
    {
      char tmp = string[i];
c0024fd7:	8a 19                	mov    (%ecx),%bl
      string[i] = string[i + 1];
c0024fd9:	8a 51 01             	mov    0x1(%ecx),%dl
c0024fdc:	88 11                	mov    %dl,(%ecx)
      string[i + 1] = tmp;
c0024fde:	88 59 01             	mov    %bl,0x1(%ecx)
c0024fe1:	83 c1 02             	add    $0x2,%ecx
  for (i = 0; i + 1 < size; i += 2)
c0024fe4:	39 f1                	cmp    %esi,%ecx
c0024fe6:	75 ef                	jne    c0024fd7 <descramble_ata_string+0x16>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0024fe8:	8d 57 ff             	lea    -0x1(%edi),%edx
c0024feb:	85 d2                	test   %edx,%edx
c0024fed:	7f 05                	jg     c0024ff4 <descramble_ata_string+0x33>
c0024fef:	eb 14                	jmp    c0025005 <descramble_ata_string+0x44>
c0024ff1:	4a                   	dec    %edx
c0024ff2:	74 11                	je     c0025005 <descramble_ata_string+0x44>
    {
      int c = string[size - 1];
c0024ff4:	8a 4c 10 ff          	mov    -0x1(%eax,%edx,1),%cl
      if (c != '\0' && !isspace (c))
c0024ff8:	f6 c1 df             	test   $0xdf,%cl
c0024ffb:	74 f4                	je     c0024ff1 <descramble_ata_string+0x30>
          || c == '\r' || c == '\t' || c == '\v');
c0024ffd:	83 e9 09             	sub    $0x9,%ecx
c0025000:	80 f9 04             	cmp    $0x4,%cl
c0025003:	76 ec                	jbe    c0024ff1 <descramble_ata_string+0x30>
        break; 
    }
  string[size] = '\0';
c0025005:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

  return string;
}
c0025009:	5b                   	pop    %ebx
c002500a:	5e                   	pop    %esi
c002500b:	5f                   	pop    %edi
c002500c:	c3                   	ret    

c002500d <interrupt_handler>:
}

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c002500d:	83 ec 0c             	sub    $0xc,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
    if (f->vec_no == c->irq)
c0025010:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025014:	8b 40 30             	mov    0x30(%eax),%eax
c0025017:	0f b6 15 8a 9b 03 c0 	movzbl 0xc0039b8a,%edx
c002501e:	39 d0                	cmp    %edx,%eax
c0025020:	74 29                	je     c002504b <interrupt_handler+0x3e>
c0025022:	0f b6 15 0a 9c 03 c0 	movzbl 0xc0039c0a,%edx
c0025029:	b9 00 9c 03 c0       	mov    $0xc0039c00,%ecx
c002502e:	39 c2                	cmp    %eax,%edx
c0025030:	74 1e                	je     c0025050 <interrupt_handler+0x43>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c0025032:	68 24 de 02 c0       	push   $0xc002de24
c0025037:	68 b8 cb 02 c0       	push   $0xc002cbb8
c002503c:	68 0c 02 00 00       	push   $0x20c
c0025041:	68 d1 ed 02 c0       	push   $0xc002edd1
c0025046:	e8 c2 32 00 00       	call   c002830d <debug_panic>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c002504b:	b9 80 9b 03 c0       	mov    $0xc0039b80,%ecx
        if (c->expecting_interrupt) 
c0025050:	80 79 40 00          	cmpb   $0x0,0x40(%ecx)
c0025054:	74 1a                	je     c0025070 <interrupt_handler+0x63>
            inb (reg_status (c));               /* Acknowledge interrupt. */
c0025056:	8b 41 08             	mov    0x8(%ecx),%eax
c0025059:	8d 50 07             	lea    0x7(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002505c:	ec                   	in     (%dx),%al
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c002505d:	83 ec 0c             	sub    $0xc,%esp
c0025060:	83 c1 44             	add    $0x44,%ecx
c0025063:	51                   	push   %ecx
c0025064:	e8 0a d8 ff ff       	call   c0022873 <sema_up>
c0025069:	83 c4 10             	add    $0x10,%esp
}
c002506c:	83 c4 0c             	add    $0xc,%esp
c002506f:	c3                   	ret    
          printf ("%s: unexpected interrupt\n", c->name);
c0025070:	83 ec 08             	sub    $0x8,%esp
c0025073:	51                   	push   %ecx
c0025074:	68 b7 ed 02 c0       	push   $0xc002edb7
c0025079:	e8 e1 17 00 00       	call   c002685f <printf>
c002507e:	83 c4 10             	add    $0x10,%esp
c0025081:	eb e9                	jmp    c002506c <interrupt_handler+0x5f>

c0025083 <wait_until_idle>:
{
c0025083:	56                   	push   %esi
c0025084:	53                   	push   %ebx
c0025085:	83 ec 04             	sub    $0x4,%esp
c0025088:	89 c6                	mov    %eax,%esi
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c002508a:	8b 40 08             	mov    0x8(%eax),%eax
c002508d:	8b 40 08             	mov    0x8(%eax),%eax
c0025090:	8d 50 07             	lea    0x7(%eax),%edx
c0025093:	ec                   	in     (%dx),%al
c0025094:	a8 88                	test   $0x88,%al
c0025096:	74 45                	je     c00250dd <wait_until_idle+0x5a>
      timer_usleep (10);
c0025098:	83 ec 08             	sub    $0x8,%esp
c002509b:	6a 00                	push   $0x0
c002509d:	6a 0a                	push   $0xa
c002509f:	e8 5c ef ff ff       	call   c0024000 <timer_usleep>
c00250a4:	83 c4 10             	add    $0x10,%esp
c00250a7:	bb e7 03 00 00       	mov    $0x3e7,%ebx
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c00250ac:	8b 46 08             	mov    0x8(%esi),%eax
c00250af:	8b 40 08             	mov    0x8(%eax),%eax
c00250b2:	8d 50 07             	lea    0x7(%eax),%edx
c00250b5:	ec                   	in     (%dx),%al
c00250b6:	a8 88                	test   $0x88,%al
c00250b8:	74 23                	je     c00250dd <wait_until_idle+0x5a>
      timer_usleep (10);
c00250ba:	83 ec 08             	sub    $0x8,%esp
c00250bd:	6a 00                	push   $0x0
c00250bf:	6a 0a                	push   $0xa
c00250c1:	e8 3a ef ff ff       	call   c0024000 <timer_usleep>
  for (i = 0; i < 1000; i++) 
c00250c6:	83 c4 10             	add    $0x10,%esp
c00250c9:	4b                   	dec    %ebx
c00250ca:	75 e0                	jne    c00250ac <wait_until_idle+0x29>
  printf ("%s: idle timeout\n", d->name);
c00250cc:	83 ec 08             	sub    $0x8,%esp
c00250cf:	56                   	push   %esi
c00250d0:	68 e5 ed 02 c0       	push   $0xc002ede5
c00250d5:	e8 85 17 00 00       	call   c002685f <printf>
c00250da:	83 c4 10             	add    $0x10,%esp
}
c00250dd:	83 c4 04             	add    $0x4,%esp
c00250e0:	5b                   	pop    %ebx
c00250e1:	5e                   	pop    %esi
c00250e2:	c3                   	ret    

c00250e3 <select_device>:
{
c00250e3:	83 ec 0c             	sub    $0xc,%esp
  struct channel *c = d->channel;
c00250e6:	8b 50 08             	mov    0x8(%eax),%edx
  if (d->dev_no == 1)
c00250e9:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
c00250ed:	74 23                	je     c0025112 <select_device+0x2f>
  uint8_t dev = DEV_MBS;
c00250ef:	b0 a0                	mov    $0xa0,%al
  outb (reg_device (c), dev);
c00250f1:	8b 4a 08             	mov    0x8(%edx),%ecx
c00250f4:	8d 51 06             	lea    0x6(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00250f7:	ee                   	out    %al,(%dx)
  inb (reg_alt_status (c));
c00250f8:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00250fe:	ec                   	in     (%dx),%al
  timer_nsleep (400);
c00250ff:	83 ec 08             	sub    $0x8,%esp
c0025102:	6a 00                	push   $0x0
c0025104:	68 90 01 00 00       	push   $0x190
c0025109:	e8 0b ef ff ff       	call   c0024019 <timer_nsleep>
}
c002510e:	83 c4 1c             	add    $0x1c,%esp
c0025111:	c3                   	ret    
    dev |= DEV_DEV;
c0025112:	b0 b0                	mov    $0xb0,%al
c0025114:	eb db                	jmp    c00250f1 <select_device+0xe>

c0025116 <check_device_type>:
{
c0025116:	56                   	push   %esi
c0025117:	53                   	push   %ebx
c0025118:	83 ec 14             	sub    $0x14,%esp
c002511b:	89 c6                	mov    %eax,%esi
  struct channel *c = d->channel;
c002511d:	8b 58 08             	mov    0x8(%eax),%ebx
  select_device (d);
c0025120:	e8 be ff ff ff       	call   c00250e3 <select_device>
  error = inb (reg_error (c));
c0025125:	8b 5b 08             	mov    0x8(%ebx),%ebx
c0025128:	8d 53 01             	lea    0x1(%ebx),%edx
c002512b:	ec                   	in     (%dx),%al
c002512c:	88 c1                	mov    %al,%cl
  lbam = inb (reg_lbam (c));
c002512e:	8d 53 04             	lea    0x4(%ebx),%edx
c0025131:	ec                   	in     (%dx),%al
c0025132:	88 44 24 0e          	mov    %al,0xe(%esp)
  lbah = inb (reg_lbah (c));
c0025136:	8d 53 05             	lea    0x5(%ebx),%edx
c0025139:	ec                   	in     (%dx),%al
c002513a:	88 44 24 0f          	mov    %al,0xf(%esp)
  status = inb (reg_status (c));
c002513e:	8d 53 07             	lea    0x7(%ebx),%edx
c0025141:	ec                   	in     (%dx),%al
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025142:	80 f9 01             	cmp    $0x1,%cl
c0025145:	74 1b                	je     c0025162 <check_device_type+0x4c>
c0025147:	80 f9 81             	cmp    $0x81,%cl
c002514a:	74 10                	je     c002515c <check_device_type+0x46>
      d->is_ata = false;
c002514c:	c6 46 10 00          	movb   $0x0,0x10(%esi)
      return error != 0x81;      
c0025150:	80 f9 81             	cmp    $0x81,%cl
c0025153:	0f 95 c0             	setne  %al
}
c0025156:	83 c4 14             	add    $0x14,%esp
c0025159:	5b                   	pop    %ebx
c002515a:	5e                   	pop    %esi
c002515b:	c3                   	ret    
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c002515c:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c0025160:	74 ea                	je     c002514c <check_device_type+0x36>
      || (status & STA_DRDY) == 0
c0025162:	a8 40                	test   $0x40,%al
c0025164:	74 e6                	je     c002514c <check_device_type+0x36>
      || (status & STA_BSY) != 0)
c0025166:	84 c0                	test   %al,%al
c0025168:	78 e2                	js     c002514c <check_device_type+0x36>
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c002516a:	80 7c 24 0e 00       	cmpb   $0x0,0xe(%esp)
c002516f:	75 16                	jne    c0025187 <check_device_type+0x71>
c0025171:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0025176:	0f 94 c0             	sete   %al
c0025179:	0f b6 c0             	movzbl %al,%eax
c002517c:	88 46 10             	mov    %al,0x10(%esi)
c002517f:	80 66 10 01          	andb   $0x1,0x10(%esi)
      return true; 
c0025183:	b0 01                	mov    $0x1,%al
c0025185:	eb cf                	jmp    c0025156 <check_device_type+0x40>
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025187:	80 7c 24 0e 3c       	cmpb   $0x3c,0xe(%esp)
c002518c:	74 07                	je     c0025195 <check_device_type+0x7f>
c002518e:	b8 00 00 00 00       	mov    $0x0,%eax
c0025193:	eb e7                	jmp    c002517c <check_device_type+0x66>
c0025195:	80 7c 24 0f c3       	cmpb   $0xc3,0xf(%esp)
c002519a:	0f 94 c0             	sete   %al
c002519d:	0f b6 c0             	movzbl %al,%eax
c00251a0:	eb da                	jmp    c002517c <check_device_type+0x66>

c00251a2 <select_sector>:
{
c00251a2:	57                   	push   %edi
c00251a3:	56                   	push   %esi
c00251a4:	53                   	push   %ebx
  struct channel *c = d->channel;
c00251a5:	8b 78 08             	mov    0x8(%eax),%edi
  ASSERT (sec_no < (1UL << 28));
c00251a8:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c00251ae:	77 4d                	ja     c00251fd <select_sector+0x5b>
c00251b0:	89 c6                	mov    %eax,%esi
c00251b2:	89 d3                	mov    %edx,%ebx
  wait_until_idle (d);
c00251b4:	e8 ca fe ff ff       	call   c0025083 <wait_until_idle>
  select_device (d);
c00251b9:	89 f0                	mov    %esi,%eax
c00251bb:	e8 23 ff ff ff       	call   c00250e3 <select_device>
  wait_until_idle (d);
c00251c0:	89 f0                	mov    %esi,%eax
c00251c2:	e8 bc fe ff ff       	call   c0025083 <wait_until_idle>
  outb (reg_nsect (c), 1);
c00251c7:	8b 4f 08             	mov    0x8(%edi),%ecx
c00251ca:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00251cd:	b0 01                	mov    $0x1,%al
c00251cf:	ee                   	out    %al,(%dx)
  outb (reg_lbal (c), sec_no);
c00251d0:	8d 51 03             	lea    0x3(%ecx),%edx
c00251d3:	88 d8                	mov    %bl,%al
c00251d5:	ee                   	out    %al,(%dx)
  outb (reg_lbam (c), sec_no >> 8);
c00251d6:	89 d8                	mov    %ebx,%eax
c00251d8:	c1 e8 08             	shr    $0x8,%eax
c00251db:	8d 51 04             	lea    0x4(%ecx),%edx
c00251de:	ee                   	out    %al,(%dx)
  outb (reg_lbah (c), (sec_no >> 16));
c00251df:	89 d8                	mov    %ebx,%eax
c00251e1:	c1 e8 10             	shr    $0x10,%eax
c00251e4:	8d 51 05             	lea    0x5(%ecx),%edx
c00251e7:	ee                   	out    %al,(%dx)
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c00251e8:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c00251ec:	74 30                	je     c002521e <select_sector+0x7c>
c00251ee:	b0 e0                	mov    $0xe0,%al
c00251f0:	c1 eb 18             	shr    $0x18,%ebx
c00251f3:	09 d8                	or     %ebx,%eax
  outb (reg_device (c),
c00251f5:	8d 51 06             	lea    0x6(%ecx),%edx
c00251f8:	ee                   	out    %al,(%dx)
}
c00251f9:	5b                   	pop    %ebx
c00251fa:	5e                   	pop    %esi
c00251fb:	5f                   	pop    %edi
c00251fc:	c3                   	ret    
  ASSERT (sec_no < (1UL << 28));
c00251fd:	83 ec 0c             	sub    $0xc,%esp
c0025200:	68 f7 ed 02 c0       	push   $0xc002edf7
c0025205:	68 3f d9 02 c0       	push   $0xc002d93f
c002520a:	68 88 cb 02 c0       	push   $0xc002cb88
c002520f:	68 89 01 00 00       	push   $0x189
c0025214:	68 d1 ed 02 c0       	push   $0xc002edd1
c0025219:	e8 ef 30 00 00       	call   c002830d <debug_panic>
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c002521e:	b0 f0                	mov    $0xf0,%al
c0025220:	eb ce                	jmp    c00251f0 <select_sector+0x4e>

c0025222 <wait_while_busy>:
{
c0025222:	57                   	push   %edi
c0025223:	56                   	push   %esi
c0025224:	53                   	push   %ebx
c0025225:	89 c7                	mov    %eax,%edi
  struct channel *c = d->channel;
c0025227:	8b 70 08             	mov    0x8(%eax),%esi
  for (i = 0; i < 3000; i++)
c002522a:	bb 00 00 00 00       	mov    $0x0,%ebx
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c002522f:	8b 46 08             	mov    0x8(%esi),%eax
c0025232:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025238:	ec                   	in     (%dx),%al
c0025239:	84 c0                	test   %al,%al
c002523b:	79 33                	jns    c0025270 <wait_while_busy+0x4e>
      timer_msleep (10);
c002523d:	83 ec 08             	sub    $0x8,%esp
c0025240:	6a 00                	push   $0x0
c0025242:	6a 0a                	push   $0xa
c0025244:	e8 9e ed ff ff       	call   c0023fe7 <timer_msleep>
  for (i = 0; i < 3000; i++)
c0025249:	43                   	inc    %ebx
c002524a:	83 c4 10             	add    $0x10,%esp
c002524d:	81 fb b8 0b 00 00    	cmp    $0xbb8,%ebx
c0025253:	74 49                	je     c002529e <wait_while_busy+0x7c>
      if (i == 700)
c0025255:	81 fb bc 02 00 00    	cmp    $0x2bc,%ebx
c002525b:	75 d2                	jne    c002522f <wait_while_busy+0xd>
        printf ("%s: busy, waiting...", d->name);
c002525d:	83 ec 08             	sub    $0x8,%esp
c0025260:	57                   	push   %edi
c0025261:	68 0c ee 02 c0       	push   $0xc002ee0c
c0025266:	e8 f4 15 00 00       	call   c002685f <printf>
c002526b:	83 c4 10             	add    $0x10,%esp
c002526e:	eb bf                	jmp    c002522f <wait_while_busy+0xd>
          if (i >= 700)
c0025270:	81 fb bb 02 00 00    	cmp    $0x2bb,%ebx
c0025276:	7f 14                	jg     c002528c <wait_while_busy+0x6a>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0025278:	8b 46 08             	mov    0x8(%esi),%eax
c002527b:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025281:	ec                   	in     (%dx),%al
c0025282:	c0 e8 03             	shr    $0x3,%al
c0025285:	83 e0 01             	and    $0x1,%eax
}
c0025288:	5b                   	pop    %ebx
c0025289:	5e                   	pop    %esi
c002528a:	5f                   	pop    %edi
c002528b:	c3                   	ret    
            printf ("ok\n");
c002528c:	83 ec 0c             	sub    $0xc,%esp
c002528f:	68 21 ee 02 c0       	push   $0xc002ee21
c0025294:	e8 bb 4a 00 00       	call   c0029d54 <puts>
c0025299:	83 c4 10             	add    $0x10,%esp
c002529c:	eb da                	jmp    c0025278 <wait_while_busy+0x56>
  printf ("failed\n");
c002529e:	83 ec 0c             	sub    $0xc,%esp
c00252a1:	68 c4 f6 02 c0       	push   $0xc002f6c4
c00252a6:	e8 a9 4a 00 00       	call   c0029d54 <puts>
  return false;
c00252ab:	83 c4 10             	add    $0x10,%esp
c00252ae:	b0 00                	mov    $0x0,%al
c00252b0:	eb d6                	jmp    c0025288 <wait_while_busy+0x66>

c00252b2 <issue_pio_command>:
{
c00252b2:	56                   	push   %esi
c00252b3:	53                   	push   %ebx
c00252b4:	83 ec 04             	sub    $0x4,%esp
c00252b7:	89 c3                	mov    %eax,%ebx
c00252b9:	89 d6                	mov    %edx,%esi
  ASSERT (intr_get_level () == INTR_ON);
c00252bb:	e8 f9 c3 ff ff       	call   c00216b9 <intr_get_level>
c00252c0:	83 f8 01             	cmp    $0x1,%eax
c00252c3:	75 13                	jne    c00252d8 <issue_pio_command+0x26>
  c->expecting_interrupt = true;
c00252c5:	c6 43 40 01          	movb   $0x1,0x40(%ebx)
  outb (reg_command (c), command);
c00252c9:	8b 53 08             	mov    0x8(%ebx),%edx
c00252cc:	83 c2 07             	add    $0x7,%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00252cf:	89 f0                	mov    %esi,%eax
c00252d1:	ee                   	out    %al,(%dx)
}
c00252d2:	83 c4 04             	add    $0x4,%esp
c00252d5:	5b                   	pop    %ebx
c00252d6:	5e                   	pop    %esi
c00252d7:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c00252d8:	83 ec 0c             	sub    $0xc,%esp
c00252db:	68 2f e5 02 c0       	push   $0xc002e52f
c00252e0:	68 3f d9 02 c0       	push   $0xc002d93f
c00252e5:	68 68 cb 02 c0       	push   $0xc002cb68
c00252ea:	68 9b 01 00 00       	push   $0x19b
c00252ef:	68 d1 ed 02 c0       	push   $0xc002edd1
c00252f4:	e8 14 30 00 00       	call   c002830d <debug_panic>

c00252f9 <ide_write>:
{
c00252f9:	57                   	push   %edi
c00252fa:	56                   	push   %esi
c00252fb:	53                   	push   %ebx
c00252fc:	8b 74 24 10          	mov    0x10(%esp),%esi
  struct channel *c = d->channel;
c0025300:	8b 5e 08             	mov    0x8(%esi),%ebx
  lock_acquire (&c->lock);
c0025303:	8d 7b 0c             	lea    0xc(%ebx),%edi
c0025306:	83 ec 0c             	sub    $0xc,%esp
c0025309:	57                   	push   %edi
c002530a:	e8 63 d8 ff ff       	call   c0022b72 <lock_acquire>
  select_sector (d, sec_no);
c002530f:	8b 54 24 24          	mov    0x24(%esp),%edx
c0025313:	89 f0                	mov    %esi,%eax
c0025315:	e8 88 fe ff ff       	call   c00251a2 <select_sector>
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c002531a:	ba 30 00 00 00       	mov    $0x30,%edx
c002531f:	89 d8                	mov    %ebx,%eax
c0025321:	e8 8c ff ff ff       	call   c00252b2 <issue_pio_command>
  if (!wait_while_busy (d))
c0025326:	89 f0                	mov    %esi,%eax
c0025328:	e8 f5 fe ff ff       	call   c0025222 <wait_while_busy>
c002532d:	83 c4 10             	add    $0x10,%esp
c0025330:	84 c0                	test   %al,%al
c0025332:	74 2a                	je     c002535e <ide_write+0x65>
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025334:	8b 53 08             	mov    0x8(%ebx),%edx
c0025337:	8b 74 24 18          	mov    0x18(%esp),%esi
c002533b:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025340:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
  sema_down (&c->completion_wait);
c0025343:	83 ec 0c             	sub    $0xc,%esp
c0025346:	83 c3 44             	add    $0x44,%ebx
c0025349:	53                   	push   %ebx
c002534a:	e8 43 d4 ff ff       	call   c0022792 <sema_down>
  lock_release (&c->lock);
c002534f:	89 3c 24             	mov    %edi,(%esp)
c0025352:	e8 b8 d9 ff ff       	call   c0022d0f <lock_release>
}
c0025357:	83 c4 10             	add    $0x10,%esp
c002535a:	5b                   	pop    %ebx
c002535b:	5e                   	pop    %esi
c002535c:	5f                   	pop    %edi
c002535d:	c3                   	ret    
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c002535e:	83 ec 08             	sub    $0x8,%esp
c0025361:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025365:	56                   	push   %esi
c0025366:	68 70 ee 02 c0       	push   $0xc002ee70
c002536b:	68 98 cb 02 c0       	push   $0xc002cb98
c0025370:	68 75 01 00 00       	push   $0x175
c0025375:	68 d1 ed 02 c0       	push   $0xc002edd1
c002537a:	e8 8e 2f 00 00       	call   c002830d <debug_panic>

c002537f <identify_ata_device>:
{
c002537f:	57                   	push   %edi
c0025380:	56                   	push   %esi
c0025381:	53                   	push   %ebx
c0025382:	81 ec 80 02 00 00    	sub    $0x280,%esp
  struct channel *c = d->channel;
c0025388:	8b 70 08             	mov    0x8(%eax),%esi
  ASSERT (d->is_ata);
c002538b:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c002538f:	74 49                	je     c00253da <identify_ata_device+0x5b>
c0025391:	89 c3                	mov    %eax,%ebx
  wait_until_idle (d);
c0025393:	e8 eb fc ff ff       	call   c0025083 <wait_until_idle>
  select_device (d);
c0025398:	89 d8                	mov    %ebx,%eax
c002539a:	e8 44 fd ff ff       	call   c00250e3 <select_device>
  wait_until_idle (d);
c002539f:	89 d8                	mov    %ebx,%eax
c00253a1:	e8 dd fc ff ff       	call   c0025083 <wait_until_idle>
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c00253a6:	ba ec 00 00 00       	mov    $0xec,%edx
c00253ab:	89 f0                	mov    %esi,%eax
c00253ad:	e8 00 ff ff ff       	call   c00252b2 <issue_pio_command>
  sema_down (&c->completion_wait);
c00253b2:	83 ec 0c             	sub    $0xc,%esp
c00253b5:	8d 46 44             	lea    0x44(%esi),%eax
c00253b8:	50                   	push   %eax
c00253b9:	e8 d4 d3 ff ff       	call   c0022792 <sema_down>
  if (!wait_while_busy (d))
c00253be:	89 d8                	mov    %ebx,%eax
c00253c0:	e8 5d fe ff ff       	call   c0025222 <wait_while_busy>
c00253c5:	83 c4 10             	add    $0x10,%esp
c00253c8:	84 c0                	test   %al,%al
c00253ca:	75 2f                	jne    c00253fb <identify_ata_device+0x7c>
      d->is_ata = false;
c00253cc:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
}
c00253d0:	81 c4 80 02 00 00    	add    $0x280,%esp
c00253d6:	5b                   	pop    %ebx
c00253d7:	5e                   	pop    %esi
c00253d8:	5f                   	pop    %edi
c00253d9:	c3                   	ret    
  ASSERT (d->is_ata);
c00253da:	83 ec 0c             	sub    $0xc,%esp
c00253dd:	68 24 ee 02 c0       	push   $0xc002ee24
c00253e2:	68 3f d9 02 c0       	push   $0xc002d93f
c00253e7:	68 a4 cb 02 c0       	push   $0xc002cba4
c00253ec:	68 0d 01 00 00       	push   $0x10d
c00253f1:	68 d1 ed 02 c0       	push   $0xc002edd1
c00253f6:	e8 12 2f 00 00       	call   c002830d <debug_panic>
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c00253fb:	8b 56 08             	mov    0x8(%esi),%edx
c00253fe:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0025405:	b9 00 01 00 00       	mov    $0x100,%ecx
c002540a:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  capacity = *(uint32_t *) &id[60 * 2];
c002540d:	8b b4 24 f8 00 00 00 	mov    0xf8(%esp),%esi
  model = descramble_ata_string (&id[10 * 2], 20);
c0025414:	ba 14 00 00 00       	mov    $0x14,%edx
c0025419:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0025420:	e8 9c fb ff ff       	call   c0024fc1 <descramble_ata_string>
c0025425:	89 c7                	mov    %eax,%edi
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025427:	ba 28 00 00 00       	mov    $0x28,%edx
c002542c:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c0025433:	e8 89 fb ff ff       	call   c0024fc1 <descramble_ata_string>
  snprintf (extra_info, sizeof extra_info,
c0025438:	83 ec 0c             	sub    $0xc,%esp
c002543b:	50                   	push   %eax
c002543c:	57                   	push   %edi
c002543d:	68 2e ee 02 c0       	push   $0xc002ee2e
c0025442:	68 80 00 00 00       	push   $0x80
c0025447:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002544b:	50                   	push   %eax
c002544c:	e8 9a 1b 00 00       	call   c0026feb <snprintf>
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0025451:	83 c4 20             	add    $0x20,%esp
c0025454:	81 fe ff ff 1f 00    	cmp    $0x1fffff,%esi
c002545a:	76 3a                	jbe    c0025496 <identify_ata_device+0x117>
      printf ("%s: ignoring ", d->name);
c002545c:	83 ec 08             	sub    $0x8,%esp
c002545f:	53                   	push   %ebx
c0025460:	68 46 ee 02 c0       	push   $0xc002ee46
c0025465:	e8 f5 13 00 00       	call   c002685f <printf>
      print_human_readable_size (capacity * 512);
c002546a:	83 c4 08             	add    $0x8,%esp
c002546d:	89 f0                	mov    %esi,%eax
c002546f:	c1 e0 09             	shl    $0x9,%eax
c0025472:	ba 00 00 00 00       	mov    $0x0,%edx
c0025477:	52                   	push   %edx
c0025478:	50                   	push   %eax
c0025479:	e8 85 1d 00 00       	call   c0027203 <print_human_readable_size>
      printf ("disk for safety\n");
c002547e:	c7 04 24 54 ee 02 c0 	movl   $0xc002ee54,(%esp)
c0025485:	e8 ca 48 00 00       	call   c0029d54 <puts>
      d->is_ata = false;
c002548a:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
      return;
c002548e:	83 c4 10             	add    $0x10,%esp
c0025491:	e9 3a ff ff ff       	jmp    c00253d0 <identify_ata_device+0x51>
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025496:	83 ec 08             	sub    $0x8,%esp
c0025499:	53                   	push   %ebx
c002549a:	68 90 80 03 c0       	push   $0xc0038090
c002549f:	56                   	push   %esi
c00254a0:	8d 44 24 14          	lea    0x14(%esp),%eax
c00254a4:	50                   	push   %eax
c00254a5:	6a 04                	push   $0x4
c00254a7:	53                   	push   %ebx
c00254a8:	e8 d0 f5 ff ff       	call   c0024a7d <block_register>
  partition_scan (block);
c00254ad:	83 c4 14             	add    $0x14,%esp
c00254b0:	50                   	push   %eax
c00254b1:	e8 bb fa ff ff       	call   c0024f71 <partition_scan>
c00254b6:	83 c4 10             	add    $0x10,%esp
c00254b9:	e9 12 ff ff ff       	jmp    c00253d0 <identify_ata_device+0x51>

c00254be <ide_read>:
{
c00254be:	55                   	push   %ebp
c00254bf:	57                   	push   %edi
c00254c0:	56                   	push   %esi
c00254c1:	53                   	push   %ebx
c00254c2:	83 ec 18             	sub    $0x18,%esp
c00254c5:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  struct channel *c = d->channel;
c00254c9:	8b 5e 08             	mov    0x8(%esi),%ebx
  lock_acquire (&c->lock);
c00254cc:	8d 6b 0c             	lea    0xc(%ebx),%ebp
c00254cf:	55                   	push   %ebp
c00254d0:	e8 9d d6 ff ff       	call   c0022b72 <lock_acquire>
  select_sector (d, sec_no);
c00254d5:	8b 54 24 34          	mov    0x34(%esp),%edx
c00254d9:	89 f0                	mov    %esi,%eax
c00254db:	e8 c2 fc ff ff       	call   c00251a2 <select_sector>
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c00254e0:	ba 20 00 00 00       	mov    $0x20,%edx
c00254e5:	89 d8                	mov    %ebx,%eax
c00254e7:	e8 c6 fd ff ff       	call   c00252b2 <issue_pio_command>
  sema_down (&c->completion_wait);
c00254ec:	8d 43 44             	lea    0x44(%ebx),%eax
c00254ef:	89 04 24             	mov    %eax,(%esp)
c00254f2:	e8 9b d2 ff ff       	call   c0022792 <sema_down>
  if (!wait_while_busy (d))
c00254f7:	89 f0                	mov    %esi,%eax
c00254f9:	e8 24 fd ff ff       	call   c0025222 <wait_while_busy>
c00254fe:	83 c4 10             	add    $0x10,%esp
c0025501:	84 c0                	test   %al,%al
c0025503:	74 20                	je     c0025525 <ide_read+0x67>
c0025505:	8b 53 08             	mov    0x8(%ebx),%edx
c0025508:	8b 7c 24 28          	mov    0x28(%esp),%edi
c002550c:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025511:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  lock_release (&c->lock);
c0025514:	83 ec 0c             	sub    $0xc,%esp
c0025517:	55                   	push   %ebp
c0025518:	e8 f2 d7 ff ff       	call   c0022d0f <lock_release>
}
c002551d:	83 c4 1c             	add    $0x1c,%esp
c0025520:	5b                   	pop    %ebx
c0025521:	5e                   	pop    %esi
c0025522:	5f                   	pop    %edi
c0025523:	5d                   	pop    %ebp
c0025524:	c3                   	ret    
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0025525:	83 ec 08             	sub    $0x8,%esp
c0025528:	ff 74 24 2c          	pushl  0x2c(%esp)
c002552c:	56                   	push   %esi
c002552d:	68 94 ee 02 c0       	push   $0xc002ee94
c0025532:	68 7c cb 02 c0       	push   $0xc002cb7c
c0025537:	68 62 01 00 00       	push   $0x162
c002553c:	68 d1 ed 02 c0       	push   $0xc002edd1
c0025541:	e8 c7 2d 00 00       	call   c002830d <debug_panic>

c0025546 <ide_init>:
{
c0025546:	55                   	push   %ebp
c0025547:	57                   	push   %edi
c0025548:	56                   	push   %esi
c0025549:	53                   	push   %ebx
c002554a:	83 ec 1c             	sub    $0x1c,%esp
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c002554d:	6a 00                	push   $0x0
c002554f:	68 64 ee 02 c0       	push   $0xc002ee64
c0025554:	6a 08                	push   $0x8
c0025556:	68 80 9b 03 c0       	push   $0xc0039b80
c002555b:	e8 8b 1a 00 00       	call   c0026feb <snprintf>
          c->reg_base = 0x1f0;
c0025560:	66 c7 05 88 9b 03 c0 	movw   $0x1f0,0xc0039b88
c0025567:	f0 01 
          c->irq = 14 + 0x20;
c0025569:	c6 05 8a 9b 03 c0 2e 	movb   $0x2e,0xc0039b8a
      lock_init (&c->lock);
c0025570:	c7 04 24 8c 9b 03 c0 	movl   $0xc0039b8c,(%esp)
c0025577:	e8 82 d4 ff ff       	call   c00229fe <lock_init>
      c->expecting_interrupt = false;
c002557c:	c6 05 c0 9b 03 c0 00 	movb   $0x0,0xc0039bc0
      sema_init (&c->completion_wait, 0);
c0025583:	83 c4 08             	add    $0x8,%esp
c0025586:	6a 00                	push   $0x0
c0025588:	68 c4 9b 03 c0       	push   $0xc0039bc4
c002558d:	e8 92 d1 ff ff       	call   c0022724 <sema_init>
          snprintf (d->name, sizeof d->name,
c0025592:	6a 61                	push   $0x61
c0025594:	68 6b ee 02 c0       	push   $0xc002ee6b
c0025599:	6a 08                	push   $0x8
c002559b:	68 d8 9b 03 c0       	push   $0xc0039bd8
c00255a0:	e8 46 1a 00 00       	call   c0026feb <snprintf>
          d->channel = c;
c00255a5:	c7 05 e0 9b 03 c0 80 	movl   $0xc0039b80,0xc0039be0
c00255ac:	9b 03 c0 
          d->dev_no = dev_no;
c00255af:	c7 05 e4 9b 03 c0 00 	movl   $0x0,0xc0039be4
c00255b6:	00 00 00 
          d->is_ata = false;
c00255b9:	c6 05 e8 9b 03 c0 00 	movb   $0x0,0xc0039be8
          snprintf (d->name, sizeof d->name,
c00255c0:	83 c4 20             	add    $0x20,%esp
c00255c3:	6a 62                	push   $0x62
c00255c5:	68 6b ee 02 c0       	push   $0xc002ee6b
c00255ca:	6a 08                	push   $0x8
c00255cc:	68 ec 9b 03 c0       	push   $0xc0039bec
c00255d1:	e8 15 1a 00 00       	call   c0026feb <snprintf>
          d->channel = c;
c00255d6:	c7 05 f4 9b 03 c0 80 	movl   $0xc0039b80,0xc0039bf4
c00255dd:	9b 03 c0 
          d->dev_no = dev_no;
c00255e0:	c7 05 f8 9b 03 c0 01 	movl   $0x1,0xc0039bf8
c00255e7:	00 00 00 
          d->is_ata = false;
c00255ea:	c6 05 fc 9b 03 c0 00 	movb   $0x0,0xc0039bfc
      intr_register_ext (c->irq, interrupt_handler, c->name);
c00255f1:	83 c4 0c             	add    $0xc,%esp
c00255f4:	68 80 9b 03 c0       	push   $0xc0039b80
c00255f9:	68 0d 50 02 c0       	push   $0xc002500d
c00255fe:	0f b6 05 8a 9b 03 c0 	movzbl 0xc0039b8a,%eax
c0025605:	50                   	push   %eax
c0025606:	e8 6c c2 ff ff       	call   c0021877 <intr_register_ext>
      select_device (d);
c002560b:	b8 d8 9b 03 c0       	mov    $0xc0039bd8,%eax
c0025610:	e8 ce fa ff ff       	call   c00250e3 <select_device>
      outb (reg_nsect (c), 0x55);
c0025615:	8b 0d 88 9b 03 c0    	mov    0xc0039b88,%ecx
c002561b:	8d 59 02             	lea    0x2(%ecx),%ebx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002561e:	b0 55                	mov    $0x55,%al
c0025620:	89 da                	mov    %ebx,%edx
c0025622:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025623:	83 c1 03             	add    $0x3,%ecx
c0025626:	b0 aa                	mov    $0xaa,%al
c0025628:	89 ca                	mov    %ecx,%edx
c002562a:	ee                   	out    %al,(%dx)
c002562b:	89 da                	mov    %ebx,%edx
c002562d:	ee                   	out    %al,(%dx)
c002562e:	b0 55                	mov    $0x55,%al
c0025630:	89 ca                	mov    %ecx,%edx
c0025632:	ee                   	out    %al,(%dx)
c0025633:	89 da                	mov    %ebx,%edx
c0025635:	ee                   	out    %al,(%dx)
c0025636:	b0 aa                	mov    $0xaa,%al
c0025638:	89 ca                	mov    %ecx,%edx
c002563a:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002563b:	89 da                	mov    %ebx,%edx
c002563d:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c002563e:	83 c4 10             	add    $0x10,%esp
c0025641:	3c 55                	cmp    $0x55,%al
c0025643:	0f 84 84 02 00 00    	je     c00258cd <ide_init+0x387>
c0025649:	b3 00                	mov    $0x0,%bl
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c002564b:	88 5c 24 0e          	mov    %bl,0xe(%esp)
      select_device (d);
c002564f:	b8 ec 9b 03 c0       	mov    $0xc0039bec,%eax
c0025654:	e8 8a fa ff ff       	call   c00250e3 <select_device>
      outb (reg_nsect (c), 0x55);
c0025659:	8b 0d 88 9b 03 c0    	mov    0xc0039b88,%ecx
c002565f:	8d 71 02             	lea    0x2(%ecx),%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025662:	b0 55                	mov    $0x55,%al
c0025664:	89 f2                	mov    %esi,%edx
c0025666:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025667:	8d 79 03             	lea    0x3(%ecx),%edi
c002566a:	b0 aa                	mov    $0xaa,%al
c002566c:	89 fa                	mov    %edi,%edx
c002566e:	ee                   	out    %al,(%dx)
c002566f:	89 f2                	mov    %esi,%edx
c0025671:	ee                   	out    %al,(%dx)
c0025672:	b0 55                	mov    $0x55,%al
c0025674:	89 fa                	mov    %edi,%edx
c0025676:	ee                   	out    %al,(%dx)
c0025677:	89 f2                	mov    %esi,%edx
c0025679:	ee                   	out    %al,(%dx)
c002567a:	b0 aa                	mov    $0xaa,%al
c002567c:	89 fa                	mov    %edi,%edx
c002567e:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002567f:	89 f2                	mov    %esi,%edx
c0025681:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025682:	3c 55                	cmp    $0x55,%al
c0025684:	0f 84 50 02 00 00    	je     c00258da <ide_init+0x394>
c002568a:	be 00 00 00 00       	mov    $0x0,%esi
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c002568f:	89 f0                	mov    %esi,%eax
c0025691:	88 44 24 0f          	mov    %al,0xf(%esp)
  outb (reg_ctl (c), 0);
c0025695:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002569b:	b0 00                	mov    $0x0,%al
c002569d:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c002569e:	83 ec 08             	sub    $0x8,%esp
c00256a1:	6a 00                	push   $0x0
c00256a3:	6a 0a                	push   $0xa
c00256a5:	e8 56 e9 ff ff       	call   c0024000 <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c00256aa:	a1 88 9b 03 c0       	mov    0xc0039b88,%eax
c00256af:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c00256b5:	b0 04                	mov    $0x4,%al
c00256b7:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c00256b8:	83 c4 08             	add    $0x8,%esp
c00256bb:	6a 00                	push   $0x0
c00256bd:	6a 0a                	push   $0xa
c00256bf:	e8 3c e9 ff ff       	call   c0024000 <timer_usleep>
  outb (reg_ctl (c), 0);
c00256c4:	a1 88 9b 03 c0       	mov    0xc0039b88,%eax
c00256c9:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c00256cf:	b0 00                	mov    $0x0,%al
c00256d1:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c00256d2:	83 c4 08             	add    $0x8,%esp
c00256d5:	6a 00                	push   $0x0
c00256d7:	68 96 00 00 00       	push   $0x96
c00256dc:	e8 06 e9 ff ff       	call   c0023fe7 <timer_msleep>
  if (present[0]) 
c00256e1:	83 c4 10             	add    $0x10,%esp
c00256e4:	84 db                	test   %bl,%bl
c00256e6:	0f 85 fd 01 00 00    	jne    c00258e9 <ide_init+0x3a3>
  if (present[1])
c00256ec:	89 f0                	mov    %esi,%eax
c00256ee:	84 c0                	test   %al,%al
c00256f0:	0f 85 0c 02 00 00    	jne    c0025902 <ide_init+0x3bc>
      if (check_device_type (&c->devices[0]))
c00256f6:	b8 d8 9b 03 c0       	mov    $0xc0039bd8,%eax
c00256fb:	e8 16 fa ff ff       	call   c0025116 <check_device_type>
c0025700:	84 c0                	test   %al,%al
c0025702:	0f 85 42 02 00 00    	jne    c002594a <ide_init+0x404>
        if (c->devices[dev_no].is_ata)
c0025708:	80 3d e8 9b 03 c0 00 	cmpb   $0x0,0xc0039be8
c002570f:	0f 85 44 02 00 00    	jne    c0025959 <ide_init+0x413>
c0025715:	80 3d fc 9b 03 c0 00 	cmpb   $0x0,0xc0039bfc
c002571c:	0f 85 46 02 00 00    	jne    c0025968 <ide_init+0x422>
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025722:	6a 01                	push   $0x1
c0025724:	68 64 ee 02 c0       	push   $0xc002ee64
c0025729:	6a 08                	push   $0x8
c002572b:	68 00 9c 03 c0       	push   $0xc0039c00
c0025730:	e8 b6 18 00 00       	call   c0026feb <snprintf>
          c->reg_base = 0x170;
c0025735:	66 c7 05 08 9c 03 c0 	movw   $0x170,0xc0039c08
c002573c:	70 01 
          c->irq = 15 + 0x20;
c002573e:	c6 05 0a 9c 03 c0 2f 	movb   $0x2f,0xc0039c0a
      lock_init (&c->lock);
c0025745:	c7 04 24 0c 9c 03 c0 	movl   $0xc0039c0c,(%esp)
c002574c:	e8 ad d2 ff ff       	call   c00229fe <lock_init>
      c->expecting_interrupt = false;
c0025751:	c6 05 40 9c 03 c0 00 	movb   $0x0,0xc0039c40
      sema_init (&c->completion_wait, 0);
c0025758:	83 c4 08             	add    $0x8,%esp
c002575b:	6a 00                	push   $0x0
c002575d:	68 44 9c 03 c0       	push   $0xc0039c44
c0025762:	e8 bd cf ff ff       	call   c0022724 <sema_init>
          snprintf (d->name, sizeof d->name,
c0025767:	6a 63                	push   $0x63
c0025769:	68 6b ee 02 c0       	push   $0xc002ee6b
c002576e:	6a 08                	push   $0x8
c0025770:	68 58 9c 03 c0       	push   $0xc0039c58
c0025775:	e8 71 18 00 00       	call   c0026feb <snprintf>
          d->channel = c;
c002577a:	c7 05 60 9c 03 c0 00 	movl   $0xc0039c00,0xc0039c60
c0025781:	9c 03 c0 
          d->dev_no = dev_no;
c0025784:	c7 05 64 9c 03 c0 00 	movl   $0x0,0xc0039c64
c002578b:	00 00 00 
          d->is_ata = false;
c002578e:	c6 05 68 9c 03 c0 00 	movb   $0x0,0xc0039c68
          snprintf (d->name, sizeof d->name,
c0025795:	83 c4 20             	add    $0x20,%esp
c0025798:	6a 64                	push   $0x64
c002579a:	68 6b ee 02 c0       	push   $0xc002ee6b
c002579f:	6a 08                	push   $0x8
c00257a1:	68 6c 9c 03 c0       	push   $0xc0039c6c
c00257a6:	e8 40 18 00 00       	call   c0026feb <snprintf>
          d->channel = c;
c00257ab:	c7 05 74 9c 03 c0 00 	movl   $0xc0039c00,0xc0039c74
c00257b2:	9c 03 c0 
          d->dev_no = dev_no;
c00257b5:	c7 05 78 9c 03 c0 01 	movl   $0x1,0xc0039c78
c00257bc:	00 00 00 
          d->is_ata = false;
c00257bf:	c6 05 7c 9c 03 c0 00 	movb   $0x0,0xc0039c7c
      intr_register_ext (c->irq, interrupt_handler, c->name);
c00257c6:	83 c4 0c             	add    $0xc,%esp
c00257c9:	68 00 9c 03 c0       	push   $0xc0039c00
c00257ce:	68 0d 50 02 c0       	push   $0xc002500d
c00257d3:	0f b6 05 0a 9c 03 c0 	movzbl 0xc0039c0a,%eax
c00257da:	50                   	push   %eax
c00257db:	e8 97 c0 ff ff       	call   c0021877 <intr_register_ext>
c00257e0:	bf 58 9c 03 c0       	mov    $0xc0039c58,%edi
c00257e5:	8d 74 24 1e          	lea    0x1e(%esp),%esi
c00257e9:	83 c4 10             	add    $0x10,%esp
      select_device (d);
c00257ec:	89 f8                	mov    %edi,%eax
c00257ee:	e8 f0 f8 ff ff       	call   c00250e3 <select_device>
      outb (reg_nsect (c), 0x55);
c00257f3:	8b 2d 08 9c 03 c0    	mov    0xc0039c08,%ebp
c00257f9:	8d 4d 02             	lea    0x2(%ebp),%ecx
c00257fc:	b0 55                	mov    $0x55,%al
c00257fe:	89 ca                	mov    %ecx,%edx
c0025800:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025801:	8d 5d 03             	lea    0x3(%ebp),%ebx
c0025804:	b0 aa                	mov    $0xaa,%al
c0025806:	89 da                	mov    %ebx,%edx
c0025808:	ee                   	out    %al,(%dx)
c0025809:	89 ca                	mov    %ecx,%edx
c002580b:	ee                   	out    %al,(%dx)
c002580c:	b0 55                	mov    $0x55,%al
c002580e:	89 da                	mov    %ebx,%edx
c0025810:	ee                   	out    %al,(%dx)
c0025811:	89 ca                	mov    %ecx,%edx
c0025813:	ee                   	out    %al,(%dx)
c0025814:	b0 aa                	mov    $0xaa,%al
c0025816:	89 da                	mov    %ebx,%edx
c0025818:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025819:	89 ca                	mov    %ecx,%edx
c002581b:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c002581c:	3c 55                	cmp    $0x55,%al
c002581e:	0f 84 53 01 00 00    	je     c0025977 <ide_init+0x431>
c0025824:	b0 00                	mov    $0x0,%al
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025826:	88 06                	mov    %al,(%esi)
c0025828:	83 c7 14             	add    $0x14,%edi
c002582b:	46                   	inc    %esi
  for (dev_no = 0; dev_no < 2; dev_no++)
c002582c:	8d 44 24 10          	lea    0x10(%esp),%eax
c0025830:	39 f0                	cmp    %esi,%eax
c0025832:	75 b8                	jne    c00257ec <ide_init+0x2a6>
  outb (reg_ctl (c), 0);
c0025834:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002583a:	b0 00                	mov    $0x0,%al
c002583c:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c002583d:	83 ec 08             	sub    $0x8,%esp
c0025840:	6a 00                	push   $0x0
c0025842:	6a 0a                	push   $0xa
c0025844:	e8 b7 e7 ff ff       	call   c0024000 <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c0025849:	a1 08 9c 03 c0       	mov    0xc0039c08,%eax
c002584e:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025854:	b0 04                	mov    $0x4,%al
c0025856:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0025857:	83 c4 08             	add    $0x8,%esp
c002585a:	6a 00                	push   $0x0
c002585c:	6a 0a                	push   $0xa
c002585e:	e8 9d e7 ff ff       	call   c0024000 <timer_usleep>
  outb (reg_ctl (c), 0);
c0025863:	a1 08 9c 03 c0       	mov    0xc0039c08,%eax
c0025868:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c002586e:	b0 00                	mov    $0x0,%al
c0025870:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c0025871:	83 c4 08             	add    $0x8,%esp
c0025874:	6a 00                	push   $0x0
c0025876:	68 96 00 00 00       	push   $0x96
c002587b:	e8 67 e7 ff ff       	call   c0023fe7 <timer_msleep>
  if (present[0]) 
c0025880:	83 c4 10             	add    $0x10,%esp
c0025883:	80 7c 24 0e 00       	cmpb   $0x0,0xe(%esp)
c0025888:	0f 85 f6 00 00 00    	jne    c0025984 <ide_init+0x43e>
  if (present[1])
c002588e:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0025893:	0f 85 04 01 00 00    	jne    c002599d <ide_init+0x457>
      if (check_device_type (&c->devices[0]))
c0025899:	b8 58 9c 03 c0       	mov    $0xc0039c58,%eax
c002589e:	e8 73 f8 ff ff       	call   c0025116 <check_device_type>
c00258a3:	84 c0                	test   %al,%al
c00258a5:	0f 85 3a 01 00 00    	jne    c00259e5 <ide_init+0x49f>
        if (c->devices[dev_no].is_ata)
c00258ab:	80 3d 68 9c 03 c0 00 	cmpb   $0x0,0xc0039c68
c00258b2:	0f 85 3c 01 00 00    	jne    c00259f4 <ide_init+0x4ae>
c00258b8:	80 3d 7c 9c 03 c0 00 	cmpb   $0x0,0xc0039c7c
c00258bf:	0f 85 3e 01 00 00    	jne    c0025a03 <ide_init+0x4bd>
}
c00258c5:	83 c4 1c             	add    $0x1c,%esp
c00258c8:	5b                   	pop    %ebx
c00258c9:	5e                   	pop    %esi
c00258ca:	5f                   	pop    %edi
c00258cb:	5d                   	pop    %ebp
c00258cc:	c3                   	ret    
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00258cd:	89 ca                	mov    %ecx,%edx
c00258cf:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c00258d0:	3c aa                	cmp    $0xaa,%al
c00258d2:	0f 94 c3             	sete   %bl
c00258d5:	e9 71 fd ff ff       	jmp    c002564b <ide_init+0x105>
c00258da:	89 fa                	mov    %edi,%edx
c00258dc:	ec                   	in     (%dx),%al
c00258dd:	3c aa                	cmp    $0xaa,%al
c00258df:	0f 94 c0             	sete   %al
c00258e2:	89 c6                	mov    %eax,%esi
c00258e4:	e9 a6 fd ff ff       	jmp    c002568f <ide_init+0x149>
      select_device (&c->devices[0]);
c00258e9:	b8 d8 9b 03 c0       	mov    $0xc0039bd8,%eax
c00258ee:	e8 f0 f7 ff ff       	call   c00250e3 <select_device>
      wait_while_busy (&c->devices[0]); 
c00258f3:	b8 d8 9b 03 c0       	mov    $0xc0039bd8,%eax
c00258f8:	e8 25 f9 ff ff       	call   c0025222 <wait_while_busy>
c00258fd:	e9 ea fd ff ff       	jmp    c00256ec <ide_init+0x1a6>
      select_device (&c->devices[1]);
c0025902:	b8 ec 9b 03 c0       	mov    $0xc0039bec,%eax
c0025907:	e8 d7 f7 ff ff       	call   c00250e3 <select_device>
c002590c:	bb b8 0b 00 00       	mov    $0xbb8,%ebx
c0025911:	eb 12                	jmp    c0025925 <ide_init+0x3df>
          timer_msleep (10);
c0025913:	83 ec 08             	sub    $0x8,%esp
c0025916:	6a 00                	push   $0x0
c0025918:	6a 0a                	push   $0xa
c002591a:	e8 c8 e6 ff ff       	call   c0023fe7 <timer_msleep>
      for (i = 0; i < 3000; i++) 
c002591f:	83 c4 10             	add    $0x10,%esp
c0025922:	4b                   	dec    %ebx
c0025923:	74 16                	je     c002593b <ide_init+0x3f5>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025925:	8b 0d 88 9b 03 c0    	mov    0xc0039b88,%ecx
c002592b:	8d 51 02             	lea    0x2(%ecx),%edx
c002592e:	ec                   	in     (%dx),%al
c002592f:	3c 01                	cmp    $0x1,%al
c0025931:	75 e0                	jne    c0025913 <ide_init+0x3cd>
c0025933:	8d 51 03             	lea    0x3(%ecx),%edx
c0025936:	ec                   	in     (%dx),%al
c0025937:	3c 01                	cmp    $0x1,%al
c0025939:	75 d8                	jne    c0025913 <ide_init+0x3cd>
      wait_while_busy (&c->devices[1]);
c002593b:	b8 ec 9b 03 c0       	mov    $0xc0039bec,%eax
c0025940:	e8 dd f8 ff ff       	call   c0025222 <wait_while_busy>
c0025945:	e9 ac fd ff ff       	jmp    c00256f6 <ide_init+0x1b0>
        check_device_type (&c->devices[1]);
c002594a:	b8 ec 9b 03 c0       	mov    $0xc0039bec,%eax
c002594f:	e8 c2 f7 ff ff       	call   c0025116 <check_device_type>
c0025954:	e9 af fd ff ff       	jmp    c0025708 <ide_init+0x1c2>
          identify_ata_device (&c->devices[dev_no]);
c0025959:	b8 d8 9b 03 c0       	mov    $0xc0039bd8,%eax
c002595e:	e8 1c fa ff ff       	call   c002537f <identify_ata_device>
c0025963:	e9 ad fd ff ff       	jmp    c0025715 <ide_init+0x1cf>
c0025968:	b8 ec 9b 03 c0       	mov    $0xc0039bec,%eax
c002596d:	e8 0d fa ff ff       	call   c002537f <identify_ata_device>
c0025972:	e9 ab fd ff ff       	jmp    c0025722 <ide_init+0x1dc>
c0025977:	89 da                	mov    %ebx,%edx
c0025979:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c002597a:	3c aa                	cmp    $0xaa,%al
c002597c:	0f 94 c0             	sete   %al
c002597f:	e9 a2 fe ff ff       	jmp    c0025826 <ide_init+0x2e0>
      select_device (&c->devices[0]);
c0025984:	b8 58 9c 03 c0       	mov    $0xc0039c58,%eax
c0025989:	e8 55 f7 ff ff       	call   c00250e3 <select_device>
      wait_while_busy (&c->devices[0]); 
c002598e:	b8 58 9c 03 c0       	mov    $0xc0039c58,%eax
c0025993:	e8 8a f8 ff ff       	call   c0025222 <wait_while_busy>
c0025998:	e9 f1 fe ff ff       	jmp    c002588e <ide_init+0x348>
      select_device (&c->devices[1]);
c002599d:	b8 6c 9c 03 c0       	mov    $0xc0039c6c,%eax
c00259a2:	e8 3c f7 ff ff       	call   c00250e3 <select_device>
c00259a7:	bb b8 0b 00 00       	mov    $0xbb8,%ebx
c00259ac:	eb 12                	jmp    c00259c0 <ide_init+0x47a>
          timer_msleep (10);
c00259ae:	83 ec 08             	sub    $0x8,%esp
c00259b1:	6a 00                	push   $0x0
c00259b3:	6a 0a                	push   $0xa
c00259b5:	e8 2d e6 ff ff       	call   c0023fe7 <timer_msleep>
      for (i = 0; i < 3000; i++) 
c00259ba:	83 c4 10             	add    $0x10,%esp
c00259bd:	4b                   	dec    %ebx
c00259be:	74 16                	je     c00259d6 <ide_init+0x490>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c00259c0:	8b 0d 08 9c 03 c0    	mov    0xc0039c08,%ecx
c00259c6:	8d 51 02             	lea    0x2(%ecx),%edx
c00259c9:	ec                   	in     (%dx),%al
c00259ca:	3c 01                	cmp    $0x1,%al
c00259cc:	75 e0                	jne    c00259ae <ide_init+0x468>
c00259ce:	8d 51 03             	lea    0x3(%ecx),%edx
c00259d1:	ec                   	in     (%dx),%al
c00259d2:	3c 01                	cmp    $0x1,%al
c00259d4:	75 d8                	jne    c00259ae <ide_init+0x468>
      wait_while_busy (&c->devices[1]);
c00259d6:	b8 6c 9c 03 c0       	mov    $0xc0039c6c,%eax
c00259db:	e8 42 f8 ff ff       	call   c0025222 <wait_while_busy>
c00259e0:	e9 b4 fe ff ff       	jmp    c0025899 <ide_init+0x353>
        check_device_type (&c->devices[1]);
c00259e5:	b8 6c 9c 03 c0       	mov    $0xc0039c6c,%eax
c00259ea:	e8 27 f7 ff ff       	call   c0025116 <check_device_type>
c00259ef:	e9 b7 fe ff ff       	jmp    c00258ab <ide_init+0x365>
          identify_ata_device (&c->devices[dev_no]);
c00259f4:	b8 58 9c 03 c0       	mov    $0xc0039c58,%eax
c00259f9:	e8 81 f9 ff ff       	call   c002537f <identify_ata_device>
c00259fe:	e9 b5 fe ff ff       	jmp    c00258b8 <ide_init+0x372>
c0025a03:	b8 6c 9c 03 c0       	mov    $0xc0039c6c,%eax
c0025a08:	e8 72 f9 ff ff       	call   c002537f <identify_ata_device>
}
c0025a0d:	e9 b3 fe ff ff       	jmp    c00258c5 <ide_init+0x37f>

c0025a12 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0025a12:	83 ec 18             	sub    $0x18,%esp
  intq_init (&buffer);
c0025a15:	68 80 9c 03 c0       	push   $0xc0039c80
c0025a1a:	e8 77 01 00 00       	call   c0025b96 <intq_init>
}
c0025a1f:	83 c4 1c             	add    $0x1c,%esp
c0025a22:	c3                   	ret    

c0025a23 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0025a23:	53                   	push   %ebx
c0025a24:	83 ec 08             	sub    $0x8,%esp
c0025a27:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025a2b:	e8 89 bc ff ff       	call   c00216b9 <intr_get_level>
c0025a30:	85 c0                	test   %eax,%eax
c0025a32:	75 2f                	jne    c0025a63 <input_putc+0x40>
  ASSERT (!intq_full (&buffer));
c0025a34:	83 ec 0c             	sub    $0xc,%esp
c0025a37:	68 80 9c 03 c0       	push   $0xc0039c80
c0025a3c:	e8 c7 01 00 00       	call   c0025c08 <intq_full>
c0025a41:	83 c4 10             	add    $0x10,%esp
c0025a44:	84 c0                	test   %al,%al
c0025a46:	75 39                	jne    c0025a81 <input_putc+0x5e>

  intq_putc (&buffer, key);
c0025a48:	83 ec 08             	sub    $0x8,%esp
c0025a4b:	0f b6 db             	movzbl %bl,%ebx
c0025a4e:	53                   	push   %ebx
c0025a4f:	68 80 9c 03 c0       	push   $0xc0039c80
c0025a54:	e8 0c 04 00 00       	call   c0025e65 <intq_putc>
  serial_notify ();
c0025a59:	e8 5e ed ff ff       	call   c00247bc <serial_notify>
}
c0025a5e:	83 c4 18             	add    $0x18,%esp
c0025a61:	5b                   	pop    %ebx
c0025a62:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025a63:	83 ec 0c             	sub    $0xc,%esp
c0025a66:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0025a6b:	68 3f d9 02 c0       	push   $0xc002d93f
c0025a70:	68 d8 cb 02 c0       	push   $0xc002cbd8
c0025a75:	6a 15                	push   $0x15
c0025a77:	68 b4 ee 02 c0       	push   $0xc002eeb4
c0025a7c:	e8 8c 28 00 00       	call   c002830d <debug_panic>
  ASSERT (!intq_full (&buffer));
c0025a81:	83 ec 0c             	sub    $0xc,%esp
c0025a84:	68 ca ee 02 c0       	push   $0xc002eeca
c0025a89:	68 3f d9 02 c0       	push   $0xc002d93f
c0025a8e:	68 d8 cb 02 c0       	push   $0xc002cbd8
c0025a93:	6a 16                	push   $0x16
c0025a95:	68 b4 ee 02 c0       	push   $0xc002eeb4
c0025a9a:	e8 6e 28 00 00       	call   c002830d <debug_panic>

c0025a9f <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0025a9f:	56                   	push   %esi
c0025aa0:	53                   	push   %ebx
c0025aa1:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0025aa4:	e8 4d bc ff ff       	call   c00216f6 <intr_disable>
c0025aa9:	89 c6                	mov    %eax,%esi
  key = intq_getc (&buffer);
c0025aab:	83 ec 0c             	sub    $0xc,%esp
c0025aae:	68 80 9c 03 c0       	push   $0xc0039c80
c0025ab3:	e8 f2 02 00 00       	call   c0025daa <intq_getc>
c0025ab8:	88 c3                	mov    %al,%bl
  serial_notify ();
c0025aba:	e8 fd ec ff ff       	call   c00247bc <serial_notify>
  intr_set_level (old_level);
c0025abf:	89 34 24             	mov    %esi,(%esp)
c0025ac2:	e8 36 bc ff ff       	call   c00216fd <intr_set_level>
  
  return key;
}
c0025ac7:	88 d8                	mov    %bl,%al
c0025ac9:	83 c4 14             	add    $0x14,%esp
c0025acc:	5b                   	pop    %ebx
c0025acd:	5e                   	pop    %esi
c0025ace:	c3                   	ret    

c0025acf <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0025acf:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0025ad2:	e8 e2 bb ff ff       	call   c00216b9 <intr_get_level>
c0025ad7:	85 c0                	test   %eax,%eax
c0025ad9:	75 11                	jne    c0025aec <input_full+0x1d>
  return intq_full (&buffer);
c0025adb:	83 ec 0c             	sub    $0xc,%esp
c0025ade:	68 80 9c 03 c0       	push   $0xc0039c80
c0025ae3:	e8 20 01 00 00       	call   c0025c08 <intq_full>
}
c0025ae8:	83 c4 1c             	add    $0x1c,%esp
c0025aeb:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025aec:	83 ec 0c             	sub    $0xc,%esp
c0025aef:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0025af4:	68 3f d9 02 c0       	push   $0xc002d93f
c0025af9:	68 cc cb 02 c0       	push   $0xc002cbcc
c0025afe:	6a 32                	push   $0x32
c0025b00:	68 b4 ee 02 c0       	push   $0xc002eeb4
c0025b05:	e8 03 28 00 00       	call   c002830d <debug_panic>

c0025b0a <input_getline>:

/*
 * read a line from input
 */
void
input_getline(char *str, int max_len) {
c0025b0a:	55                   	push   %ebp
c0025b0b:	57                   	push   %edi
c0025b0c:	56                   	push   %esi
c0025b0d:	53                   	push   %ebx
c0025b0e:	83 ec 0c             	sub    $0xc,%esp
c0025b11:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025b15:	8b 7c 24 24          	mov    0x24(%esp),%edi
  int len = 0;
c0025b19:	be 00 00 00 00       	mov    $0x0,%esi
c0025b1e:	eb 2d                	jmp    c0025b4d <input_getline+0x43>
  do {
    char ch = input_getc();
    bool done = false;
    switch (ch) {
c0025b20:	3c 0d                	cmp    $0xd,%al
c0025b22:	74 3f                	je     c0025b63 <input_getline+0x59>
          putbuf("\b \b", 3);
          len--;
        }
        break;
      default:
        if (ch == 0x09 || (ch >= 0x20 && ch <= 0x7E)) {
c0025b24:	80 fb 09             	cmp    $0x9,%bl
c0025b27:	74 07                	je     c0025b30 <input_getline+0x26>
c0025b29:	8d 43 e0             	lea    -0x20(%ebx),%eax
c0025b2c:	3c 5e                	cmp    $0x5e,%al
c0025b2e:	77 16                	ja     c0025b46 <input_getline+0x3c>
          putchar(ch);
c0025b30:	83 ec 0c             	sub    $0xc,%esp
    switch (ch) {
c0025b33:	0f be c3             	movsbl %bl,%eax
          putchar(ch);
c0025b36:	50                   	push   %eax
c0025b37:	e8 84 42 00 00       	call   c0029dc0 <putchar>
          str[len++] = ch;
c0025b3c:	88 5c 35 00          	mov    %bl,0x0(%ebp,%esi,1)
c0025b40:	83 c4 10             	add    $0x10,%esp
c0025b43:	8d 76 01             	lea    0x1(%esi),%esi
        }
        break;
    }
    if (done || len + 1 >= max_len) {
c0025b46:	8d 46 01             	lea    0x1(%esi),%eax
c0025b49:	39 f8                	cmp    %edi,%eax
c0025b4b:	7d 16                	jge    c0025b63 <input_getline+0x59>
    char ch = input_getc();
c0025b4d:	e8 4d ff ff ff       	call   c0025a9f <input_getc>
c0025b52:	88 c3                	mov    %al,%bl
    switch (ch) {
c0025b54:	3c 08                	cmp    $0x8,%al
c0025b56:	74 25                	je     c0025b7d <input_getline+0x73>
c0025b58:	3c 08                	cmp    $0x8,%al
c0025b5a:	77 c4                	ja     c0025b20 <input_getline+0x16>
c0025b5c:	8d 43 fd             	lea    -0x3(%ebx),%eax
c0025b5f:	3c 01                	cmp    $0x1,%al
c0025b61:	77 c1                	ja     c0025b24 <input_getline+0x1a>
      putchar('\n');
c0025b63:	83 ec 0c             	sub    $0xc,%esp
c0025b66:	6a 0a                	push   $0xa
c0025b68:	e8 53 42 00 00       	call   c0029dc0 <putchar>
      break;
    }
  } while (true);
  str[len] = '\0';
c0025b6d:	c6 44 35 00 00       	movb   $0x0,0x0(%ebp,%esi,1)
c0025b72:	83 c4 10             	add    $0x10,%esp
c0025b75:	83 c4 0c             	add    $0xc,%esp
c0025b78:	5b                   	pop    %ebx
c0025b79:	5e                   	pop    %esi
c0025b7a:	5f                   	pop    %edi
c0025b7b:	5d                   	pop    %ebp
c0025b7c:	c3                   	ret    
        if (len > 0) {
c0025b7d:	85 f6                	test   %esi,%esi
c0025b7f:	7e c5                	jle    c0025b46 <input_getline+0x3c>
          putbuf("\b \b", 3);
c0025b81:	83 ec 08             	sub    $0x8,%esp
c0025b84:	6a 03                	push   $0x3
c0025b86:	68 df ee 02 c0       	push   $0xc002eedf
c0025b8b:	e8 ff 41 00 00       	call   c0029d8f <putbuf>
          len--;
c0025b90:	4e                   	dec    %esi
c0025b91:	83 c4 10             	add    $0x10,%esp
c0025b94:	eb b0                	jmp    c0025b46 <input_getline+0x3c>

c0025b96 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c0025b96:	53                   	push   %ebx
c0025b97:	83 ec 14             	sub    $0x14,%esp
c0025b9a:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_init (&q->lock);
c0025b9e:	53                   	push   %ebx
c0025b9f:	e8 5a ce ff ff       	call   c00229fe <lock_init>
  q->not_full = q->not_empty = NULL;
c0025ba4:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
c0025bab:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  q->head = q->tail = 0;
c0025bb2:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
c0025bb9:	00 00 00 
c0025bbc:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
}
c0025bc3:	83 c4 18             	add    $0x18,%esp
c0025bc6:	5b                   	pop    %ebx
c0025bc7:	c3                   	ret    

c0025bc8 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0025bc8:	53                   	push   %ebx
c0025bc9:	83 ec 08             	sub    $0x8,%esp
c0025bcc:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025bd0:	e8 e4 ba ff ff       	call   c00216b9 <intr_get_level>
c0025bd5:	85 c0                	test   %eax,%eax
c0025bd7:	75 11                	jne    c0025bea <intq_empty+0x22>
  return q->head == q->tail;
c0025bd9:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
c0025bdf:	39 43 7c             	cmp    %eax,0x7c(%ebx)
c0025be2:	0f 94 c0             	sete   %al
}
c0025be5:	83 c4 08             	add    $0x8,%esp
c0025be8:	5b                   	pop    %ebx
c0025be9:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025bea:	83 ec 0c             	sub    $0xc,%esp
c0025bed:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0025bf2:	68 3f d9 02 c0       	push   $0xc002d93f
c0025bf7:	68 18 cc 02 c0       	push   $0xc002cc18
c0025bfc:	6a 16                	push   $0x16
c0025bfe:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025c03:	e8 05 27 00 00       	call   c002830d <debug_panic>

c0025c08 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c0025c08:	53                   	push   %ebx
c0025c09:	83 ec 08             	sub    $0x8,%esp
c0025c0c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025c10:	e8 a4 ba ff ff       	call   c00216b9 <intr_get_level>
c0025c15:	85 c0                	test   %eax,%eax
c0025c17:	75 19                	jne    c0025c32 <intq_full+0x2a>

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
  return (pos + 1) % INTQ_BUFSIZE;
c0025c19:	8b 43 7c             	mov    0x7c(%ebx),%eax
c0025c1c:	40                   	inc    %eax
c0025c1d:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0025c22:	78 2c                	js     c0025c50 <intq_full+0x48>
  return next (q->head) == q->tail;
c0025c24:	3b 83 80 00 00 00    	cmp    0x80(%ebx),%eax
c0025c2a:	0f 94 c0             	sete   %al
}
c0025c2d:	83 c4 08             	add    $0x8,%esp
c0025c30:	5b                   	pop    %ebx
c0025c31:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025c32:	83 ec 0c             	sub    $0xc,%esp
c0025c35:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0025c3a:	68 3f d9 02 c0       	push   $0xc002d93f
c0025c3f:	68 0c cc 02 c0       	push   $0xc002cc0c
c0025c44:	6a 1e                	push   $0x1e
c0025c46:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025c4b:	e8 bd 26 00 00       	call   c002830d <debug_panic>
  return (pos + 1) % INTQ_BUFSIZE;
c0025c50:	48                   	dec    %eax
c0025c51:	83 c8 c0             	or     $0xffffffc0,%eax
c0025c54:	40                   	inc    %eax
c0025c55:	eb cd                	jmp    c0025c24 <intq_full+0x1c>

c0025c57 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0025c57:	56                   	push   %esi
c0025c58:	53                   	push   %ebx
c0025c59:	83 ec 04             	sub    $0x4,%esp
c0025c5c:	89 c3                	mov    %eax,%ebx
c0025c5e:	89 d6                	mov    %edx,%esi
  ASSERT (!intr_context ());
c0025c60:	e8 b2 bc ff ff       	call   c0021917 <intr_context>
c0025c65:	84 c0                	test   %al,%al
c0025c67:	75 39                	jne    c0025ca2 <wait+0x4b>
  ASSERT (intr_get_level () == INTR_OFF);
c0025c69:	e8 4b ba ff ff       	call   c00216b9 <intr_get_level>
c0025c6e:	85 c0                	test   %eax,%eax
c0025c70:	75 4e                	jne    c0025cc0 <wait+0x69>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0025c72:	8d 43 38             	lea    0x38(%ebx),%eax
c0025c75:	39 c6                	cmp    %eax,%esi
c0025c77:	74 65                	je     c0025cde <wait+0x87>
c0025c79:	8d 43 34             	lea    0x34(%ebx),%eax
c0025c7c:	39 c6                	cmp    %eax,%esi
c0025c7e:	75 70                	jne    c0025cf0 <wait+0x99>
c0025c80:	83 ec 0c             	sub    $0xc,%esp
c0025c83:	53                   	push   %ebx
c0025c84:	e8 7f ff ff ff       	call   c0025c08 <intq_full>
c0025c89:	83 c4 10             	add    $0x10,%esp
c0025c8c:	84 c0                	test   %al,%al
c0025c8e:	74 60                	je     c0025cf0 <wait+0x99>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0025c90:	e8 f1 ad ff ff       	call   c0020a86 <thread_current>
c0025c95:	89 06                	mov    %eax,(%esi)
  thread_block ();
c0025c97:	e8 10 b5 ff ff       	call   c00211ac <thread_block>
}
c0025c9c:	83 c4 04             	add    $0x4,%esp
c0025c9f:	5b                   	pop    %ebx
c0025ca0:	5e                   	pop    %esi
c0025ca1:	c3                   	ret    
  ASSERT (!intr_context ());
c0025ca2:	83 ec 0c             	sub    $0xc,%esp
c0025ca5:	68 8f dd 02 c0       	push   $0xc002dd8f
c0025caa:	68 3f d9 02 c0       	push   $0xc002d93f
c0025caf:	68 f8 cb 02 c0       	push   $0xc002cbf8
c0025cb4:	6a 59                	push   $0x59
c0025cb6:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025cbb:	e8 4d 26 00 00       	call   c002830d <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0025cc0:	83 ec 0c             	sub    $0xc,%esp
c0025cc3:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0025cc8:	68 3f d9 02 c0       	push   $0xc002d93f
c0025ccd:	68 f8 cb 02 c0       	push   $0xc002cbf8
c0025cd2:	6a 5a                	push   $0x5a
c0025cd4:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025cd9:	e8 2f 26 00 00       	call   c002830d <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0025cde:	83 ec 0c             	sub    $0xc,%esp
c0025ce1:	53                   	push   %ebx
c0025ce2:	e8 e1 fe ff ff       	call   c0025bc8 <intq_empty>
c0025ce7:	83 c4 10             	add    $0x10,%esp
c0025cea:	84 c0                	test   %al,%al
c0025cec:	74 8b                	je     c0025c79 <wait+0x22>
c0025cee:	eb a0                	jmp    c0025c90 <wait+0x39>
c0025cf0:	83 ec 0c             	sub    $0xc,%esp
c0025cf3:	68 f8 ee 02 c0       	push   $0xc002eef8
c0025cf8:	68 3f d9 02 c0       	push   $0xc002d93f
c0025cfd:	68 f8 cb 02 c0       	push   $0xc002cbf8
c0025d02:	6a 5c                	push   $0x5c
c0025d04:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025d09:	e8 ff 25 00 00       	call   c002830d <debug_panic>

c0025d0e <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0025d0e:	56                   	push   %esi
c0025d0f:	53                   	push   %ebx
c0025d10:	83 ec 04             	sub    $0x4,%esp
c0025d13:	89 c6                	mov    %eax,%esi
c0025d15:	89 d3                	mov    %edx,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025d17:	e8 9d b9 ff ff       	call   c00216b9 <intr_get_level>
c0025d1c:	85 c0                	test   %eax,%eax
c0025d1e:	75 3c                	jne    c0025d5c <signal+0x4e>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0025d20:	8d 46 38             	lea    0x38(%esi),%eax
c0025d23:	39 c3                	cmp    %eax,%ebx
c0025d25:	74 53                	je     c0025d7a <signal+0x6c>
c0025d27:	8d 46 34             	lea    0x34(%esi),%eax
c0025d2a:	39 c3                	cmp    %eax,%ebx
c0025d2c:	75 5e                	jne    c0025d8c <signal+0x7e>
c0025d2e:	83 ec 0c             	sub    $0xc,%esp
c0025d31:	56                   	push   %esi
c0025d32:	e8 d1 fe ff ff       	call   c0025c08 <intq_full>
c0025d37:	83 c4 10             	add    $0x10,%esp
c0025d3a:	84 c0                	test   %al,%al
c0025d3c:	75 4e                	jne    c0025d8c <signal+0x7e>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c0025d3e:	8b 03                	mov    (%ebx),%eax
c0025d40:	85 c0                	test   %eax,%eax
c0025d42:	74 12                	je     c0025d56 <signal+0x48>
    {
      thread_unblock (*waiter);
c0025d44:	83 ec 0c             	sub    $0xc,%esp
c0025d47:	50                   	push   %eax
c0025d48:	e8 e0 ae ff ff       	call   c0020c2d <thread_unblock>
      *waiter = NULL;
c0025d4d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
c0025d53:	83 c4 10             	add    $0x10,%esp
    }
}
c0025d56:	83 c4 04             	add    $0x4,%esp
c0025d59:	5b                   	pop    %ebx
c0025d5a:	5e                   	pop    %esi
c0025d5b:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025d5c:	83 ec 0c             	sub    $0xc,%esp
c0025d5f:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0025d64:	68 3f d9 02 c0       	push   $0xc002d93f
c0025d69:	68 f0 cb 02 c0       	push   $0xc002cbf0
c0025d6e:	6a 69                	push   $0x69
c0025d70:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025d75:	e8 93 25 00 00       	call   c002830d <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0025d7a:	83 ec 0c             	sub    $0xc,%esp
c0025d7d:	56                   	push   %esi
c0025d7e:	e8 45 fe ff ff       	call   c0025bc8 <intq_empty>
c0025d83:	83 c4 10             	add    $0x10,%esp
c0025d86:	84 c0                	test   %al,%al
c0025d88:	74 b4                	je     c0025d3e <signal+0x30>
c0025d8a:	eb 9b                	jmp    c0025d27 <signal+0x19>
c0025d8c:	83 ec 0c             	sub    $0xc,%esp
c0025d8f:	68 54 ef 02 c0       	push   $0xc002ef54
c0025d94:	68 3f d9 02 c0       	push   $0xc002d93f
c0025d99:	68 f0 cb 02 c0       	push   $0xc002cbf0
c0025d9e:	6a 6b                	push   $0x6b
c0025da0:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025da5:	e8 63 25 00 00       	call   c002830d <debug_panic>

c0025daa <intq_getc>:
{
c0025daa:	56                   	push   %esi
c0025dab:	53                   	push   %ebx
c0025dac:	83 ec 04             	sub    $0x4,%esp
c0025daf:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025db3:	e8 01 b9 ff ff       	call   c00216b9 <intr_get_level>
c0025db8:	85 c0                	test   %eax,%eax
c0025dba:	75 3b                	jne    c0025df7 <intq_getc+0x4d>
      wait (q, &q->not_empty);
c0025dbc:	8d 73 38             	lea    0x38(%ebx),%esi
  while (intq_empty (q)) 
c0025dbf:	83 ec 0c             	sub    $0xc,%esp
c0025dc2:	53                   	push   %ebx
c0025dc3:	e8 00 fe ff ff       	call   c0025bc8 <intq_empty>
c0025dc8:	83 c4 10             	add    $0x10,%esp
c0025dcb:	84 c0                	test   %al,%al
c0025dcd:	74 64                	je     c0025e33 <intq_getc+0x89>
      ASSERT (!intr_context ());
c0025dcf:	e8 43 bb ff ff       	call   c0021917 <intr_context>
c0025dd4:	84 c0                	test   %al,%al
c0025dd6:	75 3d                	jne    c0025e15 <intq_getc+0x6b>
      lock_acquire (&q->lock);
c0025dd8:	83 ec 0c             	sub    $0xc,%esp
c0025ddb:	53                   	push   %ebx
c0025ddc:	e8 91 cd ff ff       	call   c0022b72 <lock_acquire>
      wait (q, &q->not_empty);
c0025de1:	89 f2                	mov    %esi,%edx
c0025de3:	89 d8                	mov    %ebx,%eax
c0025de5:	e8 6d fe ff ff       	call   c0025c57 <wait>
      lock_release (&q->lock);
c0025dea:	89 1c 24             	mov    %ebx,(%esp)
c0025ded:	e8 1d cf ff ff       	call   c0022d0f <lock_release>
c0025df2:	83 c4 10             	add    $0x10,%esp
c0025df5:	eb c8                	jmp    c0025dbf <intq_getc+0x15>
  ASSERT (intr_get_level () == INTR_OFF);
c0025df7:	83 ec 0c             	sub    $0xc,%esp
c0025dfa:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0025dff:	68 3f d9 02 c0       	push   $0xc002d93f
c0025e04:	68 00 cc 02 c0       	push   $0xc002cc00
c0025e09:	6a 2a                	push   $0x2a
c0025e0b:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025e10:	e8 f8 24 00 00       	call   c002830d <debug_panic>
      ASSERT (!intr_context ());
c0025e15:	83 ec 0c             	sub    $0xc,%esp
c0025e18:	68 8f dd 02 c0       	push   $0xc002dd8f
c0025e1d:	68 3f d9 02 c0       	push   $0xc002d93f
c0025e22:	68 00 cc 02 c0       	push   $0xc002cc00
c0025e27:	6a 2d                	push   $0x2d
c0025e29:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025e2e:	e8 da 24 00 00       	call   c002830d <debug_panic>
  byte = q->buf[q->tail];
c0025e33:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
c0025e39:	0f b6 74 03 3c       	movzbl 0x3c(%ebx,%eax,1),%esi
  return (pos + 1) % INTQ_BUFSIZE;
c0025e3e:	40                   	inc    %eax
c0025e3f:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0025e44:	78 18                	js     c0025e5e <intq_getc+0xb4>
  q->tail = next (q->tail);
c0025e46:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
  signal (q, &q->not_full);
c0025e4c:	8d 53 34             	lea    0x34(%ebx),%edx
c0025e4f:	89 d8                	mov    %ebx,%eax
c0025e51:	e8 b8 fe ff ff       	call   c0025d0e <signal>
}
c0025e56:	89 f0                	mov    %esi,%eax
c0025e58:	83 c4 04             	add    $0x4,%esp
c0025e5b:	5b                   	pop    %ebx
c0025e5c:	5e                   	pop    %esi
c0025e5d:	c3                   	ret    
  return (pos + 1) % INTQ_BUFSIZE;
c0025e5e:	48                   	dec    %eax
c0025e5f:	83 c8 c0             	or     $0xffffffc0,%eax
c0025e62:	40                   	inc    %eax
c0025e63:	eb e1                	jmp    c0025e46 <intq_getc+0x9c>

c0025e65 <intq_putc>:
{
c0025e65:	57                   	push   %edi
c0025e66:	56                   	push   %esi
c0025e67:	53                   	push   %ebx
c0025e68:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0025e6c:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c0025e70:	e8 44 b8 ff ff       	call   c00216b9 <intr_get_level>
c0025e75:	85 c0                	test   %eax,%eax
c0025e77:	75 3b                	jne    c0025eb4 <intq_putc+0x4f>
      wait (q, &q->not_full);
c0025e79:	8d 73 34             	lea    0x34(%ebx),%esi
  while (intq_full (q))
c0025e7c:	83 ec 0c             	sub    $0xc,%esp
c0025e7f:	53                   	push   %ebx
c0025e80:	e8 83 fd ff ff       	call   c0025c08 <intq_full>
c0025e85:	83 c4 10             	add    $0x10,%esp
c0025e88:	84 c0                	test   %al,%al
c0025e8a:	74 64                	je     c0025ef0 <intq_putc+0x8b>
      ASSERT (!intr_context ());
c0025e8c:	e8 86 ba ff ff       	call   c0021917 <intr_context>
c0025e91:	84 c0                	test   %al,%al
c0025e93:	75 3d                	jne    c0025ed2 <intq_putc+0x6d>
      lock_acquire (&q->lock);
c0025e95:	83 ec 0c             	sub    $0xc,%esp
c0025e98:	53                   	push   %ebx
c0025e99:	e8 d4 cc ff ff       	call   c0022b72 <lock_acquire>
      wait (q, &q->not_full);
c0025e9e:	89 f2                	mov    %esi,%edx
c0025ea0:	89 d8                	mov    %ebx,%eax
c0025ea2:	e8 b0 fd ff ff       	call   c0025c57 <wait>
      lock_release (&q->lock);
c0025ea7:	89 1c 24             	mov    %ebx,(%esp)
c0025eaa:	e8 60 ce ff ff       	call   c0022d0f <lock_release>
c0025eaf:	83 c4 10             	add    $0x10,%esp
c0025eb2:	eb c8                	jmp    c0025e7c <intq_putc+0x17>
  ASSERT (intr_get_level () == INTR_OFF);
c0025eb4:	83 ec 0c             	sub    $0xc,%esp
c0025eb7:	68 d2 dc 02 c0       	push   $0xc002dcd2
c0025ebc:	68 3f d9 02 c0       	push   $0xc002d93f
c0025ec1:	68 e4 cb 02 c0       	push   $0xc002cbe4
c0025ec6:	6a 3f                	push   $0x3f
c0025ec8:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025ecd:	e8 3b 24 00 00       	call   c002830d <debug_panic>
      ASSERT (!intr_context ());
c0025ed2:	83 ec 0c             	sub    $0xc,%esp
c0025ed5:	68 8f dd 02 c0       	push   $0xc002dd8f
c0025eda:	68 3f d9 02 c0       	push   $0xc002d93f
c0025edf:	68 e4 cb 02 c0       	push   $0xc002cbe4
c0025ee4:	6a 42                	push   $0x42
c0025ee6:	68 e3 ee 02 c0       	push   $0xc002eee3
c0025eeb:	e8 1d 24 00 00       	call   c002830d <debug_panic>
  q->buf[q->head] = byte;
c0025ef0:	8b 43 7c             	mov    0x7c(%ebx),%eax
c0025ef3:	89 f9                	mov    %edi,%ecx
c0025ef5:	88 4c 03 3c          	mov    %cl,0x3c(%ebx,%eax,1)
  return (pos + 1) % INTQ_BUFSIZE;
c0025ef9:	40                   	inc    %eax
c0025efa:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0025eff:	78 11                	js     c0025f12 <intq_putc+0xad>
  q->head = next (q->head);
c0025f01:	89 43 7c             	mov    %eax,0x7c(%ebx)
  signal (q, &q->not_empty);
c0025f04:	8d 53 38             	lea    0x38(%ebx),%edx
c0025f07:	89 d8                	mov    %ebx,%eax
c0025f09:	e8 00 fe ff ff       	call   c0025d0e <signal>
}
c0025f0e:	5b                   	pop    %ebx
c0025f0f:	5e                   	pop    %esi
c0025f10:	5f                   	pop    %edi
c0025f11:	c3                   	ret    
  return (pos + 1) % INTQ_BUFSIZE;
c0025f12:	48                   	dec    %eax
c0025f13:	83 c8 c0             	or     $0xffffffc0,%eax
c0025f16:	40                   	inc    %eax
c0025f17:	eb e8                	jmp    c0025f01 <intq_putc+0x9c>

c0025f19 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0025f19:	55                   	push   %ebp
c0025f1a:	57                   	push   %edi
c0025f1b:	56                   	push   %esi
c0025f1c:	53                   	push   %ebx
c0025f1d:	83 ec 18             	sub    $0x18,%esp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f20:	bf 00 00 00 00       	mov    $0x0,%edi
c0025f25:	89 f8                	mov    %edi,%eax
c0025f27:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f29:	e4 71                	in     $0x71,%al
c0025f2b:	88 c2                	mov    %al,%dl
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f2d:	b0 02                	mov    $0x2,%al
c0025f2f:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f31:	e4 71                	in     $0x71,%al
c0025f33:	88 04 24             	mov    %al,(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f36:	b0 04                	mov    $0x4,%al
c0025f38:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f3a:	e4 71                	in     $0x71,%al
c0025f3c:	88 44 24 13          	mov    %al,0x13(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f40:	b0 07                	mov    $0x7,%al
c0025f42:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f44:	e4 71                	in     $0x71,%al
c0025f46:	89 c5                	mov    %eax,%ebp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f48:	b0 08                	mov    $0x8,%al
c0025f4a:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f4c:	e4 71                	in     $0x71,%al
c0025f4e:	88 c3                	mov    %al,%bl
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f50:	b0 09                	mov    $0x9,%al
c0025f52:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f54:	e4 71                	in     $0x71,%al
c0025f56:	89 c6                	mov    %eax,%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f58:	89 f8                	mov    %edi,%eax
c0025f5a:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f5c:	e4 71                	in     $0x71,%al

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c0025f5e:	88 c1                	mov    %al,%cl
c0025f60:	c0 e9 04             	shr    $0x4,%cl
c0025f63:	0f b6 c9             	movzbl %cl,%ecx
c0025f66:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0025f69:	01 c9                	add    %ecx,%ecx
c0025f6b:	83 e0 0f             	and    $0xf,%eax
c0025f6e:	01 c8                	add    %ecx,%eax
c0025f70:	88 d1                	mov    %dl,%cl
c0025f72:	c0 e9 04             	shr    $0x4,%cl
c0025f75:	0f b6 c9             	movzbl %cl,%ecx
c0025f78:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0025f7b:	01 c9                	add    %ecx,%ecx
c0025f7d:	83 e2 0f             	and    $0xf,%edx
c0025f80:	01 ca                	add    %ecx,%edx
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c0025f82:	39 d0                	cmp    %edx,%eax
c0025f84:	75 9f                	jne    c0025f25 <rtc_get_time+0xc>
  return (x & 0x0f) + ((x >> 4) * 10);
c0025f86:	89 f2                	mov    %esi,%edx
c0025f88:	c0 ea 04             	shr    $0x4,%dl
c0025f8b:	0f b6 d2             	movzbl %dl,%edx
c0025f8e:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0025f91:	01 d2                	add    %edx,%edx
c0025f93:	83 e6 0f             	and    $0xf,%esi
c0025f96:	01 d6                	add    %edx,%esi
  if (year < 70)
c0025f98:	83 fe 45             	cmp    $0x45,%esi
c0025f9b:	7f 03                	jg     c0025fa0 <rtc_get_time+0x87>
    year += 100;
c0025f9d:	83 c6 64             	add    $0x64,%esi
  return (x & 0x0f) + ((x >> 4) * 10);
c0025fa0:	88 da                	mov    %bl,%dl
c0025fa2:	c0 ea 04             	shr    $0x4,%dl
c0025fa5:	0f b6 d2             	movzbl %dl,%edx
c0025fa8:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0025fab:	01 d2                	add    %edx,%edx
c0025fad:	83 e3 0f             	and    $0xf,%ebx
c0025fb0:	01 d3                	add    %edx,%ebx
  year -= 70;
c0025fb2:	8d 7e ba             	lea    -0x46(%esi),%edi
c0025fb5:	89 7c 24 14          	mov    %edi,0x14(%esp)
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0025fb9:	83 ee 47             	sub    $0x47,%esi
c0025fbc:	89 f2                	mov    %esi,%edx
c0025fbe:	85 f6                	test   %esi,%esi
c0025fc0:	0f 88 de 00 00 00    	js     c00260a4 <rtc_get_time+0x18b>
c0025fc6:	c1 fa 02             	sar    $0x2,%edx
c0025fc9:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0025fcd:	8d 0c ff             	lea    (%edi,%edi,8),%ecx
c0025fd0:	8d 0c cf             	lea    (%edi,%ecx,8),%ecx
c0025fd3:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0025fd6:	01 ca                	add    %ecx,%edx
c0025fd8:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0025fdb:	8d 0c 8a             	lea    (%edx,%ecx,4),%ecx
c0025fde:	8d 3c ca             	lea    (%edx,%ecx,8),%edi
c0025fe1:	c1 e7 02             	shl    $0x2,%edi
c0025fe4:	29 d7                	sub    %edx,%edi
c0025fe6:	c1 e7 07             	shl    $0x7,%edi
  for (i = 1; i <= mon; i++)
c0025fe9:	85 db                	test   %ebx,%ebx
c0025feb:	7e 24                	jle    c0026011 <rtc_get_time+0xf8>
c0025fed:	be 01 00 00 00       	mov    $0x1,%esi
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0025ff2:	8b 0c b5 3c cc 02 c0 	mov    -0x3ffd33c4(,%esi,4),%ecx
c0025ff9:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
c0025ffc:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c0025fff:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
c0026002:	c1 e2 02             	shl    $0x2,%edx
c0026005:	29 ca                	sub    %ecx,%edx
c0026007:	c1 e2 07             	shl    $0x7,%edx
c002600a:	01 d7                	add    %edx,%edi
  for (i = 1; i <= mon; i++)
c002600c:	46                   	inc    %esi
c002600d:	39 de                	cmp    %ebx,%esi
c002600f:	7e e1                	jle    c0025ff2 <rtc_get_time+0xd9>
  if (mon > 2 && year % 4 == 0)
c0026011:	83 fb 02             	cmp    $0x2,%ebx
c0026014:	7e 0d                	jle    c0026023 <rtc_get_time+0x10a>
c0026016:	f6 44 24 14 03       	testb  $0x3,0x14(%esp)
c002601b:	75 06                	jne    c0026023 <rtc_get_time+0x10a>
    time += 24 * 60 * 60;
c002601d:	81 c7 80 51 01 00    	add    $0x15180,%edi
  return (x & 0x0f) + ((x >> 4) * 10);
c0026023:	8a 5c 24 13          	mov    0x13(%esp),%bl
c0026027:	88 da                	mov    %bl,%dl
c0026029:	c0 ea 04             	shr    $0x4,%dl
c002602c:	0f b6 d2             	movzbl %dl,%edx
c002602f:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026032:	01 c9                	add    %ecx,%ecx
c0026034:	89 da                	mov    %ebx,%edx
c0026036:	83 e2 0f             	and    $0xf,%edx
c0026039:	01 ca                	add    %ecx,%edx
  time += hour * 60 * 60;
c002603b:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
c002603e:	01 d1                	add    %edx,%ecx
c0026040:	01 c9                	add    %ecx,%ecx
c0026042:	01 d1                	add    %edx,%ecx
c0026044:	c1 e1 05             	shl    $0x5,%ecx
c0026047:	01 d1                	add    %edx,%ecx
c0026049:	c1 e1 04             	shl    $0x4,%ecx
  return (x & 0x0f) + ((x >> 4) * 10);
c002604c:	8a 14 24             	mov    (%esp),%dl
c002604f:	c0 ea 04             	shr    $0x4,%dl
c0026052:	0f b6 d2             	movzbl %dl,%edx
c0026055:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026058:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
c002605b:	8b 14 24             	mov    (%esp),%edx
c002605e:	83 e2 0f             	and    $0xf,%edx
c0026061:	01 da                	add    %ebx,%edx
  time += min * 60;
c0026063:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
c0026066:	01 da                	add    %ebx,%edx
c0026068:	8d 14 92             	lea    (%edx,%edx,4),%edx
  time += sec;
c002606b:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c002606e:	01 d0                	add    %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c0026070:	89 ea                	mov    %ebp,%edx
c0026072:	c0 ea 04             	shr    $0x4,%dl
c0026075:	0f b6 d2             	movzbl %dl,%edx
c0026078:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002607b:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
c002607e:	89 ea                	mov    %ebp,%edx
c0026080:	83 e2 0f             	and    $0xf,%edx
  time += (mday - 1) * 24 * 60 * 60;
c0026083:	8d 4c 11 ff          	lea    -0x1(%ecx,%edx,1),%ecx
c0026087:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
c002608a:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c002608d:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
c0026090:	c1 e2 02             	shl    $0x2,%edx
c0026093:	29 ca                	sub    %ecx,%edx
c0026095:	c1 e2 07             	shl    $0x7,%edx
  time += sec;
c0026098:	01 d0                	add    %edx,%eax
c002609a:	01 f8                	add    %edi,%eax
}
c002609c:	83 c4 18             	add    $0x18,%esp
c002609f:	5b                   	pop    %ebx
c00260a0:	5e                   	pop    %esi
c00260a1:	5f                   	pop    %edi
c00260a2:	5d                   	pop    %ebp
c00260a3:	c3                   	ret    
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c00260a4:	8d 56 03             	lea    0x3(%esi),%edx
c00260a7:	e9 1a ff ff ff       	jmp    c0025fc6 <rtc_get_time+0xad>

c00260ac <shutdown_configure>:
/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
  how = type;
c00260ac:	8b 44 24 04          	mov    0x4(%esp),%eax
c00260b0:	a3 04 9d 03 c0       	mov    %eax,0xc0039d04
c00260b5:	c3                   	ret    

c00260b6 <shutdown_reboot>:
}

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c00260b6:	56                   	push   %esi
c00260b7:	53                   	push   %ebx
c00260b8:	83 ec 10             	sub    $0x10,%esp
  printf ("Rebooting...\n");
c00260bb:	68 af ef 02 c0       	push   $0xc002efaf
c00260c0:	e8 8f 3c 00 00       	call   c0029d54 <puts>
c00260c5:	83 c4 10             	add    $0x10,%esp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00260c8:	be fe ff ff ff       	mov    $0xfffffffe,%esi
c00260cd:	eb 1f                	jmp    c00260ee <shutdown_reboot+0x38>
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
          timer_udelay (2);
        }

      timer_udelay (50);
c00260cf:	83 ec 08             	sub    $0x8,%esp
c00260d2:	6a 00                	push   $0x0
c00260d4:	6a 32                	push   $0x32
c00260d6:	e8 70 df ff ff       	call   c002404b <timer_udelay>
c00260db:	89 f0                	mov    %esi,%eax
c00260dd:	e6 64                	out    %al,$0x64

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
      timer_udelay (50);
c00260df:	83 c4 08             	add    $0x8,%esp
c00260e2:	6a 00                	push   $0x0
c00260e4:	6a 32                	push   $0x32
c00260e6:	e8 60 df ff ff       	call   c002404b <timer_udelay>
    {
c00260eb:	83 c4 10             	add    $0x10,%esp
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00260ee:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c00260f0:	a8 02                	test   $0x2,%al
c00260f2:	74 db                	je     c00260cf <shutdown_reboot+0x19>
          timer_udelay (2);
c00260f4:	83 ec 08             	sub    $0x8,%esp
c00260f7:	6a 00                	push   $0x0
c00260f9:	6a 02                	push   $0x2
c00260fb:	e8 4b df ff ff       	call   c002404b <timer_udelay>
c0026100:	83 c4 10             	add    $0x10,%esp
c0026103:	bb ff ff 00 00       	mov    $0xffff,%ebx
c0026108:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c002610a:	a8 02                	test   $0x2,%al
c002610c:	74 c1                	je     c00260cf <shutdown_reboot+0x19>
          timer_udelay (2);
c002610e:	83 ec 08             	sub    $0x8,%esp
c0026111:	6a 00                	push   $0x0
c0026113:	6a 02                	push   $0x2
c0026115:	e8 31 df ff ff       	call   c002404b <timer_udelay>
      for (i = 0; i < 0x10000; i++)
c002611a:	83 c4 10             	add    $0x10,%esp
c002611d:	4b                   	dec    %ebx
c002611e:	75 e8                	jne    c0026108 <shutdown_reboot+0x52>
c0026120:	eb ad                	jmp    c00260cf <shutdown_reboot+0x19>

c0026122 <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026122:	57                   	push   %edi
c0026123:	56                   	push   %esi
c0026124:	83 ec 14             	sub    $0x14,%esp
  const char s[] = "Shutdown";
c0026127:	8d 7c 24 07          	lea    0x7(%esp),%edi
c002612b:	be dd ef 02 c0       	mov    $0xc002efdd,%esi
c0026130:	b9 09 00 00 00       	mov    $0x9,%ecx
c0026135:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
  timer_print_stats ();
c0026137:	e8 41 df ff ff       	call   c002407d <timer_print_stats>
  thread_print_stats ();
c002613c:	e8 18 a9 ff ff       	call   c0020a59 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c0026141:	e8 bd 3b 00 00       	call   c0029d03 <console_print_stats>
  kbd_print_stats ();
c0026146:	e8 43 e1 ff ff       	call   c002428e <kbd_print_stats>
  printf ("Powering off...\n");
c002614b:	83 ec 0c             	sub    $0xc,%esp
c002614e:	68 bc ef 02 c0       	push   $0xc002efbc
c0026153:	e8 fc 3b 00 00       	call   c0029d54 <puts>
  serial_flush ();
c0026158:	e8 18 e6 ff ff       	call   c0024775 <serial_flush>
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c002615d:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c0026162:	b8 00 20 00 00       	mov    $0x2000,%eax
c0026167:	66 ef                	out    %ax,(%dx)
  for (p = s; *p != '\0'; p++)
c0026169:	8a 44 24 17          	mov    0x17(%esp),%al
c002616d:	83 c4 10             	add    $0x10,%esp
c0026170:	84 c0                	test   %al,%al
c0026172:	74 11                	je     c0026185 <shutdown_power_off+0x63>
c0026174:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026178:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c002617d:	ee                   	out    %al,(%dx)
c002617e:	41                   	inc    %ecx
c002617f:	8a 01                	mov    (%ecx),%al
c0026181:	84 c0                	test   %al,%al
c0026183:	75 f8                	jne    c002617d <shutdown_power_off+0x5b>
c0026185:	ba 01 05 00 00       	mov    $0x501,%edx
c002618a:	b0 31                	mov    $0x31,%al
c002618c:	ee                   	out    %al,(%dx)
  asm volatile ("cli; hlt" : : : "memory");
c002618d:	fa                   	cli    
c002618e:	f4                   	hlt    
  printf ("still running...\n");
c002618f:	83 ec 0c             	sub    $0xc,%esp
c0026192:	68 cc ef 02 c0       	push   $0xc002efcc
c0026197:	e8 b8 3b 00 00       	call   c0029d54 <puts>
c002619c:	83 c4 10             	add    $0x10,%esp
c002619f:	eb fe                	jmp    c002619f <shutdown_power_off+0x7d>

c00261a1 <shutdown>:
{
c00261a1:	83 ec 0c             	sub    $0xc,%esp
  switch (how)
c00261a4:	a1 04 9d 03 c0       	mov    0xc0039d04,%eax
c00261a9:	83 f8 01             	cmp    $0x1,%eax
c00261ac:	74 09                	je     c00261b7 <shutdown+0x16>
c00261ae:	83 f8 02             	cmp    $0x2,%eax
c00261b1:	74 09                	je     c00261bc <shutdown+0x1b>
}
c00261b3:	83 c4 0c             	add    $0xc,%esp
c00261b6:	c3                   	ret    
      shutdown_power_off ();
c00261b7:	e8 66 ff ff ff       	call   c0026122 <shutdown_power_off>
      shutdown_reboot ();
c00261bc:	e8 f5 fe ff ff       	call   c00260b6 <shutdown_reboot>

c00261c1 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c00261c1:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_disable ();
c00261c4:	e8 2d b5 ff ff       	call   c00216f6 <intr_disable>
c00261c9:	89 c2                	mov    %eax,%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00261cb:	e4 61                	in     $0x61,%al
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00261cd:	83 e0 fc             	and    $0xfffffffc,%eax
c00261d0:	e6 61                	out    %al,$0x61
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
  intr_set_level (old_level);
c00261d2:	83 ec 0c             	sub    $0xc,%esp
c00261d5:	52                   	push   %edx
c00261d6:	e8 22 b5 ff ff       	call   c00216fd <intr_set_level>
}
c00261db:	83 c4 1c             	add    $0x1c,%esp
c00261de:	c3                   	ret    

c00261df <speaker_on>:
{
c00261df:	56                   	push   %esi
c00261e0:	53                   	push   %ebx
c00261e1:	83 ec 04             	sub    $0x4,%esp
c00261e4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (frequency >= 20 && frequency <= 20000)
c00261e8:	8d 43 ec             	lea    -0x14(%ebx),%eax
c00261eb:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c00261f0:	76 0b                	jbe    c00261fd <speaker_on+0x1e>
      speaker_off ();
c00261f2:	e8 ca ff ff ff       	call   c00261c1 <speaker_off>
}
c00261f7:	83 c4 04             	add    $0x4,%esp
c00261fa:	5b                   	pop    %ebx
c00261fb:	5e                   	pop    %esi
c00261fc:	c3                   	ret    
      enum intr_level old_level = intr_disable ();
c00261fd:	e8 f4 b4 ff ff       	call   c00216f6 <intr_disable>
c0026202:	89 c6                	mov    %eax,%esi
      pit_configure_channel (2, 3, frequency);
c0026204:	83 ec 04             	sub    $0x4,%esp
c0026207:	53                   	push   %ebx
c0026208:	6a 03                	push   $0x3
c002620a:	6a 02                	push   $0x2
c002620c:	e8 95 d9 ff ff       	call   c0023ba6 <pit_configure_channel>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026211:	e4 61                	in     $0x61,%al
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026213:	83 c8 03             	or     $0x3,%eax
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026216:	e6 61                	out    %al,$0x61
      intr_set_level (old_level);
c0026218:	89 34 24             	mov    %esi,(%esp)
c002621b:	e8 dd b4 ff ff       	call   c00216fd <intr_set_level>
c0026220:	83 c4 10             	add    $0x10,%esp
c0026223:	eb d2                	jmp    c00261f7 <speaker_on+0x18>

c0026225 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0026225:	83 ec 0c             	sub    $0xc,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026228:	e8 8c b4 ff ff       	call   c00216b9 <intr_get_level>
c002622d:	83 f8 01             	cmp    $0x1,%eax
c0026230:	74 04                	je     c0026236 <speaker_beep+0x11>
    {
      speaker_on (440);
      timer_msleep (250);
      speaker_off ();
    }
}
c0026232:	83 c4 0c             	add    $0xc,%esp
c0026235:	c3                   	ret    
      speaker_on (440);
c0026236:	83 ec 0c             	sub    $0xc,%esp
c0026239:	68 b8 01 00 00       	push   $0x1b8
c002623e:	e8 9c ff ff ff       	call   c00261df <speaker_on>
      timer_msleep (250);
c0026243:	83 c4 08             	add    $0x8,%esp
c0026246:	6a 00                	push   $0x0
c0026248:	68 fa 00 00 00       	push   $0xfa
c002624d:	e8 95 dd ff ff       	call   c0023fe7 <timer_msleep>
      speaker_off ();
c0026252:	e8 6a ff ff ff       	call   c00261c1 <speaker_off>
c0026257:	83 c4 10             	add    $0x10,%esp
}
c002625a:	eb d6                	jmp    c0026232 <speaker_beep+0xd>

c002625c <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c002625c:	55                   	push   %ebp
c002625d:	89 e5                	mov    %esp,%ebp
c002625f:	53                   	push   %ebx
c0026260:	83 ec 0c             	sub    $0xc,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026263:	ff 75 04             	pushl  0x4(%ebp)
c0026266:	68 e6 ef 02 c0       	push   $0xc002efe6
c002626b:	e8 ef 05 00 00       	call   c002685f <printf>
  for (frame = __builtin_frame_address (1);
c0026270:	8b 5d 00             	mov    0x0(%ebp),%ebx
c0026273:	83 c4 10             	add    $0x10,%esp
c0026276:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c002627c:	76 27                	jbe    c00262a5 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c002627e:	83 3b 00             	cmpl   $0x0,(%ebx)
c0026281:	74 22                	je     c00262a5 <debug_backtrace+0x49>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026283:	83 ec 08             	sub    $0x8,%esp
c0026286:	ff 73 04             	pushl  0x4(%ebx)
c0026289:	68 f1 ef 02 c0       	push   $0xc002eff1
c002628e:	e8 cc 05 00 00       	call   c002685f <printf>
       frame = frame[0]) 
c0026293:	8b 1b                	mov    (%ebx),%ebx
  for (frame = __builtin_frame_address (1);
c0026295:	83 c4 10             	add    $0x10,%esp
c0026298:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c002629e:	76 05                	jbe    c00262a5 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c00262a0:	83 3b 00             	cmpl   $0x0,(%ebx)
c00262a3:	75 de                	jne    c0026283 <debug_backtrace+0x27>
  printf (".\n");
c00262a5:	83 ec 0c             	sub    $0xc,%esp
c00262a8:	68 7b eb 02 c0       	push   $0xc002eb7b
c00262ad:	e8 a2 3a 00 00       	call   c0029d54 <puts>

  if (!explained) 
c00262b2:	83 c4 10             	add    $0x10,%esp
c00262b5:	80 3d 08 9d 03 c0 00 	cmpb   $0x0,0xc0039d08
c00262bc:	74 05                	je     c00262c3 <debug_backtrace+0x67>
      explained = true;
      printf ("The `backtrace' program can make call stacks useful.\n"
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c00262be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00262c1:	c9                   	leave  
c00262c2:	c3                   	ret    
      explained = true;
c00262c3:	c6 05 08 9d 03 c0 01 	movb   $0x1,0xc0039d08
      printf ("The `backtrace' program can make call stacks useful.\n"
c00262ca:	83 ec 0c             	sub    $0xc,%esp
c00262cd:	68 f8 ef 02 c0       	push   $0xc002eff8
c00262d2:	e8 7d 3a 00 00       	call   c0029d54 <puts>
c00262d7:	83 c4 10             	add    $0x10,%esp
}
c00262da:	eb e2                	jmp    c00262be <debug_backtrace+0x62>

c00262dc <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c00262dc:	56                   	push   %esi
c00262dd:	53                   	push   %ebx
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c00262de:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c00262e3:	88 80 40 9d 03 c0    	mov    %al,-0x3ffc62c0(%eax)
  for (i = 0; i < 256; i++) 
c00262e9:	40                   	inc    %eax
c00262ea:	3d 00 01 00 00       	cmp    $0x100,%eax
c00262ef:	75 f2                	jne    c00262e3 <random_init+0x7>
c00262f1:	be 00 00 00 00       	mov    $0x0,%esi
c00262f6:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = j = 0; i < 256; i++) 
    {
      j += s[i] + seedp[i % sizeof seed];
c00262fb:	89 c1                	mov    %eax,%ecx
c00262fd:	83 e1 03             	and    $0x3,%ecx
c0026300:	8a 98 40 9d 03 c0    	mov    -0x3ffc62c0(%eax),%bl
c0026306:	88 da                	mov    %bl,%dl
c0026308:	02 54 0c 0c          	add    0xc(%esp,%ecx,1),%dl
c002630c:	88 d1                	mov    %dl,%cl
c002630e:	01 ce                	add    %ecx,%esi
      swap_byte (s + i, s + j);
c0026310:	89 f2                	mov    %esi,%edx
c0026312:	0f b6 ca             	movzbl %dl,%ecx
  *a = *b;
c0026315:	8a 91 40 9d 03 c0    	mov    -0x3ffc62c0(%ecx),%dl
c002631b:	88 90 40 9d 03 c0    	mov    %dl,-0x3ffc62c0(%eax)
  *b = t;
c0026321:	88 99 40 9d 03 c0    	mov    %bl,-0x3ffc62c0(%ecx)
  for (i = j = 0; i < 256; i++) 
c0026327:	40                   	inc    %eax
c0026328:	3d 00 01 00 00       	cmp    $0x100,%eax
c002632d:	75 cc                	jne    c00262fb <random_init+0x1f>
    }

  s_i = s_j = 0;
c002632f:	c6 05 21 9d 03 c0 00 	movb   $0x0,0xc0039d21
c0026336:	c6 05 22 9d 03 c0 00 	movb   $0x0,0xc0039d22
  inited = true;
c002633d:	c6 05 20 9d 03 c0 01 	movb   $0x1,0xc0039d20
}
c0026344:	5b                   	pop    %ebx
c0026345:	5e                   	pop    %esi
c0026346:	c3                   	ret    

c0026347 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026347:	55                   	push   %ebp
c0026348:	57                   	push   %edi
c0026349:	56                   	push   %esi
c002634a:	53                   	push   %ebx
c002634b:	83 ec 04             	sub    $0x4,%esp
c002634e:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint8_t *buf;

  if (!inited)
c0026352:	80 3d 20 9d 03 c0 00 	cmpb   $0x0,0xc0039d20
c0026359:	0f 84 8c 00 00 00    	je     c00263eb <random_bytes+0xa4>
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c002635f:	8d 6f ff             	lea    -0x1(%edi),%ebp
c0026362:	85 ff                	test   %edi,%edi
c0026364:	74 7d                	je     c00263e3 <random_bytes+0x9c>
c0026366:	0f b6 35 21 9d 03 c0 	movzbl 0xc0039d21,%esi
c002636d:	a0 22 9d 03 c0       	mov    0xc0039d22,%al
c0026372:	40                   	inc    %eax
c0026373:	88 44 24 03          	mov    %al,0x3(%esp)
c0026377:	03 7c 24 18          	add    0x18(%esp),%edi
c002637b:	88 44 24 01          	mov    %al,0x1(%esp)
c002637f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    {
      uint8_t s_k;
      
      s_i++;
      s_j += s[s_i];
c0026383:	0f b6 54 24 01       	movzbl 0x1(%esp),%edx
c0026388:	89 f3                	mov    %esi,%ebx
c002638a:	02 9a 40 9d 03 c0    	add    -0x3ffc62c0(%edx),%bl
c0026390:	89 de                	mov    %ebx,%esi
      swap_byte (s + s_i, s + s_j);
c0026392:	0f b6 c3             	movzbl %bl,%eax
  uint8_t t = *a;
c0026395:	8a 9a 40 9d 03 c0    	mov    -0x3ffc62c0(%edx),%bl
c002639b:	88 5c 24 02          	mov    %bl,0x2(%esp)
  *a = *b;
c002639f:	8a 98 40 9d 03 c0    	mov    -0x3ffc62c0(%eax),%bl
c00263a5:	88 9a 40 9d 03 c0    	mov    %bl,-0x3ffc62c0(%edx)
  *b = t;
c00263ab:	8a 5c 24 02          	mov    0x2(%esp),%bl
c00263af:	88 98 40 9d 03 c0    	mov    %bl,-0x3ffc62c0(%eax)

      s_k = s[s_i] + s[s_j];
c00263b5:	88 d8                	mov    %bl,%al
c00263b7:	02 82 40 9d 03 c0    	add    -0x3ffc62c0(%edx),%al
      *buf = s[s_k];
c00263bd:	0f b6 c0             	movzbl %al,%eax
c00263c0:	8a 90 40 9d 03 c0    	mov    -0x3ffc62c0(%eax),%dl
c00263c6:	88 11                	mov    %dl,(%ecx)
  for (buf = buf_; size-- > 0; buf++)
c00263c8:	41                   	inc    %ecx
c00263c9:	fe 44 24 01          	incb   0x1(%esp)
c00263cd:	39 f9                	cmp    %edi,%ecx
c00263cf:	75 b2                	jne    c0026383 <random_bytes+0x3c>
c00263d1:	8a 44 24 03          	mov    0x3(%esp),%al
c00263d5:	01 e8                	add    %ebp,%eax
c00263d7:	a2 22 9d 03 c0       	mov    %al,0xc0039d22
c00263dc:	89 f0                	mov    %esi,%eax
c00263de:	a2 21 9d 03 c0       	mov    %al,0xc0039d21
    }
}
c00263e3:	83 c4 04             	add    $0x4,%esp
c00263e6:	5b                   	pop    %ebx
c00263e7:	5e                   	pop    %esi
c00263e8:	5f                   	pop    %edi
c00263e9:	5d                   	pop    %ebp
c00263ea:	c3                   	ret    
    random_init (0);
c00263eb:	6a 00                	push   $0x0
c00263ed:	e8 ea fe ff ff       	call   c00262dc <random_init>
c00263f2:	83 c4 04             	add    $0x4,%esp
c00263f5:	e9 65 ff ff ff       	jmp    c002635f <random_bytes+0x18>

c00263fa <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c00263fa:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c00263fd:	6a 04                	push   $0x4
c00263ff:	8d 44 24 10          	lea    0x10(%esp),%eax
c0026403:	50                   	push   %eax
c0026404:	e8 3e ff ff ff       	call   c0026347 <random_bytes>
  return ul;
}
c0026409:	8b 44 24 14          	mov    0x14(%esp),%eax
c002640d:	83 c4 18             	add    $0x18,%esp
c0026410:	c3                   	ret    

c0026411 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0026411:	53                   	push   %ebx
c0026412:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0026416:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c002641a:	8b 50 04             	mov    0x4(%eax),%edx
c002641d:	8d 4a 01             	lea    0x1(%edx),%ecx
c0026420:	89 48 04             	mov    %ecx,0x4(%eax)
c0026423:	3b 50 08             	cmp    0x8(%eax),%edx
c0026426:	7d 09                	jge    c0026431 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c0026428:	8b 10                	mov    (%eax),%edx
c002642a:	8d 4a 01             	lea    0x1(%edx),%ecx
c002642d:	89 08                	mov    %ecx,(%eax)
c002642f:	88 1a                	mov    %bl,(%edx)
}
c0026431:	5b                   	pop    %ebx
c0026432:	c3                   	ret    

c0026433 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0026433:	55                   	push   %ebp
c0026434:	57                   	push   %edi
c0026435:	56                   	push   %esi
c0026436:	53                   	push   %ebx
c0026437:	83 ec 0c             	sub    $0xc,%esp
c002643a:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c002643e:	85 d2                	test   %edx,%edx
c0026440:	74 18                	je     c002645a <output_dup+0x27>
c0026442:	8d 5a ff             	lea    -0x1(%edx),%ebx
c0026445:	89 cd                	mov    %ecx,%ebp
    output (ch, aux);
c0026447:	0f be f0             	movsbl %al,%esi
c002644a:	83 ec 08             	sub    $0x8,%esp
c002644d:	57                   	push   %edi
c002644e:	56                   	push   %esi
c002644f:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c0026451:	4b                   	dec    %ebx
c0026452:	83 c4 10             	add    $0x10,%esp
c0026455:	83 fb ff             	cmp    $0xffffffff,%ebx
c0026458:	75 f0                	jne    c002644a <output_dup+0x17>
}
c002645a:	83 c4 0c             	add    $0xc,%esp
c002645d:	5b                   	pop    %ebx
c002645e:	5e                   	pop    %esi
c002645f:	5f                   	pop    %edi
c0026460:	5d                   	pop    %ebp
c0026461:	c3                   	ret    

c0026462 <format_integer>:
{
c0026462:	55                   	push   %ebp
c0026463:	57                   	push   %edi
c0026464:	56                   	push   %esi
c0026465:	53                   	push   %ebx
c0026466:	83 ec 7c             	sub    $0x7c,%esp
c0026469:	89 c6                	mov    %eax,%esi
c002646b:	89 d7                	mov    %edx,%edi
c002646d:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  if (is_signed) 
c0026474:	84 c9                	test   %cl,%cl
c0026476:	74 42                	je     c00264ba <format_integer+0x58>
      if (c->flags & PLUS)
c0026478:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c002647f:	8b 11                	mov    (%ecx),%edx
c0026481:	f6 c2 02             	test   $0x2,%dl
c0026484:	74 10                	je     c0026496 <format_integer+0x34>
        sign = negative ? '-' : '+';
c0026486:	3c 01                	cmp    $0x1,%al
c0026488:	19 c0                	sbb    %eax,%eax
c002648a:	83 e0 fe             	and    $0xfffffffe,%eax
c002648d:	83 c0 2d             	add    $0x2d,%eax
c0026490:	89 44 24 24          	mov    %eax,0x24(%esp)
c0026494:	eb 2c                	jmp    c00264c2 <format_integer+0x60>
      else if (c->flags & SPACE)
c0026496:	f6 c2 04             	test   $0x4,%dl
c0026499:	74 10                	je     c00264ab <format_integer+0x49>
        sign = negative ? '-' : ' ';
c002649b:	3c 01                	cmp    $0x1,%al
c002649d:	19 c0                	sbb    %eax,%eax
c002649f:	83 e0 f3             	and    $0xfffffff3,%eax
c00264a2:	83 c0 2d             	add    $0x2d,%eax
c00264a5:	89 44 24 24          	mov    %eax,0x24(%esp)
c00264a9:	eb 17                	jmp    c00264c2 <format_integer+0x60>
        sign = '-';
c00264ab:	3c 01                	cmp    $0x1,%al
c00264ad:	19 c0                	sbb    %eax,%eax
c00264af:	f7 d0                	not    %eax
c00264b1:	83 e0 2d             	and    $0x2d,%eax
c00264b4:	89 44 24 24          	mov    %eax,0x24(%esp)
c00264b8:	eb 08                	jmp    c00264c2 <format_integer+0x60>
  sign = 0;
c00264ba:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c00264c1:	00 
  x = (c->flags & POUND) && value ? b->x : 0;
c00264c2:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00264c9:	8b 00                	mov    (%eax),%eax
c00264cb:	89 44 24 28          	mov    %eax,0x28(%esp)
c00264cf:	83 e0 08             	and    $0x8,%eax
c00264d2:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c00264d6:	74 1a                	je     c00264f2 <format_integer+0x90>
c00264d8:	89 fa                	mov    %edi,%edx
c00264da:	09 f2                	or     %esi,%edx
c00264dc:	0f 84 cc 00 00 00    	je     c00265ae <format_integer+0x14c>
c00264e2:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c00264e9:	8b 40 08             	mov    0x8(%eax),%eax
c00264ec:	89 44 24 20          	mov    %eax,0x20(%esp)
c00264f0:	eb 12                	jmp    c0026504 <format_integer+0xa2>
  while (value > 0) 
c00264f2:	89 fa                	mov    %edi,%edx
c00264f4:	09 f2                	or     %esi,%edx
c00264f6:	0f 84 c3 01 00 00    	je     c00266bf <format_integer+0x25d>
  x = (c->flags & POUND) && value ? b->x : 0;
c00264fc:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0026503:	00 
      *cp++ = b->digits[value % b->base];
c0026504:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c002650b:	8b 40 04             	mov    0x4(%eax),%eax
c002650e:	89 44 24 18          	mov    %eax,0x18(%esp)
c0026512:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026519:	8b 00                	mov    (%eax),%eax
c002651b:	89 44 24 08          	mov    %eax,0x8(%esp)
c002651f:	89 c1                	mov    %eax,%ecx
c0026521:	c1 f9 1f             	sar    $0x1f,%ecx
c0026524:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0026528:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c002652f:	00 
c0026530:	8d 5c 24 30          	lea    0x30(%esp),%ebx
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0026534:	8b 44 24 28          	mov    0x28(%esp),%eax
c0026538:	83 e0 20             	and    $0x20,%eax
c002653b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002653f:	eb 3f                	jmp    c0026580 <format_integer+0x11e>
c0026541:	89 dd                	mov    %ebx,%ebp
      *cp++ = b->digits[value % b->base];
c0026543:	8d 5d 01             	lea    0x1(%ebp),%ebx
c0026546:	ff 74 24 0c          	pushl  0xc(%esp)
c002654a:	ff 74 24 0c          	pushl  0xc(%esp)
c002654e:	57                   	push   %edi
c002654f:	56                   	push   %esi
c0026550:	e8 35 18 00 00       	call   c0027d8a <__umoddi3>
c0026555:	83 c4 10             	add    $0x10,%esp
c0026558:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c002655c:	8a 04 01             	mov    (%ecx,%eax,1),%al
c002655f:	88 45 00             	mov    %al,0x0(%ebp)
      value /= b->base;
c0026562:	ff 74 24 0c          	pushl  0xc(%esp)
c0026566:	ff 74 24 0c          	pushl  0xc(%esp)
c002656a:	57                   	push   %edi
c002656b:	56                   	push   %esi
c002656c:	e8 fd 17 00 00       	call   c0027d6e <__udivdi3>
c0026571:	83 c4 10             	add    $0x10,%esp
c0026574:	89 c6                	mov    %eax,%esi
c0026576:	89 d7                	mov    %edx,%edi
      digit_cnt++;
c0026578:	ff 44 24 14          	incl   0x14(%esp)
  while (value > 0) 
c002657c:	09 c2                	or     %eax,%edx
c002657e:	74 3a                	je     c00265ba <format_integer+0x158>
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0026580:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0026585:	74 ba                	je     c0026541 <format_integer+0xdf>
c0026587:	8b 44 24 14          	mov    0x14(%esp),%eax
c002658b:	85 c0                	test   %eax,%eax
c002658d:	7e 17                	jle    c00265a6 <format_integer+0x144>
c002658f:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c0026596:	99                   	cltd   
c0026597:	f7 79 0c             	idivl  0xc(%ecx)
c002659a:	85 d2                	test   %edx,%edx
c002659c:	75 0c                	jne    c00265aa <format_integer+0x148>
        *cp++ = ',';
c002659e:	8d 6b 01             	lea    0x1(%ebx),%ebp
c00265a1:	c6 03 2c             	movb   $0x2c,(%ebx)
c00265a4:	eb 9d                	jmp    c0026543 <format_integer+0xe1>
c00265a6:	89 dd                	mov    %ebx,%ebp
c00265a8:	eb 99                	jmp    c0026543 <format_integer+0xe1>
c00265aa:	89 dd                	mov    %ebx,%ebp
c00265ac:	eb 95                	jmp    c0026543 <format_integer+0xe1>
  x = (c->flags & POUND) && value ? b->x : 0;
c00265ae:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c00265b5:	00 
  cp = buf;
c00265b6:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  precision = c->precision < 0 ? 1 : c->precision;
c00265ba:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00265c1:	8b 50 08             	mov    0x8(%eax),%edx
c00265c4:	85 d2                	test   %edx,%edx
c00265c6:	0f 88 04 01 00 00    	js     c00266d0 <format_integer+0x26e>
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00265cc:	8d 7c 24 30          	lea    0x30(%esp),%edi
c00265d0:	89 d8                	mov    %ebx,%eax
c00265d2:	29 f8                	sub    %edi,%eax
c00265d4:	39 c2                	cmp    %eax,%edx
c00265d6:	7e 21                	jle    c00265f9 <format_integer+0x197>
c00265d8:	8d 44 24 6f          	lea    0x6f(%esp),%eax
c00265dc:	39 c3                	cmp    %eax,%ebx
c00265de:	73 19                	jae    c00265f9 <format_integer+0x197>
c00265e0:	89 f9                	mov    %edi,%ecx
c00265e2:	89 c6                	mov    %eax,%esi
    *cp++ = '0';
c00265e4:	43                   	inc    %ebx
c00265e5:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00265e9:	89 d8                	mov    %ebx,%eax
c00265eb:	29 c8                	sub    %ecx,%eax
c00265ed:	39 d0                	cmp    %edx,%eax
c00265ef:	7d 08                	jge    c00265f9 <format_integer+0x197>
c00265f1:	39 f3                	cmp    %esi,%ebx
c00265f3:	75 ef                	jne    c00265e4 <format_integer+0x182>
    *cp++ = '0';
c00265f5:	8d 5c 24 6f          	lea    0x6f(%esp),%ebx
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00265f9:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c00265fe:	74 10                	je     c0026610 <format_integer+0x1ae>
c0026600:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026607:	83 38 08             	cmpl   $0x8,(%eax)
c002660a:	0f 84 ca 00 00 00    	je     c00266da <format_integer+0x278>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0026610:	29 df                	sub    %ebx,%edi
c0026612:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c0026619:	89 f8                	mov    %edi,%eax
c002661b:	03 41 04             	add    0x4(%ecx),%eax
c002661e:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0026623:	0f 95 c2             	setne  %dl
c0026626:	0f b6 d2             	movzbl %dl,%edx
c0026629:	d1 e2                	shl    %edx
c002662b:	29 d0                	sub    %edx,%eax
c002662d:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0026632:	0f 95 c2             	setne  %dl
c0026635:	0f b6 d2             	movzbl %dl,%edx
c0026638:	29 d0                	sub    %edx,%eax
c002663a:	89 c7                	mov    %eax,%edi
c002663c:	85 c0                	test   %eax,%eax
c002663e:	0f 88 b3 00 00 00    	js     c00266f7 <format_integer+0x295>
  if ((c->flags & (MINUS | ZERO)) == 0)
c0026644:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c0026649:	0f 84 b2 00 00 00    	je     c0026701 <format_integer+0x29f>
  if (sign)
c002664f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0026654:	0f 85 cc 00 00 00    	jne    c0026726 <format_integer+0x2c4>
  if (x) 
c002665a:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c002665f:	0f 85 de 00 00 00    	jne    c0026743 <format_integer+0x2e1>
  if (c->flags & ZERO)
c0026665:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002666c:	f6 00 10             	testb  $0x10,(%eax)
c002666f:	0f 85 00 01 00 00    	jne    c0026775 <format_integer+0x313>
  while (cp > buf)
c0026675:	8d 44 24 30          	lea    0x30(%esp),%eax
c0026679:	39 c3                	cmp    %eax,%ebx
c002667b:	76 2a                	jbe    c00266a7 <format_integer+0x245>
c002667d:	89 c6                	mov    %eax,%esi
c002667f:	89 7c 24 08          	mov    %edi,0x8(%esp)
c0026683:	8b bc 24 9c 00 00 00 	mov    0x9c(%esp),%edi
c002668a:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
    output (*--cp, aux);
c0026691:	4b                   	dec    %ebx
c0026692:	83 ec 08             	sub    $0x8,%esp
c0026695:	55                   	push   %ebp
c0026696:	0f be 03             	movsbl (%ebx),%eax
c0026699:	50                   	push   %eax
c002669a:	ff d7                	call   *%edi
  while (cp > buf)
c002669c:	83 c4 10             	add    $0x10,%esp
c002669f:	39 f3                	cmp    %esi,%ebx
c00266a1:	75 ee                	jne    c0026691 <format_integer+0x22f>
c00266a3:	8b 7c 24 08          	mov    0x8(%esp),%edi
  if (c->flags & MINUS)
c00266a7:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00266ae:	f6 00 01             	testb  $0x1,(%eax)
c00266b1:	0f 85 e3 00 00 00    	jne    c002679a <format_integer+0x338>
}
c00266b7:	83 c4 7c             	add    $0x7c,%esp
c00266ba:	5b                   	pop    %ebx
c00266bb:	5e                   	pop    %esi
c00266bc:	5f                   	pop    %edi
c00266bd:	5d                   	pop    %ebp
c00266be:	c3                   	ret    
  x = (c->flags & POUND) && value ? b->x : 0;
c00266bf:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c00266c6:	00 
  cp = buf;
c00266c7:	8d 5c 24 30          	lea    0x30(%esp),%ebx
c00266cb:	e9 ea fe ff ff       	jmp    c00265ba <format_integer+0x158>
  precision = c->precision < 0 ? 1 : c->precision;
c00266d0:	ba 01 00 00 00       	mov    $0x1,%edx
c00266d5:	e9 f2 fe ff ff       	jmp    c00265cc <format_integer+0x16a>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00266da:	8d 44 24 30          	lea    0x30(%esp),%eax
c00266de:	39 c3                	cmp    %eax,%ebx
c00266e0:	74 0a                	je     c00266ec <format_integer+0x28a>
c00266e2:	80 7b ff 30          	cmpb   $0x30,-0x1(%ebx)
c00266e6:	0f 84 24 ff ff ff    	je     c0026610 <format_integer+0x1ae>
    *cp++ = '0';
c00266ec:	c6 03 30             	movb   $0x30,(%ebx)
c00266ef:	8d 5b 01             	lea    0x1(%ebx),%ebx
c00266f2:	e9 19 ff ff ff       	jmp    c0026610 <format_integer+0x1ae>
c00266f7:	bf 00 00 00 00       	mov    $0x0,%edi
c00266fc:	e9 43 ff ff ff       	jmp    c0026644 <format_integer+0x1e2>
    output_dup (' ', pad_cnt, output, aux);
c0026701:	83 ec 0c             	sub    $0xc,%esp
c0026704:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c002670b:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0026712:	89 fa                	mov    %edi,%edx
c0026714:	b8 20 00 00 00       	mov    $0x20,%eax
c0026719:	e8 15 fd ff ff       	call   c0026433 <output_dup>
c002671e:	83 c4 10             	add    $0x10,%esp
c0026721:	e9 29 ff ff ff       	jmp    c002664f <format_integer+0x1ed>
    output (sign, aux);
c0026726:	83 ec 08             	sub    $0x8,%esp
c0026729:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0026730:	ff 74 24 30          	pushl  0x30(%esp)
c0026734:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c002673b:	83 c4 10             	add    $0x10,%esp
c002673e:	e9 17 ff ff ff       	jmp    c002665a <format_integer+0x1f8>
      output ('0', aux);
c0026743:	83 ec 08             	sub    $0x8,%esp
c0026746:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002674d:	6a 30                	push   $0x30
c002674f:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c0026756:	83 c4 08             	add    $0x8,%esp
c0026759:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0026760:	0f be 44 24 2c       	movsbl 0x2c(%esp),%eax
c0026765:	50                   	push   %eax
c0026766:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c002676d:	83 c4 10             	add    $0x10,%esp
c0026770:	e9 f0 fe ff ff       	jmp    c0026665 <format_integer+0x203>
    output_dup ('0', pad_cnt, output, aux);
c0026775:	83 ec 0c             	sub    $0xc,%esp
c0026778:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c002677f:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0026786:	89 fa                	mov    %edi,%edx
c0026788:	b8 30 00 00 00       	mov    $0x30,%eax
c002678d:	e8 a1 fc ff ff       	call   c0026433 <output_dup>
c0026792:	83 c4 10             	add    $0x10,%esp
c0026795:	e9 db fe ff ff       	jmp    c0026675 <format_integer+0x213>
    output_dup (' ', pad_cnt, output, aux);
c002679a:	83 ec 0c             	sub    $0xc,%esp
c002679d:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c00267a4:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c00267ab:	89 fa                	mov    %edi,%edx
c00267ad:	b8 20 00 00 00       	mov    $0x20,%eax
c00267b2:	e8 7c fc ff ff       	call   c0026433 <output_dup>
c00267b7:	83 c4 10             	add    $0x10,%esp
}
c00267ba:	e9 f8 fe ff ff       	jmp    c00266b7 <format_integer+0x255>

c00267bf <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c00267bf:	55                   	push   %ebp
c00267c0:	57                   	push   %edi
c00267c1:	56                   	push   %esi
c00267c2:	53                   	push   %ebx
c00267c3:	83 ec 1c             	sub    $0x1c,%esp
c00267c6:	89 c5                	mov    %eax,%ebp
c00267c8:	89 d3                	mov    %edx,%ebx
c00267ca:	89 54 24 08          	mov    %edx,0x8(%esp)
c00267ce:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c00267d2:	8b 74 24 30          	mov    0x30(%esp),%esi
c00267d6:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c00267da:	8b 51 04             	mov    0x4(%ecx),%edx
c00267dd:	39 da                	cmp    %ebx,%edx
c00267df:	7e 42                	jle    c0026823 <format_string+0x64>
c00267e1:	89 c8                	mov    %ecx,%eax
c00267e3:	f6 00 01             	testb  $0x1,(%eax)
c00267e6:	74 20                	je     c0026808 <format_string+0x49>
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c00267e8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c00267ed:	7f 3b                	jg     c002682a <format_string+0x6b>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
c00267ef:	2b 54 24 08          	sub    0x8(%esp),%edx
c00267f3:	83 ec 0c             	sub    $0xc,%esp
c00267f6:	57                   	push   %edi
c00267f7:	89 f1                	mov    %esi,%ecx
c00267f9:	b8 20 00 00 00       	mov    $0x20,%eax
c00267fe:	e8 30 fc ff ff       	call   c0026433 <output_dup>
c0026803:	83 c4 10             	add    $0x10,%esp
}
c0026806:	eb 4f                	jmp    c0026857 <format_string+0x98>
    output_dup (' ', c->width - length, output, aux);
c0026808:	29 da                	sub    %ebx,%edx
c002680a:	83 ec 0c             	sub    $0xc,%esp
c002680d:	57                   	push   %edi
c002680e:	89 f1                	mov    %esi,%ecx
c0026810:	b8 20 00 00 00       	mov    $0x20,%eax
c0026815:	e8 19 fc ff ff       	call   c0026433 <output_dup>
  for (i = 0; i < length; i++)
c002681a:	83 c4 10             	add    $0x10,%esp
c002681d:	85 db                	test   %ebx,%ebx
c002681f:	7f 09                	jg     c002682a <format_string+0x6b>
c0026821:	eb 22                	jmp    c0026845 <format_string+0x86>
c0026823:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0026828:	7e 2d                	jle    c0026857 <format_string+0x98>
{
c002682a:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
c002682f:	83 ec 08             	sub    $0x8,%esp
c0026832:	57                   	push   %edi
c0026833:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c0026838:	50                   	push   %eax
c0026839:	ff d6                	call   *%esi
  for (i = 0; i < length; i++)
c002683b:	43                   	inc    %ebx
c002683c:	83 c4 10             	add    $0x10,%esp
c002683f:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
c0026843:	7f ea                	jg     c002682f <format_string+0x70>
  if (c->width > length && (c->flags & MINUS) != 0)
c0026845:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0026849:	8b 50 04             	mov    0x4(%eax),%edx
c002684c:	39 54 24 08          	cmp    %edx,0x8(%esp)
c0026850:	7d 05                	jge    c0026857 <format_string+0x98>
c0026852:	f6 00 01             	testb  $0x1,(%eax)
c0026855:	75 98                	jne    c00267ef <format_string+0x30>
}
c0026857:	83 c4 1c             	add    $0x1c,%esp
c002685a:	5b                   	pop    %ebx
c002685b:	5e                   	pop    %esi
c002685c:	5f                   	pop    %edi
c002685d:	5d                   	pop    %ebp
c002685e:	c3                   	ret    

c002685f <printf>:
{
c002685f:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0026862:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c0026866:	83 ec 08             	sub    $0x8,%esp
c0026869:	50                   	push   %eax
c002686a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002686e:	e8 ad 34 00 00       	call   c0029d20 <vprintf>
}
c0026873:	83 c4 1c             	add    $0x1c,%esp
c0026876:	c3                   	ret    

c0026877 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0026877:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c002687a:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c002687e:	ff 74 24 18          	pushl  0x18(%esp)
c0026882:	ff 74 24 18          	pushl  0x18(%esp)
c0026886:	50                   	push   %eax
c0026887:	ff 74 24 1c          	pushl  0x1c(%esp)
c002688b:	e8 04 00 00 00       	call   c0026894 <__vprintf>
  va_end (args);
}
c0026890:	83 c4 1c             	add    $0x1c,%esp
c0026893:	c3                   	ret    

c0026894 <__vprintf>:
{
c0026894:	55                   	push   %ebp
c0026895:	57                   	push   %edi
c0026896:	56                   	push   %esi
c0026897:	53                   	push   %ebx
c0026898:	83 ec 3c             	sub    $0x3c,%esp
c002689b:	8b 74 24 50          	mov    0x50(%esp),%esi
  for (; *format != '\0'; format++)
c002689f:	8a 06                	mov    (%esi),%al
c00268a1:	84 c0                	test   %al,%al
c00268a3:	75 44                	jne    c00268e9 <__vprintf+0x55>
}
c00268a5:	83 c4 3c             	add    $0x3c,%esp
c00268a8:	5b                   	pop    %ebx
c00268a9:	5e                   	pop    %esi
c00268aa:	5f                   	pop    %edi
c00268ab:	5d                   	pop    %ebp
c00268ac:	c3                   	ret    
      format++;
c00268ad:	8d 5e 01             	lea    0x1(%esi),%ebx
      if (*format == '%') 
c00268b0:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c00268b4:	74 19                	je     c00268cf <__vprintf+0x3b>
  c->flags = 0;
c00268b6:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c00268bd:	00 
c00268be:	bf 00 00 00 00       	mov    $0x0,%edi
c00268c3:	be 00 00 00 00       	mov    $0x0,%esi
c00268c8:	bd 01 00 00 00       	mov    $0x1,%ebp
c00268cd:	eb 3b                	jmp    c002690a <__vprintf+0x76>
          output ('%', aux);
c00268cf:	83 ec 08             	sub    $0x8,%esp
c00268d2:	ff 74 24 64          	pushl  0x64(%esp)
c00268d6:	6a 25                	push   $0x25
c00268d8:	ff 54 24 68          	call   *0x68(%esp)
          continue;
c00268dc:	83 c4 10             	add    $0x10,%esp
  for (; *format != '\0'; format++)
c00268df:	8d 73 01             	lea    0x1(%ebx),%esi
c00268e2:	8a 43 01             	mov    0x1(%ebx),%al
c00268e5:	84 c0                	test   %al,%al
c00268e7:	74 bc                	je     c00268a5 <__vprintf+0x11>
      if (*format != '%') 
c00268e9:	3c 25                	cmp    $0x25,%al
c00268eb:	74 c0                	je     c00268ad <__vprintf+0x19>
          output (*format, aux);
c00268ed:	83 ec 08             	sub    $0x8,%esp
c00268f0:	ff 74 24 64          	pushl  0x64(%esp)
c00268f4:	0f be c0             	movsbl %al,%eax
c00268f7:	50                   	push   %eax
c00268f8:	ff 54 24 68          	call   *0x68(%esp)
          continue;
c00268fc:	83 c4 10             	add    $0x10,%esp
c00268ff:	89 f3                	mov    %esi,%ebx
c0026901:	eb dc                	jmp    c00268df <__vprintf+0x4b>
          c->flags |= MINUS;
c0026903:	83 ce 01             	or     $0x1,%esi
c0026906:	89 ef                	mov    %ebp,%edi
      switch (*format++) 
c0026908:	89 cb                	mov    %ecx,%ebx
c002690a:	8d 4b 01             	lea    0x1(%ebx),%ecx
c002690d:	8a 41 ff             	mov    -0x1(%ecx),%al
c0026910:	8d 50 e0             	lea    -0x20(%eax),%edx
c0026913:	80 fa 10             	cmp    $0x10,%dl
c0026916:	77 23                	ja     c002693b <__vprintf+0xa7>
c0026918:	0f b6 d2             	movzbl %dl,%edx
c002691b:	ff 24 95 70 cc 02 c0 	jmp    *-0x3ffd3390(,%edx,4)
          c->flags |= PLUS;
c0026922:	83 ce 02             	or     $0x2,%esi
c0026925:	eb df                	jmp    c0026906 <__vprintf+0x72>
          c->flags |= SPACE;
c0026927:	83 ce 04             	or     $0x4,%esi
c002692a:	eb da                	jmp    c0026906 <__vprintf+0x72>
          c->flags |= POUND;
c002692c:	83 ce 08             	or     $0x8,%esi
c002692f:	eb d5                	jmp    c0026906 <__vprintf+0x72>
          c->flags |= ZERO;
c0026931:	83 ce 10             	or     $0x10,%esi
c0026934:	eb d0                	jmp    c0026906 <__vprintf+0x72>
          c->flags |= GROUP;
c0026936:	83 ce 20             	or     $0x20,%esi
c0026939:	eb cb                	jmp    c0026906 <__vprintf+0x72>
c002693b:	89 fa                	mov    %edi,%edx
c002693d:	84 d2                	test   %dl,%dl
c002693f:	0f 85 85 00 00 00    	jne    c00269ca <__vprintf+0x136>
  if (c->flags & PLUS)
c0026945:	8b 54 24 20          	mov    0x20(%esp),%edx
c0026949:	f6 c2 02             	test   $0x2,%dl
c002694c:	74 07                	je     c0026955 <__vprintf+0xc1>
    c->flags &= ~SPACE;
c002694e:	83 e2 fb             	and    $0xfffffffb,%edx
c0026951:	89 54 24 20          	mov    %edx,0x20(%esp)
  c->width = 0;
c0026955:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c002695c:	00 
  if (*format == '*')
c002695d:	3c 2a                	cmp    $0x2a,%al
c002695f:	0f 84 81 00 00 00    	je     c00269e6 <__vprintf+0x152>
      for (; isdigit (*format); format++)
c0026965:	0f be c0             	movsbl %al,%eax
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0026968:	8d 48 d0             	lea    -0x30(%eax),%ecx
c002696b:	ba 00 00 00 00       	mov    $0x0,%edx
c0026970:	83 f9 09             	cmp    $0x9,%ecx
c0026973:	77 21                	ja     c0026996 <__vprintf+0x102>
        c->width = c->width * 10 + *format - '0';
c0026975:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026978:	01 d2                	add    %edx,%edx
c002697a:	8d 54 10 d0          	lea    -0x30(%eax,%edx,1),%edx
      for (; isdigit (*format); format++)
c002697e:	43                   	inc    %ebx
c002697f:	0f be 03             	movsbl (%ebx),%eax
c0026982:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0026985:	83 f9 09             	cmp    $0x9,%ecx
c0026988:	76 eb                	jbe    c0026975 <__vprintf+0xe1>
c002698a:	89 54 24 24          	mov    %edx,0x24(%esp)
  if (c->width < 0) 
c002698e:	8b 44 24 24          	mov    0x24(%esp),%eax
c0026992:	85 c0                	test   %eax,%eax
c0026994:	78 69                	js     c00269ff <__vprintf+0x16b>
  c->precision = -1;
c0026996:	c7 44 24 28 ff ff ff 	movl   $0xffffffff,0x28(%esp)
c002699d:	ff 
  if (*format == '.') 
c002699e:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c00269a1:	74 69                	je     c0026a0c <__vprintf+0x178>
  if (c->precision >= 0)
c00269a3:	8b 54 24 28          	mov    0x28(%esp),%edx
  c->type = INT;
c00269a7:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c00269ae:	00 
  switch (*format++) 
c00269af:	8d 7b 01             	lea    0x1(%ebx),%edi
c00269b2:	8a 03                	mov    (%ebx),%al
c00269b4:	8d 48 98             	lea    -0x68(%eax),%ecx
c00269b7:	80 f9 12             	cmp    $0x12,%cl
c00269ba:	0f 87 d5 01 00 00    	ja     c0026b95 <__vprintf+0x301>
c00269c0:	0f b6 c9             	movzbl %cl,%ecx
c00269c3:	ff 24 8d b4 cc 02 c0 	jmp    *-0x3ffd334c(,%ecx,4)
c00269ca:	89 74 24 20          	mov    %esi,0x20(%esp)
  if (c->flags & MINUS)
c00269ce:	f7 c6 01 00 00 00    	test   $0x1,%esi
c00269d4:	0f 84 6b ff ff ff    	je     c0026945 <__vprintf+0xb1>
    c->flags &= ~ZERO;
c00269da:	83 e6 ef             	and    $0xffffffef,%esi
c00269dd:	89 74 24 20          	mov    %esi,0x20(%esp)
c00269e1:	e9 5f ff ff ff       	jmp    c0026945 <__vprintf+0xb1>
      c->width = va_arg (*args, int);
c00269e6:	8b 44 24 54          	mov    0x54(%esp),%eax
c00269ea:	8b 00                	mov    (%eax),%eax
c00269ec:	89 44 24 24          	mov    %eax,0x24(%esp)
c00269f0:	8b 44 24 54          	mov    0x54(%esp),%eax
c00269f4:	8d 40 04             	lea    0x4(%eax),%eax
c00269f7:	89 44 24 54          	mov    %eax,0x54(%esp)
      switch (*format++) 
c00269fb:	89 cb                	mov    %ecx,%ebx
c00269fd:	eb 8f                	jmp    c002698e <__vprintf+0xfa>
      c->width = -c->width;
c00269ff:	f7 d8                	neg    %eax
c0026a01:	89 44 24 24          	mov    %eax,0x24(%esp)
      c->flags |= MINUS;
c0026a05:	83 4c 24 20 01       	orl    $0x1,0x20(%esp)
c0026a0a:	eb 8a                	jmp    c0026996 <__vprintf+0x102>
      format++;
c0026a0c:	8d 53 01             	lea    0x1(%ebx),%edx
      if (*format == '*') 
c0026a0f:	8a 43 01             	mov    0x1(%ebx),%al
c0026a12:	3c 2a                	cmp    $0x2a,%al
c0026a14:	74 45                	je     c0026a5b <__vprintf+0x1c7>
          c->precision = 0;
c0026a16:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
c0026a1d:	00 
          for (; isdigit (*format); format++)
c0026a1e:	0f be c0             	movsbl %al,%eax
c0026a21:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0026a24:	83 f9 09             	cmp    $0x9,%ecx
c0026a27:	77 59                	ja     c0026a82 <__vprintf+0x1ee>
c0026a29:	b9 00 00 00 00       	mov    $0x0,%ecx
            c->precision = c->precision * 10 + *format - '0';
c0026a2e:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026a31:	01 c9                	add    %ecx,%ecx
c0026a33:	8d 4c 08 d0          	lea    -0x30(%eax,%ecx,1),%ecx
          for (; isdigit (*format); format++)
c0026a37:	42                   	inc    %edx
c0026a38:	0f be 02             	movsbl (%edx),%eax
c0026a3b:	8d 58 d0             	lea    -0x30(%eax),%ebx
c0026a3e:	83 fb 09             	cmp    $0x9,%ebx
c0026a41:	76 eb                	jbe    c0026a2e <__vprintf+0x19a>
c0026a43:	89 4c 24 28          	mov    %ecx,0x28(%esp)
c0026a47:	89 d3                	mov    %edx,%ebx
      if (c->precision < 0) 
c0026a49:	8b 54 24 28          	mov    0x28(%esp),%edx
c0026a4d:	85 d2                	test   %edx,%edx
c0026a4f:	78 24                	js     c0026a75 <__vprintf+0x1e1>
    c->flags &= ~ZERO;
c0026a51:	83 64 24 20 ef       	andl   $0xffffffef,0x20(%esp)
c0026a56:	e9 4c ff ff ff       	jmp    c00269a7 <__vprintf+0x113>
          format++;
c0026a5b:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c0026a5e:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026a62:	8b 00                	mov    (%eax),%eax
c0026a64:	89 44 24 28          	mov    %eax,0x28(%esp)
c0026a68:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026a6c:	8d 40 04             	lea    0x4(%eax),%eax
c0026a6f:	89 44 24 54          	mov    %eax,0x54(%esp)
c0026a73:	eb d4                	jmp    c0026a49 <__vprintf+0x1b5>
        c->precision = -1;
c0026a75:	c7 44 24 28 ff ff ff 	movl   $0xffffffff,0x28(%esp)
c0026a7c:	ff 
c0026a7d:	e9 21 ff ff ff       	jmp    c00269a3 <__vprintf+0x10f>
      format++;
c0026a82:	89 d3                	mov    %edx,%ebx
  if (c->precision >= 0)
c0026a84:	ba 00 00 00 00       	mov    $0x0,%edx
c0026a89:	eb c6                	jmp    c0026a51 <__vprintf+0x1bd>
      if (*format == 'h') 
c0026a8b:	8a 43 01             	mov    0x1(%ebx),%al
c0026a8e:	3c 68                	cmp    $0x68,%al
c0026a90:	74 21                	je     c0026ab3 <__vprintf+0x21f>
        c->type = SHORT;
c0026a92:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c0026a99:	00 
      switch (*format) 
c0026a9a:	0f be e8             	movsbl %al,%ebp
c0026a9d:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026aa0:	80 fb 33             	cmp    $0x33,%bl
c0026aa3:	0f 87 ba 04 00 00    	ja     c0026f63 <__vprintf+0x6cf>
c0026aa9:	0f b6 db             	movzbl %bl,%ebx
c0026aac:	ff 24 9d 00 cd 02 c0 	jmp    *-0x3ffd3300(,%ebx,4)
          format++;
c0026ab3:	8d 7b 02             	lea    0x2(%ebx),%edi
          c->type = CHAR;
c0026ab6:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c0026abd:	00 
      switch (*format) 
c0026abe:	8a 43 02             	mov    0x2(%ebx),%al
c0026ac1:	0f be e8             	movsbl %al,%ebp
c0026ac4:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026ac7:	80 fb 33             	cmp    $0x33,%bl
c0026aca:	0f 87 93 04 00 00    	ja     c0026f63 <__vprintf+0x6cf>
c0026ad0:	0f b6 db             	movzbl %bl,%ebx
c0026ad3:	ff 24 9d d0 cd 02 c0 	jmp    *-0x3ffd3230(,%ebx,4)
      c->type = INTMAX;
c0026ada:	c7 44 24 2c 04 00 00 	movl   $0x4,0x2c(%esp)
c0026ae1:	00 
      switch (*format) 
c0026ae2:	8a 43 01             	mov    0x1(%ebx),%al
c0026ae5:	0f be e8             	movsbl %al,%ebp
c0026ae8:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026aeb:	80 fb 33             	cmp    $0x33,%bl
c0026aee:	0f 87 6f 04 00 00    	ja     c0026f63 <__vprintf+0x6cf>
c0026af4:	0f b6 db             	movzbl %bl,%ebx
c0026af7:	ff 24 9d a0 ce 02 c0 	jmp    *-0x3ffd3160(,%ebx,4)
      if (*format == 'l')
c0026afe:	8a 43 01             	mov    0x1(%ebx),%al
c0026b01:	3c 6c                	cmp    $0x6c,%al
c0026b03:	74 21                	je     c0026b26 <__vprintf+0x292>
        c->type = LONG;
c0026b05:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c0026b0c:	00 
      switch (*format) 
c0026b0d:	0f be e8             	movsbl %al,%ebp
c0026b10:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026b13:	80 fb 33             	cmp    $0x33,%bl
c0026b16:	0f 87 47 04 00 00    	ja     c0026f63 <__vprintf+0x6cf>
c0026b1c:	0f b6 db             	movzbl %bl,%ebx
c0026b1f:	ff 24 9d 70 cf 02 c0 	jmp    *-0x3ffd3090(,%ebx,4)
          format++;
c0026b26:	8d 7b 02             	lea    0x2(%ebx),%edi
          c->type = LONGLONG;
c0026b29:	c7 44 24 2c 06 00 00 	movl   $0x6,0x2c(%esp)
c0026b30:	00 
      switch (*format) 
c0026b31:	8a 43 02             	mov    0x2(%ebx),%al
c0026b34:	0f be e8             	movsbl %al,%ebp
c0026b37:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026b3a:	80 fb 33             	cmp    $0x33,%bl
c0026b3d:	0f 87 20 04 00 00    	ja     c0026f63 <__vprintf+0x6cf>
c0026b43:	0f b6 db             	movzbl %bl,%ebx
c0026b46:	ff 24 9d 40 d0 02 c0 	jmp    *-0x3ffd2fc0(,%ebx,4)
      c->type = PTRDIFFT;
c0026b4d:	c7 44 24 2c 07 00 00 	movl   $0x7,0x2c(%esp)
c0026b54:	00 
      switch (*format) 
c0026b55:	8a 43 01             	mov    0x1(%ebx),%al
c0026b58:	0f be e8             	movsbl %al,%ebp
c0026b5b:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026b5e:	80 fb 33             	cmp    $0x33,%bl
c0026b61:	0f 87 fc 03 00 00    	ja     c0026f63 <__vprintf+0x6cf>
c0026b67:	0f b6 db             	movzbl %bl,%ebx
c0026b6a:	ff 24 9d 10 d1 02 c0 	jmp    *-0x3ffd2ef0(,%ebx,4)
      c->type = SIZET;
c0026b71:	c7 44 24 2c 08 00 00 	movl   $0x8,0x2c(%esp)
c0026b78:	00 
      switch (*format) 
c0026b79:	8a 43 01             	mov    0x1(%ebx),%al
c0026b7c:	0f be e8             	movsbl %al,%ebp
c0026b7f:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026b82:	80 fb 33             	cmp    $0x33,%bl
c0026b85:	0f 87 d8 03 00 00    	ja     c0026f63 <__vprintf+0x6cf>
c0026b8b:	0f b6 db             	movzbl %bl,%ebx
c0026b8e:	ff 24 9d e0 d1 02 c0 	jmp    *-0x3ffd2e20(,%ebx,4)
c0026b95:	0f be e8             	movsbl %al,%ebp
c0026b98:	8d 70 bb             	lea    -0x45(%eax),%esi
c0026b9b:	89 f1                	mov    %esi,%ecx
c0026b9d:	80 f9 33             	cmp    $0x33,%cl
c0026ba0:	0f 87 bb 03 00 00    	ja     c0026f61 <__vprintf+0x6cd>
c0026ba6:	0f b6 f1             	movzbl %cl,%esi
c0026ba9:	ff 24 b5 b0 d2 02 c0 	jmp    *-0x3ffd2d50(,%esi,4)
c0026bb0:	89 df                	mov    %ebx,%edi
            switch (c.type) 
c0026bb2:	83 7c 24 2c 08       	cmpl   $0x8,0x2c(%esp)
c0026bb7:	0f 87 fb 00 00 00    	ja     c0026cb8 <__vprintf+0x424>
c0026bbd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0026bc1:	ff 24 85 80 d3 02 c0 	jmp    *-0x3ffd2c80(,%eax,4)
                value = (signed char) va_arg (args, int);
c0026bc8:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026bcc:	0f be 08             	movsbl (%eax),%ecx
c0026bcf:	89 cb                	mov    %ecx,%ebx
c0026bd1:	c1 fb 1f             	sar    $0x1f,%ebx
c0026bd4:	8d 40 04             	lea    0x4(%eax),%eax
c0026bd7:	89 44 24 54          	mov    %eax,0x54(%esp)
            format_integer (value < 0 ? -value : value,
c0026bdb:	89 c8                	mov    %ecx,%eax
c0026bdd:	89 da                	mov    %ebx,%edx
c0026bdf:	85 db                	test   %ebx,%ebx
c0026be1:	0f 88 f3 00 00 00    	js     c0026cda <__vprintf+0x446>
c0026be7:	83 ec 0c             	sub    $0xc,%esp
c0026bea:	ff 74 24 68          	pushl  0x68(%esp)
c0026bee:	ff 74 24 68          	pushl  0x68(%esp)
c0026bf2:	8d 74 24 34          	lea    0x34(%esp),%esi
c0026bf6:	56                   	push   %esi
c0026bf7:	68 e0 d3 02 c0       	push   $0xc002d3e0
c0026bfc:	89 d9                	mov    %ebx,%ecx
c0026bfe:	c1 e9 1f             	shr    $0x1f,%ecx
c0026c01:	51                   	push   %ecx
c0026c02:	b9 01 00 00 00       	mov    $0x1,%ecx
c0026c07:	e8 56 f8 ff ff       	call   c0026462 <format_integer>
          break;
c0026c0c:	83 c4 20             	add    $0x20,%esp
c0026c0f:	89 fb                	mov    %edi,%ebx
c0026c11:	e9 c9 fc ff ff       	jmp    c00268df <__vprintf+0x4b>
                value = (short) va_arg (args, int);
c0026c16:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026c1a:	0f bf 08             	movswl (%eax),%ecx
c0026c1d:	89 cb                	mov    %ecx,%ebx
c0026c1f:	c1 fb 1f             	sar    $0x1f,%ebx
c0026c22:	8d 40 04             	lea    0x4(%eax),%eax
c0026c25:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026c29:	eb b0                	jmp    c0026bdb <__vprintf+0x347>
                value = va_arg (args, int);
c0026c2b:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026c2f:	8b 08                	mov    (%eax),%ecx
c0026c31:	89 cb                	mov    %ecx,%ebx
c0026c33:	c1 fb 1f             	sar    $0x1f,%ebx
c0026c36:	8d 40 04             	lea    0x4(%eax),%eax
c0026c39:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026c3d:	eb 9c                	jmp    c0026bdb <__vprintf+0x347>
                value = va_arg (args, intmax_t);
c0026c3f:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026c43:	8b 08                	mov    (%eax),%ecx
c0026c45:	8b 58 04             	mov    0x4(%eax),%ebx
c0026c48:	8d 40 08             	lea    0x8(%eax),%eax
c0026c4b:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026c4f:	eb 8a                	jmp    c0026bdb <__vprintf+0x347>
                value = va_arg (args, long);
c0026c51:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026c55:	8b 08                	mov    (%eax),%ecx
c0026c57:	89 cb                	mov    %ecx,%ebx
c0026c59:	c1 fb 1f             	sar    $0x1f,%ebx
c0026c5c:	8d 40 04             	lea    0x4(%eax),%eax
c0026c5f:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026c63:	e9 73 ff ff ff       	jmp    c0026bdb <__vprintf+0x347>
                value = va_arg (args, long long);
c0026c68:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026c6c:	8b 08                	mov    (%eax),%ecx
c0026c6e:	8b 58 04             	mov    0x4(%eax),%ebx
c0026c71:	8d 40 08             	lea    0x8(%eax),%eax
c0026c74:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026c78:	e9 5e ff ff ff       	jmp    c0026bdb <__vprintf+0x347>
                value = va_arg (args, ptrdiff_t);
c0026c7d:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026c81:	8b 08                	mov    (%eax),%ecx
c0026c83:	89 cb                	mov    %ecx,%ebx
c0026c85:	c1 fb 1f             	sar    $0x1f,%ebx
c0026c88:	8d 40 04             	lea    0x4(%eax),%eax
c0026c8b:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026c8f:	e9 47 ff ff ff       	jmp    c0026bdb <__vprintf+0x347>
                value = va_arg (args, size_t);
c0026c94:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026c98:	83 c0 04             	add    $0x4,%eax
c0026c9b:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026c9f:	8b 0e                	mov    (%esi),%ecx
c0026ca1:	bb 00 00 00 00       	mov    $0x0,%ebx
                if (value > SIZE_MAX / 2)
c0026ca6:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
c0026cac:	76 23                	jbe    c0026cd1 <__vprintf+0x43d>
                  value = value - SIZE_MAX - 1;
c0026cae:	4b                   	dec    %ebx
                value = va_arg (args, size_t);
c0026caf:	89 44 24 54          	mov    %eax,0x54(%esp)
c0026cb3:	e9 23 ff ff ff       	jmp    c0026bdb <__vprintf+0x347>
                NOT_REACHED ();
c0026cb8:	68 24 de 02 c0       	push   $0xc002de24
c0026cbd:	68 a4 d3 02 c0       	push   $0xc002d3a4
c0026cc2:	68 dc 00 00 00       	push   $0xdc
c0026cc7:	68 99 f0 02 c0       	push   $0xc002f099
c0026ccc:	e8 3c 16 00 00       	call   c002830d <debug_panic>
                value = va_arg (args, size_t);
c0026cd1:	89 44 24 54          	mov    %eax,0x54(%esp)
c0026cd5:	e9 01 ff ff ff       	jmp    c0026bdb <__vprintf+0x347>
            format_integer (value < 0 ? -value : value,
c0026cda:	f7 d8                	neg    %eax
c0026cdc:	83 d2 00             	adc    $0x0,%edx
c0026cdf:	f7 da                	neg    %edx
c0026ce1:	e9 01 ff ff ff       	jmp    c0026be7 <__vprintf+0x353>
                value = va_arg (args, unsigned);
c0026ce6:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0026cea:	8b 3f                	mov    (%edi),%edi
c0026cec:	bd 00 00 00 00       	mov    $0x0,%ebp
c0026cf1:	89 7c 24 08          	mov    %edi,0x8(%esp)
c0026cf5:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
c0026cf9:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0026cfd:	8d 7f 04             	lea    0x4(%edi),%edi
c0026d00:	89 7c 24 54          	mov    %edi,0x54(%esp)
            switch (*format) 
c0026d04:	3c 6f                	cmp    $0x6f,%al
c0026d06:	0f 84 68 01 00 00    	je     c0026e74 <__vprintf+0x5e0>
c0026d0c:	3c 6f                	cmp    $0x6f,%al
c0026d0e:	0f 8e 0a 01 00 00    	jle    c0026e1e <__vprintf+0x58a>
c0026d14:	3c 75                	cmp    $0x75,%al
c0026d16:	0f 84 0d 01 00 00    	je     c0026e29 <__vprintf+0x595>
c0026d1c:	3c 78                	cmp    $0x78,%al
c0026d1e:	0f 85 37 01 00 00    	jne    c0026e5b <__vprintf+0x5c7>
              case 'x': b = &base_x; break;
c0026d24:	b8 c0 d3 02 c0       	mov    $0xc002d3c0,%eax
c0026d29:	e9 00 01 00 00       	jmp    c0026e2e <__vprintf+0x59a>
                value = (unsigned char) va_arg (args, unsigned);
c0026d2e:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026d32:	0f b6 16             	movzbl (%esi),%edx
c0026d35:	89 54 24 08          	mov    %edx,0x8(%esp)
c0026d39:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0026d40:	00 
                break;
c0026d41:	89 fb                	mov    %edi,%ebx
                value = (unsigned char) va_arg (args, unsigned);
c0026d43:	8d 7e 04             	lea    0x4(%esi),%edi
c0026d46:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0026d4a:	eb b8                	jmp    c0026d04 <__vprintf+0x470>
                value = (unsigned short) va_arg (args, unsigned);
c0026d4c:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026d50:	0f b7 16             	movzwl (%esi),%edx
c0026d53:	89 54 24 08          	mov    %edx,0x8(%esp)
c0026d57:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0026d5e:	00 
                break;
c0026d5f:	89 fb                	mov    %edi,%ebx
                value = (unsigned short) va_arg (args, unsigned);
c0026d61:	8d 7e 04             	lea    0x4(%esi),%edi
c0026d64:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0026d68:	eb 9a                	jmp    c0026d04 <__vprintf+0x470>
                value = va_arg (args, uintmax_t);
c0026d6a:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026d6e:	8b 1e                	mov    (%esi),%ebx
c0026d70:	8b 76 04             	mov    0x4(%esi),%esi
c0026d73:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0026d77:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c0026d7b:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, uintmax_t);
c0026d7d:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0026d81:	8d 7f 08             	lea    0x8(%edi),%edi
c0026d84:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0026d88:	e9 77 ff ff ff       	jmp    c0026d04 <__vprintf+0x470>
                value = va_arg (args, unsigned long);
c0026d8d:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026d91:	8b 1e                	mov    (%esi),%ebx
c0026d93:	be 00 00 00 00       	mov    $0x0,%esi
c0026d98:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0026d9c:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c0026da0:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, unsigned long);
c0026da2:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0026da6:	8d 7f 04             	lea    0x4(%edi),%edi
c0026da9:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0026dad:	e9 52 ff ff ff       	jmp    c0026d04 <__vprintf+0x470>
                value = va_arg (args, unsigned long long);
c0026db2:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026db6:	8b 1e                	mov    (%esi),%ebx
c0026db8:	8b 76 04             	mov    0x4(%esi),%esi
c0026dbb:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0026dbf:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c0026dc3:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, unsigned long long);
c0026dc5:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0026dc9:	8d 7f 08             	lea    0x8(%edi),%edi
c0026dcc:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0026dd0:	e9 2f ff ff ff       	jmp    c0026d04 <__vprintf+0x470>
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0026dd5:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026dd9:	8b 36                	mov    (%esi),%esi
c0026ddb:	89 74 24 08          	mov    %esi,0x8(%esp)
c0026ddf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0026de6:	00 
                break;
c0026de7:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, ptrdiff_t);
c0026de9:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0026ded:	8d 7f 04             	lea    0x4(%edi),%edi
c0026df0:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0026df4:	e9 0b ff ff ff       	jmp    c0026d04 <__vprintf+0x470>
                value = va_arg (args, size_t);
c0026df9:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026dfd:	8b 1e                	mov    (%esi),%ebx
c0026dff:	be 00 00 00 00       	mov    $0x0,%esi
c0026e04:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0026e08:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c0026e0c:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, size_t);
c0026e0e:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0026e12:	8d 7f 04             	lea    0x4(%edi),%edi
c0026e15:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0026e19:	e9 e6 fe ff ff       	jmp    c0026d04 <__vprintf+0x470>
            switch (*format) 
c0026e1e:	3c 58                	cmp    $0x58,%al
c0026e20:	75 39                	jne    c0026e5b <__vprintf+0x5c7>
              case 'X': b = &base_X; break;
c0026e22:	b8 b0 d3 02 c0       	mov    $0xc002d3b0,%eax
c0026e27:	eb 05                	jmp    c0026e2e <__vprintf+0x59a>
              case 'u': b = &base_d; break;
c0026e29:	b8 e0 d3 02 c0       	mov    $0xc002d3e0,%eax
            format_integer (value, false, false, b, &c, output, aux);
c0026e2e:	83 ec 0c             	sub    $0xc,%esp
c0026e31:	ff 74 24 68          	pushl  0x68(%esp)
c0026e35:	ff 74 24 68          	pushl  0x68(%esp)
c0026e39:	8d 7c 24 34          	lea    0x34(%esp),%edi
c0026e3d:	57                   	push   %edi
c0026e3e:	50                   	push   %eax
c0026e3f:	6a 00                	push   $0x0
c0026e41:	b9 00 00 00 00       	mov    $0x0,%ecx
c0026e46:	8b 44 24 28          	mov    0x28(%esp),%eax
c0026e4a:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0026e4e:	e8 0f f6 ff ff       	call   c0026462 <format_integer>
          break;
c0026e53:	83 c4 20             	add    $0x20,%esp
c0026e56:	e9 84 fa ff ff       	jmp    c00268df <__vprintf+0x4b>
              default: NOT_REACHED ();
c0026e5b:	68 24 de 02 c0       	push   $0xc002de24
c0026e60:	68 a4 d3 02 c0       	push   $0xc002d3a4
c0026e65:	68 14 01 00 00       	push   $0x114
c0026e6a:	68 99 f0 02 c0       	push   $0xc002f099
c0026e6f:	e8 99 14 00 00       	call   c002830d <debug_panic>
              case 'o': b = &base_o; break;
c0026e74:	b8 d0 d3 02 c0       	mov    $0xc002d3d0,%eax
c0026e79:	eb b3                	jmp    c0026e2e <__vprintf+0x59a>
      switch (*format) 
c0026e7b:	89 df                	mov    %ebx,%edi
            char ch = va_arg (args, int);
c0026e7d:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026e81:	8d 70 04             	lea    0x4(%eax),%esi
c0026e84:	8b 00                	mov    (%eax),%eax
c0026e86:	88 44 24 1f          	mov    %al,0x1f(%esp)
            format_string (&ch, 1, &c, output, aux);
c0026e8a:	83 ec 08             	sub    $0x8,%esp
c0026e8d:	ff 74 24 64          	pushl  0x64(%esp)
c0026e91:	ff 74 24 64          	pushl  0x64(%esp)
c0026e95:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c0026e99:	ba 01 00 00 00       	mov    $0x1,%edx
c0026e9e:	8d 44 24 2f          	lea    0x2f(%esp),%eax
c0026ea2:	e8 18 f9 ff ff       	call   c00267bf <format_string>
          break;
c0026ea7:	83 c4 10             	add    $0x10,%esp
c0026eaa:	89 fb                	mov    %edi,%ebx
            char ch = va_arg (args, int);
c0026eac:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c0026eb0:	e9 2a fa ff ff       	jmp    c00268df <__vprintf+0x4b>
      switch (*format) 
c0026eb5:	89 df                	mov    %ebx,%edi
            const char *s = va_arg (args, char *);
c0026eb7:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026ebb:	8d 70 04             	lea    0x4(%eax),%esi
c0026ebe:	8b 18                	mov    (%eax),%ebx
            if (s == NULL)
c0026ec0:	85 db                	test   %ebx,%ebx
c0026ec2:	74 30                	je     c0026ef4 <__vprintf+0x660>
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0026ec4:	83 ec 08             	sub    $0x8,%esp
c0026ec7:	52                   	push   %edx
c0026ec8:	53                   	push   %ebx
c0026ec9:	e8 0e 0b 00 00       	call   c00279dc <strnlen>
c0026ece:	83 c4 08             	add    $0x8,%esp
c0026ed1:	ff 74 24 64          	pushl  0x64(%esp)
c0026ed5:	ff 74 24 64          	pushl  0x64(%esp)
c0026ed9:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c0026edd:	89 c2                	mov    %eax,%edx
c0026edf:	89 d8                	mov    %ebx,%eax
c0026ee1:	e8 d9 f8 ff ff       	call   c00267bf <format_string>
          break;
c0026ee6:	83 c4 10             	add    $0x10,%esp
c0026ee9:	89 fb                	mov    %edi,%ebx
            const char *s = va_arg (args, char *);
c0026eeb:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c0026eef:	e9 eb f9 ff ff       	jmp    c00268df <__vprintf+0x4b>
              s = "(null)";
c0026ef4:	bb 92 f0 02 c0       	mov    $0xc002f092,%ebx
c0026ef9:	eb c9                	jmp    c0026ec4 <__vprintf+0x630>
      switch (*format) 
c0026efb:	89 df                	mov    %ebx,%edi
            void *p = va_arg (args, void *);
c0026efd:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f01:	8d 70 04             	lea    0x4(%eax),%esi
c0026f04:	8b 00                	mov    (%eax),%eax
            c.flags = POUND;
c0026f06:	c7 44 24 20 08 00 00 	movl   $0x8,0x20(%esp)
c0026f0d:	00 
            format_integer ((uintptr_t) p, false, false,
c0026f0e:	83 ec 0c             	sub    $0xc,%esp
c0026f11:	ff 74 24 68          	pushl  0x68(%esp)
c0026f15:	ff 74 24 68          	pushl  0x68(%esp)
c0026f19:	8d 5c 24 34          	lea    0x34(%esp),%ebx
c0026f1d:	53                   	push   %ebx
c0026f1e:	68 c0 d3 02 c0       	push   $0xc002d3c0
c0026f23:	6a 00                	push   $0x0
c0026f25:	b9 00 00 00 00       	mov    $0x0,%ecx
c0026f2a:	ba 00 00 00 00       	mov    $0x0,%edx
c0026f2f:	e8 2e f5 ff ff       	call   c0026462 <format_integer>
          break;
c0026f34:	83 c4 20             	add    $0x20,%esp
c0026f37:	89 fb                	mov    %edi,%ebx
            void *p = va_arg (args, void *);
c0026f39:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c0026f3d:	e9 9d f9 ff ff       	jmp    c00268df <__vprintf+0x4b>
      switch (*format) 
c0026f42:	89 df                	mov    %ebx,%edi
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0026f44:	55                   	push   %ebp
c0026f45:	ff 74 24 60          	pushl  0x60(%esp)
c0026f49:	ff 74 24 60          	pushl  0x60(%esp)
c0026f4d:	68 ab f0 02 c0       	push   $0xc002f0ab
c0026f52:	e8 20 f9 ff ff       	call   c0026877 <__printf>
          break;
c0026f57:	83 c4 10             	add    $0x10,%esp
c0026f5a:	89 fb                	mov    %edi,%ebx
c0026f5c:	e9 7e f9 ff ff       	jmp    c00268df <__vprintf+0x4b>
      switch (*format) 
c0026f61:	89 df                	mov    %ebx,%edi
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0026f63:	55                   	push   %ebp
c0026f64:	ff 74 24 60          	pushl  0x60(%esp)
c0026f68:	ff 74 24 60          	pushl  0x60(%esp)
c0026f6c:	68 c1 f0 02 c0       	push   $0xc002f0c1
c0026f71:	e8 01 f9 ff ff       	call   c0026877 <__printf>
          break;
c0026f76:	83 c4 10             	add    $0x10,%esp
c0026f79:	89 fb                	mov    %edi,%ebx
c0026f7b:	e9 5f f9 ff ff       	jmp    c00268df <__vprintf+0x4b>

c0026f80 <vsnprintf>:
{
c0026f80:	53                   	push   %ebx
c0026f81:	83 ec 18             	sub    $0x18,%esp
c0026f84:	8b 44 24 24          	mov    0x24(%esp),%eax
c0026f88:	8b 54 24 28          	mov    0x28(%esp),%edx
c0026f8c:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c0026f90:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0026f94:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  aux.length = 0;
c0026f98:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0026f9f:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0026fa0:	85 c0                	test   %eax,%eax
c0026fa2:	74 29                	je     c0026fcd <vsnprintf+0x4d>
c0026fa4:	48                   	dec    %eax
c0026fa5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf (format, args, vsnprintf_helper, &aux);
c0026fa9:	8d 44 24 04          	lea    0x4(%esp),%eax
c0026fad:	50                   	push   %eax
c0026fae:	68 11 64 02 c0       	push   $0xc0026411
c0026fb3:	51                   	push   %ecx
c0026fb4:	52                   	push   %edx
c0026fb5:	e8 da f8 ff ff       	call   c0026894 <__vprintf>
    *aux.p = '\0';
c0026fba:	8b 44 24 14          	mov    0x14(%esp),%eax
c0026fbe:	c6 00 00             	movb   $0x0,(%eax)
c0026fc1:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c0026fc4:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c0026fc8:	83 c4 18             	add    $0x18,%esp
c0026fcb:	5b                   	pop    %ebx
c0026fcc:	c3                   	ret    
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0026fcd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0026fd4:	00 
  __vprintf (format, args, vsnprintf_helper, &aux);
c0026fd5:	8d 44 24 04          	lea    0x4(%esp),%eax
c0026fd9:	50                   	push   %eax
c0026fda:	68 11 64 02 c0       	push   $0xc0026411
c0026fdf:	51                   	push   %ecx
c0026fe0:	52                   	push   %edx
c0026fe1:	e8 ae f8 ff ff       	call   c0026894 <__vprintf>
c0026fe6:	83 c4 10             	add    $0x10,%esp
c0026fe9:	eb d9                	jmp    c0026fc4 <vsnprintf+0x44>

c0026feb <snprintf>:
{
c0026feb:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0026fee:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c0026ff2:	50                   	push   %eax
c0026ff3:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026ff7:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026ffb:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026fff:	e8 7c ff ff ff       	call   c0026f80 <vsnprintf>
}
c0027004:	83 c4 1c             	add    $0x1c,%esp
c0027007:	c3                   	ret    

c0027008 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027008:	55                   	push   %ebp
c0027009:	57                   	push   %edi
c002700a:	56                   	push   %esi
c002700b:	53                   	push   %ebx
c002700c:	83 ec 1c             	sub    $0x1c,%esp
c002700f:	8a 44 24 3c          	mov    0x3c(%esp),%al
c0027013:	88 44 24 0f          	mov    %al,0xf(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027017:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002701c:	0f 84 d9 01 00 00    	je     c00271fb <hex_dump+0x1f3>
c0027022:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027026:	89 44 24 08          	mov    %eax,0x8(%esp)
c002702a:	e9 87 00 00 00       	jmp    c00270b6 <hex_dump+0xae>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
c002702f:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027033:	89 44 24 04          	mov    %eax,0x4(%esp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c0027037:	89 f3                	mov    %esi,%ebx
c0027039:	e9 e2 00 00 00       	jmp    c0027120 <hex_dump+0x118>
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c002703e:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027043:	e9 f0 00 00 00       	jmp    c0027138 <hex_dump+0x130>
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c0027048:	83 ec 0c             	sub    $0xc,%esp
c002704b:	0f b6 c0             	movzbl %al,%eax
c002704e:	50                   	push   %eax
c002704f:	e8 6c 2d 00 00       	call   c0029dc0 <putchar>
          for (; i < end; i++)
c0027054:	43                   	inc    %ebx
c0027055:	83 c4 10             	add    $0x10,%esp
c0027058:	39 fb                	cmp    %edi,%ebx
c002705a:	73 12                	jae    c002706e <hex_dump+0x66>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c002705c:	8a 04 1e             	mov    (%esi,%ebx,1),%al
static inline int isprint (int c) { return c >= 32 && c < 127; }
c002705f:	0f b6 d0             	movzbl %al,%edx
c0027062:	83 ea 20             	sub    $0x20,%edx
            printf ("%c",
c0027065:	83 fa 5e             	cmp    $0x5e,%edx
c0027068:	76 de                	jbe    c0027048 <hex_dump+0x40>
c002706a:	89 e8                	mov    %ebp,%eax
c002706c:	eb da                	jmp    c0027048 <hex_dump+0x40>
          for (; i < per_line; i++)
c002706e:	83 fb 0f             	cmp    $0xf,%ebx
c0027071:	77 13                	ja     c0027086 <hex_dump+0x7e>
            printf (" ");
c0027073:	83 ec 0c             	sub    $0xc,%esp
c0027076:	6a 20                	push   $0x20
c0027078:	e8 43 2d 00 00       	call   c0029dc0 <putchar>
          for (; i < per_line; i++)
c002707d:	43                   	inc    %ebx
c002707e:	83 c4 10             	add    $0x10,%esp
c0027081:	83 fb 0f             	cmp    $0xf,%ebx
c0027084:	76 ed                	jbe    c0027073 <hex_dump+0x6b>
          printf ("|");
c0027086:	83 ec 0c             	sub    $0xc,%esp
c0027089:	6a 7c                	push   $0x7c
c002708b:	e8 30 2d 00 00       	call   c0029dc0 <putchar>
c0027090:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027093:	83 ec 0c             	sub    $0xc,%esp
c0027096:	6a 0a                	push   $0xa
c0027098:	e8 23 2d 00 00       	call   c0029dc0 <putchar>

      ofs += n;
c002709d:	8b 44 24 14          	mov    0x14(%esp),%eax
c00270a1:	01 44 24 40          	add    %eax,0x40(%esp)
      buf += n;
c00270a5:	01 44 24 18          	add    %eax,0x18(%esp)
  while (size > 0)
c00270a9:	83 c4 10             	add    $0x10,%esp
c00270ac:	29 44 24 38          	sub    %eax,0x38(%esp)
c00270b0:	0f 84 45 01 00 00    	je     c00271fb <hex_dump+0x1f3>
      start = ofs % per_line;
c00270b6:	8b 74 24 30          	mov    0x30(%esp),%esi
c00270ba:	83 e6 0f             	and    $0xf,%esi
      if (end - start > size)
c00270bd:	b8 10 00 00 00       	mov    $0x10,%eax
c00270c2:	29 f0                	sub    %esi,%eax
c00270c4:	89 44 24 04          	mov    %eax,0x4(%esp)
c00270c8:	3b 44 24 38          	cmp    0x38(%esp),%eax
c00270cc:	0f 86 ea 00 00 00    	jbe    c00271bc <hex_dump+0x1b4>
        end = start + size;
c00270d2:	89 f7                	mov    %esi,%edi
c00270d4:	03 7c 24 38          	add    0x38(%esp),%edi
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c00270d8:	83 ec 04             	sub    $0x4,%esp
c00270db:	8b 44 24 34          	mov    0x34(%esp),%eax
c00270df:	83 e0 f0             	and    $0xfffffff0,%eax
c00270e2:	ba 00 00 00 00       	mov    $0x0,%edx
c00270e7:	52                   	push   %edx
c00270e8:	50                   	push   %eax
c00270e9:	68 d8 f0 02 c0       	push   $0xc002f0d8
c00270ee:	e8 6c f7 ff ff       	call   c002685f <printf>
      for (i = 0; i < start; i++)
c00270f3:	83 c4 10             	add    $0x10,%esp
c00270f6:	85 f6                	test   %esi,%esi
c00270f8:	0f 84 31 ff ff ff    	je     c002702f <hex_dump+0x27>
      n = end - start;
c00270fe:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027102:	89 44 24 04          	mov    %eax,0x4(%esp)
      end = per_line;
c0027106:	bb 00 00 00 00       	mov    $0x0,%ebx
        printf ("   ");
c002710b:	83 ec 0c             	sub    $0xc,%esp
c002710e:	68 e0 f0 02 c0       	push   $0xc002f0e0
c0027113:	e8 47 f7 ff ff       	call   c002685f <printf>
      for (i = 0; i < start; i++)
c0027118:	43                   	inc    %ebx
c0027119:	83 c4 10             	add    $0x10,%esp
c002711c:	39 de                	cmp    %ebx,%esi
c002711e:	77 eb                	ja     c002710b <hex_dump+0x103>
      for (; i < end; i++) 
c0027120:	39 fb                	cmp    %edi,%ebx
c0027122:	73 30                	jae    c0027154 <hex_dump+0x14c>
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027124:	8b 6c 24 08          	mov    0x8(%esp),%ebp
c0027128:	29 f5                	sub    %esi,%ebp
        printf ("%02hhx%c",
c002712a:	83 fb 07             	cmp    $0x7,%ebx
c002712d:	0f 84 0b ff ff ff    	je     c002703e <hex_dump+0x36>
c0027133:	b8 20 00 00 00       	mov    $0x20,%eax
c0027138:	83 ec 04             	sub    $0x4,%esp
c002713b:	50                   	push   %eax
c002713c:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
c0027141:	50                   	push   %eax
c0027142:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0027147:	e8 13 f7 ff ff       	call   c002685f <printf>
      for (; i < end; i++) 
c002714c:	43                   	inc    %ebx
c002714d:	83 c4 10             	add    $0x10,%esp
c0027150:	39 fb                	cmp    %edi,%ebx
c0027152:	72 d6                	jb     c002712a <hex_dump+0x122>
      if (ascii) 
c0027154:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0027159:	0f 84 34 ff ff ff    	je     c0027093 <hex_dump+0x8b>
          for (; i < per_line; i++)
c002715f:	83 fb 0f             	cmp    $0xf,%ebx
c0027162:	77 16                	ja     c002717a <hex_dump+0x172>
            printf ("   ");
c0027164:	83 ec 0c             	sub    $0xc,%esp
c0027167:	68 e0 f0 02 c0       	push   $0xc002f0e0
c002716c:	e8 ee f6 ff ff       	call   c002685f <printf>
          for (; i < per_line; i++)
c0027171:	43                   	inc    %ebx
c0027172:	83 c4 10             	add    $0x10,%esp
c0027175:	83 fb 10             	cmp    $0x10,%ebx
c0027178:	75 ea                	jne    c0027164 <hex_dump+0x15c>
          printf ("|");
c002717a:	83 ec 0c             	sub    $0xc,%esp
c002717d:	6a 7c                	push   $0x7c
c002717f:	e8 3c 2c 00 00       	call   c0029dc0 <putchar>
          for (i = 0; i < start; i++)
c0027184:	83 c4 10             	add    $0x10,%esp
c0027187:	85 f6                	test   %esi,%esi
c0027189:	74 63                	je     c00271ee <hex_dump+0x1e6>
c002718b:	bb 00 00 00 00       	mov    $0x0,%ebx
            printf (" ");
c0027190:	83 ec 0c             	sub    $0xc,%esp
c0027193:	6a 20                	push   $0x20
c0027195:	e8 26 2c 00 00       	call   c0029dc0 <putchar>
          for (i = 0; i < start; i++)
c002719a:	43                   	inc    %ebx
c002719b:	83 c4 10             	add    $0x10,%esp
c002719e:	39 de                	cmp    %ebx,%esi
c00271a0:	75 ee                	jne    c0027190 <hex_dump+0x188>
          for (; i < end; i++)
c00271a2:	39 fb                	cmp    %edi,%ebx
c00271a4:	0f 83 c4 fe ff ff    	jae    c002706e <hex_dump+0x66>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c00271aa:	8b 44 24 08          	mov    0x8(%esp),%eax
c00271ae:	29 f0                	sub    %esi,%eax
c00271b0:	89 c6                	mov    %eax,%esi
c00271b2:	bd 2e 00 00 00       	mov    $0x2e,%ebp
c00271b7:	e9 a0 fe ff ff       	jmp    c002705c <hex_dump+0x54>
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c00271bc:	83 ec 04             	sub    $0x4,%esp
c00271bf:	8b 44 24 34          	mov    0x34(%esp),%eax
c00271c3:	83 e0 f0             	and    $0xfffffff0,%eax
c00271c6:	ba 00 00 00 00       	mov    $0x0,%edx
c00271cb:	52                   	push   %edx
c00271cc:	50                   	push   %eax
c00271cd:	68 d8 f0 02 c0       	push   $0xc002f0d8
c00271d2:	e8 88 f6 ff ff       	call   c002685f <printf>
      for (i = 0; i < start; i++)
c00271d7:	83 c4 10             	add    $0x10,%esp
      end = per_line;
c00271da:	bf 10 00 00 00       	mov    $0x10,%edi
      for (i = 0; i < start; i++)
c00271df:	89 f3                	mov    %esi,%ebx
c00271e1:	85 f6                	test   %esi,%esi
c00271e3:	0f 85 1d ff ff ff    	jne    c0027106 <hex_dump+0xfe>
c00271e9:	e9 36 ff ff ff       	jmp    c0027124 <hex_dump+0x11c>
          for (i = 0; i < start; i++)
c00271ee:	89 f3                	mov    %esi,%ebx
          for (; i < end; i++)
c00271f0:	85 ff                	test   %edi,%edi
c00271f2:	75 b6                	jne    c00271aa <hex_dump+0x1a2>
          for (i = 0; i < start; i++)
c00271f4:	89 fb                	mov    %edi,%ebx
c00271f6:	e9 78 fe ff ff       	jmp    c0027073 <hex_dump+0x6b>
      size -= n;
    }
}
c00271fb:	83 c4 1c             	add    $0x1c,%esp
c00271fe:	5b                   	pop    %ebx
c00271ff:	5e                   	pop    %esi
c0027200:	5f                   	pop    %edi
c0027201:	5d                   	pop    %ebp
c0027202:	c3                   	ret    

c0027203 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027203:	57                   	push   %edi
c0027204:	56                   	push   %esi
c0027205:	83 ec 04             	sub    $0x4,%esp
c0027208:	8b 74 24 10          	mov    0x10(%esp),%esi
c002720c:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
c0027210:	89 f0                	mov    %esi,%eax
c0027212:	83 f0 01             	xor    $0x1,%eax
c0027215:	89 fa                	mov    %edi,%edx
c0027217:	09 c2                	or     %eax,%edx
c0027219:	74 1d                	je     c0027238 <print_human_readable_size+0x35>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002721b:	83 ff 00             	cmp    $0x0,%edi
c002721e:	77 08                	ja     c0027228 <print_human_readable_size+0x25>
c0027220:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0027226:	76 5d                	jbe    c0027285 <print_human_readable_size+0x82>
c0027228:	b9 98 80 03 c0       	mov    $0xc0038098,%ecx
c002722d:	83 3d 9c 80 03 c0 00 	cmpl   $0x0,0xc003809c
c0027234:	75 1a                	jne    c0027250 <print_human_readable_size+0x4d>
c0027236:	eb 36                	jmp    c002726e <print_human_readable_size+0x6b>
    printf ("1 byte");
c0027238:	83 ec 0c             	sub    $0xc,%esp
c002723b:	68 ed f0 02 c0       	push   $0xc002f0ed
c0027240:	e8 1a f6 ff ff       	call   c002685f <printf>
c0027245:	83 c4 10             	add    $0x10,%esp
c0027248:	eb 35                	jmp    c002727f <print_human_readable_size+0x7c>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002724a:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
c002724e:	74 1e                	je     c002726e <print_human_readable_size+0x6b>
        size /= 1024;
c0027250:	89 f0                	mov    %esi,%eax
c0027252:	89 fa                	mov    %edi,%edx
c0027254:	0f ac f8 0a          	shrd   $0xa,%edi,%eax
c0027258:	c1 ea 0a             	shr    $0xa,%edx
c002725b:	89 c6                	mov    %eax,%esi
c002725d:	89 d7                	mov    %edx,%edi
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002725f:	83 c1 04             	add    $0x4,%ecx
c0027262:	83 fa 00             	cmp    $0x0,%edx
c0027265:	77 e3                	ja     c002724a <print_human_readable_size+0x47>
c0027267:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c002726c:	77 dc                	ja     c002724a <print_human_readable_size+0x47>
      printf ("%"PRIu64" %s", size, *fp);
c002726e:	ff 31                	pushl  (%ecx)
c0027270:	57                   	push   %edi
c0027271:	56                   	push   %esi
c0027272:	68 f4 f0 02 c0       	push   $0xc002f0f4
c0027277:	e8 e3 f5 ff ff       	call   c002685f <printf>
c002727c:	83 c4 10             	add    $0x10,%esp
    }
}
c002727f:	83 c4 04             	add    $0x4,%esp
c0027282:	5e                   	pop    %esi
c0027283:	5f                   	pop    %edi
c0027284:	c3                   	ret    
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027285:	b9 98 80 03 c0       	mov    $0xc0038098,%ecx
c002728a:	eb e2                	jmp    c002726e <print_human_readable_size+0x6b>

c002728c <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c002728c:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c002728f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027293:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027297:	8b 44 24 28          	mov    0x28(%esp),%eax
c002729b:	ff 10                	call   *(%eax)
}
c002729d:	83 c4 1c             	add    $0x1c,%esp
c00272a0:	c3                   	ret    

c00272a1 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c00272a1:	55                   	push   %ebp
c00272a2:	57                   	push   %edi
c00272a3:	56                   	push   %esi
c00272a4:	53                   	push   %ebx
c00272a5:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c00272a9:	8d 72 ff             	lea    -0x1(%edx),%esi
c00272ac:	0f af f7             	imul   %edi,%esi
  unsigned char *b = array + (b_idx - 1) * size;
c00272af:	8d 59 ff             	lea    -0x1(%ecx),%ebx
c00272b2:	0f af df             	imul   %edi,%ebx
  size_t i;

  for (i = 0; i < size; i++)
c00272b5:	85 ff                	test   %edi,%edi
c00272b7:	74 1d                	je     c00272d6 <do_swap+0x35>
c00272b9:	8d 14 30             	lea    (%eax,%esi,1),%edx
c00272bc:	01 f7                	add    %esi,%edi
c00272be:	01 c7                	add    %eax,%edi
    {
      unsigned char t = a[i];
c00272c0:	0f b6 2a             	movzbl (%edx),%ebp
c00272c3:	89 d1                	mov    %edx,%ecx
c00272c5:	29 f1                	sub    %esi,%ecx
      a[i] = b[i];
c00272c7:	8a 04 19             	mov    (%ecx,%ebx,1),%al
c00272ca:	88 02                	mov    %al,(%edx)
      b[i] = t;
c00272cc:	89 e8                	mov    %ebp,%eax
c00272ce:	88 04 19             	mov    %al,(%ecx,%ebx,1)
c00272d1:	42                   	inc    %edx
  for (i = 0; i < size; i++)
c00272d2:	39 fa                	cmp    %edi,%edx
c00272d4:	75 ea                	jne    c00272c0 <do_swap+0x1f>
    }
}
c00272d6:	5b                   	pop    %ebx
c00272d7:	5e                   	pop    %esi
c00272d8:	5f                   	pop    %edi
c00272d9:	5d                   	pop    %ebp
c00272da:	c3                   	ret    

c00272db <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c00272db:	55                   	push   %ebp
c00272dc:	57                   	push   %edi
c00272dd:	56                   	push   %esi
c00272de:	53                   	push   %ebx
c00272df:	83 ec 1c             	sub    $0x1c,%esp
c00272e2:	89 44 24 0c          	mov    %eax,0xc(%esp)
c00272e6:	89 d6                	mov    %edx,%esi
c00272e8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c00272ec:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c00272f0:	eb 4a                	jmp    c002733c <heapify+0x61>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c00272f2:	83 ec 04             	sub    $0x4,%esp
c00272f5:	ff 74 24 3c          	pushl  0x3c(%esp)
c00272f9:	8d 46 ff             	lea    -0x1(%esi),%eax
c00272fc:	0f af c5             	imul   %ebp,%eax
c00272ff:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0027303:	01 c8                	add    %ecx,%eax
c0027305:	50                   	push   %eax
c0027306:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027309:	0f af c5             	imul   %ebp,%eax
c002730c:	01 c8                	add    %ecx,%eax
c002730e:	50                   	push   %eax
c002730f:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027313:	83 c4 10             	add    $0x10,%esp
c0027316:	85 c0                	test   %eax,%eax
c0027318:	7e 2e                	jle    c0027348 <heapify+0x6d>
        max = left;
      if (right <= cnt
c002731a:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002731e:	76 5b                	jbe    c002737b <heapify+0xa0>
        max = left;
c0027320:	89 df                	mov    %ebx,%edi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0027322:	39 fe                	cmp    %edi,%esi
c0027324:	74 4d                	je     c0027373 <heapify+0x98>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0027326:	83 ec 0c             	sub    $0xc,%esp
c0027329:	55                   	push   %ebp
c002732a:	89 f9                	mov    %edi,%ecx
c002732c:	89 f2                	mov    %esi,%edx
c002732e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0027332:	e8 6a ff ff ff       	call   c00272a1 <do_swap>
c0027337:	89 fe                	mov    %edi,%esi
    {
c0027339:	83 c4 10             	add    $0x10,%esp
      size_t left = 2 * i;
c002733c:	8d 1c 36             	lea    (%esi,%esi,1),%ebx
      size_t right = 2 * i + 1;
c002733f:	8d 7b 01             	lea    0x1(%ebx),%edi
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027342:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0027346:	76 aa                	jbe    c00272f2 <heapify+0x17>
      if (right <= cnt
c0027348:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002734c:	77 25                	ja     c0027373 <heapify+0x98>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c002734e:	83 ec 04             	sub    $0x4,%esp
c0027351:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027355:	8d 46 ff             	lea    -0x1(%esi),%eax
c0027358:	0f af c5             	imul   %ebp,%eax
c002735b:	8b 54 24 14          	mov    0x14(%esp),%edx
c002735f:	01 d0                	add    %edx,%eax
c0027361:	50                   	push   %eax
c0027362:	0f af dd             	imul   %ebp,%ebx
c0027365:	01 d3                	add    %edx,%ebx
c0027367:	53                   	push   %ebx
c0027368:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c002736c:	83 c4 10             	add    $0x10,%esp
c002736f:	85 c0                	test   %eax,%eax
c0027371:	7f af                	jg     c0027322 <heapify+0x47>
      i = max;
    }
}
c0027373:	83 c4 1c             	add    $0x1c,%esp
c0027376:	5b                   	pop    %ebx
c0027377:	5e                   	pop    %esi
c0027378:	5f                   	pop    %edi
c0027379:	5d                   	pop    %ebp
c002737a:	c3                   	ret    
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c002737b:	83 ec 04             	sub    $0x4,%esp
c002737e:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027382:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027385:	0f af c5             	imul   %ebp,%eax
c0027388:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002738c:	01 c8                	add    %ecx,%eax
c002738e:	50                   	push   %eax
c002738f:	89 d8                	mov    %ebx,%eax
c0027391:	0f af c5             	imul   %ebp,%eax
c0027394:	01 c8                	add    %ecx,%eax
c0027396:	50                   	push   %eax
c0027397:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c002739b:	83 c4 10             	add    $0x10,%esp
c002739e:	85 c0                	test   %eax,%eax
c00273a0:	7f 80                	jg     c0027322 <heapify+0x47>
        max = left;
c00273a2:	89 df                	mov    %ebx,%edi
c00273a4:	e9 79 ff ff ff       	jmp    c0027322 <heapify+0x47>

c00273a9 <atoi>:
{
c00273a9:	56                   	push   %esi
c00273aa:	53                   	push   %ebx
c00273ab:	83 ec 04             	sub    $0x4,%esp
c00273ae:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (s != NULL);
c00273b2:	85 d2                	test   %edx,%edx
c00273b4:	75 1f                	jne    c00273d5 <atoi+0x2c>
c00273b6:	83 ec 0c             	sub    $0xc,%esp
c00273b9:	68 93 f1 02 c0       	push   $0xc002f193
c00273be:	68 3f d9 02 c0       	push   $0xc002d93f
c00273c3:	68 f8 d3 02 c0       	push   $0xc002d3f8
c00273c8:	6a 0f                	push   $0xf
c00273ca:	68 44 f1 02 c0       	push   $0xc002f144
c00273cf:	e8 39 0f 00 00       	call   c002830d <debug_panic>
    s++;
c00273d4:	42                   	inc    %edx
  while (isspace ((unsigned char) *s))
c00273d5:	8a 02                	mov    (%edx),%al
          || c == '\r' || c == '\t' || c == '\v');
c00273d7:	3c 20                	cmp    $0x20,%al
c00273d9:	74 f9                	je     c00273d4 <atoi+0x2b>
c00273db:	8d 48 f7             	lea    -0x9(%eax),%ecx
c00273de:	80 f9 04             	cmp    $0x4,%cl
c00273e1:	76 f1                	jbe    c00273d4 <atoi+0x2b>
  if (*s == '+')
c00273e3:	3c 2b                	cmp    $0x2b,%al
c00273e5:	74 3e                	je     c0027425 <atoi+0x7c>
  else if (*s == '-')
c00273e7:	3c 2d                	cmp    $0x2d,%al
c00273e9:	74 3d                	je     c0027428 <atoi+0x7f>
  for (value = 0; isdigit (*s); s++)
c00273eb:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00273ee:	8d 41 d0             	lea    -0x30(%ecx),%eax
c00273f1:	be 00 00 00 00       	mov    $0x0,%esi
c00273f6:	83 f8 09             	cmp    $0x9,%eax
c00273f9:	77 4c                	ja     c0027447 <atoi+0x9e>
      negative = true;
c00273fb:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c0027400:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0027403:	89 c3                	mov    %eax,%ebx
c0027405:	29 cb                	sub    %ecx,%ebx
c0027407:	8d 44 03 30          	lea    0x30(%ebx,%eax,1),%eax
  for (value = 0; isdigit (*s); s++)
c002740b:	42                   	inc    %edx
c002740c:	0f be 0a             	movsbl (%edx),%ecx
c002740f:	8d 59 d0             	lea    -0x30(%ecx),%ebx
c0027412:	83 fb 09             	cmp    $0x9,%ebx
c0027415:	76 e9                	jbe    c0027400 <atoi+0x57>
  if (!negative)
c0027417:	89 f3                	mov    %esi,%ebx
c0027419:	84 db                	test   %bl,%bl
c002741b:	75 02                	jne    c002741f <atoi+0x76>
    value = -value;
c002741d:	f7 d8                	neg    %eax
}
c002741f:	83 c4 04             	add    $0x4,%esp
c0027422:	5b                   	pop    %ebx
c0027423:	5e                   	pop    %esi
c0027424:	c3                   	ret    
    s++;
c0027425:	42                   	inc    %edx
c0027426:	eb c3                	jmp    c00273eb <atoi+0x42>
      s++;
c0027428:	8d 42 01             	lea    0x1(%edx),%eax
  for (value = 0; isdigit (*s); s++)
c002742b:	0f be 4a 01          	movsbl 0x1(%edx),%ecx
c002742f:	8d 51 d0             	lea    -0x30(%ecx),%edx
c0027432:	83 fa 09             	cmp    $0x9,%edx
c0027435:	77 09                	ja     c0027440 <atoi+0x97>
      s++;
c0027437:	89 c2                	mov    %eax,%edx
      negative = true;
c0027439:	be 01 00 00 00       	mov    $0x1,%esi
c002743e:	eb bb                	jmp    c00273fb <atoi+0x52>
  for (value = 0; isdigit (*s); s++)
c0027440:	b8 00 00 00 00       	mov    $0x0,%eax
  return value;
c0027445:	eb d8                	jmp    c002741f <atoi+0x76>
  for (value = 0; isdigit (*s); s++)
c0027447:	b8 00 00 00 00       	mov    $0x0,%eax
c002744c:	eb cf                	jmp    c002741d <atoi+0x74>

c002744e <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c002744e:	55                   	push   %ebp
c002744f:	57                   	push   %edi
c0027450:	56                   	push   %esi
c0027451:	53                   	push   %ebx
c0027452:	83 ec 0c             	sub    $0xc,%esp
c0027455:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c0027459:	8b 7c 24 28          	mov    0x28(%esp),%edi
c002745d:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c0027461:	8b 74 24 30          	mov    0x30(%esp),%esi
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0027465:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c002746a:	74 7b                	je     c00274e7 <sort+0x99>
  ASSERT (compare != NULL);
c002746c:	85 ed                	test   %ebp,%ebp
c002746e:	0f 84 98 00 00 00    	je     c002750c <sort+0xbe>
  ASSERT (size > 0);
c0027474:	85 ff                	test   %edi,%edi
c0027476:	0f 84 b1 00 00 00    	je     c002752d <sort+0xdf>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c002747c:	89 d8                	mov    %ebx,%eax
c002747e:	d1 e8                	shr    %eax
c0027480:	74 25                	je     c00274a7 <sort+0x59>
c0027482:	89 5c 24 24          	mov    %ebx,0x24(%esp)
c0027486:	89 c3                	mov    %eax,%ebx
    heapify (array, i, cnt, size, compare, aux);
c0027488:	83 ec 04             	sub    $0x4,%esp
c002748b:	56                   	push   %esi
c002748c:	55                   	push   %ebp
c002748d:	57                   	push   %edi
c002748e:	8b 4c 24 34          	mov    0x34(%esp),%ecx
c0027492:	89 da                	mov    %ebx,%edx
c0027494:	8b 44 24 30          	mov    0x30(%esp),%eax
c0027498:	e8 3e fe ff ff       	call   c00272db <heapify>
  for (i = cnt / 2; i > 0; i--)
c002749d:	83 c4 10             	add    $0x10,%esp
c00274a0:	4b                   	dec    %ebx
c00274a1:	75 e5                	jne    c0027488 <sort+0x3a>
c00274a3:	8b 5c 24 24          	mov    0x24(%esp),%ebx

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c00274a7:	83 fb 01             	cmp    $0x1,%ebx
c00274aa:	76 33                	jbe    c00274df <sort+0x91>
    {
      do_swap (array, 1, i, size);
c00274ac:	83 ec 0c             	sub    $0xc,%esp
c00274af:	57                   	push   %edi
c00274b0:	89 d9                	mov    %ebx,%ecx
c00274b2:	ba 01 00 00 00       	mov    $0x1,%edx
c00274b7:	8b 44 24 30          	mov    0x30(%esp),%eax
c00274bb:	e8 e1 fd ff ff       	call   c00272a1 <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c00274c0:	4b                   	dec    %ebx
c00274c1:	83 c4 0c             	add    $0xc,%esp
c00274c4:	56                   	push   %esi
c00274c5:	55                   	push   %ebp
c00274c6:	57                   	push   %edi
c00274c7:	89 d9                	mov    %ebx,%ecx
c00274c9:	ba 01 00 00 00       	mov    $0x1,%edx
c00274ce:	8b 44 24 30          	mov    0x30(%esp),%eax
c00274d2:	e8 04 fe ff ff       	call   c00272db <heapify>
  for (i = cnt; i > 1; i--) 
c00274d7:	83 c4 10             	add    $0x10,%esp
c00274da:	83 fb 01             	cmp    $0x1,%ebx
c00274dd:	75 cd                	jne    c00274ac <sort+0x5e>
    }
}
c00274df:	83 c4 0c             	add    $0xc,%esp
c00274e2:	5b                   	pop    %ebx
c00274e3:	5e                   	pop    %esi
c00274e4:	5f                   	pop    %edi
c00274e5:	5d                   	pop    %ebp
c00274e6:	c3                   	ret    
  ASSERT (array != NULL || cnt == 0);
c00274e7:	85 db                	test   %ebx,%ebx
c00274e9:	74 81                	je     c002746c <sort+0x1e>
c00274eb:	83 ec 0c             	sub    $0xc,%esp
c00274ee:	68 57 f1 02 c0       	push   $0xc002f157
c00274f3:	68 3f d9 02 c0       	push   $0xc002d93f
c00274f8:	68 f0 d3 02 c0       	push   $0xc002d3f0
c00274fd:	68 8a 00 00 00       	push   $0x8a
c0027502:	68 44 f1 02 c0       	push   $0xc002f144
c0027507:	e8 01 0e 00 00       	call   c002830d <debug_panic>
  ASSERT (compare != NULL);
c002750c:	83 ec 0c             	sub    $0xc,%esp
c002750f:	68 71 f1 02 c0       	push   $0xc002f171
c0027514:	68 3f d9 02 c0       	push   $0xc002d93f
c0027519:	68 f0 d3 02 c0       	push   $0xc002d3f0
c002751e:	68 8b 00 00 00       	push   $0x8b
c0027523:	68 44 f1 02 c0       	push   $0xc002f144
c0027528:	e8 e0 0d 00 00       	call   c002830d <debug_panic>
  ASSERT (size > 0);
c002752d:	83 ec 0c             	sub    $0xc,%esp
c0027530:	68 81 f1 02 c0       	push   $0xc002f181
c0027535:	68 3f d9 02 c0       	push   $0xc002d93f
c002753a:	68 f0 d3 02 c0       	push   $0xc002d3f0
c002753f:	68 8c 00 00 00       	push   $0x8c
c0027544:	68 44 f1 02 c0       	push   $0xc002f144
c0027549:	e8 bf 0d 00 00       	call   c002830d <debug_panic>

c002754e <qsort>:
{
c002754e:	83 ec 18             	sub    $0x18,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c0027551:	8d 44 24 28          	lea    0x28(%esp),%eax
c0027555:	50                   	push   %eax
c0027556:	68 8c 72 02 c0       	push   $0xc002728c
c002755b:	ff 74 24 2c          	pushl  0x2c(%esp)
c002755f:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027563:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027567:	e8 e2 fe ff ff       	call   c002744e <sort>
}
c002756c:	83 c4 2c             	add    $0x2c,%esp
c002756f:	c3                   	ret    

c0027570 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c0027570:	55                   	push   %ebp
c0027571:	57                   	push   %edi
c0027572:	56                   	push   %esi
c0027573:	53                   	push   %ebx
c0027574:	83 ec 0c             	sub    $0xc,%esp
c0027577:	8b 74 24 24          	mov    0x24(%esp),%esi
c002757b:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c002757f:	89 fd                	mov    %edi,%ebp
c0027581:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c0027586:	01 f5                	add    %esi,%ebp

  while (first < last) 
c0027588:	39 ee                	cmp    %ebp,%esi
c002758a:	72 0d                	jb     c0027599 <binary_search+0x29>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c002758c:	b8 00 00 00 00       	mov    $0x0,%eax
c0027591:	eb 3e                	jmp    c00275d1 <binary_search+0x61>
      const unsigned char *middle = first + (range / 2) * size;
c0027593:	89 dd                	mov    %ebx,%ebp
  while (first < last) 
c0027595:	39 ee                	cmp    %ebp,%esi
c0027597:	73 33                	jae    c00275cc <binary_search+0x5c>
      size_t range = (last - first) / size;
c0027599:	89 e8                	mov    %ebp,%eax
c002759b:	29 f0                	sub    %esi,%eax
c002759d:	ba 00 00 00 00       	mov    $0x0,%edx
c00275a2:	f7 f7                	div    %edi
      const unsigned char *middle = first + (range / 2) * size;
c00275a4:	d1 e8                	shr    %eax
c00275a6:	0f af c7             	imul   %edi,%eax
c00275a9:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c00275ac:	83 ec 04             	sub    $0x4,%esp
c00275af:	ff 74 24 38          	pushl  0x38(%esp)
c00275b3:	53                   	push   %ebx
c00275b4:	ff 74 24 2c          	pushl  0x2c(%esp)
c00275b8:	ff 54 24 40          	call   *0x40(%esp)
      if (cmp < 0) 
c00275bc:	83 c4 10             	add    $0x10,%esp
c00275bf:	85 c0                	test   %eax,%eax
c00275c1:	78 d0                	js     c0027593 <binary_search+0x23>
      else if (cmp > 0) 
c00275c3:	85 c0                	test   %eax,%eax
c00275c5:	7e 12                	jle    c00275d9 <binary_search+0x69>
        first = middle + size;
c00275c7:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c00275ca:	eb c9                	jmp    c0027595 <binary_search+0x25>
  return NULL;
c00275cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00275d1:	83 c4 0c             	add    $0xc,%esp
c00275d4:	5b                   	pop    %ebx
c00275d5:	5e                   	pop    %esi
c00275d6:	5f                   	pop    %edi
c00275d7:	5d                   	pop    %ebp
c00275d8:	c3                   	ret    
      const unsigned char *middle = first + (range / 2) * size;
c00275d9:	89 d8                	mov    %ebx,%eax
c00275db:	eb f4                	jmp    c00275d1 <binary_search+0x61>

c00275dd <bsearch>:
{
c00275dd:	83 ec 14             	sub    $0x14,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00275e0:	8d 44 24 28          	lea    0x28(%esp),%eax
c00275e4:	50                   	push   %eax
c00275e5:	68 8c 72 02 c0       	push   $0xc002728c
c00275ea:	ff 74 24 2c          	pushl  0x2c(%esp)
c00275ee:	ff 74 24 2c          	pushl  0x2c(%esp)
c00275f2:	ff 74 24 2c          	pushl  0x2c(%esp)
c00275f6:	ff 74 24 2c          	pushl  0x2c(%esp)
c00275fa:	e8 71 ff ff ff       	call   c0027570 <binary_search>
}
c00275ff:	83 c4 2c             	add    $0x2c,%esp
c0027602:	c3                   	ret    

c0027603 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0027603:	56                   	push   %esi
c0027604:	53                   	push   %ebx
c0027605:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027609:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002760d:	8b 74 24 14          	mov    0x14(%esp),%esi
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c0027611:	85 f6                	test   %esi,%esi
c0027613:	74 10                	je     c0027625 <memcpy+0x22>
c0027615:	ba 00 00 00 00       	mov    $0x0,%edx
    *dst++ = *src++;
c002761a:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
c002761d:	88 0c 10             	mov    %cl,(%eax,%edx,1)
c0027620:	42                   	inc    %edx
  while (size-- > 0)
c0027621:	39 f2                	cmp    %esi,%edx
c0027623:	75 f5                	jne    c002761a <memcpy+0x17>

  return dst_;
}
c0027625:	5b                   	pop    %ebx
c0027626:	5e                   	pop    %esi
c0027627:	c3                   	ret    

c0027628 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c0027628:	57                   	push   %edi
c0027629:	56                   	push   %esi
c002762a:	53                   	push   %ebx
c002762b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002762f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0027633:	8b 74 24 18          	mov    0x18(%esp),%esi
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
c0027637:	39 d9                	cmp    %ebx,%ecx
c0027639:	73 1d                	jae    c0027658 <memmove+0x30>
    {
      while (size-- > 0)
c002763b:	85 f6                	test   %esi,%esi
c002763d:	74 35                	je     c0027674 <memmove+0x4c>
c002763f:	b8 00 00 00 00       	mov    $0x0,%eax
        *dst++ = *src++;
c0027644:	8a 14 03             	mov    (%ebx,%eax,1),%dl
c0027647:	88 14 01             	mov    %dl,(%ecx,%eax,1)
c002764a:	40                   	inc    %eax
      while (size-- > 0)
c002764b:	39 f0                	cmp    %esi,%eax
c002764d:	75 f5                	jne    c0027644 <memmove+0x1c>
c002764f:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c0027652:	89 f8                	mov    %edi,%eax
c0027654:	5b                   	pop    %ebx
c0027655:	5e                   	pop    %esi
c0027656:	5f                   	pop    %edi
c0027657:	c3                   	ret    
      dst += size;
c0027658:	8d 3c 31             	lea    (%ecx,%esi,1),%edi
      while (size-- > 0)
c002765b:	8d 56 ff             	lea    -0x1(%esi),%edx
c002765e:	85 f6                	test   %esi,%esi
c0027660:	74 f0                	je     c0027652 <memmove+0x2a>
c0027662:	89 ce                	mov    %ecx,%esi
c0027664:	89 f7                	mov    %esi,%edi
        *--dst = *--src;
c0027666:	8a 04 13             	mov    (%ebx,%edx,1),%al
c0027669:	88 04 11             	mov    %al,(%ecx,%edx,1)
      while (size-- > 0)
c002766c:	4a                   	dec    %edx
c002766d:	83 fa ff             	cmp    $0xffffffff,%edx
c0027670:	75 f2                	jne    c0027664 <memmove+0x3c>
c0027672:	eb de                	jmp    c0027652 <memmove+0x2a>
      while (size-- > 0)
c0027674:	89 cf                	mov    %ecx,%edi
c0027676:	eb da                	jmp    c0027652 <memmove+0x2a>

c0027678 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0027678:	57                   	push   %edi
c0027679:	56                   	push   %esi
c002767a:	53                   	push   %ebx
c002767b:	8b 74 24 10          	mov    0x10(%esp),%esi
c002767f:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0027683:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c0027687:	85 db                	test   %ebx,%ebx
c0027689:	74 30                	je     c00276bb <memcmp+0x43>
    if (*a != *b)
c002768b:	8a 16                	mov    (%esi),%dl
c002768d:	8a 0f                	mov    (%edi),%cl
c002768f:	38 ca                	cmp    %cl,%dl
c0027691:	75 15                	jne    c00276a8 <memcmp+0x30>
c0027693:	b8 01 00 00 00       	mov    $0x1,%eax
  for (; size-- > 0; a++, b++)
c0027698:	39 d8                	cmp    %ebx,%eax
c002769a:	74 18                	je     c00276b4 <memcmp+0x3c>
    if (*a != *b)
c002769c:	8a 14 06             	mov    (%esi,%eax,1),%dl
c002769f:	40                   	inc    %eax
c00276a0:	8a 4c 07 ff          	mov    -0x1(%edi,%eax,1),%cl
c00276a4:	38 ca                	cmp    %cl,%dl
c00276a6:	74 f0                	je     c0027698 <memcmp+0x20>
      return *a > *b ? +1 : -1;
c00276a8:	38 d1                	cmp    %dl,%cl
c00276aa:	19 c0                	sbb    %eax,%eax
c00276ac:	83 e0 02             	and    $0x2,%eax
c00276af:	48                   	dec    %eax
  return 0;
}
c00276b0:	5b                   	pop    %ebx
c00276b1:	5e                   	pop    %esi
c00276b2:	5f                   	pop    %edi
c00276b3:	c3                   	ret    
  return 0;
c00276b4:	b8 00 00 00 00       	mov    $0x0,%eax
c00276b9:	eb f5                	jmp    c00276b0 <memcmp+0x38>
c00276bb:	b8 00 00 00 00       	mov    $0x0,%eax
c00276c0:	eb ee                	jmp    c00276b0 <memcmp+0x38>

c00276c2 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c00276c2:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00276c6:	8b 44 24 08          	mov    0x8(%esp),%eax
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c00276ca:	8a 11                	mov    (%ecx),%dl
c00276cc:	84 d2                	test   %dl,%dl
c00276ce:	74 10                	je     c00276e0 <strcmp+0x1e>
c00276d0:	3a 10                	cmp    (%eax),%dl
c00276d2:	75 0c                	jne    c00276e0 <strcmp+0x1e>
    {
      a++;
c00276d4:	41                   	inc    %ecx
      b++;
c00276d5:	40                   	inc    %eax
  while (*a != '\0' && *a == *b) 
c00276d6:	8a 11                	mov    (%ecx),%dl
c00276d8:	84 d2                	test   %dl,%dl
c00276da:	74 04                	je     c00276e0 <strcmp+0x1e>
c00276dc:	3a 10                	cmp    (%eax),%dl
c00276de:	74 f4                	je     c00276d4 <strcmp+0x12>
    }

  return *a < *b ? -1 : *a > *b;
c00276e0:	8a 00                	mov    (%eax),%al
c00276e2:	38 d0                	cmp    %dl,%al
c00276e4:	77 07                	ja     c00276ed <strcmp+0x2b>
c00276e6:	0f 92 c0             	setb   %al
c00276e9:	0f b6 c0             	movzbl %al,%eax
c00276ec:	c3                   	ret    
c00276ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c00276f2:	c3                   	ret    

c00276f3 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c00276f3:	53                   	push   %ebx
c00276f4:	8b 44 24 08          	mov    0x8(%esp),%eax
c00276f8:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00276fc:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0027700:	85 d2                	test   %edx,%edx
c0027702:	74 1a                	je     c002771e <memchr+0x2b>
c0027704:	88 d9                	mov    %bl,%cl
    if (*block == ch)
c0027706:	3a 18                	cmp    (%eax),%bl
c0027708:	74 12                	je     c002771c <memchr+0x29>
c002770a:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c002770c:	40                   	inc    %eax
c002770d:	39 c2                	cmp    %eax,%edx
c002770f:	74 06                	je     c0027717 <memchr+0x24>
    if (*block == ch)
c0027711:	3a 08                	cmp    (%eax),%cl
c0027713:	75 f7                	jne    c002770c <memchr+0x19>
c0027715:	eb 05                	jmp    c002771c <memchr+0x29>
      return (void *) block;

  return NULL;
c0027717:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002771c:	5b                   	pop    %ebx
c002771d:	c3                   	ret    
  return NULL;
c002771e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027723:	eb f7                	jmp    c002771c <memchr+0x29>

c0027725 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c0027725:	53                   	push   %ebx
c0027726:	8b 44 24 08          	mov    0x8(%esp),%eax
c002772a:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c002772e:	8a 18                	mov    (%eax),%bl
c0027730:	38 da                	cmp    %bl,%dl
c0027732:	74 16                	je     c002774a <strchr+0x25>
c0027734:	88 d1                	mov    %dl,%cl
      return (char *) string;
    else if (*string == '\0')
c0027736:	84 db                	test   %bl,%bl
c0027738:	74 12                	je     c002774c <strchr+0x27>
      return NULL;
    else
      string++;
c002773a:	40                   	inc    %eax
    if (*string == c)
c002773b:	8a 10                	mov    (%eax),%dl
c002773d:	38 d1                	cmp    %dl,%cl
c002773f:	74 09                	je     c002774a <strchr+0x25>
    else if (*string == '\0')
c0027741:	84 d2                	test   %dl,%dl
c0027743:	75 f5                	jne    c002773a <strchr+0x15>
      return NULL;
c0027745:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002774a:	5b                   	pop    %ebx
c002774b:	c3                   	ret    
      return NULL;
c002774c:	b8 00 00 00 00       	mov    $0x0,%eax
c0027751:	eb f7                	jmp    c002774a <strchr+0x25>

c0027753 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c0027753:	57                   	push   %edi
c0027754:	56                   	push   %esi
c0027755:	53                   	push   %ebx
c0027756:	8b 74 24 10          	mov    0x10(%esp),%esi
c002775a:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c002775e:	8a 06                	mov    (%esi),%al
c0027760:	84 c0                	test   %al,%al
c0027762:	74 24                	je     c0027788 <strcspn+0x35>
c0027764:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c0027769:	0f be c0             	movsbl %al,%eax
c002776c:	50                   	push   %eax
c002776d:	57                   	push   %edi
c002776e:	e8 b2 ff ff ff       	call   c0027725 <strchr>
c0027773:	83 c4 08             	add    $0x8,%esp
c0027776:	85 c0                	test   %eax,%eax
c0027778:	75 08                	jne    c0027782 <strcspn+0x2f>
  for (length = 0; string[length] != '\0'; length++)
c002777a:	43                   	inc    %ebx
c002777b:	8a 04 1e             	mov    (%esi,%ebx,1),%al
c002777e:	84 c0                	test   %al,%al
c0027780:	75 e7                	jne    c0027769 <strcspn+0x16>
      break;
  return length;
}
c0027782:	89 d8                	mov    %ebx,%eax
c0027784:	5b                   	pop    %ebx
c0027785:	5e                   	pop    %esi
c0027786:	5f                   	pop    %edi
c0027787:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0027788:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c002778d:	eb f3                	jmp    c0027782 <strcspn+0x2f>

c002778f <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c002778f:	56                   	push   %esi
c0027790:	53                   	push   %ebx
c0027791:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027795:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c0027799:	8a 13                	mov    (%ebx),%dl
c002779b:	84 d2                	test   %dl,%dl
c002779d:	74 1a                	je     c00277b9 <strpbrk+0x2a>
    if (strchr (stop, *string) != NULL)
c002779f:	0f be d2             	movsbl %dl,%edx
c00277a2:	52                   	push   %edx
c00277a3:	56                   	push   %esi
c00277a4:	e8 7c ff ff ff       	call   c0027725 <strchr>
c00277a9:	83 c4 08             	add    $0x8,%esp
c00277ac:	85 c0                	test   %eax,%eax
c00277ae:	75 10                	jne    c00277c0 <strpbrk+0x31>
  for (; *string != '\0'; string++)
c00277b0:	43                   	inc    %ebx
c00277b1:	8a 13                	mov    (%ebx),%dl
c00277b3:	84 d2                	test   %dl,%dl
c00277b5:	75 e8                	jne    c002779f <strpbrk+0x10>
c00277b7:	eb 09                	jmp    c00277c2 <strpbrk+0x33>
      return (char *) string;
  return NULL;
c00277b9:	b8 00 00 00 00       	mov    $0x0,%eax
c00277be:	eb 02                	jmp    c00277c2 <strpbrk+0x33>
c00277c0:	89 d8                	mov    %ebx,%eax
}
c00277c2:	5b                   	pop    %ebx
c00277c3:	5e                   	pop    %esi
c00277c4:	c3                   	ret    

c00277c5 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c00277c5:	53                   	push   %ebx
c00277c6:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c00277ca:	8a 5c 24 0c          	mov    0xc(%esp),%bl
  const char *p = NULL;

  for (; *string != '\0'; string++)
c00277ce:	8a 0a                	mov    (%edx),%cl
c00277d0:	84 c9                	test   %cl,%cl
c00277d2:	74 16                	je     c00277ea <strrchr+0x25>
c00277d4:	b8 00 00 00 00       	mov    $0x0,%eax
c00277d9:	eb 07                	jmp    c00277e2 <strrchr+0x1d>
c00277db:	42                   	inc    %edx
c00277dc:	8a 0a                	mov    (%edx),%cl
c00277de:	84 c9                	test   %cl,%cl
c00277e0:	74 0d                	je     c00277ef <strrchr+0x2a>
    if (*string == c)
c00277e2:	38 cb                	cmp    %cl,%bl
c00277e4:	75 f5                	jne    c00277db <strrchr+0x16>
c00277e6:	89 d0                	mov    %edx,%eax
c00277e8:	eb f1                	jmp    c00277db <strrchr+0x16>
  const char *p = NULL;
c00277ea:	b8 00 00 00 00       	mov    $0x0,%eax
      p = string;
  return (char *) p;
}
c00277ef:	5b                   	pop    %ebx
c00277f0:	c3                   	ret    

c00277f1 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c00277f1:	57                   	push   %edi
c00277f2:	56                   	push   %esi
c00277f3:	53                   	push   %ebx
c00277f4:	8b 74 24 10          	mov    0x10(%esp),%esi
c00277f8:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c00277fc:	8a 06                	mov    (%esi),%al
c00277fe:	84 c0                	test   %al,%al
c0027800:	74 24                	je     c0027826 <strspn+0x35>
c0027802:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c0027807:	0f be c0             	movsbl %al,%eax
c002780a:	50                   	push   %eax
c002780b:	57                   	push   %edi
c002780c:	e8 14 ff ff ff       	call   c0027725 <strchr>
c0027811:	83 c4 08             	add    $0x8,%esp
c0027814:	85 c0                	test   %eax,%eax
c0027816:	74 08                	je     c0027820 <strspn+0x2f>
  for (length = 0; string[length] != '\0'; length++)
c0027818:	43                   	inc    %ebx
c0027819:	8a 04 1e             	mov    (%esi,%ebx,1),%al
c002781c:	84 c0                	test   %al,%al
c002781e:	75 e7                	jne    c0027807 <strspn+0x16>
      break;
  return length;
}
c0027820:	89 d8                	mov    %ebx,%eax
c0027822:	5b                   	pop    %ebx
c0027823:	5e                   	pop    %esi
c0027824:	5f                   	pop    %edi
c0027825:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0027826:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c002782b:	eb f3                	jmp    c0027820 <strspn+0x2f>

c002782d <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c002782d:	55                   	push   %ebp
c002782e:	57                   	push   %edi
c002782f:	56                   	push   %esi
c0027830:	53                   	push   %ebx
c0027831:	83 ec 1c             	sub    $0x1c,%esp
c0027834:	8b 74 24 30          	mov    0x30(%esp),%esi
c0027838:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
c002783c:	85 ff                	test   %edi,%edi
c002783e:	74 2c                	je     c002786c <strtok_r+0x3f>
  ASSERT (save_ptr != NULL);
c0027840:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0027845:	74 46                	je     c002788d <strtok_r+0x60>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0027847:	85 f6                	test   %esi,%esi
c0027849:	74 63                	je     c00278ae <strtok_r+0x81>
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c002784b:	8a 1e                	mov    (%esi),%bl
c002784d:	83 ec 08             	sub    $0x8,%esp
c0027850:	0f be c3             	movsbl %bl,%eax
c0027853:	50                   	push   %eax
c0027854:	57                   	push   %edi
c0027855:	e8 cb fe ff ff       	call   c0027725 <strchr>
c002785a:	83 c4 10             	add    $0x10,%esp
c002785d:	85 c0                	test   %eax,%eax
c002785f:	0f 84 87 00 00 00    	je     c00278ec <strtok_r+0xbf>
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0027865:	84 db                	test   %bl,%bl
c0027867:	74 70                	je     c00278d9 <strtok_r+0xac>
        {
          *save_ptr = s;
          return NULL;
        }

      s++;
c0027869:	46                   	inc    %esi
c002786a:	eb df                	jmp    c002784b <strtok_r+0x1e>
  ASSERT (delimiters != NULL);
c002786c:	83 ec 0c             	sub    $0xc,%esp
c002786f:	68 8a f1 02 c0       	push   $0xc002f18a
c0027874:	68 3f d9 02 c0       	push   $0xc002d93f
c0027879:	68 10 d4 02 c0       	push   $0xc002d410
c002787e:	68 ef 00 00 00       	push   $0xef
c0027883:	68 9d f1 02 c0       	push   $0xc002f19d
c0027888:	e8 80 0a 00 00       	call   c002830d <debug_panic>
  ASSERT (save_ptr != NULL);
c002788d:	83 ec 0c             	sub    $0xc,%esp
c0027890:	68 b0 f1 02 c0       	push   $0xc002f1b0
c0027895:	68 3f d9 02 c0       	push   $0xc002d93f
c002789a:	68 10 d4 02 c0       	push   $0xc002d410
c002789f:	68 f0 00 00 00       	push   $0xf0
c00278a4:	68 9d f1 02 c0       	push   $0xc002f19d
c00278a9:	e8 5f 0a 00 00       	call   c002830d <debug_panic>
    s = *save_ptr;
c00278ae:	8b 44 24 38          	mov    0x38(%esp),%eax
c00278b2:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
c00278b4:	85 f6                	test   %esi,%esi
c00278b6:	75 93                	jne    c002784b <strtok_r+0x1e>
c00278b8:	83 ec 0c             	sub    $0xc,%esp
c00278bb:	68 93 f1 02 c0       	push   $0xc002f193
c00278c0:	68 3f d9 02 c0       	push   $0xc002d93f
c00278c5:	68 10 d4 02 c0       	push   $0xc002d410
c00278ca:	68 f6 00 00 00       	push   $0xf6
c00278cf:	68 9d f1 02 c0       	push   $0xc002f19d
c00278d4:	e8 34 0a 00 00       	call   c002830d <debug_panic>
          *save_ptr = s;
c00278d9:	8b 44 24 38          	mov    0x38(%esp),%eax
c00278dd:	89 30                	mov    %esi,(%eax)
          return NULL;
c00278df:	b8 00 00 00 00       	mov    $0x0,%eax
      *save_ptr = s + 1;
    }
  else 
    *save_ptr = s;
  return token;
}
c00278e4:	83 c4 1c             	add    $0x1c,%esp
c00278e7:	5b                   	pop    %ebx
c00278e8:	5e                   	pop    %esi
c00278e9:	5f                   	pop    %edi
c00278ea:	5d                   	pop    %ebp
c00278eb:	c3                   	ret    
c00278ec:	89 f5                	mov    %esi,%ebp
c00278ee:	eb 04                	jmp    c00278f4 <strtok_r+0xc7>
    s++;
c00278f0:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c00278f4:	8d 45 01             	lea    0x1(%ebp),%eax
c00278f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (strchr (delimiters, *s) == NULL)
c00278fb:	8a 5d 01             	mov    0x1(%ebp),%bl
c00278fe:	83 ec 08             	sub    $0x8,%esp
c0027901:	0f be c3             	movsbl %bl,%eax
c0027904:	50                   	push   %eax
c0027905:	57                   	push   %edi
c0027906:	e8 1a fe ff ff       	call   c0027725 <strchr>
c002790b:	83 c4 10             	add    $0x10,%esp
c002790e:	85 c0                	test   %eax,%eax
c0027910:	74 de                	je     c00278f0 <strtok_r+0xc3>
  if (*s != '\0') 
c0027912:	84 db                	test   %bl,%bl
c0027914:	75 0e                	jne    c0027924 <strtok_r+0xf7>
    *save_ptr = s;
c0027916:	8b 44 24 38          	mov    0x38(%esp),%eax
c002791a:	8b 54 24 0c          	mov    0xc(%esp),%edx
c002791e:	89 10                	mov    %edx,(%eax)
c0027920:	89 f0                	mov    %esi,%eax
c0027922:	eb c0                	jmp    c00278e4 <strtok_r+0xb7>
      *s = '\0';
c0027924:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027928:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c002792b:	83 c5 02             	add    $0x2,%ebp
c002792e:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027932:	89 28                	mov    %ebp,(%eax)
c0027934:	89 f0                	mov    %esi,%eax
c0027936:	eb ac                	jmp    c00278e4 <strtok_r+0xb7>

c0027938 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0027938:	53                   	push   %ebx
c0027939:	8b 44 24 08          	mov    0x8(%esp),%eax
c002793d:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027941:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0027945:	85 c9                	test   %ecx,%ecx
c0027947:	74 0c                	je     c0027955 <memset+0x1d>
c0027949:	01 c1                	add    %eax,%ecx
c002794b:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c002794d:	42                   	inc    %edx
c002794e:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c0027951:	39 d1                	cmp    %edx,%ecx
c0027953:	75 f8                	jne    c002794d <memset+0x15>

  return dst_;
}
c0027955:	5b                   	pop    %ebx
c0027956:	c3                   	ret    

c0027957 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0027957:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT (string != NULL);

  for (p = string; *p != '\0'; p++)
c002795b:	80 3a 00             	cmpb   $0x0,(%edx)
c002795e:	74 0b                	je     c002796b <strlen+0x14>
c0027960:	89 d0                	mov    %edx,%eax
c0027962:	40                   	inc    %eax
c0027963:	80 38 00             	cmpb   $0x0,(%eax)
c0027966:	75 fa                	jne    c0027962 <strlen+0xb>
    continue;
  return p - string;
c0027968:	29 d0                	sub    %edx,%eax
}
c002796a:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c002796b:	89 d0                	mov    %edx,%eax
c002796d:	eb f9                	jmp    c0027968 <strlen+0x11>

c002796f <strstr>:
{
c002796f:	55                   	push   %ebp
c0027970:	57                   	push   %edi
c0027971:	56                   	push   %esi
c0027972:	53                   	push   %ebx
c0027973:	83 ec 04             	sub    $0x4,%esp
c0027976:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c002797a:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002797f:	b0 00                	mov    $0x0,%al
c0027981:	89 d9                	mov    %ebx,%ecx
c0027983:	8b 7c 24 18          	mov    0x18(%esp),%edi
c0027987:	f2 ae                	repnz scas %es:(%edi),%al
c0027989:	f7 d1                	not    %ecx
c002798b:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c002798e:	89 d9                	mov    %ebx,%ecx
c0027990:	89 ef                	mov    %ebp,%edi
c0027992:	f2 ae                	repnz scas %es:(%edi),%al
c0027994:	89 c8                	mov    %ecx,%eax
c0027996:	f7 d0                	not    %eax
c0027998:	8d 78 ff             	lea    -0x1(%eax),%edi
  if (haystack_len >= needle_len) 
c002799b:	39 fa                	cmp    %edi,%edx
c002799d:	72 2c                	jb     c00279cb <strstr+0x5c>
      for (i = 0; i <= haystack_len - needle_len; i++)
c002799f:	29 fa                	sub    %edi,%edx
c00279a1:	89 14 24             	mov    %edx,(%esp)
c00279a4:	bb 00 00 00 00       	mov    $0x0,%ebx
c00279a9:	89 de                	mov    %ebx,%esi
c00279ab:	03 74 24 18          	add    0x18(%esp),%esi
        if (!memcmp (haystack + i, needle, needle_len))
c00279af:	57                   	push   %edi
c00279b0:	55                   	push   %ebp
c00279b1:	56                   	push   %esi
c00279b2:	e8 c1 fc ff ff       	call   c0027678 <memcmp>
c00279b7:	83 c4 0c             	add    $0xc,%esp
c00279ba:	85 c0                	test   %eax,%eax
c00279bc:	74 14                	je     c00279d2 <strstr+0x63>
      for (i = 0; i <= haystack_len - needle_len; i++)
c00279be:	43                   	inc    %ebx
c00279bf:	3b 1c 24             	cmp    (%esp),%ebx
c00279c2:	76 e5                	jbe    c00279a9 <strstr+0x3a>
  return NULL;
c00279c4:	b8 00 00 00 00       	mov    $0x0,%eax
c00279c9:	eb 09                	jmp    c00279d4 <strstr+0x65>
c00279cb:	b8 00 00 00 00       	mov    $0x0,%eax
c00279d0:	eb 02                	jmp    c00279d4 <strstr+0x65>
        if (!memcmp (haystack + i, needle, needle_len))
c00279d2:	89 f0                	mov    %esi,%eax
}
c00279d4:	83 c4 04             	add    $0x4,%esp
c00279d7:	5b                   	pop    %ebx
c00279d8:	5e                   	pop    %esi
c00279d9:	5f                   	pop    %edi
c00279da:	5d                   	pop    %ebp
c00279db:	c3                   	ret    

c00279dc <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00279dc:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00279e0:	8b 54 24 08          	mov    0x8(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00279e4:	80 39 00             	cmpb   $0x0,(%ecx)
c00279e7:	74 15                	je     c00279fe <strnlen+0x22>
c00279e9:	85 d2                	test   %edx,%edx
c00279eb:	74 17                	je     c0027a04 <strnlen+0x28>
c00279ed:	b8 00 00 00 00       	mov    $0x0,%eax
c00279f2:	40                   	inc    %eax
c00279f3:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
c00279f7:	74 0d                	je     c0027a06 <strnlen+0x2a>
c00279f9:	39 c2                	cmp    %eax,%edx
c00279fb:	75 f5                	jne    c00279f2 <strnlen+0x16>
c00279fd:	c3                   	ret    
c00279fe:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a03:	c3                   	ret    
c0027a04:	89 d0                	mov    %edx,%eax
    continue;
  return length;
}
c0027a06:	c3                   	ret    

c0027a07 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0027a07:	55                   	push   %ebp
c0027a08:	57                   	push   %edi
c0027a09:	56                   	push   %esi
c0027a0a:	53                   	push   %ebx
c0027a0b:	83 ec 0c             	sub    $0xc,%esp
c0027a0e:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0027a12:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027a16:	8b 54 24 28          	mov    0x28(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c0027a1a:	85 db                	test   %ebx,%ebx
c0027a1c:	74 33                	je     c0027a51 <strlcpy+0x4a>
  ASSERT (src != NULL);
c0027a1e:	85 f6                	test   %esi,%esi
c0027a20:	74 50                	je     c0027a72 <strlcpy+0x6b>

  src_len = strlen (src);
c0027a22:	b0 00                	mov    $0x0,%al
c0027a24:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0027a29:	89 f7                	mov    %esi,%edi
c0027a2b:	f2 ae                	repnz scas %es:(%edi),%al
c0027a2d:	89 c8                	mov    %ecx,%eax
c0027a2f:	f7 d0                	not    %eax
c0027a31:	48                   	dec    %eax
  if (size > 0) 
c0027a32:	85 d2                	test   %edx,%edx
c0027a34:	74 13                	je     c0027a49 <strlcpy+0x42>
    {
      size_t dst_len = size - 1;
c0027a36:	4a                   	dec    %edx
c0027a37:	89 c5                	mov    %eax,%ebp
c0027a39:	39 d0                	cmp    %edx,%eax
c0027a3b:	76 02                	jbe    c0027a3f <strlcpy+0x38>
c0027a3d:	89 d5                	mov    %edx,%ebp
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c0027a3f:	89 df                	mov    %ebx,%edi
c0027a41:	89 e9                	mov    %ebp,%ecx
c0027a43:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
      dst[dst_len] = '\0';
c0027a45:	c6 04 2b 00          	movb   $0x0,(%ebx,%ebp,1)
    }
  return src_len;
}
c0027a49:	83 c4 0c             	add    $0xc,%esp
c0027a4c:	5b                   	pop    %ebx
c0027a4d:	5e                   	pop    %esi
c0027a4e:	5f                   	pop    %edi
c0027a4f:	5d                   	pop    %ebp
c0027a50:	c3                   	ret    
  ASSERT (dst != NULL);
c0027a51:	83 ec 0c             	sub    $0xc,%esp
c0027a54:	68 c1 f1 02 c0       	push   $0xc002f1c1
c0027a59:	68 3f d9 02 c0       	push   $0xc002d93f
c0027a5e:	68 08 d4 02 c0       	push   $0xc002d408
c0027a63:	68 4a 01 00 00       	push   $0x14a
c0027a68:	68 9d f1 02 c0       	push   $0xc002f19d
c0027a6d:	e8 9b 08 00 00       	call   c002830d <debug_panic>
  ASSERT (src != NULL);
c0027a72:	83 ec 0c             	sub    $0xc,%esp
c0027a75:	68 cd f1 02 c0       	push   $0xc002f1cd
c0027a7a:	68 3f d9 02 c0       	push   $0xc002d93f
c0027a7f:	68 08 d4 02 c0       	push   $0xc002d408
c0027a84:	68 4b 01 00 00       	push   $0x14b
c0027a89:	68 9d f1 02 c0       	push   $0xc002f19d
c0027a8e:	e8 7a 08 00 00       	call   c002830d <debug_panic>

c0027a93 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0027a93:	55                   	push   %ebp
c0027a94:	57                   	push   %edi
c0027a95:	56                   	push   %esi
c0027a96:	53                   	push   %ebx
c0027a97:	83 ec 0c             	sub    $0xc,%esp
c0027a9a:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027a9e:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0027aa2:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0027aa7:	74 4f                	je     c0027af8 <strlcat+0x65>
  ASSERT (src != NULL);
c0027aa9:	85 f6                	test   %esi,%esi
c0027aab:	74 6c                	je     c0027b19 <strlcat+0x86>

  src_len = strlen (src);
c0027aad:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c0027ab2:	b0 00                	mov    $0x0,%al
c0027ab4:	89 e9                	mov    %ebp,%ecx
c0027ab6:	89 f7                	mov    %esi,%edi
c0027ab8:	f2 ae                	repnz scas %es:(%edi),%al
c0027aba:	f7 d1                	not    %ecx
c0027abc:	8d 51 ff             	lea    -0x1(%ecx),%edx
  dst_len = strlen (dst);
c0027abf:	89 e9                	mov    %ebp,%ecx
c0027ac1:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0027ac5:	f2 ae                	repnz scas %es:(%edi),%al
c0027ac7:	89 c8                	mov    %ecx,%eax
c0027ac9:	f7 d0                	not    %eax
c0027acb:	48                   	dec    %eax
  if (size > 0 && dst_len < size) 
c0027acc:	85 db                	test   %ebx,%ebx
c0027ace:	74 1e                	je     c0027aee <strlcat+0x5b>
c0027ad0:	39 d8                	cmp    %ebx,%eax
c0027ad2:	73 1a                	jae    c0027aee <strlcat+0x5b>
    {
      size_t copy_cnt = size - dst_len - 1;
c0027ad4:	8d 6b ff             	lea    -0x1(%ebx),%ebp
c0027ad7:	29 c5                	sub    %eax,%ebp
c0027ad9:	89 d1                	mov    %edx,%ecx
c0027adb:	39 ea                	cmp    %ebp,%edx
c0027add:	76 02                	jbe    c0027ae1 <strlcat+0x4e>
c0027adf:	89 e9                	mov    %ebp,%ecx
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c0027ae1:	89 c3                	mov    %eax,%ebx
c0027ae3:	03 5c 24 20          	add    0x20(%esp),%ebx
c0027ae7:	89 df                	mov    %ebx,%edi
c0027ae9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
      dst[dst_len + copy_cnt] = '\0';
c0027aeb:	c6 07 00             	movb   $0x0,(%edi)
    }
  return src_len + dst_len;
c0027aee:	01 d0                	add    %edx,%eax
}
c0027af0:	83 c4 0c             	add    $0xc,%esp
c0027af3:	5b                   	pop    %ebx
c0027af4:	5e                   	pop    %esi
c0027af5:	5f                   	pop    %edi
c0027af6:	5d                   	pop    %ebp
c0027af7:	c3                   	ret    
  ASSERT (dst != NULL);
c0027af8:	83 ec 0c             	sub    $0xc,%esp
c0027afb:	68 c1 f1 02 c0       	push   $0xc002f1c1
c0027b00:	68 3f d9 02 c0       	push   $0xc002d93f
c0027b05:	68 00 d4 02 c0       	push   $0xc002d400
c0027b0a:	68 68 01 00 00       	push   $0x168
c0027b0f:	68 9d f1 02 c0       	push   $0xc002f19d
c0027b14:	e8 f4 07 00 00       	call   c002830d <debug_panic>
  ASSERT (src != NULL);
c0027b19:	83 ec 0c             	sub    $0xc,%esp
c0027b1c:	68 cd f1 02 c0       	push   $0xc002f1cd
c0027b21:	68 3f d9 02 c0       	push   $0xc002d93f
c0027b26:	68 00 d4 02 c0       	push   $0xc002d400
c0027b2b:	68 69 01 00 00       	push   $0x169
c0027b30:	68 9d f1 02 c0       	push   $0xc002f19d
c0027b35:	e8 d3 07 00 00       	call   c002830d <debug_panic>

c0027b3a <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0027b3a:	55                   	push   %ebp
c0027b3b:	57                   	push   %edi
c0027b3c:	56                   	push   %esi
c0027b3d:	53                   	push   %ebx
c0027b3e:	83 ec 1c             	sub    $0x1c,%esp
c0027b41:	89 04 24             	mov    %eax,(%esp)
c0027b44:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027b48:	8b 74 24 30          	mov    0x30(%esp),%esi
c0027b4c:	8b 7c 24 34          	mov    0x34(%esp),%edi
  if ((d >> 32) == 0) 
c0027b50:	85 ff                	test   %edi,%edi
c0027b52:	74 2f                	je     c0027b83 <udiv64+0x49>
c0027b54:	89 fa                	mov    %edi,%edx
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0027b56:	8b 0c 24             	mov    (%esp),%ecx
c0027b59:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0027b5d:	39 df                	cmp    %ebx,%edi
c0027b5f:	0f 87 43 01 00 00    	ja     c0027ca8 <udiv64+0x16e>
c0027b65:	72 08                	jb     c0027b6f <udiv64+0x35>
c0027b67:	39 ce                	cmp    %ecx,%esi
c0027b69:	0f 87 39 01 00 00    	ja     c0027ca8 <udiv64+0x16e>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
c0027b6f:	89 d0                	mov    %edx,%eax
  if (x <= 0x0000FFFF)
c0027b71:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
c0027b77:	77 56                	ja     c0027bcf <udiv64+0x95>
      x <<= 16; 
c0027b79:	c1 e0 10             	shl    $0x10,%eax
      n += 16;
c0027b7c:	b9 10 00 00 00       	mov    $0x10,%ecx
c0027b81:	eb 51                	jmp    c0027bd4 <udiv64+0x9a>
      uint32_t n1 = n >> 32;
c0027b83:	8b 44 24 04          	mov    0x4(%esp),%eax
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0027b87:	ba 00 00 00 00       	mov    $0x0,%edx
c0027b8c:	f7 f6                	div    %esi
c0027b8e:	89 d1                	mov    %edx,%ecx
c0027b90:	89 c5                	mov    %eax,%ebp
c0027b92:	b8 00 00 00 00       	mov    $0x0,%eax
c0027b97:	89 ca                	mov    %ecx,%edx
c0027b99:	8b 0c 24             	mov    (%esp),%ecx
c0027b9c:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027ba1:	01 c8                	add    %ecx,%eax
c0027ba3:	11 da                	adc    %ebx,%edx
  asm ("divl %4"
c0027ba5:	f7 f6                	div    %esi
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0027ba7:	be 00 00 00 00       	mov    $0x0,%esi
c0027bac:	89 c1                	mov    %eax,%ecx
c0027bae:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027bb3:	01 f1                	add    %esi,%ecx
c0027bb5:	11 eb                	adc    %ebp,%ebx
c0027bb7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027bbb:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
          return n - (q - 1) * d < d ? q - 1 : q; 
        }
    }
}
c0027bbf:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027bc3:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027bc7:	83 c4 1c             	add    $0x1c,%esp
c0027bca:	5b                   	pop    %ebx
c0027bcb:	5e                   	pop    %esi
c0027bcc:	5f                   	pop    %edi
c0027bcd:	5d                   	pop    %ebp
c0027bce:	c3                   	ret    
  int n = 0;
c0027bcf:	b9 00 00 00 00       	mov    $0x0,%ecx
  if (x <= 0x00FFFFFF)
c0027bd4:	3d ff ff ff 00       	cmp    $0xffffff,%eax
c0027bd9:	77 06                	ja     c0027be1 <udiv64+0xa7>
      n += 8;
c0027bdb:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
c0027bde:	c1 e0 08             	shl    $0x8,%eax
  if (x <= 0x0FFFFFFF)
c0027be1:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
c0027be6:	77 06                	ja     c0027bee <udiv64+0xb4>
      n += 4;
c0027be8:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
c0027beb:	c1 e0 04             	shl    $0x4,%eax
  if (x <= 0x3FFFFFFF)
c0027bee:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
c0027bf3:	77 06                	ja     c0027bfb <udiv64+0xc1>
      n += 2;
c0027bf5:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
c0027bf8:	c1 e0 02             	shl    $0x2,%eax
    n++;
c0027bfb:	3d 00 00 00 80       	cmp    $0x80000000,%eax
c0027c00:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c0027c03:	8b 04 24             	mov    (%esp),%eax
c0027c06:	8b 54 24 04          	mov    0x4(%esp),%edx
c0027c0a:	89 d3                	mov    %edx,%ebx
c0027c0c:	d1 eb                	shr    %ebx
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0027c0e:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0027c12:	d1 ea                	shr    %edx
c0027c14:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027c18:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0027c1c:	89 f0                	mov    %esi,%eax
c0027c1e:	89 fa                	mov    %edi,%edx
c0027c20:	0f a5 f2             	shld   %cl,%esi,%edx
c0027c23:	d3 e0                	shl    %cl,%eax
c0027c25:	f6 c1 20             	test   $0x20,%cl
c0027c28:	74 02                	je     c0027c2c <udiv64+0xf2>
c0027c2a:	89 c2                	mov    %eax,%edx
c0027c2c:	89 54 24 14          	mov    %edx,0x14(%esp)
  asm ("divl %4"
c0027c30:	89 da                	mov    %ebx,%edx
c0027c32:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027c36:	f7 74 24 14          	divl   0x14(%esp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0027c3a:	ba 1f 00 00 00       	mov    $0x1f,%edx
c0027c3f:	29 ca                	sub    %ecx,%edx
c0027c41:	89 d1                	mov    %edx,%ecx
c0027c43:	d3 e8                	shr    %cl,%eax
c0027c45:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027c4a:	89 44 24 10          	mov    %eax,0x10(%esp)
c0027c4e:	89 4c 24 14          	mov    %ecx,0x14(%esp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0027c52:	89 cb                	mov    %ecx,%ebx
c0027c54:	89 c1                	mov    %eax,%ecx
c0027c56:	83 c1 ff             	add    $0xffffffff,%ecx
c0027c59:	83 d3 ff             	adc    $0xffffffff,%ebx
c0027c5c:	89 fd                	mov    %edi,%ebp
c0027c5e:	0f af e9             	imul   %ecx,%ebp
c0027c61:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027c65:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0027c69:	0f af de             	imul   %esi,%ebx
c0027c6c:	01 dd                	add    %ebx,%ebp
c0027c6e:	89 f0                	mov    %esi,%eax
c0027c70:	f7 64 24 08          	mull   0x8(%esp)
c0027c74:	01 ea                	add    %ebp,%edx
c0027c76:	8b 0c 24             	mov    (%esp),%ecx
c0027c79:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0027c7d:	29 c1                	sub    %eax,%ecx
c0027c7f:	19 d3                	sbb    %edx,%ebx
c0027c81:	39 df                	cmp    %ebx,%edi
c0027c83:	0f 87 36 ff ff ff    	ja     c0027bbf <udiv64+0x85>
c0027c89:	72 08                	jb     c0027c93 <udiv64+0x159>
c0027c8b:	39 ce                	cmp    %ecx,%esi
c0027c8d:	0f 87 2c ff ff ff    	ja     c0027bbf <udiv64+0x85>
c0027c93:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027c97:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027c9b:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027c9f:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0027ca3:	e9 17 ff ff ff       	jmp    c0027bbf <udiv64+0x85>
        return 0;
c0027ca8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0027caf:	00 
c0027cb0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027cb7:	00 
c0027cb8:	e9 02 ff ff ff       	jmp    c0027bbf <udiv64+0x85>

c0027cbd <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0027cbd:	57                   	push   %edi
c0027cbe:	56                   	push   %esi
c0027cbf:	53                   	push   %ebx
c0027cc0:	83 ec 08             	sub    $0x8,%esp
c0027cc3:	89 04 24             	mov    %eax,(%esp)
c0027cc6:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027cca:	8b 74 24 18          	mov    0x18(%esp),%esi
c0027cce:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0027cd2:	85 d2                	test   %edx,%edx
c0027cd4:	78 32                	js     c0027d08 <sdiv64+0x4b>
c0027cd6:	8b 04 24             	mov    (%esp),%eax
c0027cd9:	8b 54 24 04          	mov    0x4(%esp),%edx
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0027cdd:	85 ff                	test   %edi,%edi
c0027cdf:	78 30                	js     c0027d11 <sdiv64+0x54>
c0027ce1:	89 f1                	mov    %esi,%ecx
c0027ce3:	89 fb                	mov    %edi,%ebx
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0027ce5:	53                   	push   %ebx
c0027ce6:	51                   	push   %ecx
c0027ce7:	e8 4e fe ff ff       	call   c0027b3a <udiv64>
c0027cec:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0027cef:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0027cf3:	f7 d1                	not    %ecx
c0027cf5:	c1 e9 1f             	shr    $0x1f,%ecx
c0027cf8:	89 fb                	mov    %edi,%ebx
c0027cfa:	c1 eb 1f             	shr    $0x1f,%ebx
c0027cfd:	38 d9                	cmp    %bl,%cl
c0027cff:	74 1d                	je     c0027d1e <sdiv64+0x61>
}
c0027d01:	83 c4 08             	add    $0x8,%esp
c0027d04:	5b                   	pop    %ebx
c0027d05:	5e                   	pop    %esi
c0027d06:	5f                   	pop    %edi
c0027d07:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0027d08:	f7 d8                	neg    %eax
c0027d0a:	83 d2 00             	adc    $0x0,%edx
c0027d0d:	f7 da                	neg    %edx
c0027d0f:	eb cc                	jmp    c0027cdd <sdiv64+0x20>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0027d11:	89 f1                	mov    %esi,%ecx
c0027d13:	89 fb                	mov    %edi,%ebx
c0027d15:	f7 d9                	neg    %ecx
c0027d17:	83 d3 00             	adc    $0x0,%ebx
c0027d1a:	f7 db                	neg    %ebx
c0027d1c:	eb c7                	jmp    c0027ce5 <sdiv64+0x28>
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0027d1e:	f7 d8                	neg    %eax
c0027d20:	83 d2 00             	adc    $0x0,%edx
c0027d23:	f7 da                	neg    %edx
c0027d25:	eb da                	jmp    c0027d01 <sdiv64+0x44>

c0027d27 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0027d27:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c0027d2a:	ff 74 24 14          	pushl  0x14(%esp)
c0027d2e:	ff 74 24 14          	pushl  0x14(%esp)
c0027d32:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027d36:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027d3a:	e8 7e ff ff ff       	call   c0027cbd <sdiv64>
}
c0027d3f:	83 c4 0c             	add    $0xc,%esp
c0027d42:	c3                   	ret    

c0027d43 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c0027d43:	57                   	push   %edi
c0027d44:	56                   	push   %esi
c0027d45:	53                   	push   %ebx
c0027d46:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0027d4a:	8b 74 24 18          	mov    0x18(%esp),%esi
c0027d4e:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64 (n, d);
c0027d52:	57                   	push   %edi
c0027d53:	56                   	push   %esi
c0027d54:	89 d8                	mov    %ebx,%eax
c0027d56:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0027d5a:	e8 5e ff ff ff       	call   c0027cbd <sdiv64>
c0027d5f:	83 c4 08             	add    $0x8,%esp
c0027d62:	0f af c6             	imul   %esi,%eax
c0027d65:	29 c3                	sub    %eax,%ebx
c0027d67:	89 d8                	mov    %ebx,%eax
  return smod64 (n, d);
c0027d69:	99                   	cltd   
}
c0027d6a:	5b                   	pop    %ebx
c0027d6b:	5e                   	pop    %esi
c0027d6c:	5f                   	pop    %edi
c0027d6d:	c3                   	ret    

c0027d6e <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0027d6e:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c0027d71:	ff 74 24 14          	pushl  0x14(%esp)
c0027d75:	ff 74 24 14          	pushl  0x14(%esp)
c0027d79:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027d7d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027d81:	e8 b4 fd ff ff       	call   c0027b3a <udiv64>
}
c0027d86:	83 c4 0c             	add    $0xc,%esp
c0027d89:	c3                   	ret    

c0027d8a <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0027d8a:	57                   	push   %edi
c0027d8b:	56                   	push   %esi
c0027d8c:	53                   	push   %ebx
c0027d8d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0027d91:	8b 74 24 18          	mov    0x18(%esp),%esi
c0027d95:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64 (n, d);
c0027d99:	57                   	push   %edi
c0027d9a:	56                   	push   %esi
c0027d9b:	89 d8                	mov    %ebx,%eax
c0027d9d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0027da1:	e8 94 fd ff ff       	call   c0027b3a <udiv64>
c0027da6:	83 c4 08             	add    $0x8,%esp
c0027da9:	0f af c6             	imul   %esi,%eax
c0027dac:	29 c3                	sub    %eax,%ebx
c0027dae:	89 d8                	mov    %ebx,%eax
  return umod64 (n, d);
}
c0027db0:	ba 00 00 00 00       	mov    $0x0,%edx
c0027db5:	5b                   	pop    %ebx
c0027db6:	5e                   	pop    %esi
c0027db7:	5f                   	pop    %edi
c0027db8:	c3                   	ret    

c0027db9 <parse_octal_field>:
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
c0027db9:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c0027dbf:	85 d2                	test   %edx,%edx
c0027dc1:	74 46                	je     c0027e09 <parse_octal_field+0x50>
{
c0027dc3:	55                   	push   %ebp
c0027dc4:	57                   	push   %edi
c0027dc5:	56                   	push   %esi
c0027dc6:	53                   	push   %ebx
c0027dc7:	89 d5                	mov    %edx,%ebp
    {
      char c = s[ofs];
c0027dc9:	8a 18                	mov    (%eax),%bl
      if (c >= '0' && c <= '7')
c0027dcb:	8d 73 d0             	lea    -0x30(%ebx),%esi
c0027dce:	89 f2                	mov    %esi,%edx
  for (ofs = 0; ofs < size; ofs++)
c0027dd0:	be 00 00 00 00       	mov    $0x0,%esi
      if (c >= '0' && c <= '7')
c0027dd5:	80 fa 07             	cmp    $0x7,%dl
c0027dd8:	77 39                	ja     c0027e13 <parse_octal_field+0x5a>
c0027dda:	bf 00 00 00 00       	mov    $0x0,%edi
c0027ddf:	be 00 00 00 00       	mov    $0x0,%esi
          if (*value > ULONG_MAX / 8)
            {
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
c0027de4:	0f be db             	movsbl %bl,%ebx
c0027de7:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c0027deb:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c0027ded:	46                   	inc    %esi
c0027dee:	39 f5                	cmp    %esi,%ebp
c0027df0:	74 1a                	je     c0027e0c <parse_octal_field+0x53>
      char c = s[ofs];
c0027df2:	8a 1c 30             	mov    (%eax,%esi,1),%bl
      if (c >= '0' && c <= '7')
c0027df5:	8d 53 d0             	lea    -0x30(%ebx),%edx
c0027df8:	80 fa 07             	cmp    $0x7,%dl
c0027dfb:	77 16                	ja     c0027e13 <parse_octal_field+0x5a>
          if (*value > ULONG_MAX / 8)
c0027dfd:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c0027e03:	76 df                	jbe    c0027de4 <parse_octal_field+0x2b>
              return false;
c0027e05:	b0 00                	mov    $0x0,%al
c0027e07:	eb 05                	jmp    c0027e0e <parse_octal_field+0x55>
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0027e09:	b0 00                	mov    $0x0,%al
c0027e0b:	c3                   	ret    
c0027e0c:	b0 00                	mov    $0x0,%al
}
c0027e0e:	5b                   	pop    %ebx
c0027e0f:	5e                   	pop    %esi
c0027e10:	5f                   	pop    %edi
c0027e11:	5d                   	pop    %ebp
c0027e12:	c3                   	ret    
      else if (c == ' ' || c == '\0')
c0027e13:	f6 c3 df             	test   $0xdf,%bl
c0027e16:	75 07                	jne    c0027e1f <parse_octal_field+0x66>
          return ofs > 0;
c0027e18:	85 f6                	test   %esi,%esi
c0027e1a:	0f 95 c0             	setne  %al
c0027e1d:	eb ef                	jmp    c0027e0e <parse_octal_field+0x55>
          return false;
c0027e1f:	b0 00                	mov    $0x0,%al
c0027e21:	eb eb                	jmp    c0027e0e <parse_octal_field+0x55>

c0027e23 <strip_antisocial_prefixes>:
{
c0027e23:	55                   	push   %ebp
c0027e24:	57                   	push   %edi
c0027e25:	56                   	push   %esi
c0027e26:	53                   	push   %ebx
c0027e27:	83 ec 0c             	sub    $0xc,%esp
c0027e2a:	89 c5                	mov    %eax,%ebp
  while (*file_name == '/'
c0027e2c:	eb 11                	jmp    c0027e3f <strip_antisocial_prefixes+0x1c>
    file_name = strchr (file_name, '/') + 1;
c0027e2e:	83 ec 08             	sub    $0x8,%esp
c0027e31:	6a 2f                	push   $0x2f
c0027e33:	55                   	push   %ebp
c0027e34:	e8 ec f8 ff ff       	call   c0027725 <strchr>
c0027e39:	83 c4 10             	add    $0x10,%esp
c0027e3c:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/'
c0027e3f:	8a 5d 00             	mov    0x0(%ebp),%bl
c0027e42:	80 fb 2f             	cmp    $0x2f,%bl
c0027e45:	74 e7                	je     c0027e2e <strip_antisocial_prefixes+0xb>
         || !memcmp (file_name, "./", 2)
c0027e47:	83 ec 04             	sub    $0x4,%esp
c0027e4a:	6a 02                	push   $0x2
c0027e4c:	68 f6 e5 02 c0       	push   $0xc002e5f6
c0027e51:	55                   	push   %ebp
c0027e52:	e8 21 f8 ff ff       	call   c0027678 <memcmp>
c0027e57:	83 c4 10             	add    $0x10,%esp
c0027e5a:	85 c0                	test   %eax,%eax
c0027e5c:	74 d0                	je     c0027e2e <strip_antisocial_prefixes+0xb>
         || !memcmp (file_name, "../", 3))
c0027e5e:	83 ec 04             	sub    $0x4,%esp
c0027e61:	6a 03                	push   $0x3
c0027e63:	68 d9 f1 02 c0       	push   $0xc002f1d9
c0027e68:	55                   	push   %ebp
c0027e69:	e8 0a f8 ff ff       	call   c0027678 <memcmp>
c0027e6e:	83 c4 10             	add    $0x10,%esp
c0027e71:	85 c0                	test   %eax,%eax
c0027e73:	74 b9                	je     c0027e2e <strip_antisocial_prefixes+0xb>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0027e75:	84 db                	test   %bl,%bl
c0027e77:	74 23                	je     c0027e9c <strip_antisocial_prefixes+0x79>
c0027e79:	bf 7a eb 02 c0       	mov    $0xc002eb7a,%edi
c0027e7e:	b9 03 00 00 00       	mov    $0x3,%ecx
c0027e83:	89 ee                	mov    %ebp,%esi
c0027e85:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0027e87:	0f 97 c2             	seta   %dl
c0027e8a:	0f 92 c0             	setb   %al
c0027e8d:	38 c2                	cmp    %al,%dl
c0027e8f:	75 07                	jne    c0027e98 <strip_antisocial_prefixes+0x75>
c0027e91:	b8 7b eb 02 c0       	mov    $0xc002eb7b,%eax
c0027e96:	eb 09                	jmp    c0027ea1 <strip_antisocial_prefixes+0x7e>
c0027e98:	89 e8                	mov    %ebp,%eax
c0027e9a:	eb 05                	jmp    c0027ea1 <strip_antisocial_prefixes+0x7e>
c0027e9c:	b8 7b eb 02 c0       	mov    $0xc002eb7b,%eax
}
c0027ea1:	83 c4 0c             	add    $0xc,%esp
c0027ea4:	5b                   	pop    %ebx
c0027ea5:	5e                   	pop    %esi
c0027ea6:	5f                   	pop    %edi
c0027ea7:	5d                   	pop    %ebp
c0027ea8:	c3                   	ret    

c0027ea9 <ustar_make_header>:
{
c0027ea9:	57                   	push   %edi
c0027eaa:	56                   	push   %esi
c0027eab:	53                   	push   %ebx
c0027eac:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027eb0:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0027eb4:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0027eb8:	83 fb 30             	cmp    $0x30,%ebx
c0027ebb:	0f 84 83 01 00 00    	je     c0028044 <ustar_make_header+0x19b>
c0027ec1:	83 fb 35             	cmp    $0x35,%ebx
c0027ec4:	0f 85 3e 01 00 00    	jne    c0028008 <ustar_make_header+0x15f>
  file_name = strip_antisocial_prefixes (file_name);
c0027eca:	e8 54 ff ff ff       	call   c0027e23 <strip_antisocial_prefixes>
c0027ecf:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c0027ed1:	b0 00                	mov    $0x0,%al
c0027ed3:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0027ed8:	89 d7                	mov    %edx,%edi
c0027eda:	f2 ae                	repnz scas %es:(%edi),%al
c0027edc:	89 c8                	mov    %ecx,%eax
c0027ede:	f7 d0                	not    %eax
c0027ee0:	48                   	dec    %eax
c0027ee1:	83 f8 63             	cmp    $0x63,%eax
c0027ee4:	0f 87 3c 01 00 00    	ja     c0028026 <ustar_make_header+0x17d>
  memset (h, 0, sizeof *h);
c0027eea:	b9 80 00 00 00       	mov    $0x80,%ecx
c0027eef:	b8 00 00 00 00       	mov    $0x0,%eax
c0027ef4:	89 f7                	mov    %esi,%edi
c0027ef6:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0027ef8:	83 ec 04             	sub    $0x4,%esp
c0027efb:	6a 64                	push   $0x64
c0027efd:	52                   	push   %edx
c0027efe:	56                   	push   %esi
c0027eff:	e8 03 fb ff ff       	call   c0027a07 <strlcpy>
c0027f04:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c0027f07:	b8 ed 01 00 00       	mov    $0x1ed,%eax
c0027f0c:	50                   	push   %eax
c0027f0d:	68 07 f2 02 c0       	push   $0xc002f207
c0027f12:	6a 08                	push   $0x8
c0027f14:	8d 46 64             	lea    0x64(%esi),%eax
c0027f17:	50                   	push   %eax
c0027f18:	e8 ce f0 ff ff       	call   c0026feb <snprintf>
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0027f1d:	83 c4 0c             	add    $0xc,%esp
c0027f20:	6a 08                	push   $0x8
c0027f22:	68 0c f2 02 c0       	push   $0xc002f20c
c0027f27:	8d 46 6c             	lea    0x6c(%esi),%eax
c0027f2a:	50                   	push   %eax
c0027f2b:	e8 d7 fa ff ff       	call   c0027a07 <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0027f30:	83 c4 0c             	add    $0xc,%esp
c0027f33:	6a 08                	push   $0x8
c0027f35:	68 0c f2 02 c0       	push   $0xc002f20c
c0027f3a:	8d 46 74             	lea    0x74(%esi),%eax
c0027f3d:	50                   	push   %eax
c0027f3e:	e8 c4 fa ff ff       	call   c0027a07 <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c0027f43:	ff 74 24 28          	pushl  0x28(%esp)
c0027f47:	68 14 f2 02 c0       	push   $0xc002f214
c0027f4c:	6a 0c                	push   $0xc
c0027f4e:	8d 46 7c             	lea    0x7c(%esi),%eax
c0027f51:	50                   	push   %eax
c0027f52:	e8 94 f0 ff ff       	call   c0026feb <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0027f57:	83 c4 20             	add    $0x20,%esp
c0027f5a:	68 00 8c b7 43       	push   $0x43b78c00
c0027f5f:	68 14 f2 02 c0       	push   $0xc002f214
c0027f64:	6a 0c                	push   $0xc
c0027f66:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c0027f6c:	50                   	push   %eax
c0027f6d:	e8 79 f0 ff ff       	call   c0026feb <snprintf>
  h->typeflag = type;
c0027f72:	88 9e 9c 00 00 00    	mov    %bl,0x9c(%esi)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0027f78:	83 c4 0c             	add    $0xc,%esp
c0027f7b:	6a 06                	push   $0x6
c0027f7d:	68 1a f2 02 c0       	push   $0xc002f21a
c0027f82:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0027f88:	50                   	push   %eax
c0027f89:	e8 79 fa ff ff       	call   c0027a07 <strlcpy>
  h->version[0] = h->version[1] = '0';
c0027f8e:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c0027f95:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy (h->gname, "root", sizeof h->gname);
c0027f9c:	83 c4 0c             	add    $0xc,%esp
c0027f9f:	6a 20                	push   $0x20
c0027fa1:	68 ac e7 02 c0       	push   $0xc002e7ac
c0027fa6:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c0027fac:	50                   	push   %eax
c0027fad:	e8 55 fa ff ff       	call   c0027a07 <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c0027fb2:	83 c4 0c             	add    $0xc,%esp
c0027fb5:	6a 20                	push   $0x20
c0027fb7:	68 ac e7 02 c0       	push   $0xc002e7ac
c0027fbc:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c0027fc2:	50                   	push   %eax
c0027fc3:	e8 3f fa ff ff       	call   c0027a07 <strlcpy>
c0027fc8:	83 c4 10             	add    $0x10,%esp
c0027fcb:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0027fd0:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c0027fd5:	b3 20                	mov    $0x20,%bl
c0027fd7:	83 f8 07             	cmp    $0x7,%eax
c0027fda:	77 5f                	ja     c002803b <ustar_make_header+0x192>
c0027fdc:	88 da                	mov    %bl,%dl
c0027fde:	0f b6 d2             	movzbl %dl,%edx
c0027fe1:	01 d1                	add    %edx,%ecx
c0027fe3:	40                   	inc    %eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0027fe4:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0027fe9:	75 ec                	jne    c0027fd7 <ustar_make_header+0x12e>
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0027feb:	51                   	push   %ecx
c0027fec:	68 07 f2 02 c0       	push   $0xc002f207
c0027ff1:	6a 08                	push   $0x8
c0027ff3:	81 c6 94 00 00 00    	add    $0x94,%esi
c0027ff9:	56                   	push   %esi
c0027ffa:	e8 ec ef ff ff       	call   c0026feb <snprintf>
  return true;
c0027fff:	83 c4 10             	add    $0x10,%esp
c0028002:	b0 01                	mov    $0x1,%al
}
c0028004:	5b                   	pop    %ebx
c0028005:	5e                   	pop    %esi
c0028006:	5f                   	pop    %edi
c0028007:	c3                   	ret    
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028008:	83 ec 0c             	sub    $0xc,%esp
c002800b:	68 c4 f2 02 c0       	push   $0xc002f2c4
c0028010:	68 3f d9 02 c0       	push   $0xc002d93f
c0028015:	68 1c d4 02 c0       	push   $0xc002d41c
c002801a:	6a 59                	push   $0x59
c002801c:	68 dd f1 02 c0       	push   $0xc002f1dd
c0028021:	e8 e7 02 00 00       	call   c002830d <debug_panic>
      printf ("%s: file name too long\n", file_name);
c0028026:	83 ec 08             	sub    $0x8,%esp
c0028029:	52                   	push   %edx
c002802a:	68 ef f1 02 c0       	push   $0xc002f1ef
c002802f:	e8 2b e8 ff ff       	call   c002685f <printf>
      return false;
c0028034:	83 c4 10             	add    $0x10,%esp
c0028037:	b0 00                	mov    $0x0,%al
c0028039:	eb c9                	jmp    c0028004 <ustar_make_header+0x15b>
      chksum += in_chksum_field ? ' ' : header[i];
c002803b:	8a 94 06 94 00 00 00 	mov    0x94(%esi,%eax,1),%dl
c0028042:	eb 9a                	jmp    c0027fde <ustar_make_header+0x135>
  file_name = strip_antisocial_prefixes (file_name);
c0028044:	e8 da fd ff ff       	call   c0027e23 <strip_antisocial_prefixes>
c0028049:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c002804b:	b0 00                	mov    $0x0,%al
c002804d:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028052:	89 d7                	mov    %edx,%edi
c0028054:	f2 ae                	repnz scas %es:(%edi),%al
c0028056:	89 c8                	mov    %ecx,%eax
c0028058:	f7 d0                	not    %eax
c002805a:	48                   	dec    %eax
c002805b:	83 f8 63             	cmp    $0x63,%eax
c002805e:	77 c6                	ja     c0028026 <ustar_make_header+0x17d>
  memset (h, 0, sizeof *h);
c0028060:	b9 80 00 00 00       	mov    $0x80,%ecx
c0028065:	b8 00 00 00 00       	mov    $0x0,%eax
c002806a:	89 f7                	mov    %esi,%edi
c002806c:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c002806e:	83 ec 04             	sub    $0x4,%esp
c0028071:	6a 64                	push   $0x64
c0028073:	52                   	push   %edx
c0028074:	56                   	push   %esi
c0028075:	e8 8d f9 ff ff       	call   c0027a07 <strlcpy>
c002807a:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c002807d:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c0028082:	e9 85 fe ff ff       	jmp    c0027f0c <ustar_make_header+0x63>

c0028087 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0028087:	56                   	push   %esi
c0028088:	53                   	push   %ebx
c0028089:	83 ec 14             	sub    $0x14,%esp
c002808c:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0028090:	8d 93 00 02 00 00    	lea    0x200(%ebx),%edx
c0028096:	89 d8                	mov    %ebx,%eax
    if (*block++ != 0)
c0028098:	40                   	inc    %eax
c0028099:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c002809d:	0f 85 47 01 00 00    	jne    c00281ea <ustar_parse_header+0x163>
  while (cnt-- > 0)
c00280a3:	39 c2                	cmp    %eax,%edx
c00280a5:	75 f1                	jne    c0028098 <ustar_parse_header+0x11>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c00280a7:	8b 44 24 24          	mov    0x24(%esp),%eax
c00280ab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c00280b1:	8b 44 24 28          	mov    0x28(%esp),%eax
c00280b5:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c00280bb:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c00280bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c00280c5:	b8 00 00 00 00       	mov    $0x0,%eax
  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
  *type = h->typeflag;
  *size = size_ul;
  return NULL;
}
c00280ca:	83 c4 14             	add    $0x14,%esp
c00280cd:	5b                   	pop    %ebx
c00280ce:	5e                   	pop    %esi
c00280cf:	c3                   	ret    
  else if (h->version[0] != '0' || h->version[1] != '0')
c00280d0:	80 bb 08 01 00 00 30 	cmpb   $0x30,0x108(%ebx)
c00280d7:	74 07                	je     c00280e0 <ustar_parse_header+0x59>
    return "invalid ustar version";
c00280d9:	b8 34 f2 02 c0       	mov    $0xc002f234,%eax
c00280de:	eb ea                	jmp    c00280ca <ustar_parse_header+0x43>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c00280e0:	8d 83 94 00 00 00    	lea    0x94(%ebx),%eax
c00280e6:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c00280ea:	ba 08 00 00 00       	mov    $0x8,%edx
c00280ef:	e8 c5 fc ff ff       	call   c0027db9 <parse_octal_field>
c00280f4:	84 c0                	test   %al,%al
c00280f6:	0f 84 b2 00 00 00    	je     c00281ae <ustar_parse_header+0x127>
c00280fc:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
c0028101:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c0028106:	be 20 00 00 00       	mov    $0x20,%esi
c002810b:	83 f8 07             	cmp    $0x7,%eax
c002810e:	77 1c                	ja     c002812c <ustar_parse_header+0xa5>
c0028110:	89 f2                	mov    %esi,%edx
c0028112:	0f b6 d2             	movzbl %dl,%edx
c0028115:	01 d1                	add    %edx,%ecx
c0028117:	40                   	inc    %eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028118:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c002811d:	75 ec                	jne    c002810b <ustar_parse_header+0x84>
  else if (chksum != calculate_chksum (h))
c002811f:	39 4c 24 0c          	cmp    %ecx,0xc(%esp)
c0028123:	74 10                	je     c0028135 <ustar_parse_header+0xae>
    return "checksum mismatch";
c0028125:	b8 5f f2 02 c0       	mov    $0xc002f25f,%eax
c002812a:	eb 9e                	jmp    c00280ca <ustar_parse_header+0x43>
      chksum += in_chksum_field ? ' ' : header[i];
c002812c:	8a 94 03 94 00 00 00 	mov    0x94(%ebx,%eax,1),%dl
c0028133:	eb dd                	jmp    c0028112 <ustar_parse_header+0x8b>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0028135:	80 7b 63 00          	cmpb   $0x0,0x63(%ebx)
c0028139:	75 7d                	jne    c00281b8 <ustar_parse_header+0x131>
c002813b:	80 bb 59 01 00 00 00 	cmpb   $0x0,0x159(%ebx)
c0028142:	75 7e                	jne    c00281c2 <ustar_parse_header+0x13b>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028144:	8a 83 9c 00 00 00    	mov    0x9c(%ebx),%al
c002814a:	3c 30                	cmp    $0x30,%al
c002814c:	74 3a                	je     c0028188 <ustar_parse_header+0x101>
c002814e:	3c 35                	cmp    $0x35,%al
c0028150:	75 7a                	jne    c00281cc <ustar_parse_header+0x145>
    size_ul = 0;
c0028152:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0028159:	00 
  *file_name = strip_antisocial_prefixes (h->name);
c002815a:	89 d8                	mov    %ebx,%eax
c002815c:	e8 c2 fc ff ff       	call   c0027e23 <strip_antisocial_prefixes>
c0028161:	8b 74 24 24          	mov    0x24(%esp),%esi
c0028165:	89 06                	mov    %eax,(%esi)
  *type = h->typeflag;
c0028167:	0f be 83 9c 00 00 00 	movsbl 0x9c(%ebx),%eax
c002816e:	8b 74 24 28          	mov    0x28(%esp),%esi
c0028172:	89 06                	mov    %eax,(%esi)
  *size = size_ul;
c0028174:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028178:	8b 74 24 2c          	mov    0x2c(%esp),%esi
c002817c:	89 06                	mov    %eax,(%esi)
  return NULL;
c002817e:	b8 00 00 00 00       	mov    $0x0,%eax
c0028183:	e9 42 ff ff ff       	jmp    c00280ca <ustar_parse_header+0x43>
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028188:	8d 43 7c             	lea    0x7c(%ebx),%eax
c002818b:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c002818f:	ba 0c 00 00 00       	mov    $0xc,%edx
c0028194:	e8 20 fc ff ff       	call   c0027db9 <parse_octal_field>
c0028199:	84 c0                	test   %al,%al
c002819b:	74 39                	je     c00281d6 <ustar_parse_header+0x14f>
      else if (size_ul > INT_MAX)
c002819d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c00281a2:	79 b6                	jns    c002815a <ustar_parse_header+0xd3>
        return "file too large";
c00281a4:	b8 b4 f2 02 c0       	mov    $0xc002f2b4,%eax
c00281a9:	e9 1c ff ff ff       	jmp    c00280ca <ustar_parse_header+0x43>
    return "corrupt chksum field";
c00281ae:	b8 4a f2 02 c0       	mov    $0xc002f24a,%eax
c00281b3:	e9 12 ff ff ff       	jmp    c00280ca <ustar_parse_header+0x43>
    return "file name too long";
c00281b8:	b8 71 f2 02 c0       	mov    $0xc002f271,%eax
c00281bd:	e9 08 ff ff ff       	jmp    c00280ca <ustar_parse_header+0x43>
c00281c2:	b8 71 f2 02 c0       	mov    $0xc002f271,%eax
c00281c7:	e9 fe fe ff ff       	jmp    c00280ca <ustar_parse_header+0x43>
    return "unimplemented file type";
c00281cc:	b8 84 f2 02 c0       	mov    $0xc002f284,%eax
c00281d1:	e9 f4 fe ff ff       	jmp    c00280ca <ustar_parse_header+0x43>
        return "corrupt file size field";
c00281d6:	b8 9c f2 02 c0       	mov    $0xc002f29c,%eax
c00281db:	e9 ea fe ff ff       	jmp    c00280ca <ustar_parse_header+0x43>
    return "not a ustar archive";
c00281e0:	b8 20 f2 02 c0       	mov    $0xc002f220,%eax
c00281e5:	e9 e0 fe ff ff       	jmp    c00280ca <ustar_parse_header+0x43>
  if (memcmp (h->magic, "ustar", 6))
c00281ea:	83 ec 04             	sub    $0x4,%esp
c00281ed:	6a 06                	push   $0x6
c00281ef:	68 1a f2 02 c0       	push   $0xc002f21a
c00281f4:	8d 83 01 01 00 00    	lea    0x101(%ebx),%eax
c00281fa:	50                   	push   %eax
c00281fb:	e8 78 f4 ff ff       	call   c0027678 <memcmp>
c0028200:	83 c4 10             	add    $0x10,%esp
c0028203:	85 c0                	test   %eax,%eax
c0028205:	75 d9                	jne    c00281e0 <ustar_parse_header+0x159>
  else if (h->version[0] != '0' || h->version[1] != '0')
c0028207:	80 bb 07 01 00 00 30 	cmpb   $0x30,0x107(%ebx)
c002820e:	0f 84 bc fe ff ff    	je     c00280d0 <ustar_parse_header+0x49>
    return "invalid ustar version";
c0028214:	b8 34 f2 02 c0       	mov    $0xc002f234,%eax
c0028219:	e9 ac fe ff ff       	jmp    c00280ca <ustar_parse_header+0x43>

c002821e <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c002821e:	55                   	push   %ebp
c002821f:	89 e5                	mov    %esp,%ebp
c0028221:	53                   	push   %ebx
c0028222:	83 ec 04             	sub    $0x4,%esp
c0028225:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0028228:	8b 43 08             	mov    0x8(%ebx),%eax
c002822b:	83 f8 01             	cmp    $0x1,%eax
c002822e:	0f 84 ab 00 00 00    	je     c00282df <print_stacktrace+0xc1>
c0028234:	83 f8 01             	cmp    $0x1,%eax
c0028237:	72 10                	jb     c0028249 <print_stacktrace+0x2b>
c0028239:	83 f8 02             	cmp    $0x2,%eax
c002823c:	0f 84 a7 00 00 00    	je     c00282e9 <print_stacktrace+0xcb>
  const char *status = "UNKNOWN";
c0028242:	b8 fb f2 02 c0       	mov    $0xc002f2fb,%eax
c0028247:	eb 05                	jmp    c002824e <print_stacktrace+0x30>
    case THREAD_RUNNING:  
      status = "RUNNING";
c0028249:	b8 76 dd 02 c0       	mov    $0xc002dd76,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c002824e:	83 ec 04             	sub    $0x4,%esp
c0028251:	50                   	push   %eax
c0028252:	8d 43 0c             	lea    0xc(%ebx),%eax
c0028255:	50                   	push   %eax
c0028256:	68 20 f3 02 c0       	push   $0xc002f320
c002825b:	e8 ff e5 ff ff       	call   c002685f <printf>

  if (t == thread_current()) 
c0028260:	e8 21 88 ff ff       	call   c0020a86 <thread_current>
c0028265:	83 c4 10             	add    $0x10,%esp
c0028268:	39 c3                	cmp    %eax,%ebx
c002826a:	0f 84 83 00 00 00    	je     c00282f3 <print_stacktrace+0xd5>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0028270:	8b 53 1c             	mov    0x1c(%ebx),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0028273:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c0028279:	39 da                	cmp    %ebx,%edx
c002827b:	74 7e                	je     c00282fb <print_stacktrace+0xdd>
c002827d:	8b 42 10             	mov    0x10(%edx),%eax
c0028280:	3d 85 15 02 c0       	cmp    $0xc0021585,%eax
c0028285:	74 74                	je     c00282fb <print_stacktrace+0xdd>
        {
          printf (" thread was never scheduled.\n");
          return;
        }

      frame = (void **) saved_frame->ebp;
c0028287:	8b 5a 08             	mov    0x8(%edx),%ebx
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c002828a:	83 ec 08             	sub    $0x8,%esp
c002828d:	50                   	push   %eax
c002828e:	68 f1 ef 02 c0       	push   $0xc002eff1
c0028293:	e8 c7 e5 ff ff       	call   c002685f <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0028298:	83 c4 10             	add    $0x10,%esp
c002829b:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c00282a1:	76 27                	jbe    c00282ca <print_stacktrace+0xac>
c00282a3:	83 3b 00             	cmpl   $0x0,(%ebx)
c00282a6:	74 22                	je     c00282ca <print_stacktrace+0xac>
    printf (" %p", frame[1]);
c00282a8:	83 ec 08             	sub    $0x8,%esp
c00282ab:	ff 73 04             	pushl  0x4(%ebx)
c00282ae:	68 f1 ef 02 c0       	push   $0xc002eff1
c00282b3:	e8 a7 e5 ff ff       	call   c002685f <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00282b8:	8b 1b                	mov    (%ebx),%ebx
c00282ba:	83 c4 10             	add    $0x10,%esp
c00282bd:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c00282c3:	76 05                	jbe    c00282ca <print_stacktrace+0xac>
c00282c5:	83 3b 00             	cmpl   $0x0,(%ebx)
c00282c8:	75 de                	jne    c00282a8 <print_stacktrace+0x8a>
  printf (".\n");
c00282ca:	83 ec 0c             	sub    $0xc,%esp
c00282cd:	68 7b eb 02 c0       	push   $0xc002eb7b
c00282d2:	e8 7d 1a 00 00       	call   c0029d54 <puts>
c00282d7:	83 c4 10             	add    $0x10,%esp
}
c00282da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00282dd:	c9                   	leave  
c00282de:	c3                   	ret    
      status = "READY";
c00282df:	b8 f5 f2 02 c0       	mov    $0xc002f2f5,%eax
      break;
c00282e4:	e9 65 ff ff ff       	jmp    c002824e <print_stacktrace+0x30>
      status = "BLOCKED";
c00282e9:	b8 3f dd 02 c0       	mov    $0xc002dd3f,%eax
      break;
c00282ee:	e9 5b ff ff ff       	jmp    c002824e <print_stacktrace+0x30>
      frame = __builtin_frame_address (1);
c00282f3:	8b 5d 00             	mov    0x0(%ebp),%ebx
      retaddr = __builtin_return_address (0);
c00282f6:	8b 45 04             	mov    0x4(%ebp),%eax
c00282f9:	eb 8f                	jmp    c002828a <print_stacktrace+0x6c>
          printf (" thread was never scheduled.\n");
c00282fb:	83 ec 0c             	sub    $0xc,%esp
c00282fe:	68 03 f3 02 c0       	push   $0xc002f303
c0028303:	e8 4c 1a 00 00       	call   c0029d54 <puts>
          return;
c0028308:	83 c4 10             	add    $0x10,%esp
c002830b:	eb cd                	jmp    c00282da <print_stacktrace+0xbc>

c002830d <debug_panic>:
{
c002830d:	57                   	push   %edi
c002830e:	56                   	push   %esi
c002830f:	53                   	push   %ebx
c0028310:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028314:	8b 74 24 14          	mov    0x14(%esp),%esi
c0028318:	8b 7c 24 18          	mov    0x18(%esp),%edi
  intr_disable ();
c002831c:	e8 d5 93 ff ff       	call   c00216f6 <intr_disable>
  console_panic ();
c0028321:	e8 d5 19 00 00       	call   c0029cfb <console_panic>
  level++;
c0028326:	a1 40 9e 03 c0       	mov    0xc0039e40,%eax
c002832b:	40                   	inc    %eax
c002832c:	a3 40 9e 03 c0       	mov    %eax,0xc0039e40
  if (level == 1) 
c0028331:	83 f8 01             	cmp    $0x1,%eax
c0028334:	74 11                	je     c0028347 <debug_panic+0x3a>
  else if (level == 2)
c0028336:	83 f8 02             	cmp    $0x2,%eax
c0028339:	74 40                	je     c002837b <debug_panic+0x6e>
  serial_flush ();
c002833b:	e8 35 c4 ff ff       	call   c0024775 <serial_flush>
  shutdown ();
c0028340:	e8 5c de ff ff       	call   c00261a1 <shutdown>
c0028345:	eb fe                	jmp    c0028345 <debug_panic+0x38>
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0028347:	57                   	push   %edi
c0028348:	56                   	push   %esi
c0028349:	53                   	push   %ebx
c002834a:	68 48 f3 02 c0       	push   $0xc002f348
c002834f:	e8 0b e5 ff ff       	call   c002685f <printf>
      va_start (args, message);
c0028354:	8d 44 24 30          	lea    0x30(%esp),%eax
      vprintf (message, args);
c0028358:	83 c4 08             	add    $0x8,%esp
c002835b:	50                   	push   %eax
c002835c:	ff 74 24 28          	pushl  0x28(%esp)
c0028360:	e8 bb 19 00 00       	call   c0029d20 <vprintf>
      printf ("\n");
c0028365:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c002836c:	e8 4f 1a 00 00       	call   c0029dc0 <putchar>
      debug_backtrace ();
c0028371:	e8 e6 de ff ff       	call   c002625c <debug_backtrace>
c0028376:	83 c4 10             	add    $0x10,%esp
c0028379:	eb c0                	jmp    c002833b <debug_panic+0x2e>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c002837b:	57                   	push   %edi
c002837c:	56                   	push   %esi
c002837d:	53                   	push   %ebx
c002837e:	68 68 f3 02 c0       	push   $0xc002f368
c0028383:	e8 d7 e4 ff ff       	call   c002685f <printf>
c0028388:	83 c4 10             	add    $0x10,%esp
c002838b:	eb ae                	jmp    c002833b <debug_panic+0x2e>

c002838d <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c002838d:	53                   	push   %ebx
c002838e:	83 ec 08             	sub    $0x8,%esp
  enum intr_level oldlevel = intr_disable ();
c0028391:	e8 60 93 ff ff       	call   c00216f6 <intr_disable>
c0028396:	89 c3                	mov    %eax,%ebx

  thread_foreach (print_stacktrace, 0);
c0028398:	83 ec 08             	sub    $0x8,%esp
c002839b:	6a 00                	push   $0x0
c002839d:	68 1e 82 02 c0       	push   $0xc002821e
c00283a2:	e8 ac 87 ff ff       	call   c0020b53 <thread_foreach>
  intr_set_level (oldlevel);
c00283a7:	89 1c 24             	mov    %ebx,(%esp)
c00283aa:	e8 4e 93 ff ff       	call   c00216fd <intr_set_level>
}
c00283af:	83 c4 18             	add    $0x18,%esp
c00283b2:	5b                   	pop    %ebx
c00283b3:	c3                   	ret    

c00283b4 <list_init>:
}

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c00283b4:	83 ec 0c             	sub    $0xc,%esp
c00283b7:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00283bb:	85 c0                	test   %eax,%eax
c00283bd:	74 1a                	je     c00283d9 <list_init+0x25>
  list->head.prev = NULL;
c00283bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c00283c5:	8d 50 08             	lea    0x8(%eax),%edx
c00283c8:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c00283cb:	89 40 08             	mov    %eax,0x8(%eax)
  list->tail.next = NULL;
c00283ce:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c00283d5:	83 c4 0c             	add    $0xc,%esp
c00283d8:	c3                   	ret    
  ASSERT (list != NULL);
c00283d9:	83 ec 0c             	sub    $0xc,%esp
c00283dc:	68 92 f3 02 c0       	push   $0xc002f392
c00283e1:	68 3f d9 02 c0       	push   $0xc002d93f
c00283e6:	68 18 d5 02 c0       	push   $0xc002d518
c00283eb:	6a 3d                	push   $0x3d
c00283ed:	68 9f f3 02 c0       	push   $0xc002f39f
c00283f2:	e8 16 ff ff ff       	call   c002830d <debug_panic>

c00283f7 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c00283f7:	83 ec 0c             	sub    $0xc,%esp
c00283fa:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00283fe:	85 c0                	test   %eax,%eax
c0028400:	74 07                	je     c0028409 <list_begin+0x12>
  return list->head.next;
c0028402:	8b 40 04             	mov    0x4(%eax),%eax
}
c0028405:	83 c4 0c             	add    $0xc,%esp
c0028408:	c3                   	ret    
  ASSERT (list != NULL);
c0028409:	83 ec 0c             	sub    $0xc,%esp
c002840c:	68 92 f3 02 c0       	push   $0xc002f392
c0028411:	68 3f d9 02 c0       	push   $0xc002d93f
c0028416:	68 0c d5 02 c0       	push   $0xc002d50c
c002841b:	6a 48                	push   $0x48
c002841d:	68 9f f3 02 c0       	push   $0xc002f39f
c0028422:	e8 e6 fe ff ff       	call   c002830d <debug_panic>

c0028427 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0028427:	83 ec 0c             	sub    $0xc,%esp
c002842a:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c002842e:	85 c0                	test   %eax,%eax
c0028430:	74 1f                	je     c0028451 <list_next+0x2a>
c0028432:	83 38 00             	cmpl   $0x0,(%eax)
c0028435:	74 12                	je     c0028449 <list_next+0x22>
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028437:	83 38 00             	cmpl   $0x0,(%eax)
c002843a:	74 15                	je     c0028451 <list_next+0x2a>
c002843c:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0028440:	74 0f                	je     c0028451 <list_next+0x2a>
  ASSERT (is_head (elem) || is_interior (elem));
  return elem->next;
c0028442:	8b 40 04             	mov    0x4(%eax),%eax
}
c0028445:	83 c4 0c             	add    $0xc,%esp
c0028448:	c3                   	ret    
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0028449:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002844d:	75 f3                	jne    c0028442 <list_next+0x1b>
c002844f:	eb e6                	jmp    c0028437 <list_next+0x10>
  ASSERT (is_head (elem) || is_interior (elem));
c0028451:	83 ec 0c             	sub    $0xc,%esp
c0028454:	68 54 f4 02 c0       	push   $0xc002f454
c0028459:	68 3f d9 02 c0       	push   $0xc002d93f
c002845e:	68 00 d5 02 c0       	push   $0xc002d500
c0028463:	6a 52                	push   $0x52
c0028465:	68 9f f3 02 c0       	push   $0xc002f39f
c002846a:	e8 9e fe ff ff       	call   c002830d <debug_panic>

c002846f <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c002846f:	83 ec 0c             	sub    $0xc,%esp
c0028472:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0028476:	85 c0                	test   %eax,%eax
c0028478:	74 07                	je     c0028481 <list_end+0x12>
  return &list->tail;
c002847a:	83 c0 08             	add    $0x8,%eax
}
c002847d:	83 c4 0c             	add    $0xc,%esp
c0028480:	c3                   	ret    
  ASSERT (list != NULL);
c0028481:	83 ec 0c             	sub    $0xc,%esp
c0028484:	68 92 f3 02 c0       	push   $0xc002f392
c0028489:	68 3f d9 02 c0       	push   $0xc002d93f
c002848e:	68 f4 d4 02 c0       	push   $0xc002d4f4
c0028493:	6a 5e                	push   $0x5e
c0028495:	68 9f f3 02 c0       	push   $0xc002f39f
c002849a:	e8 6e fe ff ff       	call   c002830d <debug_panic>

c002849f <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c002849f:	83 ec 0c             	sub    $0xc,%esp
c00284a2:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00284a6:	85 c0                	test   %eax,%eax
c00284a8:	74 07                	je     c00284b1 <list_rbegin+0x12>
  return list->tail.prev;
c00284aa:	8b 40 08             	mov    0x8(%eax),%eax
}
c00284ad:	83 c4 0c             	add    $0xc,%esp
c00284b0:	c3                   	ret    
  ASSERT (list != NULL);
c00284b1:	83 ec 0c             	sub    $0xc,%esp
c00284b4:	68 92 f3 02 c0       	push   $0xc002f392
c00284b9:	68 3f d9 02 c0       	push   $0xc002d93f
c00284be:	68 e8 d4 02 c0       	push   $0xc002d4e8
c00284c3:	6a 67                	push   $0x67
c00284c5:	68 9f f3 02 c0       	push   $0xc002f39f
c00284ca:	e8 3e fe ff ff       	call   c002830d <debug_panic>

c00284cf <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c00284cf:	83 ec 0c             	sub    $0xc,%esp
c00284d2:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00284d6:	85 c0                	test   %eax,%eax
c00284d8:	74 1c                	je     c00284f6 <list_prev+0x27>
c00284da:	83 38 00             	cmpl   $0x0,(%eax)
c00284dd:	74 0c                	je     c00284eb <list_prev+0x1c>
c00284df:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00284e3:	74 06                	je     c00284eb <list_prev+0x1c>
  ASSERT (is_interior (elem) || is_tail (elem));
  return elem->prev;
c00284e5:	8b 00                	mov    (%eax),%eax
}
c00284e7:	83 c4 0c             	add    $0xc,%esp
c00284ea:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00284eb:	83 38 00             	cmpl   $0x0,(%eax)
c00284ee:	74 06                	je     c00284f6 <list_prev+0x27>
c00284f0:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00284f4:	74 ef                	je     c00284e5 <list_prev+0x16>
  ASSERT (is_interior (elem) || is_tail (elem));
c00284f6:	83 ec 0c             	sub    $0xc,%esp
c00284f9:	68 7c f4 02 c0       	push   $0xc002f47c
c00284fe:	68 3f d9 02 c0       	push   $0xc002d93f
c0028503:	68 dc d4 02 c0       	push   $0xc002d4dc
c0028508:	6a 71                	push   $0x71
c002850a:	68 9f f3 02 c0       	push   $0xc002f39f
c002850f:	e8 f9 fd ff ff       	call   c002830d <debug_panic>

c0028514 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c0028514:	55                   	push   %ebp
c0028515:	57                   	push   %edi
c0028516:	56                   	push   %esi
c0028517:	53                   	push   %ebx
c0028518:	83 ec 0c             	sub    $0xc,%esp
c002851b:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  ASSERT (a != NULL);
c002851f:	85 c0                	test   %eax,%eax
c0028521:	74 50                	je     c0028573 <find_end_of_run+0x5f>
c0028523:	89 c3                	mov    %eax,%ebx
c0028525:	89 d6                	mov    %edx,%esi
c0028527:	89 cf                	mov    %ecx,%edi
  ASSERT (b != NULL);
c0028529:	85 d2                	test   %edx,%edx
c002852b:	74 67                	je     c0028594 <find_end_of_run+0x80>
  ASSERT (less != NULL);
c002852d:	85 c9                	test   %ecx,%ecx
c002852f:	0f 84 80 00 00 00    	je     c00285b5 <find_end_of_run+0xa1>
  ASSERT (a != b);
c0028535:	39 d0                	cmp    %edx,%eax
c0028537:	0f 84 99 00 00 00    	je     c00285d6 <find_end_of_run+0xc2>
  
  do 
    {
      a = list_next (a);
c002853d:	83 ec 0c             	sub    $0xc,%esp
c0028540:	53                   	push   %ebx
c0028541:	e8 e1 fe ff ff       	call   c0028427 <list_next>
c0028546:	83 c4 10             	add    $0x10,%esp
c0028549:	89 c3                	mov    %eax,%ebx
    }
  while (a != b && !less (a, list_prev (a), aux));
c002854b:	39 c6                	cmp    %eax,%esi
c002854d:	74 1a                	je     c0028569 <find_end_of_run+0x55>
c002854f:	83 ec 0c             	sub    $0xc,%esp
c0028552:	50                   	push   %eax
c0028553:	e8 77 ff ff ff       	call   c00284cf <list_prev>
c0028558:	83 c4 0c             	add    $0xc,%esp
c002855b:	55                   	push   %ebp
c002855c:	50                   	push   %eax
c002855d:	53                   	push   %ebx
c002855e:	ff d7                	call   *%edi
c0028560:	83 c4 10             	add    $0x10,%esp
c0028563:	84 c0                	test   %al,%al
c0028565:	74 d6                	je     c002853d <find_end_of_run+0x29>
      a = list_next (a);
c0028567:	89 de                	mov    %ebx,%esi
  return a;
}
c0028569:	89 f0                	mov    %esi,%eax
c002856b:	83 c4 0c             	add    $0xc,%esp
c002856e:	5b                   	pop    %ebx
c002856f:	5e                   	pop    %esi
c0028570:	5f                   	pop    %edi
c0028571:	5d                   	pop    %ebp
c0028572:	c3                   	ret    
  ASSERT (a != NULL);
c0028573:	83 ec 0c             	sub    $0xc,%esp
c0028576:	68 f1 e1 02 c0       	push   $0xc002e1f1
c002857b:	68 3f d9 02 c0       	push   $0xc002d93f
c0028580:	68 60 d4 02 c0       	push   $0xc002d460
c0028585:	68 67 01 00 00       	push   $0x167
c002858a:	68 9f f3 02 c0       	push   $0xc002f39f
c002858f:	e8 79 fd ff ff       	call   c002830d <debug_panic>
  ASSERT (b != NULL);
c0028594:	83 ec 0c             	sub    $0xc,%esp
c0028597:	68 b7 f3 02 c0       	push   $0xc002f3b7
c002859c:	68 3f d9 02 c0       	push   $0xc002d93f
c00285a1:	68 60 d4 02 c0       	push   $0xc002d460
c00285a6:	68 68 01 00 00       	push   $0x168
c00285ab:	68 9f f3 02 c0       	push   $0xc002f39f
c00285b0:	e8 58 fd ff ff       	call   c002830d <debug_panic>
  ASSERT (less != NULL);
c00285b5:	83 ec 0c             	sub    $0xc,%esp
c00285b8:	68 c1 f3 02 c0       	push   $0xc002f3c1
c00285bd:	68 3f d9 02 c0       	push   $0xc002d93f
c00285c2:	68 60 d4 02 c0       	push   $0xc002d460
c00285c7:	68 69 01 00 00       	push   $0x169
c00285cc:	68 9f f3 02 c0       	push   $0xc002f39f
c00285d1:	e8 37 fd ff ff       	call   c002830d <debug_panic>
  ASSERT (a != b);
c00285d6:	83 ec 0c             	sub    $0xc,%esp
c00285d9:	68 ce f3 02 c0       	push   $0xc002f3ce
c00285de:	68 3f d9 02 c0       	push   $0xc002d93f
c00285e3:	68 60 d4 02 c0       	push   $0xc002d460
c00285e8:	68 6a 01 00 00       	push   $0x16a
c00285ed:	68 9f f3 02 c0       	push   $0xc002f39f
c00285f2:	e8 16 fd ff ff       	call   c002830d <debug_panic>

c00285f7 <list_rend>:
{
c00285f7:	83 ec 0c             	sub    $0xc,%esp
c00285fa:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00285fe:	85 c0                	test   %eax,%eax
c0028600:	74 04                	je     c0028606 <list_rend+0xf>
}
c0028602:	83 c4 0c             	add    $0xc,%esp
c0028605:	c3                   	ret    
  ASSERT (list != NULL);
c0028606:	83 ec 0c             	sub    $0xc,%esp
c0028609:	68 92 f3 02 c0       	push   $0xc002f392
c002860e:	68 3f d9 02 c0       	push   $0xc002d93f
c0028613:	68 d0 d4 02 c0       	push   $0xc002d4d0
c0028618:	68 85 00 00 00       	push   $0x85
c002861d:	68 9f f3 02 c0       	push   $0xc002f39f
c0028622:	e8 e6 fc ff ff       	call   c002830d <debug_panic>

c0028627 <list_head>:
{
c0028627:	83 ec 0c             	sub    $0xc,%esp
c002862a:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002862e:	85 c0                	test   %eax,%eax
c0028630:	74 04                	je     c0028636 <list_head+0xf>
}
c0028632:	83 c4 0c             	add    $0xc,%esp
c0028635:	c3                   	ret    
  ASSERT (list != NULL);
c0028636:	83 ec 0c             	sub    $0xc,%esp
c0028639:	68 92 f3 02 c0       	push   $0xc002f392
c002863e:	68 3f d9 02 c0       	push   $0xc002d93f
c0028643:	68 c4 d4 02 c0       	push   $0xc002d4c4
c0028648:	68 97 00 00 00       	push   $0x97
c002864d:	68 9f f3 02 c0       	push   $0xc002f39f
c0028652:	e8 b6 fc ff ff       	call   c002830d <debug_panic>

c0028657 <list_tail>:
{
c0028657:	83 ec 0c             	sub    $0xc,%esp
c002865a:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002865e:	85 c0                	test   %eax,%eax
c0028660:	74 07                	je     c0028669 <list_tail+0x12>
  return &list->tail;
c0028662:	83 c0 08             	add    $0x8,%eax
}
c0028665:	83 c4 0c             	add    $0xc,%esp
c0028668:	c3                   	ret    
  ASSERT (list != NULL);
c0028669:	83 ec 0c             	sub    $0xc,%esp
c002866c:	68 92 f3 02 c0       	push   $0xc002f392
c0028671:	68 3f d9 02 c0       	push   $0xc002d93f
c0028676:	68 b8 d4 02 c0       	push   $0xc002d4b8
c002867b:	68 9f 00 00 00       	push   $0x9f
c0028680:	68 9f f3 02 c0       	push   $0xc002f39f
c0028685:	e8 83 fc ff ff       	call   c002830d <debug_panic>

c002868a <list_insert>:
{
c002868a:	83 ec 0c             	sub    $0xc,%esp
c002868d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028691:	8b 54 24 14          	mov    0x14(%esp),%edx
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028695:	85 c0                	test   %eax,%eax
c0028697:	74 2c                	je     c00286c5 <list_insert+0x3b>
c0028699:	83 38 00             	cmpl   $0x0,(%eax)
c002869c:	74 1c                	je     c00286ba <list_insert+0x30>
c002869e:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00286a2:	74 16                	je     c00286ba <list_insert+0x30>
  ASSERT (elem != NULL);
c00286a4:	85 d2                	test   %edx,%edx
c00286a6:	74 3e                	je     c00286e6 <list_insert+0x5c>
  elem->prev = before->prev;
c00286a8:	8b 08                	mov    (%eax),%ecx
c00286aa:	89 0a                	mov    %ecx,(%edx)
  elem->next = before;
c00286ac:	89 42 04             	mov    %eax,0x4(%edx)
  before->prev->next = elem;
c00286af:	8b 08                	mov    (%eax),%ecx
c00286b1:	89 51 04             	mov    %edx,0x4(%ecx)
  before->prev = elem;
c00286b4:	89 10                	mov    %edx,(%eax)
}
c00286b6:	83 c4 0c             	add    $0xc,%esp
c00286b9:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00286ba:	83 38 00             	cmpl   $0x0,(%eax)
c00286bd:	74 06                	je     c00286c5 <list_insert+0x3b>
c00286bf:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00286c3:	74 df                	je     c00286a4 <list_insert+0x1a>
  ASSERT (is_interior (before) || is_tail (before));
c00286c5:	83 ec 0c             	sub    $0xc,%esp
c00286c8:	68 a4 f4 02 c0       	push   $0xc002f4a4
c00286cd:	68 3f d9 02 c0       	push   $0xc002d93f
c00286d2:	68 ac d4 02 c0       	push   $0xc002d4ac
c00286d7:	68 a9 00 00 00       	push   $0xa9
c00286dc:	68 9f f3 02 c0       	push   $0xc002f39f
c00286e1:	e8 27 fc ff ff       	call   c002830d <debug_panic>
  ASSERT (elem != NULL);
c00286e6:	83 ec 0c             	sub    $0xc,%esp
c00286e9:	68 d5 f3 02 c0       	push   $0xc002f3d5
c00286ee:	68 3f d9 02 c0       	push   $0xc002d93f
c00286f3:	68 ac d4 02 c0       	push   $0xc002d4ac
c00286f8:	68 aa 00 00 00       	push   $0xaa
c00286fd:	68 9f f3 02 c0       	push   $0xc002f39f
c0028702:	e8 06 fc ff ff       	call   c002830d <debug_panic>

c0028707 <list_splice>:
{
c0028707:	56                   	push   %esi
c0028708:	53                   	push   %ebx
c0028709:	83 ec 04             	sub    $0x4,%esp
c002870c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028710:	8b 74 24 14          	mov    0x14(%esp),%esi
c0028714:	8b 44 24 18          	mov    0x18(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028718:	85 db                	test   %ebx,%ebx
c002871a:	74 64                	je     c0028780 <list_splice+0x79>
c002871c:	83 3b 00             	cmpl   $0x0,(%ebx)
c002871f:	74 54                	je     c0028775 <list_splice+0x6e>
c0028721:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0028725:	74 4e                	je     c0028775 <list_splice+0x6e>
  if (first == last)
c0028727:	39 c6                	cmp    %eax,%esi
c0028729:	74 44                	je     c002876f <list_splice+0x68>
  last = list_prev (last);
c002872b:	83 ec 0c             	sub    $0xc,%esp
c002872e:	50                   	push   %eax
c002872f:	e8 9b fd ff ff       	call   c00284cf <list_prev>
c0028734:	83 c4 10             	add    $0x10,%esp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028737:	85 f6                	test   %esi,%esi
c0028739:	74 66                	je     c00287a1 <list_splice+0x9a>
c002873b:	8b 16                	mov    (%esi),%edx
c002873d:	85 d2                	test   %edx,%edx
c002873f:	74 60                	je     c00287a1 <list_splice+0x9a>
c0028741:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0028745:	74 5a                	je     c00287a1 <list_splice+0x9a>
c0028747:	85 c0                	test   %eax,%eax
c0028749:	74 77                	je     c00287c2 <list_splice+0xbb>
c002874b:	83 38 00             	cmpl   $0x0,(%eax)
c002874e:	74 72                	je     c00287c2 <list_splice+0xbb>
c0028750:	8b 48 04             	mov    0x4(%eax),%ecx
c0028753:	85 c9                	test   %ecx,%ecx
c0028755:	74 6b                	je     c00287c2 <list_splice+0xbb>
  first->prev->next = last->next;
c0028757:	89 4a 04             	mov    %ecx,0x4(%edx)
  last->next->prev = first->prev;
c002875a:	8b 50 04             	mov    0x4(%eax),%edx
c002875d:	8b 0e                	mov    (%esi),%ecx
c002875f:	89 0a                	mov    %ecx,(%edx)
  first->prev = before->prev;
c0028761:	8b 13                	mov    (%ebx),%edx
c0028763:	89 16                	mov    %edx,(%esi)
  last->next = before;
c0028765:	89 58 04             	mov    %ebx,0x4(%eax)
  before->prev->next = first;
c0028768:	8b 13                	mov    (%ebx),%edx
c002876a:	89 72 04             	mov    %esi,0x4(%edx)
  before->prev = last;
c002876d:	89 03                	mov    %eax,(%ebx)
}
c002876f:	83 c4 04             	add    $0x4,%esp
c0028772:	5b                   	pop    %ebx
c0028773:	5e                   	pop    %esi
c0028774:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0028775:	83 3b 00             	cmpl   $0x0,(%ebx)
c0028778:	74 06                	je     c0028780 <list_splice+0x79>
c002877a:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c002877e:	74 a7                	je     c0028727 <list_splice+0x20>
  ASSERT (is_interior (before) || is_tail (before));
c0028780:	83 ec 0c             	sub    $0xc,%esp
c0028783:	68 a4 f4 02 c0       	push   $0xc002f4a4
c0028788:	68 3f d9 02 c0       	push   $0xc002d93f
c002878d:	68 a0 d4 02 c0       	push   $0xc002d4a0
c0028792:	68 b9 00 00 00       	push   $0xb9
c0028797:	68 9f f3 02 c0       	push   $0xc002f39f
c002879c:	e8 6c fb ff ff       	call   c002830d <debug_panic>
  ASSERT (is_interior (first));
c00287a1:	83 ec 0c             	sub    $0xc,%esp
c00287a4:	68 e2 f3 02 c0       	push   $0xc002f3e2
c00287a9:	68 3f d9 02 c0       	push   $0xc002d93f
c00287ae:	68 a0 d4 02 c0       	push   $0xc002d4a0
c00287b3:	68 be 00 00 00       	push   $0xbe
c00287b8:	68 9f f3 02 c0       	push   $0xc002f39f
c00287bd:	e8 4b fb ff ff       	call   c002830d <debug_panic>
  ASSERT (is_interior (last));
c00287c2:	83 ec 0c             	sub    $0xc,%esp
c00287c5:	68 f6 f3 02 c0       	push   $0xc002f3f6
c00287ca:	68 3f d9 02 c0       	push   $0xc002d93f
c00287cf:	68 a0 d4 02 c0       	push   $0xc002d4a0
c00287d4:	68 bf 00 00 00       	push   $0xbf
c00287d9:	68 9f f3 02 c0       	push   $0xc002f39f
c00287de:	e8 2a fb ff ff       	call   c002830d <debug_panic>

c00287e3 <list_push_front>:
{
c00287e3:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_begin (list), elem);
c00287e6:	ff 74 24 1c          	pushl  0x1c(%esp)
c00287ea:	e8 08 fc ff ff       	call   c00283f7 <list_begin>
c00287ef:	83 c4 08             	add    $0x8,%esp
c00287f2:	ff 74 24 1c          	pushl  0x1c(%esp)
c00287f6:	50                   	push   %eax
c00287f7:	e8 8e fe ff ff       	call   c002868a <list_insert>
}
c00287fc:	83 c4 1c             	add    $0x1c,%esp
c00287ff:	c3                   	ret    

c0028800 <list_push_back>:
{
c0028800:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_end (list), elem);
c0028803:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028807:	e8 63 fc ff ff       	call   c002846f <list_end>
c002880c:	83 c4 08             	add    $0x8,%esp
c002880f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028813:	50                   	push   %eax
c0028814:	e8 71 fe ff ff       	call   c002868a <list_insert>
}
c0028819:	83 c4 1c             	add    $0x1c,%esp
c002881c:	c3                   	ret    

c002881d <list_remove>:
{
c002881d:	83 ec 0c             	sub    $0xc,%esp
c0028820:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028824:	85 c0                	test   %eax,%eax
c0028826:	74 1e                	je     c0028846 <list_remove+0x29>
c0028828:	8b 10                	mov    (%eax),%edx
c002882a:	85 d2                	test   %edx,%edx
c002882c:	74 18                	je     c0028846 <list_remove+0x29>
c002882e:	8b 48 04             	mov    0x4(%eax),%ecx
c0028831:	85 c9                	test   %ecx,%ecx
c0028833:	74 11                	je     c0028846 <list_remove+0x29>
  elem->prev->next = elem->next;
c0028835:	89 4a 04             	mov    %ecx,0x4(%edx)
  elem->next->prev = elem->prev;
c0028838:	8b 50 04             	mov    0x4(%eax),%edx
c002883b:	8b 08                	mov    (%eax),%ecx
c002883d:	89 0a                	mov    %ecx,(%edx)
  return elem->next;
c002883f:	8b 40 04             	mov    0x4(%eax),%eax
}
c0028842:	83 c4 0c             	add    $0xc,%esp
c0028845:	c3                   	ret    
  ASSERT (is_interior (elem));
c0028846:	83 ec 0c             	sub    $0xc,%esp
c0028849:	68 09 f4 02 c0       	push   $0xc002f409
c002884e:	68 3f d9 02 c0       	push   $0xc002d93f
c0028853:	68 94 d4 02 c0       	push   $0xc002d494
c0028858:	68 f9 00 00 00       	push   $0xf9
c002885d:	68 9f f3 02 c0       	push   $0xc002f39f
c0028862:	e8 a6 fa ff ff       	call   c002830d <debug_panic>

c0028867 <list_size>:
{
c0028867:	57                   	push   %edi
c0028868:	56                   	push   %esi
c0028869:	53                   	push   %ebx
c002886a:	8b 7c 24 10          	mov    0x10(%esp),%edi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002886e:	83 ec 0c             	sub    $0xc,%esp
c0028871:	57                   	push   %edi
c0028872:	e8 80 fb ff ff       	call   c00283f7 <list_begin>
c0028877:	83 c4 10             	add    $0x10,%esp
c002887a:	89 c3                	mov    %eax,%ebx
  size_t cnt = 0;
c002887c:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028881:	eb 0f                	jmp    c0028892 <list_size+0x2b>
    cnt++;
c0028883:	46                   	inc    %esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028884:	83 ec 0c             	sub    $0xc,%esp
c0028887:	53                   	push   %ebx
c0028888:	e8 9a fb ff ff       	call   c0028427 <list_next>
c002888d:	83 c4 10             	add    $0x10,%esp
c0028890:	89 c3                	mov    %eax,%ebx
c0028892:	83 ec 0c             	sub    $0xc,%esp
c0028895:	57                   	push   %edi
c0028896:	e8 d4 fb ff ff       	call   c002846f <list_end>
c002889b:	83 c4 10             	add    $0x10,%esp
c002889e:	39 c3                	cmp    %eax,%ebx
c00288a0:	75 e1                	jne    c0028883 <list_size+0x1c>
}
c00288a2:	89 f0                	mov    %esi,%eax
c00288a4:	5b                   	pop    %ebx
c00288a5:	5e                   	pop    %esi
c00288a6:	5f                   	pop    %edi
c00288a7:	c3                   	ret    

c00288a8 <list_empty>:
{
c00288a8:	56                   	push   %esi
c00288a9:	53                   	push   %ebx
c00288aa:	83 ec 10             	sub    $0x10,%esp
c00288ad:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  return list_begin (list) == list_end (list);
c00288b1:	53                   	push   %ebx
c00288b2:	e8 40 fb ff ff       	call   c00283f7 <list_begin>
c00288b7:	89 c6                	mov    %eax,%esi
c00288b9:	89 1c 24             	mov    %ebx,(%esp)
c00288bc:	e8 ae fb ff ff       	call   c002846f <list_end>
c00288c1:	39 c6                	cmp    %eax,%esi
c00288c3:	0f 94 c0             	sete   %al
}
c00288c6:	83 c4 14             	add    $0x14,%esp
c00288c9:	5b                   	pop    %ebx
c00288ca:	5e                   	pop    %esi
c00288cb:	c3                   	ret    

c00288cc <list_front>:
{
c00288cc:	53                   	push   %ebx
c00288cd:	83 ec 14             	sub    $0x14,%esp
c00288d0:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  ASSERT (!list_empty (list));
c00288d4:	53                   	push   %ebx
c00288d5:	e8 ce ff ff ff       	call   c00288a8 <list_empty>
c00288da:	83 c4 10             	add    $0x10,%esp
c00288dd:	84 c0                	test   %al,%al
c00288df:	75 08                	jne    c00288e9 <list_front+0x1d>
  return list->head.next;
c00288e1:	8b 43 04             	mov    0x4(%ebx),%eax
}
c00288e4:	83 c4 08             	add    $0x8,%esp
c00288e7:	5b                   	pop    %ebx
c00288e8:	c3                   	ret    
  ASSERT (!list_empty (list));
c00288e9:	83 ec 0c             	sub    $0xc,%esp
c00288ec:	68 1c f4 02 c0       	push   $0xc002f41c
c00288f1:	68 3f d9 02 c0       	push   $0xc002d93f
c00288f6:	68 88 d4 02 c0       	push   $0xc002d488
c00288fb:	68 18 01 00 00       	push   $0x118
c0028900:	68 9f f3 02 c0       	push   $0xc002f39f
c0028905:	e8 03 fa ff ff       	call   c002830d <debug_panic>

c002890a <list_pop_front>:
{
c002890a:	53                   	push   %ebx
c002890b:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *front = list_front (list);
c002890e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028912:	e8 b5 ff ff ff       	call   c00288cc <list_front>
c0028917:	89 c3                	mov    %eax,%ebx
  list_remove (front);
c0028919:	89 04 24             	mov    %eax,(%esp)
c002891c:	e8 fc fe ff ff       	call   c002881d <list_remove>
}
c0028921:	89 d8                	mov    %ebx,%eax
c0028923:	83 c4 18             	add    $0x18,%esp
c0028926:	5b                   	pop    %ebx
c0028927:	c3                   	ret    

c0028928 <list_back>:
{
c0028928:	53                   	push   %ebx
c0028929:	83 ec 14             	sub    $0x14,%esp
c002892c:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  ASSERT (!list_empty (list));
c0028930:	53                   	push   %ebx
c0028931:	e8 72 ff ff ff       	call   c00288a8 <list_empty>
c0028936:	83 c4 10             	add    $0x10,%esp
c0028939:	84 c0                	test   %al,%al
c002893b:	75 08                	jne    c0028945 <list_back+0x1d>
  return list->tail.prev;
c002893d:	8b 43 08             	mov    0x8(%ebx),%eax
}
c0028940:	83 c4 08             	add    $0x8,%esp
c0028943:	5b                   	pop    %ebx
c0028944:	c3                   	ret    
  ASSERT (!list_empty (list));
c0028945:	83 ec 0c             	sub    $0xc,%esp
c0028948:	68 1c f4 02 c0       	push   $0xc002f41c
c002894d:	68 3f d9 02 c0       	push   $0xc002d93f
c0028952:	68 7c d4 02 c0       	push   $0xc002d47c
c0028957:	68 21 01 00 00       	push   $0x121
c002895c:	68 9f f3 02 c0       	push   $0xc002f39f
c0028961:	e8 a7 f9 ff ff       	call   c002830d <debug_panic>

c0028966 <list_pop_back>:
{
c0028966:	53                   	push   %ebx
c0028967:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *back = list_back (list);
c002896a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002896e:	e8 b5 ff ff ff       	call   c0028928 <list_back>
c0028973:	89 c3                	mov    %eax,%ebx
  list_remove (back);
c0028975:	89 04 24             	mov    %eax,(%esp)
c0028978:	e8 a0 fe ff ff       	call   c002881d <list_remove>
}
c002897d:	89 d8                	mov    %ebx,%eax
c002897f:	83 c4 18             	add    $0x18,%esp
c0028982:	5b                   	pop    %ebx
c0028983:	c3                   	ret    

c0028984 <list_reverse>:
{
c0028984:	56                   	push   %esi
c0028985:	53                   	push   %ebx
c0028986:	83 ec 10             	sub    $0x10,%esp
c0028989:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  if (!list_empty (list)) 
c002898d:	56                   	push   %esi
c002898e:	e8 15 ff ff ff       	call   c00288a8 <list_empty>
c0028993:	83 c4 10             	add    $0x10,%esp
c0028996:	84 c0                	test   %al,%al
c0028998:	74 06                	je     c00289a0 <list_reverse+0x1c>
}
c002899a:	83 c4 04             	add    $0x4,%esp
c002899d:	5b                   	pop    %ebx
c002899e:	5e                   	pop    %esi
c002899f:	c3                   	ret    
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c00289a0:	83 ec 0c             	sub    $0xc,%esp
c00289a3:	56                   	push   %esi
c00289a4:	e8 4e fa ff ff       	call   c00283f7 <list_begin>
c00289a9:	83 c4 10             	add    $0x10,%esp
c00289ac:	89 c3                	mov    %eax,%ebx
c00289ae:	eb 0c                	jmp    c00289bc <list_reverse+0x38>
  struct list_elem *t = *a;
c00289b0:	8b 13                	mov    (%ebx),%edx
  *a = *b;
c00289b2:	8b 43 04             	mov    0x4(%ebx),%eax
c00289b5:	89 03                	mov    %eax,(%ebx)
  *b = t;
c00289b7:	89 53 04             	mov    %edx,0x4(%ebx)
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c00289ba:	89 c3                	mov    %eax,%ebx
c00289bc:	83 ec 0c             	sub    $0xc,%esp
c00289bf:	56                   	push   %esi
c00289c0:	e8 aa fa ff ff       	call   c002846f <list_end>
c00289c5:	83 c4 10             	add    $0x10,%esp
c00289c8:	39 c3                	cmp    %eax,%ebx
c00289ca:	75 e4                	jne    c00289b0 <list_reverse+0x2c>
  struct list_elem *t = *a;
c00289cc:	8b 46 04             	mov    0x4(%esi),%eax
  *a = *b;
c00289cf:	8b 56 08             	mov    0x8(%esi),%edx
c00289d2:	89 56 04             	mov    %edx,0x4(%esi)
  *b = t;
c00289d5:	89 46 08             	mov    %eax,0x8(%esi)
  struct list_elem *t = *a;
c00289d8:	8b 0a                	mov    (%edx),%ecx
  *a = *b;
c00289da:	8b 58 04             	mov    0x4(%eax),%ebx
c00289dd:	89 1a                	mov    %ebx,(%edx)
  *b = t;
c00289df:	89 48 04             	mov    %ecx,0x4(%eax)
}
c00289e2:	eb b6                	jmp    c002899a <list_reverse+0x16>

c00289e4 <is_sorted>:
{
c00289e4:	55                   	push   %ebp
c00289e5:	57                   	push   %edi
c00289e6:	56                   	push   %esi
c00289e7:	53                   	push   %ebx
c00289e8:	83 ec 0c             	sub    $0xc,%esp
c00289eb:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c00289ef:	8b 74 24 24          	mov    0x24(%esp),%esi
c00289f3:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c00289f7:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  return true;
c00289fb:	b0 01                	mov    $0x1,%al
  if (a != b)
c00289fd:	39 f3                	cmp    %esi,%ebx
c00289ff:	74 30                	je     c0028a31 <is_sorted+0x4d>
    while ((a = list_next (a)) != b) 
c0028a01:	83 ec 0c             	sub    $0xc,%esp
c0028a04:	53                   	push   %ebx
c0028a05:	e8 1d fa ff ff       	call   c0028427 <list_next>
c0028a0a:	83 c4 10             	add    $0x10,%esp
c0028a0d:	89 c3                	mov    %eax,%ebx
c0028a0f:	39 c6                	cmp    %eax,%esi
c0028a11:	74 1c                	je     c0028a2f <is_sorted+0x4b>
      if (less (a, list_prev (a), aux))
c0028a13:	83 ec 0c             	sub    $0xc,%esp
c0028a16:	53                   	push   %ebx
c0028a17:	e8 b3 fa ff ff       	call   c00284cf <list_prev>
c0028a1c:	83 c4 0c             	add    $0xc,%esp
c0028a1f:	57                   	push   %edi
c0028a20:	50                   	push   %eax
c0028a21:	53                   	push   %ebx
c0028a22:	ff d5                	call   *%ebp
c0028a24:	83 c4 10             	add    $0x10,%esp
c0028a27:	84 c0                	test   %al,%al
c0028a29:	74 d6                	je     c0028a01 <is_sorted+0x1d>
        return false;
c0028a2b:	b0 00                	mov    $0x0,%al
c0028a2d:	eb 02                	jmp    c0028a31 <is_sorted+0x4d>
  return true;
c0028a2f:	b0 01                	mov    $0x1,%al
}
c0028a31:	83 c4 0c             	add    $0xc,%esp
c0028a34:	5b                   	pop    %ebx
c0028a35:	5e                   	pop    %esi
c0028a36:	5f                   	pop    %edi
c0028a37:	5d                   	pop    %ebp
c0028a38:	c3                   	ret    

c0028a39 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c0028a39:	55                   	push   %ebp
c0028a3a:	57                   	push   %edi
c0028a3b:	56                   	push   %esi
c0028a3c:	53                   	push   %ebx
c0028a3d:	83 ec 1c             	sub    $0x1c,%esp
c0028a40:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028a44:	8b 7c 24 38          	mov    0x38(%esp),%edi
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c0028a48:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0028a4d:	74 29                	je     c0028a78 <list_sort+0x3f>
  ASSERT (less != NULL);
c0028a4f:	85 ed                	test   %ebp,%ebp
c0028a51:	0f 85 ee 01 00 00    	jne    c0028c45 <list_sort+0x20c>
c0028a57:	83 ec 0c             	sub    $0xc,%esp
c0028a5a:	68 c1 f3 02 c0       	push   $0xc002f3c1
c0028a5f:	68 3f d9 02 c0       	push   $0xc002d93f
c0028a64:	68 70 d4 02 c0       	push   $0xc002d470
c0028a69:	68 98 01 00 00       	push   $0x198
c0028a6e:	68 9f f3 02 c0       	push   $0xc002f39f
c0028a73:	e8 95 f8 ff ff       	call   c002830d <debug_panic>
  ASSERT (list != NULL);
c0028a78:	83 ec 0c             	sub    $0xc,%esp
c0028a7b:	68 92 f3 02 c0       	push   $0xc002f392
c0028a80:	68 3f d9 02 c0       	push   $0xc002d93f
c0028a85:	68 70 d4 02 c0       	push   $0xc002d470
c0028a8a:	68 97 01 00 00       	push   $0x197
c0028a8f:	68 9f f3 02 c0       	push   $0xc002f39f
c0028a94:	e8 74 f8 ff ff       	call   c002830d <debug_panic>
  ASSERT (a0 != NULL);
c0028a99:	83 ec 0c             	sub    $0xc,%esp
c0028a9c:	68 2f f4 02 c0       	push   $0xc002f42f
c0028aa1:	68 3f d9 02 c0       	push   $0xc002d93f
c0028aa6:	68 50 d4 02 c0       	push   $0xc002d450
c0028aab:	68 7e 01 00 00       	push   $0x17e
c0028ab0:	68 9f f3 02 c0       	push   $0xc002f39f
c0028ab5:	e8 53 f8 ff ff       	call   c002830d <debug_panic>
  ASSERT (a1b0 != NULL);
c0028aba:	83 ec 0c             	sub    $0xc,%esp
c0028abd:	68 3a f4 02 c0       	push   $0xc002f43a
c0028ac2:	68 3f d9 02 c0       	push   $0xc002d93f
c0028ac7:	68 50 d4 02 c0       	push   $0xc002d450
c0028acc:	68 7f 01 00 00       	push   $0x17f
c0028ad1:	68 9f f3 02 c0       	push   $0xc002f39f
c0028ad6:	e8 32 f8 ff ff       	call   c002830d <debug_panic>
  ASSERT (b1 != NULL);
c0028adb:	83 ec 0c             	sub    $0xc,%esp
c0028ade:	68 47 f4 02 c0       	push   $0xc002f447
c0028ae3:	68 3f d9 02 c0       	push   $0xc002d93f
c0028ae8:	68 50 d4 02 c0       	push   $0xc002d450
c0028aed:	68 80 01 00 00       	push   $0x180
c0028af2:	68 9f f3 02 c0       	push   $0xc002f39f
c0028af7:	e8 11 f8 ff ff       	call   c002830d <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0028afc:	83 ec 0c             	sub    $0xc,%esp
c0028aff:	68 d0 f4 02 c0       	push   $0xc002f4d0
c0028b04:	68 3f d9 02 c0       	push   $0xc002d93f
c0028b09:	68 50 d4 02 c0       	push   $0xc002d450
c0028b0e:	68 82 01 00 00       	push   $0x182
c0028b13:	68 9f f3 02 c0       	push   $0xc002f39f
c0028b18:	e8 f0 f7 ff ff       	call   c002830d <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0028b1d:	83 ec 0c             	sub    $0xc,%esp
c0028b20:	68 f0 f4 02 c0       	push   $0xc002f4f0
c0028b25:	68 3f d9 02 c0       	push   $0xc002d93f
c0028b2a:	68 50 d4 02 c0       	push   $0xc002d450
c0028b2f:	68 83 01 00 00       	push   $0x183
c0028b34:	68 9f f3 02 c0       	push   $0xc002f39f
c0028b39:	e8 cf f7 ff ff       	call   c002830d <debug_panic>
        a1b0 = list_next (a1b0);
c0028b3e:	83 ec 0c             	sub    $0xc,%esp
c0028b41:	53                   	push   %ebx
c0028b42:	e8 e0 f8 ff ff       	call   c0028427 <list_next>
c0028b47:	89 c3                	mov    %eax,%ebx
        list_splice (a0, list_prev (a1b0), a1b0);
c0028b49:	89 04 24             	mov    %eax,(%esp)
c0028b4c:	e8 7e f9 ff ff       	call   c00284cf <list_prev>
c0028b51:	83 c4 0c             	add    $0xc,%esp
c0028b54:	53                   	push   %ebx
c0028b55:	50                   	push   %eax
c0028b56:	56                   	push   %esi
c0028b57:	e8 ab fb ff ff       	call   c0028707 <list_splice>
c0028b5c:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c0028b5f:	39 f3                	cmp    %esi,%ebx
c0028b61:	74 25                	je     c0028b88 <list_sort+0x14f>
c0028b63:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
c0028b67:	74 1f                	je     c0028b88 <list_sort+0x14f>
    if (!less (a1b0, a0, aux)) 
c0028b69:	83 ec 04             	sub    $0x4,%esp
c0028b6c:	57                   	push   %edi
c0028b6d:	56                   	push   %esi
c0028b6e:	53                   	push   %ebx
c0028b6f:	ff d5                	call   *%ebp
c0028b71:	83 c4 10             	add    $0x10,%esp
c0028b74:	84 c0                	test   %al,%al
c0028b76:	75 c6                	jne    c0028b3e <list_sort+0x105>
      a0 = list_next (a0);
c0028b78:	83 ec 0c             	sub    $0xc,%esp
c0028b7b:	56                   	push   %esi
c0028b7c:	e8 a6 f8 ff ff       	call   c0028427 <list_next>
c0028b81:	83 c4 10             	add    $0x10,%esp
c0028b84:	89 c6                	mov    %eax,%esi
c0028b86:	eb d7                	jmp    c0028b5f <list_sort+0x126>
{
c0028b88:	8b 74 24 08          	mov    0x8(%esp),%esi
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028b8c:	83 ec 0c             	sub    $0xc,%esp
c0028b8f:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028b93:	e8 d7 f8 ff ff       	call   c002846f <list_end>
c0028b98:	83 c4 10             	add    $0x10,%esp
c0028b9b:	39 c6                	cmp    %eax,%esi
c0028b9d:	0f 84 9b 00 00 00    	je     c0028c3e <list_sort+0x205>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c0028ba3:	ff 44 24 0c          	incl   0xc(%esp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c0028ba7:	83 ec 0c             	sub    $0xc,%esp
c0028baa:	57                   	push   %edi
c0028bab:	89 e9                	mov    %ebp,%ecx
c0028bad:	89 c2                	mov    %eax,%edx
c0028baf:	89 f0                	mov    %esi,%eax
c0028bb1:	e8 5e f9 ff ff       	call   c0028514 <find_end_of_run>
c0028bb6:	89 c3                	mov    %eax,%ebx
          if (a1b0 == list_end (list))
c0028bb8:	83 c4 04             	add    $0x4,%esp
c0028bbb:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028bbf:	e8 ab f8 ff ff       	call   c002846f <list_end>
c0028bc4:	83 c4 10             	add    $0x10,%esp
c0028bc7:	39 c3                	cmp    %eax,%ebx
c0028bc9:	74 73                	je     c0028c3e <list_sort+0x205>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c0028bcb:	83 ec 0c             	sub    $0xc,%esp
c0028bce:	57                   	push   %edi
c0028bcf:	89 e9                	mov    %ebp,%ecx
c0028bd1:	89 c2                	mov    %eax,%edx
c0028bd3:	89 d8                	mov    %ebx,%eax
c0028bd5:	e8 3a f9 ff ff       	call   c0028514 <find_end_of_run>
c0028bda:	89 44 24 18          	mov    %eax,0x18(%esp)
  ASSERT (a0 != NULL);
c0028bde:	83 c4 10             	add    $0x10,%esp
c0028be1:	85 f6                	test   %esi,%esi
c0028be3:	0f 84 b0 fe ff ff    	je     c0028a99 <list_sort+0x60>
  ASSERT (a1b0 != NULL);
c0028be9:	85 db                	test   %ebx,%ebx
c0028beb:	0f 84 c9 fe ff ff    	je     c0028aba <list_sort+0x81>
  ASSERT (b1 != NULL);
c0028bf1:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028bf6:	0f 84 df fe ff ff    	je     c0028adb <list_sort+0xa2>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0028bfc:	57                   	push   %edi
c0028bfd:	55                   	push   %ebp
c0028bfe:	53                   	push   %ebx
c0028bff:	56                   	push   %esi
c0028c00:	e8 df fd ff ff       	call   c00289e4 <is_sorted>
c0028c05:	83 c4 10             	add    $0x10,%esp
c0028c08:	84 c0                	test   %al,%al
c0028c0a:	0f 84 ec fe ff ff    	je     c0028afc <list_sort+0xc3>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0028c10:	57                   	push   %edi
c0028c11:	55                   	push   %ebp
c0028c12:	ff 74 24 10          	pushl  0x10(%esp)
c0028c16:	53                   	push   %ebx
c0028c17:	e8 c8 fd ff ff       	call   c00289e4 <is_sorted>
c0028c1c:	83 c4 10             	add    $0x10,%esp
c0028c1f:	84 c0                	test   %al,%al
c0028c21:	0f 84 f6 fe ff ff    	je     c0028b1d <list_sort+0xe4>
  while (a0 != a1b0 && a1b0 != b1)
c0028c27:	39 de                	cmp    %ebx,%esi
c0028c29:	0f 84 59 ff ff ff    	je     c0028b88 <list_sort+0x14f>
c0028c2f:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0028c33:	0f 85 30 ff ff ff    	jne    c0028b69 <list_sort+0x130>
c0028c39:	e9 4a ff ff ff       	jmp    c0028b88 <list_sort+0x14f>

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c0028c3e:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
c0028c43:	76 1e                	jbe    c0028c63 <list_sort+0x22a>
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028c45:	83 ec 0c             	sub    $0xc,%esp
c0028c48:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028c4c:	e8 a6 f7 ff ff       	call   c00283f7 <list_begin>
c0028c51:	83 c4 10             	add    $0x10,%esp
c0028c54:	89 c6                	mov    %eax,%esi
      output_run_cnt = 0;
c0028c56:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0028c5d:	00 
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028c5e:	e9 29 ff ff ff       	jmp    c0028b8c <list_sort+0x153>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0028c63:	83 ec 0c             	sub    $0xc,%esp
c0028c66:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028c6a:	e8 00 f8 ff ff       	call   c002846f <list_end>
c0028c6f:	83 c4 04             	add    $0x4,%esp
c0028c72:	89 c3                	mov    %eax,%ebx
c0028c74:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028c78:	e8 7a f7 ff ff       	call   c00283f7 <list_begin>
c0028c7d:	83 c4 10             	add    $0x10,%esp
c0028c80:	57                   	push   %edi
c0028c81:	55                   	push   %ebp
c0028c82:	53                   	push   %ebx
c0028c83:	50                   	push   %eax
c0028c84:	e8 5b fd ff ff       	call   c00289e4 <is_sorted>
c0028c89:	83 c4 10             	add    $0x10,%esp
c0028c8c:	84 c0                	test   %al,%al
c0028c8e:	74 08                	je     c0028c98 <list_sort+0x25f>
}
c0028c90:	83 c4 1c             	add    $0x1c,%esp
c0028c93:	5b                   	pop    %ebx
c0028c94:	5e                   	pop    %esi
c0028c95:	5f                   	pop    %edi
c0028c96:	5d                   	pop    %ebp
c0028c97:	c3                   	ret    
  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0028c98:	83 ec 0c             	sub    $0xc,%esp
c0028c9b:	68 10 f5 02 c0       	push   $0xc002f510
c0028ca0:	68 3f d9 02 c0       	push   $0xc002d93f
c0028ca5:	68 70 d4 02 c0       	push   $0xc002d470
c0028caa:	68 b5 01 00 00       	push   $0x1b5
c0028caf:	68 9f f3 02 c0       	push   $0xc002f39f
c0028cb4:	e8 54 f6 ff ff       	call   c002830d <debug_panic>

c0028cb9 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c0028cb9:	55                   	push   %ebp
c0028cba:	57                   	push   %edi
c0028cbb:	56                   	push   %esi
c0028cbc:	53                   	push   %ebx
c0028cbd:	83 ec 0c             	sub    $0xc,%esp
c0028cc0:	8b 74 24 20          	mov    0x20(%esp),%esi
c0028cc4:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028cc8:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *e;

  ASSERT (list != NULL);
c0028ccc:	85 f6                	test   %esi,%esi
c0028cce:	74 50                	je     c0028d20 <list_insert_ordered+0x67>
  ASSERT (elem != NULL);
c0028cd0:	85 ff                	test   %edi,%edi
c0028cd2:	74 6d                	je     c0028d41 <list_insert_ordered+0x88>
  ASSERT (less != NULL);
c0028cd4:	85 ed                	test   %ebp,%ebp
c0028cd6:	0f 84 86 00 00 00    	je     c0028d62 <list_insert_ordered+0xa9>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028cdc:	83 ec 0c             	sub    $0xc,%esp
c0028cdf:	56                   	push   %esi
c0028ce0:	e8 12 f7 ff ff       	call   c00283f7 <list_begin>
c0028ce5:	83 c4 10             	add    $0x10,%esp
c0028ce8:	89 c3                	mov    %eax,%ebx
c0028cea:	83 ec 0c             	sub    $0xc,%esp
c0028ced:	56                   	push   %esi
c0028cee:	e8 7c f7 ff ff       	call   c002846f <list_end>
c0028cf3:	83 c4 10             	add    $0x10,%esp
c0028cf6:	39 c3                	cmp    %eax,%ebx
c0028cf8:	0f 84 85 00 00 00    	je     c0028d83 <list_insert_ordered+0xca>
    if (less (elem, e, aux))
c0028cfe:	83 ec 04             	sub    $0x4,%esp
c0028d01:	ff 74 24 30          	pushl  0x30(%esp)
c0028d05:	53                   	push   %ebx
c0028d06:	57                   	push   %edi
c0028d07:	ff d5                	call   *%ebp
c0028d09:	83 c4 10             	add    $0x10,%esp
c0028d0c:	84 c0                	test   %al,%al
c0028d0e:	75 73                	jne    c0028d83 <list_insert_ordered+0xca>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028d10:	83 ec 0c             	sub    $0xc,%esp
c0028d13:	53                   	push   %ebx
c0028d14:	e8 0e f7 ff ff       	call   c0028427 <list_next>
c0028d19:	83 c4 10             	add    $0x10,%esp
c0028d1c:	89 c3                	mov    %eax,%ebx
c0028d1e:	eb ca                	jmp    c0028cea <list_insert_ordered+0x31>
  ASSERT (list != NULL);
c0028d20:	83 ec 0c             	sub    $0xc,%esp
c0028d23:	68 92 f3 02 c0       	push   $0xc002f392
c0028d28:	68 3f d9 02 c0       	push   $0xc002d93f
c0028d2d:	68 3c d4 02 c0       	push   $0xc002d43c
c0028d32:	68 c1 01 00 00       	push   $0x1c1
c0028d37:	68 9f f3 02 c0       	push   $0xc002f39f
c0028d3c:	e8 cc f5 ff ff       	call   c002830d <debug_panic>
  ASSERT (elem != NULL);
c0028d41:	83 ec 0c             	sub    $0xc,%esp
c0028d44:	68 d5 f3 02 c0       	push   $0xc002f3d5
c0028d49:	68 3f d9 02 c0       	push   $0xc002d93f
c0028d4e:	68 3c d4 02 c0       	push   $0xc002d43c
c0028d53:	68 c2 01 00 00       	push   $0x1c2
c0028d58:	68 9f f3 02 c0       	push   $0xc002f39f
c0028d5d:	e8 ab f5 ff ff       	call   c002830d <debug_panic>
  ASSERT (less != NULL);
c0028d62:	83 ec 0c             	sub    $0xc,%esp
c0028d65:	68 c1 f3 02 c0       	push   $0xc002f3c1
c0028d6a:	68 3f d9 02 c0       	push   $0xc002d93f
c0028d6f:	68 3c d4 02 c0       	push   $0xc002d43c
c0028d74:	68 c3 01 00 00       	push   $0x1c3
c0028d79:	68 9f f3 02 c0       	push   $0xc002f39f
c0028d7e:	e8 8a f5 ff ff       	call   c002830d <debug_panic>
      break;
  return list_insert (e, elem);
c0028d83:	83 ec 08             	sub    $0x8,%esp
c0028d86:	57                   	push   %edi
c0028d87:	53                   	push   %ebx
c0028d88:	e8 fd f8 ff ff       	call   c002868a <list_insert>
}
c0028d8d:	83 c4 1c             	add    $0x1c,%esp
c0028d90:	5b                   	pop    %ebx
c0028d91:	5e                   	pop    %esi
c0028d92:	5f                   	pop    %edi
c0028d93:	5d                   	pop    %ebp
c0028d94:	c3                   	ret    

c0028d95 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c0028d95:	55                   	push   %ebp
c0028d96:	57                   	push   %edi
c0028d97:	56                   	push   %esi
c0028d98:	53                   	push   %ebx
c0028d99:	83 ec 0c             	sub    $0xc,%esp
c0028d9c:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0028da0:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c0028da4:	85 ff                	test   %edi,%edi
c0028da6:	74 1c                	je     c0028dc4 <list_unique+0x2f>
  ASSERT (less != NULL);
c0028da8:	85 ed                	test   %ebp,%ebp
c0028daa:	74 39                	je     c0028de5 <list_unique+0x50>
  if (list_empty (list))
c0028dac:	83 ec 0c             	sub    $0xc,%esp
c0028daf:	57                   	push   %edi
c0028db0:	e8 f3 fa ff ff       	call   c00288a8 <list_empty>
c0028db5:	83 c4 10             	add    $0x10,%esp
c0028db8:	84 c0                	test   %al,%al
c0028dba:	74 4a                	je     c0028e06 <list_unique+0x71>
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c0028dbc:	83 c4 0c             	add    $0xc,%esp
c0028dbf:	5b                   	pop    %ebx
c0028dc0:	5e                   	pop    %esi
c0028dc1:	5f                   	pop    %edi
c0028dc2:	5d                   	pop    %ebp
c0028dc3:	c3                   	ret    
  ASSERT (list != NULL);
c0028dc4:	83 ec 0c             	sub    $0xc,%esp
c0028dc7:	68 92 f3 02 c0       	push   $0xc002f392
c0028dcc:	68 3f d9 02 c0       	push   $0xc002d93f
c0028dd1:	68 30 d4 02 c0       	push   $0xc002d430
c0028dd6:	68 d5 01 00 00       	push   $0x1d5
c0028ddb:	68 9f f3 02 c0       	push   $0xc002f39f
c0028de0:	e8 28 f5 ff ff       	call   c002830d <debug_panic>
  ASSERT (less != NULL);
c0028de5:	83 ec 0c             	sub    $0xc,%esp
c0028de8:	68 c1 f3 02 c0       	push   $0xc002f3c1
c0028ded:	68 3f d9 02 c0       	push   $0xc002d93f
c0028df2:	68 30 d4 02 c0       	push   $0xc002d430
c0028df7:	68 d6 01 00 00       	push   $0x1d6
c0028dfc:	68 9f f3 02 c0       	push   $0xc002f39f
c0028e01:	e8 07 f5 ff ff       	call   c002830d <debug_panic>
  elem = list_begin (list);
c0028e06:	83 ec 0c             	sub    $0xc,%esp
c0028e09:	57                   	push   %edi
c0028e0a:	e8 e8 f5 ff ff       	call   c00283f7 <list_begin>
c0028e0f:	83 c4 10             	add    $0x10,%esp
c0028e12:	89 c6                	mov    %eax,%esi
  while ((next = list_next (elem)) != list_end (list))
c0028e14:	eb 04                	jmp    c0028e1a <list_unique+0x85>
c0028e16:	89 f3                	mov    %esi,%ebx
c0028e18:	89 de                	mov    %ebx,%esi
c0028e1a:	83 ec 0c             	sub    $0xc,%esp
c0028e1d:	56                   	push   %esi
c0028e1e:	e8 04 f6 ff ff       	call   c0028427 <list_next>
c0028e23:	89 c3                	mov    %eax,%ebx
c0028e25:	89 3c 24             	mov    %edi,(%esp)
c0028e28:	e8 42 f6 ff ff       	call   c002846f <list_end>
c0028e2d:	83 c4 10             	add    $0x10,%esp
c0028e30:	39 c3                	cmp    %eax,%ebx
c0028e32:	74 88                	je     c0028dbc <list_unique+0x27>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c0028e34:	83 ec 04             	sub    $0x4,%esp
c0028e37:	ff 74 24 30          	pushl  0x30(%esp)
c0028e3b:	53                   	push   %ebx
c0028e3c:	56                   	push   %esi
c0028e3d:	ff d5                	call   *%ebp
c0028e3f:	83 c4 10             	add    $0x10,%esp
c0028e42:	84 c0                	test   %al,%al
c0028e44:	75 d2                	jne    c0028e18 <list_unique+0x83>
c0028e46:	83 ec 04             	sub    $0x4,%esp
c0028e49:	ff 74 24 30          	pushl  0x30(%esp)
c0028e4d:	56                   	push   %esi
c0028e4e:	53                   	push   %ebx
c0028e4f:	ff d5                	call   *%ebp
c0028e51:	83 c4 10             	add    $0x10,%esp
c0028e54:	84 c0                	test   %al,%al
c0028e56:	75 c0                	jne    c0028e18 <list_unique+0x83>
        list_remove (next);
c0028e58:	83 ec 0c             	sub    $0xc,%esp
c0028e5b:	53                   	push   %ebx
c0028e5c:	e8 bc f9 ff ff       	call   c002881d <list_remove>
        if (duplicates != NULL)
c0028e61:	83 c4 10             	add    $0x10,%esp
c0028e64:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0028e69:	74 ab                	je     c0028e16 <list_unique+0x81>
          list_push_back (duplicates, next);
c0028e6b:	83 ec 08             	sub    $0x8,%esp
c0028e6e:	53                   	push   %ebx
c0028e6f:	ff 74 24 30          	pushl  0x30(%esp)
c0028e73:	e8 88 f9 ff ff       	call   c0028800 <list_push_back>
c0028e78:	83 c4 10             	add    $0x10,%esp
c0028e7b:	89 f3                	mov    %esi,%ebx
c0028e7d:	eb 99                	jmp    c0028e18 <list_unique+0x83>

c0028e7f <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c0028e7f:	55                   	push   %ebp
c0028e80:	57                   	push   %edi
c0028e81:	56                   	push   %esi
c0028e82:	53                   	push   %ebx
c0028e83:	83 ec 18             	sub    $0x18,%esp
c0028e86:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0028e8a:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *max = list_begin (list);
c0028e8e:	57                   	push   %edi
c0028e8f:	e8 63 f5 ff ff       	call   c00283f7 <list_begin>
c0028e94:	89 c6                	mov    %eax,%esi
  if (max != list_end (list)) 
c0028e96:	89 3c 24             	mov    %edi,(%esp)
c0028e99:	e8 d1 f5 ff ff       	call   c002846f <list_end>
c0028e9e:	83 c4 10             	add    $0x10,%esp
c0028ea1:	39 c6                	cmp    %eax,%esi
c0028ea3:	74 43                	je     c0028ee8 <list_max+0x69>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c0028ea5:	83 ec 0c             	sub    $0xc,%esp
c0028ea8:	56                   	push   %esi
c0028ea9:	e8 79 f5 ff ff       	call   c0028427 <list_next>
c0028eae:	83 c4 10             	add    $0x10,%esp
c0028eb1:	89 c3                	mov    %eax,%ebx
c0028eb3:	eb 0e                	jmp    c0028ec3 <list_max+0x44>
c0028eb5:	83 ec 0c             	sub    $0xc,%esp
c0028eb8:	53                   	push   %ebx
c0028eb9:	e8 69 f5 ff ff       	call   c0028427 <list_next>
c0028ebe:	83 c4 10             	add    $0x10,%esp
c0028ec1:	89 c3                	mov    %eax,%ebx
c0028ec3:	83 ec 0c             	sub    $0xc,%esp
c0028ec6:	57                   	push   %edi
c0028ec7:	e8 a3 f5 ff ff       	call   c002846f <list_end>
c0028ecc:	83 c4 10             	add    $0x10,%esp
c0028ecf:	39 c3                	cmp    %eax,%ebx
c0028ed1:	74 17                	je     c0028eea <list_max+0x6b>
        if (less (max, e, aux))
c0028ed3:	83 ec 04             	sub    $0x4,%esp
c0028ed6:	55                   	push   %ebp
c0028ed7:	53                   	push   %ebx
c0028ed8:	56                   	push   %esi
c0028ed9:	ff 54 24 34          	call   *0x34(%esp)
c0028edd:	83 c4 10             	add    $0x10,%esp
c0028ee0:	84 c0                	test   %al,%al
c0028ee2:	74 d1                	je     c0028eb5 <list_max+0x36>
          max = e; 
c0028ee4:	89 de                	mov    %ebx,%esi
c0028ee6:	eb cd                	jmp    c0028eb5 <list_max+0x36>
  struct list_elem *max = list_begin (list);
c0028ee8:	89 c6                	mov    %eax,%esi
    }
  return max;
}
c0028eea:	89 f0                	mov    %esi,%eax
c0028eec:	83 c4 0c             	add    $0xc,%esp
c0028eef:	5b                   	pop    %ebx
c0028ef0:	5e                   	pop    %esi
c0028ef1:	5f                   	pop    %edi
c0028ef2:	5d                   	pop    %ebp
c0028ef3:	c3                   	ret    

c0028ef4 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c0028ef4:	55                   	push   %ebp
c0028ef5:	57                   	push   %edi
c0028ef6:	56                   	push   %esi
c0028ef7:	53                   	push   %ebx
c0028ef8:	83 ec 18             	sub    $0x18,%esp
c0028efb:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0028eff:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *min = list_begin (list);
c0028f03:	57                   	push   %edi
c0028f04:	e8 ee f4 ff ff       	call   c00283f7 <list_begin>
c0028f09:	89 c6                	mov    %eax,%esi
  if (min != list_end (list)) 
c0028f0b:	89 3c 24             	mov    %edi,(%esp)
c0028f0e:	e8 5c f5 ff ff       	call   c002846f <list_end>
c0028f13:	83 c4 10             	add    $0x10,%esp
c0028f16:	39 c6                	cmp    %eax,%esi
c0028f18:	74 43                	je     c0028f5d <list_min+0x69>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c0028f1a:	83 ec 0c             	sub    $0xc,%esp
c0028f1d:	56                   	push   %esi
c0028f1e:	e8 04 f5 ff ff       	call   c0028427 <list_next>
c0028f23:	83 c4 10             	add    $0x10,%esp
c0028f26:	89 c3                	mov    %eax,%ebx
c0028f28:	eb 0e                	jmp    c0028f38 <list_min+0x44>
c0028f2a:	83 ec 0c             	sub    $0xc,%esp
c0028f2d:	53                   	push   %ebx
c0028f2e:	e8 f4 f4 ff ff       	call   c0028427 <list_next>
c0028f33:	83 c4 10             	add    $0x10,%esp
c0028f36:	89 c3                	mov    %eax,%ebx
c0028f38:	83 ec 0c             	sub    $0xc,%esp
c0028f3b:	57                   	push   %edi
c0028f3c:	e8 2e f5 ff ff       	call   c002846f <list_end>
c0028f41:	83 c4 10             	add    $0x10,%esp
c0028f44:	39 c3                	cmp    %eax,%ebx
c0028f46:	74 17                	je     c0028f5f <list_min+0x6b>
        if (less (e, min, aux))
c0028f48:	83 ec 04             	sub    $0x4,%esp
c0028f4b:	55                   	push   %ebp
c0028f4c:	56                   	push   %esi
c0028f4d:	53                   	push   %ebx
c0028f4e:	ff 54 24 34          	call   *0x34(%esp)
c0028f52:	83 c4 10             	add    $0x10,%esp
c0028f55:	84 c0                	test   %al,%al
c0028f57:	74 d1                	je     c0028f2a <list_min+0x36>
          min = e; 
c0028f59:	89 de                	mov    %ebx,%esi
c0028f5b:	eb cd                	jmp    c0028f2a <list_min+0x36>
  struct list_elem *min = list_begin (list);
c0028f5d:	89 c6                	mov    %eax,%esi
    }
  return min;
}
c0028f5f:	89 f0                	mov    %esi,%eax
c0028f61:	83 c4 0c             	add    $0xc,%esp
c0028f64:	5b                   	pop    %ebx
c0028f65:	5e                   	pop    %esi
c0028f66:	5f                   	pop    %edi
c0028f67:	5d                   	pop    %ebp
c0028f68:	c3                   	ret    

c0028f69 <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0028f69:	8b 44 24 04          	mov    0x4(%esp),%eax
c0028f6d:	83 c0 1f             	add    $0x1f,%eax
c0028f70:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c0028f73:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c0028f7a:	c3                   	ret    

c0028f7b <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c0028f7b:	53                   	push   %ebx
c0028f7c:	83 ec 08             	sub    $0x8,%esp
c0028f7f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (b != NULL) 
c0028f83:	85 db                	test   %ebx,%ebx
c0028f85:	74 16                	je     c0028f9d <bitmap_destroy+0x22>
    {
      free (b->bits);
c0028f87:	83 ec 0c             	sub    $0xc,%esp
c0028f8a:	ff 73 04             	pushl  0x4(%ebx)
c0028f8d:	e8 d4 a8 ff ff       	call   c0023866 <free>
      free (b);
c0028f92:	89 1c 24             	mov    %ebx,(%esp)
c0028f95:	e8 cc a8 ff ff       	call   c0023866 <free>
c0028f9a:	83 c4 10             	add    $0x10,%esp
    }
}
c0028f9d:	83 c4 08             	add    $0x8,%esp
c0028fa0:	5b                   	pop    %ebx
c0028fa1:	c3                   	ret    

c0028fa2 <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c0028fa2:	8b 44 24 04          	mov    0x4(%esp),%eax
c0028fa6:	8b 00                	mov    (%eax),%eax
}
c0028fa8:	c3                   	ret    

c0028fa9 <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c0028fa9:	53                   	push   %ebx
c0028faa:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0028fae:	89 cb                	mov    %ecx,%ebx
c0028fb0:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0028fb3:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028fb7:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0028fba:	b8 01 00 00 00       	mov    $0x1,%eax
c0028fbf:	d3 e0                	shl    %cl,%eax
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0028fc1:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c0028fc4:	5b                   	pop    %ebx
c0028fc5:	c3                   	ret    

c0028fc6 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c0028fc6:	53                   	push   %ebx
c0028fc7:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0028fcb:	89 cb                	mov    %ecx,%ebx
c0028fcd:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0028fd0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028fd4:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0028fd7:	b8 01 00 00 00       	mov    $0x1,%eax
c0028fdc:	d3 e0                	shl    %cl,%eax
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0028fde:	f7 d0                	not    %eax
c0028fe0:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c0028fe3:	5b                   	pop    %ebx
c0028fe4:	c3                   	ret    

c0028fe5 <bitmap_set>:
{
c0028fe5:	83 ec 0c             	sub    $0xc,%esp
c0028fe8:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028fec:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028ff0:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c0028ff4:	85 c0                	test   %eax,%eax
c0028ff6:	74 19                	je     c0029011 <bitmap_set+0x2c>
  ASSERT (idx < b->bit_cnt);
c0028ff8:	39 10                	cmp    %edx,(%eax)
c0028ffa:	76 36                	jbe    c0029032 <bitmap_set+0x4d>
  if (value)
c0028ffc:	84 c9                	test   %cl,%cl
c0028ffe:	75 53                	jne    c0029053 <bitmap_set+0x6e>
    bitmap_reset (b, idx);
c0029000:	83 ec 08             	sub    $0x8,%esp
c0029003:	52                   	push   %edx
c0029004:	50                   	push   %eax
c0029005:	e8 bc ff ff ff       	call   c0028fc6 <bitmap_reset>
c002900a:	83 c4 10             	add    $0x10,%esp
}
c002900d:	83 c4 0c             	add    $0xc,%esp
c0029010:	c3                   	ret    
  ASSERT (b != NULL);
c0029011:	83 ec 0c             	sub    $0xc,%esp
c0029014:	68 b7 f3 02 c0       	push   $0xc002f3b7
c0029019:	68 3f d9 02 c0       	push   $0xc002d93f
c002901e:	68 80 d5 02 c0       	push   $0xc002d580
c0029023:	68 93 00 00 00       	push   $0x93
c0029028:	68 4a f5 02 c0       	push   $0xc002f54a
c002902d:	e8 db f2 ff ff       	call   c002830d <debug_panic>
  ASSERT (idx < b->bit_cnt);
c0029032:	83 ec 0c             	sub    $0xc,%esp
c0029035:	68 64 f5 02 c0       	push   $0xc002f564
c002903a:	68 3f d9 02 c0       	push   $0xc002d93f
c002903f:	68 80 d5 02 c0       	push   $0xc002d580
c0029044:	68 94 00 00 00       	push   $0x94
c0029049:	68 4a f5 02 c0       	push   $0xc002f54a
c002904e:	e8 ba f2 ff ff       	call   c002830d <debug_panic>
    bitmap_mark (b, idx);
c0029053:	83 ec 08             	sub    $0x8,%esp
c0029056:	52                   	push   %edx
c0029057:	50                   	push   %eax
c0029058:	e8 4c ff ff ff       	call   c0028fa9 <bitmap_mark>
c002905d:	83 c4 10             	add    $0x10,%esp
c0029060:	eb ab                	jmp    c002900d <bitmap_set+0x28>

c0029062 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c0029062:	53                   	push   %ebx
c0029063:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029067:	89 cb                	mov    %ecx,%ebx
c0029069:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002906c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029070:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029073:	b8 01 00 00 00       	mov    $0x1,%eax
c0029078:	d3 e0                	shl    %cl,%eax
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002907a:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c002907d:	5b                   	pop    %ebx
c002907e:	c3                   	ret    

c002907f <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002907f:	53                   	push   %ebx
c0029080:	83 ec 08             	sub    $0x8,%esp
c0029083:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029087:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c002908b:	85 c0                	test   %eax,%eax
c002908d:	74 1e                	je     c00290ad <bitmap_test+0x2e>
  ASSERT (idx < b->bit_cnt);
c002908f:	39 08                	cmp    %ecx,(%eax)
c0029091:	76 3b                	jbe    c00290ce <bitmap_test+0x4f>
  return bit_idx / ELEM_BITS;
c0029093:	89 cb                	mov    %ecx,%ebx
c0029095:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c0029098:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002909b:	b8 01 00 00 00       	mov    $0x1,%eax
c00290a0:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c00290a2:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c00290a5:	0f 95 c0             	setne  %al
}
c00290a8:	83 c4 08             	add    $0x8,%esp
c00290ab:	5b                   	pop    %ebx
c00290ac:	c3                   	ret    
  ASSERT (b != NULL);
c00290ad:	83 ec 0c             	sub    $0xc,%esp
c00290b0:	68 b7 f3 02 c0       	push   $0xc002f3b7
c00290b5:	68 3f d9 02 c0       	push   $0xc002d93f
c00290ba:	68 74 d5 02 c0       	push   $0xc002d574
c00290bf:	68 c8 00 00 00       	push   $0xc8
c00290c4:	68 4a f5 02 c0       	push   $0xc002f54a
c00290c9:	e8 3f f2 ff ff       	call   c002830d <debug_panic>
  ASSERT (idx < b->bit_cnt);
c00290ce:	83 ec 0c             	sub    $0xc,%esp
c00290d1:	68 64 f5 02 c0       	push   $0xc002f564
c00290d6:	68 3f d9 02 c0       	push   $0xc002d93f
c00290db:	68 74 d5 02 c0       	push   $0xc002d574
c00290e0:	68 c9 00 00 00       	push   $0xc9
c00290e5:	68 4a f5 02 c0       	push   $0xc002f54a
c00290ea:	e8 1e f2 ff ff       	call   c002830d <debug_panic>

c00290ef <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c00290ef:	55                   	push   %ebp
c00290f0:	57                   	push   %edi
c00290f1:	56                   	push   %esi
c00290f2:	53                   	push   %ebx
c00290f3:	83 ec 0c             	sub    $0xc,%esp
c00290f6:	8b 74 24 20          	mov    0x20(%esp),%esi
c00290fa:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c00290fe:	8b 54 24 28          	mov    0x28(%esp),%edx
c0029102:	8a 44 24 2c          	mov    0x2c(%esp),%al
  size_t i;
  
  ASSERT (b != NULL);
c0029106:	85 f6                	test   %esi,%esi
c0029108:	74 2f                	je     c0029139 <bitmap_set_multiple+0x4a>
  ASSERT (start <= b->bit_cnt);
c002910a:	8b 0e                	mov    (%esi),%ecx
c002910c:	39 d9                	cmp    %ebx,%ecx
c002910e:	72 4a                	jb     c002915a <bitmap_set_multiple+0x6b>
  ASSERT (start + cnt <= b->bit_cnt);
c0029110:	8d 2c 13             	lea    (%ebx,%edx,1),%ebp
c0029113:	39 e9                	cmp    %ebp,%ecx
c0029115:	72 64                	jb     c002917b <bitmap_set_multiple+0x8c>

  for (i = 0; i < cnt; i++)
c0029117:	85 d2                	test   %edx,%edx
c0029119:	74 16                	je     c0029131 <bitmap_set_multiple+0x42>
    bitmap_set (b, start + i, value);
c002911b:	0f b6 f8             	movzbl %al,%edi
c002911e:	83 ec 04             	sub    $0x4,%esp
c0029121:	57                   	push   %edi
c0029122:	53                   	push   %ebx
c0029123:	56                   	push   %esi
c0029124:	e8 bc fe ff ff       	call   c0028fe5 <bitmap_set>
c0029129:	43                   	inc    %ebx
  for (i = 0; i < cnt; i++)
c002912a:	83 c4 10             	add    $0x10,%esp
c002912d:	39 dd                	cmp    %ebx,%ebp
c002912f:	75 ed                	jne    c002911e <bitmap_set_multiple+0x2f>
}
c0029131:	83 c4 0c             	add    $0xc,%esp
c0029134:	5b                   	pop    %ebx
c0029135:	5e                   	pop    %esi
c0029136:	5f                   	pop    %edi
c0029137:	5d                   	pop    %ebp
c0029138:	c3                   	ret    
  ASSERT (b != NULL);
c0029139:	83 ec 0c             	sub    $0xc,%esp
c002913c:	68 b7 f3 02 c0       	push   $0xc002f3b7
c0029141:	68 3f d9 02 c0       	push   $0xc002d93f
c0029146:	68 50 d5 02 c0       	push   $0xc002d550
c002914b:	68 de 00 00 00       	push   $0xde
c0029150:	68 4a f5 02 c0       	push   $0xc002f54a
c0029155:	e8 b3 f1 ff ff       	call   c002830d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002915a:	83 ec 0c             	sub    $0xc,%esp
c002915d:	68 75 f5 02 c0       	push   $0xc002f575
c0029162:	68 3f d9 02 c0       	push   $0xc002d93f
c0029167:	68 50 d5 02 c0       	push   $0xc002d550
c002916c:	68 df 00 00 00       	push   $0xdf
c0029171:	68 4a f5 02 c0       	push   $0xc002f54a
c0029176:	e8 92 f1 ff ff       	call   c002830d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002917b:	83 ec 0c             	sub    $0xc,%esp
c002917e:	68 89 f5 02 c0       	push   $0xc002f589
c0029183:	68 3f d9 02 c0       	push   $0xc002d93f
c0029188:	68 50 d5 02 c0       	push   $0xc002d550
c002918d:	68 e0 00 00 00       	push   $0xe0
c0029192:	68 4a f5 02 c0       	push   $0xc002f54a
c0029197:	e8 71 f1 ff ff       	call   c002830d <debug_panic>

c002919c <bitmap_set_all>:
{
c002919c:	83 ec 0c             	sub    $0xc,%esp
c002919f:	8b 44 24 10          	mov    0x10(%esp),%eax
c00291a3:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c00291a7:	85 c0                	test   %eax,%eax
c00291a9:	74 12                	je     c00291bd <bitmap_set_all+0x21>
  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c00291ab:	0f b6 d2             	movzbl %dl,%edx
c00291ae:	52                   	push   %edx
c00291af:	ff 30                	pushl  (%eax)
c00291b1:	6a 00                	push   $0x0
c00291b3:	50                   	push   %eax
c00291b4:	e8 36 ff ff ff       	call   c00290ef <bitmap_set_multiple>
}
c00291b9:	83 c4 1c             	add    $0x1c,%esp
c00291bc:	c3                   	ret    
  ASSERT (b != NULL);
c00291bd:	83 ec 0c             	sub    $0xc,%esp
c00291c0:	68 b7 f3 02 c0       	push   $0xc002f3b7
c00291c5:	68 3f d9 02 c0       	push   $0xc002d93f
c00291ca:	68 64 d5 02 c0       	push   $0xc002d564
c00291cf:	68 d3 00 00 00       	push   $0xd3
c00291d4:	68 4a f5 02 c0       	push   $0xc002f54a
c00291d9:	e8 2f f1 ff ff       	call   c002830d <debug_panic>

c00291de <bitmap_create>:
{
c00291de:	56                   	push   %esi
c00291df:	53                   	push   %ebx
c00291e0:	83 ec 10             	sub    $0x10,%esp
c00291e3:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct bitmap *b = malloc (sizeof *b);
c00291e7:	6a 08                	push   $0x8
c00291e9:	e8 d5 a4 ff ff       	call   c00236c3 <malloc>
c00291ee:	89 c3                	mov    %eax,%ebx
  if (b != NULL)
c00291f0:	83 c4 10             	add    $0x10,%esp
c00291f3:	85 c0                	test   %eax,%eax
c00291f5:	74 2c                	je     c0029223 <bitmap_create+0x45>
      b->bit_cnt = bit_cnt;
c00291f7:	89 30                	mov    %esi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c00291f9:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c00291fc:	8d 46 1f             	lea    0x1f(%esi),%eax
c00291ff:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c0029202:	c1 e0 02             	shl    $0x2,%eax
      b->bits = malloc (byte_cnt (bit_cnt));
c0029205:	50                   	push   %eax
c0029206:	e8 b8 a4 ff ff       	call   c00236c3 <malloc>
c002920b:	89 43 04             	mov    %eax,0x4(%ebx)
      if (b->bits != NULL || bit_cnt == 0)
c002920e:	83 c4 10             	add    $0x10,%esp
c0029211:	85 c0                	test   %eax,%eax
c0029213:	74 16                	je     c002922b <bitmap_create+0x4d>
          bitmap_set_all (b, false);
c0029215:	83 ec 08             	sub    $0x8,%esp
c0029218:	6a 00                	push   $0x0
c002921a:	53                   	push   %ebx
c002921b:	e8 7c ff ff ff       	call   c002919c <bitmap_set_all>
          return b;
c0029220:	83 c4 10             	add    $0x10,%esp
}
c0029223:	89 d8                	mov    %ebx,%eax
c0029225:	83 c4 04             	add    $0x4,%esp
c0029228:	5b                   	pop    %ebx
c0029229:	5e                   	pop    %esi
c002922a:	c3                   	ret    
      if (b->bits != NULL || bit_cnt == 0)
c002922b:	85 f6                	test   %esi,%esi
c002922d:	74 e6                	je     c0029215 <bitmap_create+0x37>
      free (b);
c002922f:	83 ec 0c             	sub    $0xc,%esp
c0029232:	53                   	push   %ebx
c0029233:	e8 2e a6 ff ff       	call   c0023866 <free>
c0029238:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002923b:	bb 00 00 00 00       	mov    $0x0,%ebx
c0029240:	eb e1                	jmp    c0029223 <bitmap_create+0x45>

c0029242 <bitmap_create_in_buf>:
{
c0029242:	56                   	push   %esi
c0029243:	53                   	push   %ebx
c0029244:	83 ec 04             	sub    $0x4,%esp
c0029247:	8b 74 24 10          	mov    0x10(%esp),%esi
c002924b:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002924f:	56                   	push   %esi
c0029250:	e8 14 fd ff ff       	call   c0028f69 <bitmap_buf_size>
c0029255:	83 c4 04             	add    $0x4,%esp
c0029258:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002925c:	77 1b                	ja     c0029279 <bitmap_create_in_buf+0x37>
  b->bit_cnt = bit_cnt;
c002925e:	89 33                	mov    %esi,(%ebx)
  b->bits = (elem_type *) (b + 1);
c0029260:	8d 43 08             	lea    0x8(%ebx),%eax
c0029263:	89 43 04             	mov    %eax,0x4(%ebx)
  bitmap_set_all (b, false);
c0029266:	83 ec 08             	sub    $0x8,%esp
c0029269:	6a 00                	push   $0x0
c002926b:	53                   	push   %ebx
c002926c:	e8 2b ff ff ff       	call   c002919c <bitmap_set_all>
}
c0029271:	89 d8                	mov    %ebx,%eax
c0029273:	83 c4 14             	add    $0x14,%esp
c0029276:	5b                   	pop    %ebx
c0029277:	5e                   	pop    %esi
c0029278:	c3                   	ret    
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c0029279:	83 ec 0c             	sub    $0xc,%esp
c002927c:	68 a4 f5 02 c0       	push   $0xc002f5a4
c0029281:	68 3f d9 02 c0       	push   $0xc002d93f
c0029286:	68 8c d5 02 c0       	push   $0xc002d58c
c002928b:	6a 68                	push   $0x68
c002928d:	68 4a f5 02 c0       	push   $0xc002f54a
c0029292:	e8 76 f0 ff ff       	call   c002830d <debug_panic>

c0029297 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0029297:	55                   	push   %ebp
c0029298:	57                   	push   %edi
c0029299:	56                   	push   %esi
c002929a:	53                   	push   %ebx
c002929b:	83 ec 1c             	sub    $0x1c,%esp
c002929e:	8b 7c 24 30          	mov    0x30(%esp),%edi
c00292a2:	8b 74 24 34          	mov    0x34(%esp),%esi
c00292a6:	8b 44 24 38          	mov    0x38(%esp),%eax
c00292aa:	8a 5c 24 3c          	mov    0x3c(%esp),%bl
  size_t i, value_cnt;

  ASSERT (b != NULL);
c00292ae:	85 ff                	test   %edi,%edi
c00292b0:	74 29                	je     c00292db <bitmap_count+0x44>
  ASSERT (start <= b->bit_cnt);
c00292b2:	8b 17                	mov    (%edi),%edx
c00292b4:	39 f2                	cmp    %esi,%edx
c00292b6:	72 44                	jb     c00292fc <bitmap_count+0x65>
  ASSERT (start + cnt <= b->bit_cnt);
c00292b8:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c00292bb:	39 ea                	cmp    %ebp,%edx
c00292bd:	72 5e                	jb     c002931d <bitmap_count+0x86>

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
c00292bf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c00292c6:	00 
c00292c7:	85 c0                	test   %eax,%eax
c00292c9:	75 78                	jne    c0029343 <bitmap_count+0xac>
c00292cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (bitmap_test (b, start + i) == value)
      value_cnt++;
  return value_cnt;
}
c00292cf:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00292d3:	83 c4 1c             	add    $0x1c,%esp
c00292d6:	5b                   	pop    %ebx
c00292d7:	5e                   	pop    %esi
c00292d8:	5f                   	pop    %edi
c00292d9:	5d                   	pop    %ebp
c00292da:	c3                   	ret    
  ASSERT (b != NULL);
c00292db:	83 ec 0c             	sub    $0xc,%esp
c00292de:	68 b7 f3 02 c0       	push   $0xc002f3b7
c00292e3:	68 3f d9 02 c0       	push   $0xc002d93f
c00292e8:	68 40 d5 02 c0       	push   $0xc002d540
c00292ed:	68 ed 00 00 00       	push   $0xed
c00292f2:	68 4a f5 02 c0       	push   $0xc002f54a
c00292f7:	e8 11 f0 ff ff       	call   c002830d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c00292fc:	83 ec 0c             	sub    $0xc,%esp
c00292ff:	68 75 f5 02 c0       	push   $0xc002f575
c0029304:	68 3f d9 02 c0       	push   $0xc002d93f
c0029309:	68 40 d5 02 c0       	push   $0xc002d540
c002930e:	68 ee 00 00 00       	push   $0xee
c0029313:	68 4a f5 02 c0       	push   $0xc002f54a
c0029318:	e8 f0 ef ff ff       	call   c002830d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002931d:	83 ec 0c             	sub    $0xc,%esp
c0029320:	68 89 f5 02 c0       	push   $0xc002f589
c0029325:	68 3f d9 02 c0       	push   $0xc002d93f
c002932a:	68 40 d5 02 c0       	push   $0xc002d540
c002932f:	68 ef 00 00 00       	push   $0xef
c0029334:	68 4a f5 02 c0       	push   $0xc002f54a
c0029339:	e8 cf ef ff ff       	call   c002830d <debug_panic>
c002933e:	46                   	inc    %esi
  for (i = 0; i < cnt; i++)
c002933f:	39 f5                	cmp    %esi,%ebp
c0029341:	74 8c                	je     c00292cf <bitmap_count+0x38>
    if (bitmap_test (b, start + i) == value)
c0029343:	83 ec 08             	sub    $0x8,%esp
c0029346:	56                   	push   %esi
c0029347:	57                   	push   %edi
c0029348:	e8 32 fd ff ff       	call   c002907f <bitmap_test>
c002934d:	83 c4 10             	add    $0x10,%esp
c0029350:	38 d8                	cmp    %bl,%al
c0029352:	75 ea                	jne    c002933e <bitmap_count+0xa7>
      value_cnt++;
c0029354:	ff 44 24 0c          	incl   0xc(%esp)
c0029358:	eb e4                	jmp    c002933e <bitmap_count+0xa7>

c002935a <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002935a:	55                   	push   %ebp
c002935b:	57                   	push   %edi
c002935c:	56                   	push   %esi
c002935d:	53                   	push   %ebx
c002935e:	83 ec 0c             	sub    $0xc,%esp
c0029361:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0029365:	8b 74 24 24          	mov    0x24(%esp),%esi
c0029369:	8b 44 24 28          	mov    0x28(%esp),%eax
c002936d:	8a 5c 24 2c          	mov    0x2c(%esp),%bl
  size_t i;
  
  ASSERT (b != NULL);
c0029371:	85 ff                	test   %edi,%edi
c0029373:	74 2b                	je     c00293a0 <bitmap_contains+0x46>
  ASSERT (start <= b->bit_cnt);
c0029375:	8b 17                	mov    (%edi),%edx
c0029377:	39 f2                	cmp    %esi,%edx
c0029379:	72 46                	jb     c00293c1 <bitmap_contains+0x67>
  ASSERT (start + cnt <= b->bit_cnt);
c002937b:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002937e:	39 ea                	cmp    %ebp,%edx
c0029380:	72 60                	jb     c00293e2 <bitmap_contains+0x88>

  for (i = 0; i < cnt; i++)
c0029382:	85 c0                	test   %eax,%eax
c0029384:	74 7f                	je     c0029405 <bitmap_contains+0xab>
    if (bitmap_test (b, start + i) == value)
c0029386:	83 ec 08             	sub    $0x8,%esp
c0029389:	56                   	push   %esi
c002938a:	57                   	push   %edi
c002938b:	e8 ef fc ff ff       	call   c002907f <bitmap_test>
c0029390:	83 c4 10             	add    $0x10,%esp
c0029393:	38 d8                	cmp    %bl,%al
c0029395:	74 6c                	je     c0029403 <bitmap_contains+0xa9>
c0029397:	46                   	inc    %esi
  for (i = 0; i < cnt; i++)
c0029398:	39 f5                	cmp    %esi,%ebp
c002939a:	75 ea                	jne    c0029386 <bitmap_contains+0x2c>
      return true;
  return false;
c002939c:	b0 00                	mov    $0x0,%al
c002939e:	eb 65                	jmp    c0029405 <bitmap_contains+0xab>
  ASSERT (b != NULL);
c00293a0:	83 ec 0c             	sub    $0xc,%esp
c00293a3:	68 b7 f3 02 c0       	push   $0xc002f3b7
c00293a8:	68 3f d9 02 c0       	push   $0xc002d93f
c00293ad:	68 30 d5 02 c0       	push   $0xc002d530
c00293b2:	68 ff 00 00 00       	push   $0xff
c00293b7:	68 4a f5 02 c0       	push   $0xc002f54a
c00293bc:	e8 4c ef ff ff       	call   c002830d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c00293c1:	83 ec 0c             	sub    $0xc,%esp
c00293c4:	68 75 f5 02 c0       	push   $0xc002f575
c00293c9:	68 3f d9 02 c0       	push   $0xc002d93f
c00293ce:	68 30 d5 02 c0       	push   $0xc002d530
c00293d3:	68 00 01 00 00       	push   $0x100
c00293d8:	68 4a f5 02 c0       	push   $0xc002f54a
c00293dd:	e8 2b ef ff ff       	call   c002830d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c00293e2:	83 ec 0c             	sub    $0xc,%esp
c00293e5:	68 89 f5 02 c0       	push   $0xc002f589
c00293ea:	68 3f d9 02 c0       	push   $0xc002d93f
c00293ef:	68 30 d5 02 c0       	push   $0xc002d530
c00293f4:	68 01 01 00 00       	push   $0x101
c00293f9:	68 4a f5 02 c0       	push   $0xc002f54a
c00293fe:	e8 0a ef ff ff       	call   c002830d <debug_panic>
      return true;
c0029403:	b0 01                	mov    $0x1,%al
}
c0029405:	83 c4 0c             	add    $0xc,%esp
c0029408:	5b                   	pop    %ebx
c0029409:	5e                   	pop    %esi
c002940a:	5f                   	pop    %edi
c002940b:	5d                   	pop    %ebp
c002940c:	c3                   	ret    

c002940d <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002940d:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c0029410:	6a 01                	push   $0x1
c0029412:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029416:	ff 74 24 1c          	pushl  0x1c(%esp)
c002941a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002941e:	e8 37 ff ff ff       	call   c002935a <bitmap_contains>
}
c0029423:	83 c4 1c             	add    $0x1c,%esp
c0029426:	c3                   	ret    

c0029427 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c0029427:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c002942a:	6a 01                	push   $0x1
c002942c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029430:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029434:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029438:	e8 1d ff ff ff       	call   c002935a <bitmap_contains>
c002943d:	83 f0 01             	xor    $0x1,%eax
}
c0029440:	83 c4 1c             	add    $0x1c,%esp
c0029443:	c3                   	ret    

c0029444 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c0029444:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c0029447:	6a 00                	push   $0x0
c0029449:	ff 74 24 1c          	pushl  0x1c(%esp)
c002944d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029451:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029455:	e8 00 ff ff ff       	call   c002935a <bitmap_contains>
c002945a:	83 f0 01             	xor    $0x1,%eax
}
c002945d:	83 c4 1c             	add    $0x1c,%esp
c0029460:	c3                   	ret    

c0029461 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0029461:	55                   	push   %ebp
c0029462:	57                   	push   %edi
c0029463:	56                   	push   %esi
c0029464:	53                   	push   %ebx
c0029465:	83 ec 1c             	sub    $0x1c,%esp
c0029468:	8b 74 24 30          	mov    0x30(%esp),%esi
c002946c:	8b 5c 24 34          	mov    0x34(%esp),%ebx
c0029470:	8b 7c 24 38          	mov    0x38(%esp),%edi
c0029474:	8a 54 24 3c          	mov    0x3c(%esp),%dl
  ASSERT (b != NULL);
c0029478:	85 f6                	test   %esi,%esi
c002947a:	74 17                	je     c0029493 <bitmap_scan+0x32>
  ASSERT (start <= b->bit_cnt);
c002947c:	8b 06                	mov    (%esi),%eax
c002947e:	39 d8                	cmp    %ebx,%eax
c0029480:	72 32                	jb     c00294b4 <bitmap_scan+0x53>

  if (cnt <= b->bit_cnt) 
c0029482:	39 f8                	cmp    %edi,%eax
c0029484:	73 4f                	jae    c00294d5 <bitmap_scan+0x74>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c0029486:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002948b:	83 c4 1c             	add    $0x1c,%esp
c002948e:	5b                   	pop    %ebx
c002948f:	5e                   	pop    %esi
c0029490:	5f                   	pop    %edi
c0029491:	5d                   	pop    %ebp
c0029492:	c3                   	ret    
  ASSERT (b != NULL);
c0029493:	83 ec 0c             	sub    $0xc,%esp
c0029496:	68 b7 f3 02 c0       	push   $0xc002f3b7
c002949b:	68 3f d9 02 c0       	push   $0xc002d93f
c00294a0:	68 24 d5 02 c0       	push   $0xc002d524
c00294a5:	68 2a 01 00 00       	push   $0x12a
c00294aa:	68 4a f5 02 c0       	push   $0xc002f54a
c00294af:	e8 59 ee ff ff       	call   c002830d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c00294b4:	83 ec 0c             	sub    $0xc,%esp
c00294b7:	68 75 f5 02 c0       	push   $0xc002f575
c00294bc:	68 3f d9 02 c0       	push   $0xc002d93f
c00294c1:	68 24 d5 02 c0       	push   $0xc002d524
c00294c6:	68 2b 01 00 00       	push   $0x12b
c00294cb:	68 4a f5 02 c0       	push   $0xc002f54a
c00294d0:	e8 38 ee ff ff       	call   c002830d <debug_panic>
      size_t last = b->bit_cnt - cnt;
c00294d5:	29 f8                	sub    %edi,%eax
c00294d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
      for (i = start; i <= last; i++)
c00294db:	39 c3                	cmp    %eax,%ebx
c00294dd:	77 24                	ja     c0029503 <bitmap_scan+0xa2>
        if (!bitmap_contains (b, i, cnt, !value))
c00294df:	83 f2 01             	xor    $0x1,%edx
c00294e2:	0f b6 ea             	movzbl %dl,%ebp
c00294e5:	55                   	push   %ebp
c00294e6:	57                   	push   %edi
c00294e7:	53                   	push   %ebx
c00294e8:	56                   	push   %esi
c00294e9:	e8 6c fe ff ff       	call   c002935a <bitmap_contains>
c00294ee:	83 c4 10             	add    $0x10,%esp
c00294f1:	84 c0                	test   %al,%al
c00294f3:	74 15                	je     c002950a <bitmap_scan+0xa9>
      for (i = start; i <= last; i++)
c00294f5:	43                   	inc    %ebx
c00294f6:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c00294fa:	73 e9                	jae    c00294e5 <bitmap_scan+0x84>
  return BITMAP_ERROR;
c00294fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0029501:	eb 88                	jmp    c002948b <bitmap_scan+0x2a>
c0029503:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0029508:	eb 81                	jmp    c002948b <bitmap_scan+0x2a>
c002950a:	89 d8                	mov    %ebx,%eax
c002950c:	e9 7a ff ff ff       	jmp    c002948b <bitmap_scan+0x2a>

c0029511 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c0029511:	55                   	push   %ebp
c0029512:	57                   	push   %edi
c0029513:	56                   	push   %esi
c0029514:	53                   	push   %ebx
c0029515:	83 ec 0c             	sub    $0xc,%esp
c0029518:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002951c:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c0029520:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c0029524:	0f b6 c3             	movzbl %bl,%eax
c0029527:	50                   	push   %eax
c0029528:	55                   	push   %ebp
c0029529:	ff 74 24 2c          	pushl  0x2c(%esp)
c002952d:	57                   	push   %edi
c002952e:	e8 2e ff ff ff       	call   c0029461 <bitmap_scan>
c0029533:	83 c4 10             	add    $0x10,%esp
c0029536:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c0029538:	83 f8 ff             	cmp    $0xffffffff,%eax
c002953b:	74 12                	je     c002954f <bitmap_scan_and_flip+0x3e>
    bitmap_set_multiple (b, idx, cnt, !value);
c002953d:	83 f3 01             	xor    $0x1,%ebx
c0029540:	0f b6 db             	movzbl %bl,%ebx
c0029543:	53                   	push   %ebx
c0029544:	55                   	push   %ebp
c0029545:	50                   	push   %eax
c0029546:	57                   	push   %edi
c0029547:	e8 a3 fb ff ff       	call   c00290ef <bitmap_set_multiple>
c002954c:	83 c4 10             	add    $0x10,%esp
  return idx;
}
c002954f:	89 f0                	mov    %esi,%eax
c0029551:	83 c4 0c             	add    $0xc,%esp
c0029554:	5b                   	pop    %ebx
c0029555:	5e                   	pop    %esi
c0029556:	5f                   	pop    %edi
c0029557:	5d                   	pop    %ebp
c0029558:	c3                   	ret    

c0029559 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c0029559:	83 ec 0c             	sub    $0xc,%esp
c002955c:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c0029560:	6a 00                	push   $0x0
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029562:	8b 02                	mov    (%edx),%eax
c0029564:	83 c0 1f             	add    $0x1f,%eax
c0029567:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002956a:	c1 e0 02             	shl    $0x2,%eax
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002956d:	50                   	push   %eax
c002956e:	ff 72 04             	pushl  0x4(%edx)
c0029571:	6a 00                	push   $0x0
c0029573:	e8 90 da ff ff       	call   c0027008 <hex_dump>
}
c0029578:	83 c4 1c             	add    $0x1c,%esp
c002957b:	c3                   	ret    

c002957c <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002957c:	53                   	push   %ebx
c002957d:	83 ec 10             	sub    $0x10,%esp
c0029580:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c0029582:	ff 70 14             	pushl  0x14(%eax)
c0029585:	52                   	push   %edx
c0029586:	ff 50 0c             	call   *0xc(%eax)
c0029589:	8b 4b 04             	mov    0x4(%ebx),%ecx
c002958c:	8d 51 ff             	lea    -0x1(%ecx),%edx
c002958f:	21 d0                	and    %edx,%eax
  return &h->buckets[bucket_idx];
c0029591:	c1 e0 04             	shl    $0x4,%eax
c0029594:	03 43 08             	add    0x8(%ebx),%eax
}
c0029597:	83 c4 18             	add    $0x18,%esp
c002959a:	5b                   	pop    %ebx
c002959b:	c3                   	ret    

c002959c <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002959c:	55                   	push   %ebp
c002959d:	57                   	push   %edi
c002959e:	56                   	push   %esi
c002959f:	53                   	push   %ebx
c00295a0:	83 ec 18             	sub    $0x18,%esp
c00295a3:	89 c6                	mov    %eax,%esi
c00295a5:	89 d5                	mov    %edx,%ebp
c00295a7:	89 cf                	mov    %ecx,%edi
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c00295a9:	52                   	push   %edx
c00295aa:	e8 48 ee ff ff       	call   c00283f7 <list_begin>
c00295af:	89 c3                	mov    %eax,%ebx
c00295b1:	83 c4 10             	add    $0x10,%esp
c00295b4:	eb 0e                	jmp    c00295c4 <find_elem+0x28>
c00295b6:	83 ec 0c             	sub    $0xc,%esp
c00295b9:	53                   	push   %ebx
c00295ba:	e8 68 ee ff ff       	call   c0028427 <list_next>
c00295bf:	89 c3                	mov    %eax,%ebx
c00295c1:	83 c4 10             	add    $0x10,%esp
c00295c4:	83 ec 0c             	sub    $0xc,%esp
c00295c7:	55                   	push   %ebp
c00295c8:	e8 a2 ee ff ff       	call   c002846f <list_end>
c00295cd:	83 c4 10             	add    $0x10,%esp
c00295d0:	39 c3                	cmp    %eax,%ebx
c00295d2:	74 28                	je     c00295fc <find_elem+0x60>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c00295d4:	83 ec 04             	sub    $0x4,%esp
c00295d7:	ff 76 14             	pushl  0x14(%esi)
c00295da:	57                   	push   %edi
c00295db:	53                   	push   %ebx
c00295dc:	ff 56 10             	call   *0x10(%esi)
c00295df:	83 c4 10             	add    $0x10,%esp
c00295e2:	84 c0                	test   %al,%al
c00295e4:	75 d0                	jne    c00295b6 <find_elem+0x1a>
c00295e6:	83 ec 04             	sub    $0x4,%esp
c00295e9:	ff 76 14             	pushl  0x14(%esi)
c00295ec:	53                   	push   %ebx
c00295ed:	57                   	push   %edi
c00295ee:	ff 56 10             	call   *0x10(%esi)
c00295f1:	83 c4 10             	add    $0x10,%esp
c00295f4:	84 c0                	test   %al,%al
c00295f6:	75 be                	jne    c00295b6 <find_elem+0x1a>
c00295f8:	89 d8                	mov    %ebx,%eax
c00295fa:	eb 05                	jmp    c0029601 <find_elem+0x65>
        return hi; 
    }
  return NULL;
c00295fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029601:	83 c4 0c             	add    $0xc,%esp
c0029604:	5b                   	pop    %ebx
c0029605:	5e                   	pop    %esi
c0029606:	5f                   	pop    %edi
c0029607:	5d                   	pop    %ebp
c0029608:	c3                   	ret    

c0029609 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c0029609:	55                   	push   %ebp
c002960a:	57                   	push   %edi
c002960b:	56                   	push   %esi
c002960c:	53                   	push   %ebx
c002960d:	83 ec 2c             	sub    $0x2c,%esp
c0029610:	89 44 24 0c          	mov    %eax,0xc(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c0029614:	85 c0                	test   %eax,%eax
c0029616:	74 21                	je     c0029639 <rehash+0x30>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c0029618:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002961c:	8b 48 04             	mov    0x4(%eax),%ecx
c002961f:	89 4c 24 18          	mov    %ecx,0x18(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c0029623:	8b 00                	mov    (%eax),%eax
c0029625:	89 44 24 10          	mov    %eax,0x10(%esp)
c0029629:	89 c3                	mov    %eax,%ebx
c002962b:	d1 eb                	shr    %ebx
c002962d:	83 fb 04             	cmp    $0x4,%ebx
c0029630:	73 2d                	jae    c002965f <rehash+0x56>
c0029632:	bb 04 00 00 00       	mov    $0x4,%ebx
c0029637:	eb 26                	jmp    c002965f <rehash+0x56>
  ASSERT (h != NULL);
c0029639:	83 ec 0c             	sub    $0xc,%esp
c002963c:	68 cc f5 02 c0       	push   $0xc002f5cc
c0029641:	68 3f d9 02 c0       	push   $0xc002d93f
c0029646:	68 e0 d5 02 c0       	push   $0xc002d5e0
c002964b:	68 66 01 00 00       	push   $0x166
c0029650:	68 d6 f5 02 c0       	push   $0xc002f5d6
c0029655:	e8 b3 ec ff ff       	call   c002830d <debug_panic>
  return x & (x - 1);
c002965a:	8d 43 ff             	lea    -0x1(%ebx),%eax
c002965d:	21 c3                	and    %eax,%ebx
  return x != 0 && turn_off_least_1bit (x) == 0;
c002965f:	85 db                	test   %ebx,%ebx
c0029661:	74 f7                	je     c002965a <rehash+0x51>
  return x & (x - 1);
c0029663:	8d 43 ff             	lea    -0x1(%ebx),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c0029666:	21 d8                	and    %ebx,%eax
c0029668:	75 f0                	jne    c002965a <rehash+0x51>
c002966a:	89 c6                	mov    %eax,%esi
c002966c:	89 44 24 10          	mov    %eax,0x10(%esp)
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c0029670:	3b 5c 24 18          	cmp    0x18(%esp),%ebx
c0029674:	0f 84 ce 00 00 00    	je     c0029748 <rehash+0x13f>
  old_buckets = h->buckets;
c002967a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002967e:	8b 40 08             	mov    0x8(%eax),%eax
c0029681:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c0029685:	83 ec 0c             	sub    $0xc,%esp
c0029688:	89 d8                	mov    %ebx,%eax
c002968a:	c1 e0 04             	shl    $0x4,%eax
c002968d:	50                   	push   %eax
c002968e:	e8 30 a0 ff ff       	call   c00236c3 <malloc>
c0029693:	89 c5                	mov    %eax,%ebp
  if (new_buckets == NULL) 
c0029695:	83 c4 10             	add    $0x10,%esp
c0029698:	85 c0                	test   %eax,%eax
c002969a:	0f 84 a8 00 00 00    	je     c0029748 <rehash+0x13f>
c00296a0:	89 c7                	mov    %eax,%edi
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c00296a2:	83 ec 0c             	sub    $0xc,%esp
c00296a5:	57                   	push   %edi
c00296a6:	e8 09 ed ff ff       	call   c00283b4 <list_init>
  for (i = 0; i < new_bucket_cnt; i++) 
c00296ab:	46                   	inc    %esi
c00296ac:	83 c7 10             	add    $0x10,%edi
c00296af:	83 c4 10             	add    $0x10,%esp
c00296b2:	39 f3                	cmp    %esi,%ebx
c00296b4:	75 ec                	jne    c00296a2 <rehash+0x99>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c00296b6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00296ba:	89 68 08             	mov    %ebp,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c00296bd:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c00296c0:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c00296c5:	74 72                	je     c0029739 <rehash+0x130>
c00296c7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c00296cb:	89 44 24 14          	mov    %eax,0x14(%esp)
c00296cf:	eb 52                	jmp    c0029723 <rehash+0x11a>

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c00296d1:	89 da                	mov    %ebx,%edx
c00296d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00296d7:	e8 a0 fe ff ff       	call   c002957c <find_bucket>
c00296dc:	89 c7                	mov    %eax,%edi
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c00296de:	83 ec 0c             	sub    $0xc,%esp
c00296e1:	53                   	push   %ebx
c00296e2:	e8 40 ed ff ff       	call   c0028427 <list_next>
c00296e7:	89 c6                	mov    %eax,%esi
          list_remove (elem);
c00296e9:	89 1c 24             	mov    %ebx,(%esp)
c00296ec:	e8 2c f1 ff ff       	call   c002881d <list_remove>
          list_push_front (new_bucket, elem);
c00296f1:	83 c4 08             	add    $0x8,%esp
c00296f4:	53                   	push   %ebx
c00296f5:	57                   	push   %edi
c00296f6:	e8 e8 f0 ff ff       	call   c00287e3 <list_push_front>
           elem != list_end (old_bucket); elem = next) 
c00296fb:	83 c4 10             	add    $0x10,%esp
c00296fe:	89 f3                	mov    %esi,%ebx
c0029700:	83 ec 0c             	sub    $0xc,%esp
c0029703:	55                   	push   %ebp
c0029704:	e8 66 ed ff ff       	call   c002846f <list_end>
      for (elem = list_begin (old_bucket);
c0029709:	83 c4 10             	add    $0x10,%esp
c002970c:	39 c3                	cmp    %eax,%ebx
c002970e:	75 c1                	jne    c00296d1 <rehash+0xc8>
  for (i = 0; i < old_bucket_cnt; i++) 
c0029710:	ff 44 24 10          	incl   0x10(%esp)
c0029714:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029718:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c002971d:	39 44 24 18          	cmp    %eax,0x18(%esp)
c0029721:	74 16                	je     c0029739 <rehash+0x130>
      old_bucket = &old_buckets[i];
c0029723:	8b 44 24 14          	mov    0x14(%esp),%eax
c0029727:	89 c5                	mov    %eax,%ebp
      for (elem = list_begin (old_bucket);
c0029729:	83 ec 0c             	sub    $0xc,%esp
c002972c:	50                   	push   %eax
c002972d:	e8 c5 ec ff ff       	call   c00283f7 <list_begin>
c0029732:	89 c3                	mov    %eax,%ebx
c0029734:	83 c4 10             	add    $0x10,%esp
c0029737:	eb c7                	jmp    c0029700 <rehash+0xf7>
        }
    }

  free (old_buckets);
c0029739:	83 ec 0c             	sub    $0xc,%esp
c002973c:	ff 74 24 28          	pushl  0x28(%esp)
c0029740:	e8 21 a1 ff ff       	call   c0023866 <free>
c0029745:	83 c4 10             	add    $0x10,%esp
}
c0029748:	83 c4 2c             	add    $0x2c,%esp
c002974b:	5b                   	pop    %ebx
c002974c:	5e                   	pop    %esi
c002974d:	5f                   	pop    %edi
c002974e:	5d                   	pop    %ebp
c002974f:	c3                   	ret    

c0029750 <hash_clear>:
{
c0029750:	55                   	push   %ebp
c0029751:	57                   	push   %edi
c0029752:	56                   	push   %esi
c0029753:	53                   	push   %ebx
c0029754:	83 ec 0c             	sub    $0xc,%esp
c0029757:	8b 74 24 20          	mov    0x20(%esp),%esi
c002975b:	8b 7c 24 24          	mov    0x24(%esp),%edi
  for (i = 0; i < h->bucket_cnt; i++) 
c002975f:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029763:	74 4c                	je     c00297b1 <hash_clear+0x61>
c0029765:	bd 00 00 00 00       	mov    $0x0,%ebp
c002976a:	eb 37                	jmp    c00297a3 <hash_clear+0x53>
            struct list_elem *list_elem = list_pop_front (bucket);
c002976c:	83 ec 0c             	sub    $0xc,%esp
c002976f:	53                   	push   %ebx
c0029770:	e8 95 f1 ff ff       	call   c002890a <list_pop_front>
            destructor (hash_elem, h->aux);
c0029775:	83 c4 08             	add    $0x8,%esp
c0029778:	ff 76 14             	pushl  0x14(%esi)
c002977b:	50                   	push   %eax
c002977c:	ff d7                	call   *%edi
c002977e:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c0029781:	83 ec 0c             	sub    $0xc,%esp
c0029784:	53                   	push   %ebx
c0029785:	e8 1e f1 ff ff       	call   c00288a8 <list_empty>
c002978a:	83 c4 10             	add    $0x10,%esp
c002978d:	84 c0                	test   %al,%al
c002978f:	74 db                	je     c002976c <hash_clear+0x1c>
      list_init (bucket); 
c0029791:	83 ec 0c             	sub    $0xc,%esp
c0029794:	53                   	push   %ebx
c0029795:	e8 1a ec ff ff       	call   c00283b4 <list_init>
  for (i = 0; i < h->bucket_cnt; i++) 
c002979a:	45                   	inc    %ebp
c002979b:	83 c4 10             	add    $0x10,%esp
c002979e:	39 6e 04             	cmp    %ebp,0x4(%esi)
c00297a1:	76 0e                	jbe    c00297b1 <hash_clear+0x61>
      struct list *bucket = &h->buckets[i];
c00297a3:	89 eb                	mov    %ebp,%ebx
c00297a5:	c1 e3 04             	shl    $0x4,%ebx
c00297a8:	03 5e 08             	add    0x8(%esi),%ebx
      if (destructor != NULL) 
c00297ab:	85 ff                	test   %edi,%edi
c00297ad:	75 d2                	jne    c0029781 <hash_clear+0x31>
c00297af:	eb e0                	jmp    c0029791 <hash_clear+0x41>
  h->elem_cnt = 0;
c00297b1:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
c00297b7:	83 c4 0c             	add    $0xc,%esp
c00297ba:	5b                   	pop    %ebx
c00297bb:	5e                   	pop    %esi
c00297bc:	5f                   	pop    %edi
c00297bd:	5d                   	pop    %ebp
c00297be:	c3                   	ret    

c00297bf <hash_init>:
{
c00297bf:	53                   	push   %ebx
c00297c0:	83 ec 14             	sub    $0x14,%esp
c00297c3:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  h->elem_cnt = 0;
c00297c7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  h->bucket_cnt = 4;
c00297cd:	c7 43 04 04 00 00 00 	movl   $0x4,0x4(%ebx)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c00297d4:	6a 40                	push   $0x40
c00297d6:	e8 e8 9e ff ff       	call   c00236c3 <malloc>
c00297db:	89 43 08             	mov    %eax,0x8(%ebx)
  h->hash = hash;
c00297de:	8b 54 24 24          	mov    0x24(%esp),%edx
c00297e2:	89 53 0c             	mov    %edx,0xc(%ebx)
  h->less = less;
c00297e5:	8b 54 24 28          	mov    0x28(%esp),%edx
c00297e9:	89 53 10             	mov    %edx,0x10(%ebx)
  h->aux = aux;
c00297ec:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c00297f0:	89 53 14             	mov    %edx,0x14(%ebx)
  if (h->buckets != NULL) 
c00297f3:	83 c4 10             	add    $0x10,%esp
c00297f6:	85 c0                	test   %eax,%eax
c00297f8:	74 15                	je     c002980f <hash_init+0x50>
      hash_clear (h, NULL);
c00297fa:	83 ec 08             	sub    $0x8,%esp
c00297fd:	6a 00                	push   $0x0
c00297ff:	53                   	push   %ebx
c0029800:	e8 4b ff ff ff       	call   c0029750 <hash_clear>
      return true;
c0029805:	83 c4 10             	add    $0x10,%esp
c0029808:	b0 01                	mov    $0x1,%al
}
c002980a:	83 c4 08             	add    $0x8,%esp
c002980d:	5b                   	pop    %ebx
c002980e:	c3                   	ret    
    return false;
c002980f:	b0 00                	mov    $0x0,%al
c0029811:	eb f7                	jmp    c002980a <hash_init+0x4b>

c0029813 <hash_destroy>:
{
c0029813:	53                   	push   %ebx
c0029814:	83 ec 08             	sub    $0x8,%esp
c0029817:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002981b:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c002981f:	85 c0                	test   %eax,%eax
c0029821:	74 0d                	je     c0029830 <hash_destroy+0x1d>
    hash_clear (h, destructor);
c0029823:	83 ec 08             	sub    $0x8,%esp
c0029826:	50                   	push   %eax
c0029827:	53                   	push   %ebx
c0029828:	e8 23 ff ff ff       	call   c0029750 <hash_clear>
c002982d:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c0029830:	83 ec 0c             	sub    $0xc,%esp
c0029833:	ff 73 08             	pushl  0x8(%ebx)
c0029836:	e8 2b a0 ff ff       	call   c0023866 <free>
}
c002983b:	83 c4 18             	add    $0x18,%esp
c002983e:	5b                   	pop    %ebx
c002983f:	c3                   	ret    

c0029840 <hash_insert>:
{
c0029840:	55                   	push   %ebp
c0029841:	57                   	push   %edi
c0029842:	56                   	push   %esi
c0029843:	53                   	push   %ebx
c0029844:	83 ec 0c             	sub    $0xc,%esp
c0029847:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c002984b:	8b 74 24 24          	mov    0x24(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002984f:	89 f2                	mov    %esi,%edx
c0029851:	89 d8                	mov    %ebx,%eax
c0029853:	e8 24 fd ff ff       	call   c002957c <find_bucket>
c0029858:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002985a:	89 f1                	mov    %esi,%ecx
c002985c:	89 c2                	mov    %eax,%edx
c002985e:	89 d8                	mov    %ebx,%eax
c0029860:	e8 37 fd ff ff       	call   c002959c <find_elem>
c0029865:	89 c7                	mov    %eax,%edi
  if (old == NULL) 
c0029867:	85 c0                	test   %eax,%eax
c0029869:	74 11                	je     c002987c <hash_insert+0x3c>
  rehash (h);
c002986b:	89 d8                	mov    %ebx,%eax
c002986d:	e8 97 fd ff ff       	call   c0029609 <rehash>
}
c0029872:	89 f8                	mov    %edi,%eax
c0029874:	83 c4 0c             	add    $0xc,%esp
c0029877:	5b                   	pop    %ebx
c0029878:	5e                   	pop    %esi
c0029879:	5f                   	pop    %edi
c002987a:	5d                   	pop    %ebp
c002987b:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c002987c:	ff 03                	incl   (%ebx)
  list_push_front (bucket, &e->list_elem);
c002987e:	83 ec 08             	sub    $0x8,%esp
c0029881:	56                   	push   %esi
c0029882:	55                   	push   %ebp
c0029883:	e8 5b ef ff ff       	call   c00287e3 <list_push_front>
c0029888:	83 c4 10             	add    $0x10,%esp
c002988b:	eb de                	jmp    c002986b <hash_insert+0x2b>

c002988d <hash_replace>:
{
c002988d:	55                   	push   %ebp
c002988e:	57                   	push   %edi
c002988f:	56                   	push   %esi
c0029890:	53                   	push   %ebx
c0029891:	83 ec 0c             	sub    $0xc,%esp
c0029894:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0029898:	8b 74 24 24          	mov    0x24(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002989c:	89 f2                	mov    %esi,%edx
c002989e:	89 d8                	mov    %ebx,%eax
c00298a0:	e8 d7 fc ff ff       	call   c002957c <find_bucket>
c00298a5:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c00298a7:	89 f1                	mov    %esi,%ecx
c00298a9:	89 c2                	mov    %eax,%edx
c00298ab:	89 d8                	mov    %ebx,%eax
c00298ad:	e8 ea fc ff ff       	call   c002959c <find_elem>
c00298b2:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c00298b4:	85 c0                	test   %eax,%eax
c00298b6:	74 0e                	je     c00298c6 <hash_replace+0x39>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c00298b8:	ff 0b                	decl   (%ebx)
  list_remove (&e->list_elem);
c00298ba:	83 ec 0c             	sub    $0xc,%esp
c00298bd:	50                   	push   %eax
c00298be:	e8 5a ef ff ff       	call   c002881d <list_remove>
c00298c3:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c00298c6:	ff 03                	incl   (%ebx)
  list_push_front (bucket, &e->list_elem);
c00298c8:	83 ec 08             	sub    $0x8,%esp
c00298cb:	56                   	push   %esi
c00298cc:	55                   	push   %ebp
c00298cd:	e8 11 ef ff ff       	call   c00287e3 <list_push_front>
  rehash (h);
c00298d2:	89 d8                	mov    %ebx,%eax
c00298d4:	e8 30 fd ff ff       	call   c0029609 <rehash>
}
c00298d9:	89 f8                	mov    %edi,%eax
c00298db:	83 c4 1c             	add    $0x1c,%esp
c00298de:	5b                   	pop    %ebx
c00298df:	5e                   	pop    %esi
c00298e0:	5f                   	pop    %edi
c00298e1:	5d                   	pop    %ebp
c00298e2:	c3                   	ret    

c00298e3 <hash_find>:
{
c00298e3:	83 ec 0c             	sub    $0xc,%esp
  return find_elem (h, find_bucket (h, e), e);
c00298e6:	8b 54 24 14          	mov    0x14(%esp),%edx
c00298ea:	8b 44 24 10          	mov    0x10(%esp),%eax
c00298ee:	e8 89 fc ff ff       	call   c002957c <find_bucket>
c00298f3:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00298f7:	89 c2                	mov    %eax,%edx
c00298f9:	8b 44 24 10          	mov    0x10(%esp),%eax
c00298fd:	e8 9a fc ff ff       	call   c002959c <find_elem>
}
c0029902:	83 c4 0c             	add    $0xc,%esp
c0029905:	c3                   	ret    

c0029906 <hash_delete>:
{
c0029906:	56                   	push   %esi
c0029907:	53                   	push   %ebx
c0029908:	83 ec 04             	sub    $0x4,%esp
c002990b:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002990f:	8b 74 24 14          	mov    0x14(%esp),%esi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c0029913:	89 f2                	mov    %esi,%edx
c0029915:	89 d8                	mov    %ebx,%eax
c0029917:	e8 60 fc ff ff       	call   c002957c <find_bucket>
c002991c:	89 f1                	mov    %esi,%ecx
c002991e:	89 c2                	mov    %eax,%edx
c0029920:	89 d8                	mov    %ebx,%eax
c0029922:	e8 75 fc ff ff       	call   c002959c <find_elem>
c0029927:	89 c6                	mov    %eax,%esi
  if (found != NULL) 
c0029929:	85 c0                	test   %eax,%eax
c002992b:	74 15                	je     c0029942 <hash_delete+0x3c>
  h->elem_cnt--;
c002992d:	ff 0b                	decl   (%ebx)
  list_remove (&e->list_elem);
c002992f:	83 ec 0c             	sub    $0xc,%esp
c0029932:	50                   	push   %eax
c0029933:	e8 e5 ee ff ff       	call   c002881d <list_remove>
      rehash (h); 
c0029938:	89 d8                	mov    %ebx,%eax
c002993a:	e8 ca fc ff ff       	call   c0029609 <rehash>
c002993f:	83 c4 10             	add    $0x10,%esp
}
c0029942:	89 f0                	mov    %esi,%eax
c0029944:	83 c4 04             	add    $0x4,%esp
c0029947:	5b                   	pop    %ebx
c0029948:	5e                   	pop    %esi
c0029949:	c3                   	ret    

c002994a <hash_apply>:
{
c002994a:	55                   	push   %ebp
c002994b:	57                   	push   %edi
c002994c:	56                   	push   %esi
c002994d:	53                   	push   %ebx
c002994e:	83 ec 1c             	sub    $0x1c,%esp
c0029951:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (action != NULL);
c0029955:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c002995a:	74 16                	je     c0029972 <hash_apply+0x28>
  for (i = 0; i < h->bucket_cnt; i++) 
c002995c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0029963:	00 
c0029964:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c0029968:	75 61                	jne    c00299cb <hash_apply+0x81>
}
c002996a:	83 c4 1c             	add    $0x1c,%esp
c002996d:	5b                   	pop    %ebx
c002996e:	5e                   	pop    %esi
c002996f:	5f                   	pop    %edi
c0029970:	5d                   	pop    %ebp
c0029971:	c3                   	ret    
  ASSERT (action != NULL);
c0029972:	83 ec 0c             	sub    $0xc,%esp
c0029975:	68 ee f5 02 c0       	push   $0xc002f5ee
c002997a:	68 3f d9 02 c0       	push   $0xc002d93f
c002997f:	68 d4 d5 02 c0       	push   $0xc002d5d4
c0029984:	68 a7 00 00 00       	push   $0xa7
c0029989:	68 d6 f5 02 c0       	push   $0xc002f5d6
c002998e:	e8 7a e9 ff ff       	call   c002830d <debug_panic>
          next = list_next (elem);
c0029993:	83 ec 0c             	sub    $0xc,%esp
c0029996:	53                   	push   %ebx
c0029997:	e8 8b ea ff ff       	call   c0028427 <list_next>
c002999c:	89 c6                	mov    %eax,%esi
          action (list_elem_to_hash_elem (elem), h->aux);
c002999e:	83 c4 08             	add    $0x8,%esp
c00299a1:	ff 75 14             	pushl  0x14(%ebp)
c00299a4:	53                   	push   %ebx
c00299a5:	ff 54 24 44          	call   *0x44(%esp)
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c00299a9:	83 c4 10             	add    $0x10,%esp
c00299ac:	89 f3                	mov    %esi,%ebx
c00299ae:	83 ec 0c             	sub    $0xc,%esp
c00299b1:	57                   	push   %edi
c00299b2:	e8 b8 ea ff ff       	call   c002846f <list_end>
c00299b7:	83 c4 10             	add    $0x10,%esp
c00299ba:	39 c3                	cmp    %eax,%ebx
c00299bc:	75 d5                	jne    c0029993 <hash_apply+0x49>
  for (i = 0; i < h->bucket_cnt; i++) 
c00299be:	ff 44 24 0c          	incl   0xc(%esp)
c00299c2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00299c6:	39 45 04             	cmp    %eax,0x4(%ebp)
c00299c9:	76 9f                	jbe    c002996a <hash_apply+0x20>
      struct list *bucket = &h->buckets[i];
c00299cb:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c00299cf:	c1 e7 04             	shl    $0x4,%edi
c00299d2:	03 7d 08             	add    0x8(%ebp),%edi
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c00299d5:	83 ec 0c             	sub    $0xc,%esp
c00299d8:	57                   	push   %edi
c00299d9:	e8 19 ea ff ff       	call   c00283f7 <list_begin>
c00299de:	89 c3                	mov    %eax,%ebx
c00299e0:	83 c4 10             	add    $0x10,%esp
c00299e3:	eb c9                	jmp    c00299ae <hash_apply+0x64>

c00299e5 <hash_first>:
{
c00299e5:	53                   	push   %ebx
c00299e6:	83 ec 08             	sub    $0x8,%esp
c00299e9:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00299ed:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c00299f1:	85 db                	test   %ebx,%ebx
c00299f3:	74 1d                	je     c0029a12 <hash_first+0x2d>
  ASSERT (h != NULL);
c00299f5:	85 c0                	test   %eax,%eax
c00299f7:	74 3a                	je     c0029a33 <hash_first+0x4e>
  i->hash = h;
c00299f9:	89 03                	mov    %eax,(%ebx)
  i->bucket = i->hash->buckets;
c00299fb:	8b 40 08             	mov    0x8(%eax),%eax
c00299fe:	89 43 04             	mov    %eax,0x4(%ebx)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c0029a01:	83 ec 0c             	sub    $0xc,%esp
c0029a04:	50                   	push   %eax
c0029a05:	e8 1d ec ff ff       	call   c0028627 <list_head>
c0029a0a:	89 43 08             	mov    %eax,0x8(%ebx)
}
c0029a0d:	83 c4 18             	add    $0x18,%esp
c0029a10:	5b                   	pop    %ebx
c0029a11:	c3                   	ret    
  ASSERT (i != NULL);
c0029a12:	83 ec 0c             	sub    $0xc,%esp
c0029a15:	68 fd f5 02 c0       	push   $0xc002f5fd
c0029a1a:	68 3f d9 02 c0       	push   $0xc002d93f
c0029a1f:	68 c8 d5 02 c0       	push   $0xc002d5c8
c0029a24:	68 ca 00 00 00       	push   $0xca
c0029a29:	68 d6 f5 02 c0       	push   $0xc002f5d6
c0029a2e:	e8 da e8 ff ff       	call   c002830d <debug_panic>
  ASSERT (h != NULL);
c0029a33:	83 ec 0c             	sub    $0xc,%esp
c0029a36:	68 cc f5 02 c0       	push   $0xc002f5cc
c0029a3b:	68 3f d9 02 c0       	push   $0xc002d93f
c0029a40:	68 c8 d5 02 c0       	push   $0xc002d5c8
c0029a45:	68 cb 00 00 00       	push   $0xcb
c0029a4a:	68 d6 f5 02 c0       	push   $0xc002f5d6
c0029a4f:	e8 b9 e8 ff ff       	call   c002830d <debug_panic>

c0029a54 <hash_next>:
{
c0029a54:	56                   	push   %esi
c0029a55:	53                   	push   %ebx
c0029a56:	83 ec 04             	sub    $0x4,%esp
c0029a59:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (i != NULL);
c0029a5d:	85 db                	test   %ebx,%ebx
c0029a5f:	74 4f                	je     c0029ab0 <hash_next+0x5c>
  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c0029a61:	83 ec 0c             	sub    $0xc,%esp
c0029a64:	ff 73 08             	pushl  0x8(%ebx)
c0029a67:	e8 bb e9 ff ff       	call   c0028427 <list_next>
c0029a6c:	89 43 08             	mov    %eax,0x8(%ebx)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c0029a6f:	83 c4 10             	add    $0x10,%esp
c0029a72:	8b 73 08             	mov    0x8(%ebx),%esi
c0029a75:	83 ec 0c             	sub    $0xc,%esp
c0029a78:	ff 73 04             	pushl  0x4(%ebx)
c0029a7b:	e8 ef e9 ff ff       	call   c002846f <list_end>
c0029a80:	83 c4 10             	add    $0x10,%esp
c0029a83:	39 c6                	cmp    %eax,%esi
c0029a85:	75 51                	jne    c0029ad8 <hash_next+0x84>
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c0029a87:	8b 43 04             	mov    0x4(%ebx),%eax
c0029a8a:	8d 50 10             	lea    0x10(%eax),%edx
c0029a8d:	89 53 04             	mov    %edx,0x4(%ebx)
c0029a90:	8b 0b                	mov    (%ebx),%ecx
c0029a92:	8b 41 04             	mov    0x4(%ecx),%eax
c0029a95:	c1 e0 04             	shl    $0x4,%eax
c0029a98:	03 41 08             	add    0x8(%ecx),%eax
c0029a9b:	39 c2                	cmp    %eax,%edx
c0029a9d:	73 32                	jae    c0029ad1 <hash_next+0x7d>
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c0029a9f:	83 ec 0c             	sub    $0xc,%esp
c0029aa2:	52                   	push   %edx
c0029aa3:	e8 4f e9 ff ff       	call   c00283f7 <list_begin>
c0029aa8:	89 43 08             	mov    %eax,0x8(%ebx)
c0029aab:	83 c4 10             	add    $0x10,%esp
c0029aae:	eb c2                	jmp    c0029a72 <hash_next+0x1e>
  ASSERT (i != NULL);
c0029ab0:	83 ec 0c             	sub    $0xc,%esp
c0029ab3:	68 fd f5 02 c0       	push   $0xc002f5fd
c0029ab8:	68 3f d9 02 c0       	push   $0xc002d93f
c0029abd:	68 bc d5 02 c0       	push   $0xc002d5bc
c0029ac2:	68 dd 00 00 00       	push   $0xdd
c0029ac7:	68 d6 f5 02 c0       	push   $0xc002f5d6
c0029acc:	e8 3c e8 ff ff       	call   c002830d <debug_panic>
          i->elem = NULL;
c0029ad1:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  return i->elem;
c0029ad8:	8b 43 08             	mov    0x8(%ebx),%eax
}
c0029adb:	83 c4 04             	add    $0x4,%esp
c0029ade:	5b                   	pop    %ebx
c0029adf:	5e                   	pop    %esi
c0029ae0:	c3                   	ret    

c0029ae1 <hash_cur>:
  return i->elem;
c0029ae1:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029ae5:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029ae8:	c3                   	ret    

c0029ae9 <hash_size>:
  return h->elem_cnt;
c0029ae9:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029aed:	8b 00                	mov    (%eax),%eax
}
c0029aef:	c3                   	ret    

c0029af0 <hash_empty>:
  return h->elem_cnt == 0;
c0029af0:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029af4:	83 38 00             	cmpl   $0x0,(%eax)
c0029af7:	0f 94 c0             	sete   %al
}
c0029afa:	c3                   	ret    

c0029afb <hash_bytes>:
{
c0029afb:	53                   	push   %ebx
c0029afc:	83 ec 08             	sub    $0x8,%esp
c0029aff:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0029b03:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (buf != NULL);
c0029b07:	85 c9                	test   %ecx,%ecx
c0029b09:	74 35                	je     c0029b40 <hash_bytes+0x45>
  while (size-- > 0)
c0029b0b:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
c0029b10:	85 db                	test   %ebx,%ebx
c0029b12:	74 27                	je     c0029b3b <hash_bytes+0x40>
c0029b14:	01 cb                	add    %ecx,%ebx
c0029b16:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c0029b1b:	89 c2                	mov    %eax,%edx
c0029b1d:	c1 e2 10             	shl    $0x10,%edx
c0029b20:	01 c2                	add    %eax,%edx
c0029b22:	01 d2                	add    %edx,%edx
c0029b24:	01 c2                	add    %eax,%edx
c0029b26:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029b29:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029b2c:	01 d2                	add    %edx,%edx
c0029b2e:	01 d0                	add    %edx,%eax
c0029b30:	41                   	inc    %ecx
c0029b31:	0f b6 51 ff          	movzbl -0x1(%ecx),%edx
c0029b35:	31 d0                	xor    %edx,%eax
  while (size-- > 0)
c0029b37:	39 d9                	cmp    %ebx,%ecx
c0029b39:	75 e0                	jne    c0029b1b <hash_bytes+0x20>
} 
c0029b3b:	83 c4 08             	add    $0x8,%esp
c0029b3e:	5b                   	pop    %ebx
c0029b3f:	c3                   	ret    
  ASSERT (buf != NULL);
c0029b40:	83 ec 0c             	sub    $0xc,%esp
c0029b43:	68 07 f6 02 c0       	push   $0xc002f607
c0029b48:	68 3f d9 02 c0       	push   $0xc002d93f
c0029b4d:	68 b0 d5 02 c0       	push   $0xc002d5b0
c0029b52:	68 10 01 00 00       	push   $0x110
c0029b57:	68 d6 f5 02 c0       	push   $0xc002f5d6
c0029b5c:	e8 ac e7 ff ff       	call   c002830d <debug_panic>

c0029b61 <hash_string>:
{
c0029b61:	53                   	push   %ebx
c0029b62:	83 ec 08             	sub    $0x8,%esp
c0029b65:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (s != NULL);
c0029b69:	85 db                	test   %ebx,%ebx
c0029b6b:	74 36                	je     c0029ba3 <hash_string+0x42>
  while (*s != '\0')
c0029b6d:	8a 0b                	mov    (%ebx),%cl
c0029b6f:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
c0029b74:	84 c9                	test   %cl,%cl
c0029b76:	74 26                	je     c0029b9e <hash_string+0x3d>
c0029b78:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
    hash = (hash * FNV_32_PRIME) ^ *s++;
c0029b7d:	89 c2                	mov    %eax,%edx
c0029b7f:	c1 e2 10             	shl    $0x10,%edx
c0029b82:	01 c2                	add    %eax,%edx
c0029b84:	01 d2                	add    %edx,%edx
c0029b86:	01 c2                	add    %eax,%edx
c0029b88:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029b8b:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029b8e:	01 d2                	add    %edx,%edx
c0029b90:	01 d0                	add    %edx,%eax
c0029b92:	43                   	inc    %ebx
c0029b93:	0f b6 c9             	movzbl %cl,%ecx
c0029b96:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c0029b98:	8a 0b                	mov    (%ebx),%cl
c0029b9a:	84 c9                	test   %cl,%cl
c0029b9c:	75 df                	jne    c0029b7d <hash_string+0x1c>
}
c0029b9e:	83 c4 08             	add    $0x8,%esp
c0029ba1:	5b                   	pop    %ebx
c0029ba2:	c3                   	ret    
  ASSERT (s != NULL);
c0029ba3:	83 ec 0c             	sub    $0xc,%esp
c0029ba6:	68 93 f1 02 c0       	push   $0xc002f193
c0029bab:	68 3f d9 02 c0       	push   $0xc002d93f
c0029bb0:	68 a4 d5 02 c0       	push   $0xc002d5a4
c0029bb5:	68 20 01 00 00       	push   $0x120
c0029bba:	68 d6 f5 02 c0       	push   $0xc002f5d6
c0029bbf:	e8 49 e7 ff ff       	call   c002830d <debug_panic>

c0029bc4 <hash_int>:
{
c0029bc4:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c0029bc7:	6a 04                	push   $0x4
c0029bc9:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0029bcd:	50                   	push   %eax
c0029bce:	e8 28 ff ff ff       	call   c0029afb <hash_bytes>
}
c0029bd3:	83 c4 1c             	add    $0x1c,%esp
c0029bd6:	c3                   	ret    

c0029bd7 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c0029bd7:	53                   	push   %ebx
c0029bd8:	83 ec 08             	sub    $0x8,%esp
c0029bdb:	89 c3                	mov    %eax,%ebx
  return (intr_context ()
c0029bdd:	e8 35 7d ff ff       	call   c0021917 <intr_context>
          || lock_held_by_current_thread (&console_lock));
c0029be2:	84 c0                	test   %al,%al
c0029be4:	75 09                	jne    c0029bef <putchar_have_lock+0x18>
          || !use_console_lock
c0029be6:	80 3d 6c 9e 03 c0 00 	cmpb   $0x0,0xc0039e6c
c0029bed:	75 27                	jne    c0029c16 <putchar_have_lock+0x3f>
  ASSERT (console_locked_by_current_thread ());
  write_cnt++;
c0029bef:	83 05 60 9e 03 c0 01 	addl   $0x1,0xc0039e60
c0029bf6:	83 15 64 9e 03 c0 00 	adcl   $0x0,0xc0039e64
  serial_putc (c);
c0029bfd:	0f b6 db             	movzbl %bl,%ebx
c0029c00:	83 ec 0c             	sub    $0xc,%esp
c0029c03:	53                   	push   %ebx
c0029c04:	e8 e3 aa ff ff       	call   c00246ec <serial_putc>
  vga_putc (c);
c0029c09:	89 1c 24             	mov    %ebx,(%esp)
c0029c0c:	e8 2d a7 ff ff       	call   c002433e <vga_putc>
}
c0029c11:	83 c4 18             	add    $0x18,%esp
c0029c14:	5b                   	pop    %ebx
c0029c15:	c3                   	ret    
          || lock_held_by_current_thread (&console_lock));
c0029c16:	83 ec 0c             	sub    $0xc,%esp
c0029c19:	68 80 9e 03 c0       	push   $0xc0039e80
c0029c1e:	e8 11 8f ff ff       	call   c0022b34 <lock_held_by_current_thread>
  ASSERT (console_locked_by_current_thread ());
c0029c23:	83 c4 10             	add    $0x10,%esp
c0029c26:	84 c0                	test   %al,%al
c0029c28:	75 c5                	jne    c0029bef <putchar_have_lock+0x18>
c0029c2a:	83 ec 0c             	sub    $0xc,%esp
c0029c2d:	68 14 f6 02 c0       	push   $0xc002f614
c0029c32:	68 3f d9 02 c0       	push   $0xc002d93f
c0029c37:	68 e8 d5 02 c0       	push   $0xc002d5e8
c0029c3c:	68 bb 00 00 00       	push   $0xbb
c0029c41:	68 59 f6 02 c0       	push   $0xc002f659
c0029c46:	e8 c2 e6 ff ff       	call   c002830d <debug_panic>

c0029c4b <vprintf_helper>:
{
c0029c4b:	83 ec 0c             	sub    $0xc,%esp
c0029c4e:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c0029c52:	ff 00                	incl   (%eax)
  putchar_have_lock (c);
c0029c54:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c0029c59:	e8 79 ff ff ff       	call   c0029bd7 <putchar_have_lock>
}
c0029c5e:	83 c4 0c             	add    $0xc,%esp
c0029c61:	c3                   	ret    

c0029c62 <acquire_console>:
{
c0029c62:	83 ec 0c             	sub    $0xc,%esp
  if (!intr_context () && use_console_lock) 
c0029c65:	e8 ad 7c ff ff       	call   c0021917 <intr_context>
c0029c6a:	84 c0                	test   %al,%al
c0029c6c:	75 09                	jne    c0029c77 <acquire_console+0x15>
c0029c6e:	80 3d 6c 9e 03 c0 00 	cmpb   $0x0,0xc0039e6c
c0029c75:	75 04                	jne    c0029c7b <acquire_console+0x19>
}
c0029c77:	83 c4 0c             	add    $0xc,%esp
c0029c7a:	c3                   	ret    
      if (lock_held_by_current_thread (&console_lock)) 
c0029c7b:	83 ec 0c             	sub    $0xc,%esp
c0029c7e:	68 80 9e 03 c0       	push   $0xc0039e80
c0029c83:	e8 ac 8e ff ff       	call   c0022b34 <lock_held_by_current_thread>
c0029c88:	83 c4 10             	add    $0x10,%esp
c0029c8b:	84 c0                	test   %al,%al
c0029c8d:	74 08                	je     c0029c97 <acquire_console+0x35>
        console_lock_depth++; 
c0029c8f:	ff 05 68 9e 03 c0    	incl   0xc0039e68
c0029c95:	eb e0                	jmp    c0029c77 <acquire_console+0x15>
        lock_acquire (&console_lock); 
c0029c97:	83 ec 0c             	sub    $0xc,%esp
c0029c9a:	68 80 9e 03 c0       	push   $0xc0039e80
c0029c9f:	e8 ce 8e ff ff       	call   c0022b72 <lock_acquire>
c0029ca4:	83 c4 10             	add    $0x10,%esp
}
c0029ca7:	eb ce                	jmp    c0029c77 <acquire_console+0x15>

c0029ca9 <release_console>:
{
c0029ca9:	83 ec 0c             	sub    $0xc,%esp
  if (!intr_context () && use_console_lock) 
c0029cac:	e8 66 7c ff ff       	call   c0021917 <intr_context>
c0029cb1:	84 c0                	test   %al,%al
c0029cb3:	75 18                	jne    c0029ccd <release_console+0x24>
c0029cb5:	80 3d 6c 9e 03 c0 00 	cmpb   $0x0,0xc0039e6c
c0029cbc:	74 0f                	je     c0029ccd <release_console+0x24>
      if (console_lock_depth > 0)
c0029cbe:	a1 68 9e 03 c0       	mov    0xc0039e68,%eax
c0029cc3:	85 c0                	test   %eax,%eax
c0029cc5:	7e 0a                	jle    c0029cd1 <release_console+0x28>
        console_lock_depth--;
c0029cc7:	48                   	dec    %eax
c0029cc8:	a3 68 9e 03 c0       	mov    %eax,0xc0039e68
}
c0029ccd:	83 c4 0c             	add    $0xc,%esp
c0029cd0:	c3                   	ret    
        lock_release (&console_lock); 
c0029cd1:	83 ec 0c             	sub    $0xc,%esp
c0029cd4:	68 80 9e 03 c0       	push   $0xc0039e80
c0029cd9:	e8 31 90 ff ff       	call   c0022d0f <lock_release>
c0029cde:	83 c4 10             	add    $0x10,%esp
}
c0029ce1:	eb ea                	jmp    c0029ccd <release_console+0x24>

c0029ce3 <console_init>:
{
c0029ce3:	83 ec 18             	sub    $0x18,%esp
  lock_init (&console_lock);
c0029ce6:	68 80 9e 03 c0       	push   $0xc0039e80
c0029ceb:	e8 0e 8d ff ff       	call   c00229fe <lock_init>
  use_console_lock = true;
c0029cf0:	c6 05 6c 9e 03 c0 01 	movb   $0x1,0xc0039e6c
}
c0029cf7:	83 c4 1c             	add    $0x1c,%esp
c0029cfa:	c3                   	ret    

c0029cfb <console_panic>:
  use_console_lock = false;
c0029cfb:	c6 05 6c 9e 03 c0 00 	movb   $0x0,0xc0039e6c
c0029d02:	c3                   	ret    

c0029d03 <console_print_stats>:
{
c0029d03:	83 ec 10             	sub    $0x10,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c0029d06:	ff 35 64 9e 03 c0    	pushl  0xc0039e64
c0029d0c:	ff 35 60 9e 03 c0    	pushl  0xc0039e60
c0029d12:	68 38 f6 02 c0       	push   $0xc002f638
c0029d17:	e8 43 cb ff ff       	call   c002685f <printf>
}
c0029d1c:	83 c4 1c             	add    $0x1c,%esp
c0029d1f:	c3                   	ret    

c0029d20 <vprintf>:
{
c0029d20:	83 ec 1c             	sub    $0x1c,%esp
  int char_cnt = 0;
c0029d23:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0029d2a:	00 
  acquire_console ();
c0029d2b:	e8 32 ff ff ff       	call   c0029c62 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c0029d30:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0029d34:	50                   	push   %eax
c0029d35:	68 4b 9c 02 c0       	push   $0xc0029c4b
c0029d3a:	ff 74 24 2c          	pushl  0x2c(%esp)
c0029d3e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0029d42:	e8 4d cb ff ff       	call   c0026894 <__vprintf>
  release_console ();
c0029d47:	e8 5d ff ff ff       	call   c0029ca9 <release_console>
}
c0029d4c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0029d50:	83 c4 2c             	add    $0x2c,%esp
c0029d53:	c3                   	ret    

c0029d54 <puts>:
{
c0029d54:	53                   	push   %ebx
c0029d55:	83 ec 08             	sub    $0x8,%esp
c0029d58:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c0029d5c:	e8 01 ff ff ff       	call   c0029c62 <acquire_console>
  while (*s != '\0')
c0029d61:	8a 03                	mov    (%ebx),%al
c0029d63:	84 c0                	test   %al,%al
c0029d65:	74 0f                	je     c0029d76 <puts+0x22>
    putchar_have_lock (*s++);
c0029d67:	43                   	inc    %ebx
c0029d68:	0f b6 c0             	movzbl %al,%eax
c0029d6b:	e8 67 fe ff ff       	call   c0029bd7 <putchar_have_lock>
  while (*s != '\0')
c0029d70:	8a 03                	mov    (%ebx),%al
c0029d72:	84 c0                	test   %al,%al
c0029d74:	75 f1                	jne    c0029d67 <puts+0x13>
  putchar_have_lock ('\n');
c0029d76:	b8 0a 00 00 00       	mov    $0xa,%eax
c0029d7b:	e8 57 fe ff ff       	call   c0029bd7 <putchar_have_lock>
  release_console ();
c0029d80:	e8 24 ff ff ff       	call   c0029ca9 <release_console>
}
c0029d85:	b8 00 00 00 00       	mov    $0x0,%eax
c0029d8a:	83 c4 08             	add    $0x8,%esp
c0029d8d:	5b                   	pop    %ebx
c0029d8e:	c3                   	ret    

c0029d8f <putbuf>:
{
c0029d8f:	56                   	push   %esi
c0029d90:	53                   	push   %ebx
c0029d91:	83 ec 04             	sub    $0x4,%esp
c0029d94:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0029d98:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console ();
c0029d9c:	e8 c1 fe ff ff       	call   c0029c62 <acquire_console>
  while (n-- > 0)
c0029da1:	85 f6                	test   %esi,%esi
c0029da3:	74 10                	je     c0029db5 <putbuf+0x26>
c0029da5:	01 de                	add    %ebx,%esi
    putchar_have_lock (*buffer++);
c0029da7:	43                   	inc    %ebx
c0029da8:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c0029dac:	e8 26 fe ff ff       	call   c0029bd7 <putchar_have_lock>
  while (n-- > 0)
c0029db1:	39 de                	cmp    %ebx,%esi
c0029db3:	75 f2                	jne    c0029da7 <putbuf+0x18>
  release_console ();
c0029db5:	e8 ef fe ff ff       	call   c0029ca9 <release_console>
}
c0029dba:	83 c4 04             	add    $0x4,%esp
c0029dbd:	5b                   	pop    %ebx
c0029dbe:	5e                   	pop    %esi
c0029dbf:	c3                   	ret    

c0029dc0 <putchar>:
{
c0029dc0:	83 ec 0c             	sub    $0xc,%esp
  acquire_console ();
c0029dc3:	e8 9a fe ff ff       	call   c0029c62 <acquire_console>
  putchar_have_lock (c);
c0029dc8:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c0029dcd:	e8 05 fe ff ff       	call   c0029bd7 <putchar_have_lock>
  release_console ();
c0029dd2:	e8 d2 fe ff ff       	call   c0029ca9 <release_console>
}
c0029dd7:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029ddb:	83 c4 0c             	add    $0xc,%esp
c0029dde:	c3                   	ret    

c0029ddf <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c0029ddf:	83 ec 14             	sub    $0x14,%esp
  va_list args;
  
  printf ("(%s) ", test_name);
c0029de2:	ff 35 b4 9e 03 c0    	pushl  0xc0039eb4
c0029de8:	68 74 f6 02 c0       	push   $0xc002f674
c0029ded:	e8 6d ca ff ff       	call   c002685f <printf>
  va_start (args, format);
c0029df2:	8d 44 24 24          	lea    0x24(%esp),%eax
  vprintf (format, args);
c0029df6:	83 c4 08             	add    $0x8,%esp
c0029df9:	50                   	push   %eax
c0029dfa:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029dfe:	e8 1d ff ff ff       	call   c0029d20 <vprintf>
  va_end (args);
  putchar ('\n');
c0029e03:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0029e0a:	e8 b1 ff ff ff       	call   c0029dc0 <putchar>
}
c0029e0f:	83 c4 1c             	add    $0x1c,%esp
c0029e12:	c3                   	ret    

c0029e13 <run_test>:
{
c0029e13:	56                   	push   %esi
c0029e14:	53                   	push   %ebx
c0029e15:	83 ec 04             	sub    $0x4,%esp
c0029e18:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c0029e1c:	bb 20 d6 02 c0       	mov    $0xc002d620,%ebx
    if (!strcmp (name, t->name))
c0029e21:	83 ec 08             	sub    $0x8,%esp
c0029e24:	ff 33                	pushl  (%ebx)
c0029e26:	56                   	push   %esi
c0029e27:	e8 96 d8 ff ff       	call   c00276c2 <strcmp>
c0029e2c:	83 c4 10             	add    $0x10,%esp
c0029e2f:	85 c0                	test   %eax,%eax
c0029e31:	74 25                	je     c0029e58 <run_test+0x45>
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c0029e33:	83 c3 08             	add    $0x8,%ebx
c0029e36:	81 fb f8 d6 02 c0    	cmp    $0xc002d6f8,%ebx
c0029e3c:	72 e3                	jb     c0029e21 <run_test+0xe>
  PANIC ("no test named \"%s\"", name);
c0029e3e:	83 ec 0c             	sub    $0xc,%esp
c0029e41:	56                   	push   %esi
c0029e42:	68 84 f6 02 c0       	push   $0xc002f684
c0029e47:	68 08 d6 02 c0       	push   $0xc002d608
c0029e4c:	6a 3c                	push   $0x3c
c0029e4e:	68 97 f6 02 c0       	push   $0xc002f697
c0029e53:	e8 b5 e4 ff ff       	call   c002830d <debug_panic>
        test_name = name;
c0029e58:	89 35 b4 9e 03 c0    	mov    %esi,0xc0039eb4
        msg ("begin");
c0029e5e:	83 ec 0c             	sub    $0xc,%esp
c0029e61:	68 7a f6 02 c0       	push   $0xc002f67a
c0029e66:	e8 74 ff ff ff       	call   c0029ddf <msg>
        t->function ();
c0029e6b:	ff 53 04             	call   *0x4(%ebx)
        msg ("end");
c0029e6e:	c7 04 24 80 f6 02 c0 	movl   $0xc002f680,(%esp)
c0029e75:	e8 65 ff ff ff       	call   c0029ddf <msg>
        return;
c0029e7a:	83 c4 10             	add    $0x10,%esp
}
c0029e7d:	83 c4 04             	add    $0x4,%esp
c0029e80:	5b                   	pop    %ebx
c0029e81:	5e                   	pop    %esi
c0029e82:	c3                   	ret    

c0029e83 <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c0029e83:	83 ec 14             	sub    $0x14,%esp
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c0029e86:	ff 35 b4 9e 03 c0    	pushl  0xc0039eb4
c0029e8c:	68 b3 f6 02 c0       	push   $0xc002f6b3
c0029e91:	e8 c9 c9 ff ff       	call   c002685f <printf>
  va_start (args, format);
c0029e96:	8d 44 24 24          	lea    0x24(%esp),%eax
  vprintf (format, args);
c0029e9a:	83 c4 08             	add    $0x8,%esp
c0029e9d:	50                   	push   %eax
c0029e9e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029ea2:	e8 79 fe ff ff       	call   c0029d20 <vprintf>
  va_end (args);
  putchar ('\n');
c0029ea7:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0029eae:	e8 0d ff ff ff       	call   c0029dc0 <putchar>

  PANIC ("test failed");
c0029eb3:	68 bf f6 02 c0       	push   $0xc002f6bf
c0029eb8:	68 00 d6 02 c0       	push   $0xc002d600
c0029ebd:	6a 5d                	push   $0x5d
c0029ebf:	68 97 f6 02 c0       	push   $0xc002f697
c0029ec4:	e8 44 e4 ff ff       	call   c002830d <debug_panic>

c0029ec9 <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c0029ec9:	83 ec 14             	sub    $0x14,%esp
  printf ("(%s) PASS\n", test_name);
c0029ecc:	ff 35 b4 9e 03 c0    	pushl  0xc0039eb4
c0029ed2:	68 cb f6 02 c0       	push   $0xc002f6cb
c0029ed7:	e8 83 c9 ff ff       	call   c002685f <printf>
}
c0029edc:	83 c4 1c             	add    $0x1c,%esp
c0029edf:	c3                   	ret    

c0029ee0 <sleeper>:
}

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c0029ee0:	55                   	push   %ebp
c0029ee1:	57                   	push   %edi
c0029ee2:	56                   	push   %esi
c0029ee3:	53                   	push   %ebx
c0029ee4:	83 ec 1c             	sub    $0x1c,%esp
c0029ee7:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  struct sleep_thread *t = t_;
  struct sleep_test *test = t->test;
c0029eeb:	8b 5d 00             	mov    0x0(%ebp),%ebx
  int i;

  for (i = 1; i <= test->iterations; i++) 
c0029eee:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c0029ef2:	7e 62                	jle    c0029f56 <sleeper+0x76>
c0029ef4:	be 01 00 00 00       	mov    $0x1,%esi
    {
      int64_t sleep_until = test->start + i * t->duration;
      timer_sleep (sleep_until - timer_ticks ());
      lock_acquire (&test->output_lock);
c0029ef9:	8d 43 0c             	lea    0xc(%ebx),%eax
c0029efc:	89 44 24 0c          	mov    %eax,0xc(%esp)
      int64_t sleep_until = test->start + i * t->duration;
c0029f00:	89 f0                	mov    %esi,%eax
c0029f02:	8b 4c 24 30          	mov    0x30(%esp),%ecx
c0029f06:	0f af 41 08          	imul   0x8(%ecx),%eax
c0029f0a:	99                   	cltd   
c0029f0b:	03 03                	add    (%ebx),%eax
c0029f0d:	13 53 04             	adc    0x4(%ebx),%edx
c0029f10:	89 c7                	mov    %eax,%edi
c0029f12:	89 d5                	mov    %edx,%ebp
      timer_sleep (sleep_until - timer_ticks ());
c0029f14:	e8 89 9f ff ff       	call   c0023ea2 <timer_ticks>
c0029f19:	83 ec 08             	sub    $0x8,%esp
c0029f1c:	29 c7                	sub    %eax,%edi
c0029f1e:	19 d5                	sbb    %edx,%ebp
c0029f20:	55                   	push   %ebp
c0029f21:	57                   	push   %edi
c0029f22:	e8 c0 9f ff ff       	call   c0023ee7 <timer_sleep>
      lock_acquire (&test->output_lock);
c0029f27:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
c0029f2b:	89 3c 24             	mov    %edi,(%esp)
c0029f2e:	e8 3f 8c ff ff       	call   c0022b72 <lock_acquire>
      *test->output_pos++ = t->id;
c0029f33:	8b 43 40             	mov    0x40(%ebx),%eax
c0029f36:	8d 50 04             	lea    0x4(%eax),%edx
c0029f39:	89 53 40             	mov    %edx,0x40(%ebx)
c0029f3c:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0029f40:	8b 51 04             	mov    0x4(%ecx),%edx
c0029f43:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c0029f45:	89 3c 24             	mov    %edi,(%esp)
c0029f48:	e8 c2 8d ff ff       	call   c0022d0f <lock_release>
  for (i = 1; i <= test->iterations; i++) 
c0029f4d:	46                   	inc    %esi
c0029f4e:	83 c4 10             	add    $0x10,%esp
c0029f51:	39 73 08             	cmp    %esi,0x8(%ebx)
c0029f54:	7d aa                	jge    c0029f00 <sleeper+0x20>
    }
}
c0029f56:	83 c4 1c             	add    $0x1c,%esp
c0029f59:	5b                   	pop    %ebx
c0029f5a:	5e                   	pop    %esi
c0029f5b:	5f                   	pop    %edi
c0029f5c:	5d                   	pop    %ebp
c0029f5d:	c3                   	ret    

c0029f5e <test_sleep>:
{
c0029f5e:	55                   	push   %ebp
c0029f5f:	57                   	push   %edi
c0029f60:	56                   	push   %esi
c0029f61:	53                   	push   %ebx
c0029f62:	83 ec 7c             	sub    $0x7c,%esp
c0029f65:	89 04 24             	mov    %eax,(%esp)
c0029f68:	89 54 24 0c          	mov    %edx,0xc(%esp)
  ASSERT (!thread_mlfqs);
c0029f6c:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c0029f73:	0f 85 63 01 00 00    	jne    c002a0dc <test_sleep+0x17e>
  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c0029f79:	83 ec 04             	sub    $0x4,%esp
c0029f7c:	8b 7c 24 10          	mov    0x10(%esp),%edi
c0029f80:	57                   	push   %edi
c0029f81:	8b 74 24 08          	mov    0x8(%esp),%esi
c0029f85:	56                   	push   %esi
c0029f86:	68 f0 f8 02 c0       	push   $0xc002f8f0
c0029f8b:	e8 4f fe ff ff       	call   c0029ddf <msg>
  msg ("Thread 0 sleeps 10 ticks each time,");
c0029f90:	c7 04 24 1c f9 02 c0 	movl   $0xc002f91c,(%esp)
c0029f97:	e8 43 fe ff ff       	call   c0029ddf <msg>
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c0029f9c:	c7 04 24 40 f9 02 c0 	movl   $0xc002f940,(%esp)
c0029fa3:	e8 37 fe ff ff       	call   c0029ddf <msg>
  msg ("If successful, product of iteration count and");
c0029fa8:	c7 04 24 70 f9 02 c0 	movl   $0xc002f970,(%esp)
c0029faf:	e8 2b fe ff ff       	call   c0029ddf <msg>
  msg ("sleep duration will appear in nondescending order.");
c0029fb4:	c7 04 24 a0 f9 02 c0 	movl   $0xc002f9a0,(%esp)
c0029fbb:	e8 1f fe ff ff       	call   c0029ddf <msg>
  threads = malloc (sizeof *threads * thread_cnt);
c0029fc0:	89 f0                	mov    %esi,%eax
c0029fc2:	c1 e0 04             	shl    $0x4,%eax
c0029fc5:	89 04 24             	mov    %eax,(%esp)
c0029fc8:	e8 f6 96 ff ff       	call   c00236c3 <malloc>
c0029fcd:	89 c3                	mov    %eax,%ebx
c0029fcf:	89 44 24 14          	mov    %eax,0x14(%esp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c0029fd3:	8d 04 fd 00 00 00 00 	lea    0x0(,%edi,8),%eax
c0029fda:	0f af c6             	imul   %esi,%eax
c0029fdd:	89 04 24             	mov    %eax,(%esp)
c0029fe0:	e8 de 96 ff ff       	call   c00236c3 <malloc>
c0029fe5:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (threads == NULL || output == NULL)
c0029fe9:	83 c4 10             	add    $0x10,%esp
c0029fec:	85 db                	test   %ebx,%ebx
c0029fee:	0f 84 06 01 00 00    	je     c002a0fa <test_sleep+0x19c>
c0029ff4:	85 c0                	test   %eax,%eax
c0029ff6:	0f 84 fe 00 00 00    	je     c002a0fa <test_sleep+0x19c>
  test.start = timer_ticks () + 100;
c0029ffc:	e8 a1 9e ff ff       	call   c0023ea2 <timer_ticks>
c002a001:	83 c0 64             	add    $0x64,%eax
c002a004:	83 d2 00             	adc    $0x0,%edx
c002a007:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c002a00b:	89 54 24 30          	mov    %edx,0x30(%esp)
  test.iterations = iterations;
c002a00f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a013:	89 44 24 34          	mov    %eax,0x34(%esp)
  lock_init (&test.output_lock);
c002a017:	83 ec 0c             	sub    $0xc,%esp
c002a01a:	8d 44 24 44          	lea    0x44(%esp),%eax
c002a01e:	50                   	push   %eax
c002a01f:	e8 da 89 ff ff       	call   c00229fe <lock_init>
  test.output_pos = output;
c002a024:	8b 44 24 18          	mov    0x18(%esp),%eax
c002a028:	89 44 24 7c          	mov    %eax,0x7c(%esp)
  for (i = 0; i < thread_cnt; i++)
c002a02c:	83 c4 10             	add    $0x10,%esp
c002a02f:	83 3c 24 00          	cmpl   $0x0,(%esp)
c002a033:	0f 8e 8a 01 00 00    	jle    c002a1c3 <test_sleep+0x265>
c002a039:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c002a03d:	ba 00 00 00 00       	mov    $0x0,%edx
      t->test = &test;
c002a042:	8d 6c 24 2c          	lea    0x2c(%esp),%ebp
      snprintf (name, sizeof name, "thread %d", i);
c002a046:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
      t->test = &test;
c002a04a:	89 2b                	mov    %ebp,(%ebx)
      t->id = i;
c002a04c:	89 53 04             	mov    %edx,0x4(%ebx)
      t->duration = (i + 1) * 10;
c002a04f:	8d 72 01             	lea    0x1(%edx),%esi
c002a052:	8d 04 b6             	lea    (%esi,%esi,4),%eax
c002a055:	01 c0                	add    %eax,%eax
c002a057:	89 43 08             	mov    %eax,0x8(%ebx)
      t->iterations = 0;
c002a05a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      snprintf (name, sizeof name, "thread %d", i);
c002a061:	52                   	push   %edx
c002a062:	68 a2 f8 02 c0       	push   $0xc002f8a2
c002a067:	6a 10                	push   $0x10
c002a069:	57                   	push   %edi
c002a06a:	e8 7c cf ff ff       	call   c0026feb <snprintf>
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002a06f:	53                   	push   %ebx
c002a070:	68 e0 9e 02 c0       	push   $0xc0029ee0
c002a075:	6a 1f                	push   $0x1f
c002a077:	57                   	push   %edi
c002a078:	e8 52 73 ff ff       	call   c00213cf <thread_create>
c002a07d:	83 c3 10             	add    $0x10,%ebx
  for (i = 0; i < thread_cnt; i++)
c002a080:	89 f2                	mov    %esi,%edx
c002a082:	83 c4 20             	add    $0x20,%esp
c002a085:	39 34 24             	cmp    %esi,(%esp)
c002a088:	75 c0                	jne    c002a04a <test_sleep+0xec>
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002a08a:	83 ec 08             	sub    $0x8,%esp
c002a08d:	0f af 74 24 14       	imul   0x14(%esp),%esi
c002a092:	8d 04 b6             	lea    (%esi,%esi,4),%eax
c002a095:	8d 84 00 c8 00 00 00 	lea    0xc8(%eax,%eax,1),%eax
c002a09c:	99                   	cltd   
c002a09d:	52                   	push   %edx
c002a09e:	50                   	push   %eax
c002a09f:	e8 43 9e ff ff       	call   c0023ee7 <timer_sleep>
  lock_acquire (&test.output_lock);
c002a0a4:	83 c4 04             	add    $0x4,%esp
c002a0a7:	8d 44 24 44          	lea    0x44(%esp),%eax
c002a0ab:	50                   	push   %eax
c002a0ac:	e8 c1 8a ff ff       	call   c0022b72 <lock_acquire>
  for (op = output; op < test.output_pos; op++) 
c002a0b1:	83 c4 10             	add    $0x10,%esp
c002a0b4:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a0b8:	3b 44 24 6c          	cmp    0x6c(%esp),%eax
c002a0bc:	0f 83 cc 00 00 00    	jae    c002a18e <test_sleep+0x230>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002a0c2:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a0c6:	8b 18                	mov    (%eax),%ebx
c002a0c8:	85 db                	test   %ebx,%ebx
c002a0ca:	78 44                	js     c002a110 <test_sleep+0x1b2>
c002a0cc:	39 1c 24             	cmp    %ebx,(%esp)
c002a0cf:	7e 3f                	jle    c002a110 <test_sleep+0x1b2>
c002a0d1:	8b 74 24 08          	mov    0x8(%esp),%esi
c002a0d5:	bd 00 00 00 00       	mov    $0x0,%ebp
c002a0da:	eb 78                	jmp    c002a154 <test_sleep+0x1f6>
  ASSERT (!thread_mlfqs);
c002a0dc:	83 ec 0c             	sub    $0xc,%esp
c002a0df:	68 94 f8 02 c0       	push   $0xc002f894
c002a0e4:	68 3f d9 02 c0       	push   $0xc002d93f
c002a0e9:	68 f8 d6 02 c0       	push   $0xc002d6f8
c002a0ee:	6a 3c                	push   $0x3c
c002a0f0:	68 cc f8 02 c0       	push   $0xc002f8cc
c002a0f5:	e8 13 e2 ff ff       	call   c002830d <debug_panic>
    PANIC ("couldn't allocate memory for test");
c002a0fa:	68 d4 f9 02 c0       	push   $0xc002f9d4
c002a0ff:	68 f8 d6 02 c0       	push   $0xc002d6f8
c002a104:	6a 48                	push   $0x48
c002a106:	68 cc f8 02 c0       	push   $0xc002f8cc
c002a10b:	e8 fd e1 ff ff       	call   c002830d <debug_panic>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002a110:	83 ec 0c             	sub    $0xc,%esp
c002a113:	68 ac f8 02 c0       	push   $0xc002f8ac
c002a118:	68 3f d9 02 c0       	push   $0xc002d93f
c002a11d:	68 f8 d6 02 c0       	push   $0xc002d6f8
c002a122:	6a 6e                	push   $0x6e
c002a124:	68 cc f8 02 c0       	push   $0xc002f8cc
c002a129:	e8 df e1 ff ff       	call   c002830d <debug_panic>
        fail ("thread %d woke up out of order (%d > %d)!",
c002a12e:	57                   	push   %edi
c002a12f:	55                   	push   %ebp
c002a130:	ff 73 04             	pushl  0x4(%ebx)
c002a133:	68 2c fa 02 c0       	push   $0xc002fa2c
c002a138:	e8 46 fd ff ff       	call   c0029e83 <fail>
c002a13d:	83 c4 10             	add    $0x10,%esp
  for (op = output; op < test.output_pos; op++) 
c002a140:	83 c6 04             	add    $0x4,%esi
c002a143:	39 74 24 6c          	cmp    %esi,0x6c(%esp)
c002a147:	76 3f                	jbe    c002a188 <test_sleep+0x22a>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002a149:	8b 1e                	mov    (%esi),%ebx
c002a14b:	85 db                	test   %ebx,%ebx
c002a14d:	78 c1                	js     c002a110 <test_sleep+0x1b2>
c002a14f:	39 1c 24             	cmp    %ebx,(%esp)
c002a152:	7e bc                	jle    c002a110 <test_sleep+0x1b2>
      t = threads + *op;
c002a154:	c1 e3 04             	shl    $0x4,%ebx
c002a157:	03 5c 24 04          	add    0x4(%esp),%ebx
      new_prod = ++t->iterations * t->duration;
c002a15b:	8b 43 0c             	mov    0xc(%ebx),%eax
c002a15e:	40                   	inc    %eax
c002a15f:	89 43 0c             	mov    %eax,0xc(%ebx)
c002a162:	8b 53 08             	mov    0x8(%ebx),%edx
c002a165:	89 c7                	mov    %eax,%edi
c002a167:	0f af fa             	imul   %edx,%edi
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002a16a:	83 ec 0c             	sub    $0xc,%esp
c002a16d:	57                   	push   %edi
c002a16e:	50                   	push   %eax
c002a16f:	52                   	push   %edx
c002a170:	ff 73 04             	pushl  0x4(%ebx)
c002a173:	68 f8 f9 02 c0       	push   $0xc002f9f8
c002a178:	e8 62 fc ff ff       	call   c0029ddf <msg>
      if (new_prod >= product)
c002a17d:	83 c4 20             	add    $0x20,%esp
c002a180:	39 ef                	cmp    %ebp,%edi
c002a182:	7c aa                	jl     c002a12e <test_sleep+0x1d0>
        product = new_prod;
c002a184:	89 fd                	mov    %edi,%ebp
c002a186:	eb b8                	jmp    c002a140 <test_sleep+0x1e2>
  for (i = 0; i < thread_cnt; i++)
c002a188:	83 3c 24 00          	cmpl   $0x0,(%esp)
c002a18c:	7e 71                	jle    c002a1ff <test_sleep+0x2a1>
c002a18e:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a192:	8d 70 0c             	lea    0xc(%eax),%esi
        product = new_prod;
c002a195:	bb 00 00 00 00       	mov    $0x0,%ebx
c002a19a:	8b 2c 24             	mov    (%esp),%ebp
c002a19d:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002a1a1:	eb 08                	jmp    c002a1ab <test_sleep+0x24d>
  for (i = 0; i < thread_cnt; i++)
c002a1a3:	43                   	inc    %ebx
c002a1a4:	83 c6 10             	add    $0x10,%esi
c002a1a7:	39 dd                	cmp    %ebx,%ebp
c002a1a9:	7e 54                	jle    c002a1ff <test_sleep+0x2a1>
    if (threads[i].iterations != iterations)
c002a1ab:	8b 06                	mov    (%esi),%eax
c002a1ad:	39 c7                	cmp    %eax,%edi
c002a1af:	74 f2                	je     c002a1a3 <test_sleep+0x245>
      fail ("thread %d woke up %d times instead of %d",
c002a1b1:	57                   	push   %edi
c002a1b2:	50                   	push   %eax
c002a1b3:	53                   	push   %ebx
c002a1b4:	68 58 fa 02 c0       	push   $0xc002fa58
c002a1b9:	e8 c5 fc ff ff       	call   c0029e83 <fail>
c002a1be:	83 c4 10             	add    $0x10,%esp
c002a1c1:	eb e0                	jmp    c002a1a3 <test_sleep+0x245>
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002a1c3:	83 ec 08             	sub    $0x8,%esp
c002a1c6:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a1ca:	0f af 44 24 14       	imul   0x14(%esp),%eax
c002a1cf:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002a1d2:	8d 84 00 c8 00 00 00 	lea    0xc8(%eax,%eax,1),%eax
c002a1d9:	99                   	cltd   
c002a1da:	52                   	push   %edx
c002a1db:	50                   	push   %eax
c002a1dc:	e8 06 9d ff ff       	call   c0023ee7 <timer_sleep>
  lock_acquire (&test.output_lock);
c002a1e1:	83 c4 04             	add    $0x4,%esp
c002a1e4:	8d 44 24 44          	lea    0x44(%esp),%eax
c002a1e8:	50                   	push   %eax
c002a1e9:	e8 84 89 ff ff       	call   c0022b72 <lock_acquire>
  for (op = output; op < test.output_pos; op++) 
c002a1ee:	83 c4 10             	add    $0x10,%esp
c002a1f1:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a1f5:	3b 44 24 6c          	cmp    0x6c(%esp),%eax
c002a1f9:	0f 82 c3 fe ff ff    	jb     c002a0c2 <test_sleep+0x164>
  lock_release (&test.output_lock);
c002a1ff:	83 ec 0c             	sub    $0xc,%esp
c002a202:	8d 44 24 44          	lea    0x44(%esp),%eax
c002a206:	50                   	push   %eax
c002a207:	e8 03 8b ff ff       	call   c0022d0f <lock_release>
  free (output);
c002a20c:	83 c4 04             	add    $0x4,%esp
c002a20f:	ff 74 24 14          	pushl  0x14(%esp)
c002a213:	e8 4e 96 ff ff       	call   c0023866 <free>
  free (threads);
c002a218:	83 c4 04             	add    $0x4,%esp
c002a21b:	ff 74 24 10          	pushl  0x10(%esp)
c002a21f:	e8 42 96 ff ff       	call   c0023866 <free>
}
c002a224:	83 c4 10             	add    $0x10,%esp
c002a227:	83 c4 7c             	add    $0x7c,%esp
c002a22a:	5b                   	pop    %ebx
c002a22b:	5e                   	pop    %esi
c002a22c:	5f                   	pop    %edi
c002a22d:	5d                   	pop    %ebp
c002a22e:	c3                   	ret    

c002a22f <test_alarm_single>:
{
c002a22f:	83 ec 0c             	sub    $0xc,%esp
  test_sleep (5, 1);
c002a232:	ba 01 00 00 00       	mov    $0x1,%edx
c002a237:	b8 05 00 00 00       	mov    $0x5,%eax
c002a23c:	e8 1d fd ff ff       	call   c0029f5e <test_sleep>
}
c002a241:	83 c4 0c             	add    $0xc,%esp
c002a244:	c3                   	ret    

c002a245 <test_alarm_multiple>:
{
c002a245:	83 ec 0c             	sub    $0xc,%esp
  test_sleep (5, 7);
c002a248:	ba 07 00 00 00       	mov    $0x7,%edx
c002a24d:	b8 05 00 00 00       	mov    $0x5,%eax
c002a252:	e8 07 fd ff ff       	call   c0029f5e <test_sleep>
}
c002a257:	83 c4 0c             	add    $0xc,%esp
c002a25a:	c3                   	ret    

c002a25b <sleeper>:
}

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002a25b:	55                   	push   %ebp
c002a25c:	57                   	push   %edi
c002a25d:	56                   	push   %esi
c002a25e:	53                   	push   %ebx
c002a25f:	83 ec 14             	sub    $0x14,%esp
c002a262:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  struct sleep_test *test = test_;
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002a266:	6a 00                	push   $0x0
c002a268:	6a 01                	push   $0x1
c002a26a:	e8 78 9c ff ff       	call   c0023ee7 <timer_sleep>

  for (i = 1; i <= test->iterations; i++) 
c002a26f:	83 c4 10             	add    $0x10,%esp
c002a272:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c002a276:	7e 49                	jle    c002a2c1 <sleeper+0x66>
c002a278:	bd 01 00 00 00       	mov    $0x1,%ebp
    {
      int64_t sleep_until = test->start + i * 10;
c002a27d:	8d 44 ad 00          	lea    0x0(%ebp,%ebp,4),%eax
c002a281:	8d 34 00             	lea    (%eax,%eax,1),%esi
c002a284:	89 f7                	mov    %esi,%edi
c002a286:	c1 ff 1f             	sar    $0x1f,%edi
c002a289:	03 33                	add    (%ebx),%esi
c002a28b:	13 7b 04             	adc    0x4(%ebx),%edi
      timer_sleep (sleep_until - timer_ticks ());
c002a28e:	e8 0f 9c ff ff       	call   c0023ea2 <timer_ticks>
c002a293:	83 ec 08             	sub    $0x8,%esp
c002a296:	29 c6                	sub    %eax,%esi
c002a298:	19 d7                	sbb    %edx,%edi
c002a29a:	57                   	push   %edi
c002a29b:	56                   	push   %esi
c002a29c:	e8 46 9c ff ff       	call   c0023ee7 <timer_sleep>
      *test->output_pos++ = timer_ticks () - test->start;
c002a2a1:	8b 73 0c             	mov    0xc(%ebx),%esi
c002a2a4:	8d 46 04             	lea    0x4(%esi),%eax
c002a2a7:	89 43 0c             	mov    %eax,0xc(%ebx)
c002a2aa:	e8 f3 9b ff ff       	call   c0023ea2 <timer_ticks>
c002a2af:	2b 03                	sub    (%ebx),%eax
c002a2b1:	89 06                	mov    %eax,(%esi)
      thread_yield ();
c002a2b3:	e8 37 70 ff ff       	call   c00212ef <thread_yield>
  for (i = 1; i <= test->iterations; i++) 
c002a2b8:	45                   	inc    %ebp
c002a2b9:	83 c4 10             	add    $0x10,%esp
c002a2bc:	39 6b 08             	cmp    %ebp,0x8(%ebx)
c002a2bf:	7d bc                	jge    c002a27d <sleeper+0x22>
    }
}
c002a2c1:	83 c4 0c             	add    $0xc,%esp
c002a2c4:	5b                   	pop    %ebx
c002a2c5:	5e                   	pop    %esi
c002a2c6:	5f                   	pop    %edi
c002a2c7:	5d                   	pop    %ebp
c002a2c8:	c3                   	ret    

c002a2c9 <test_alarm_simultaneous>:
{
c002a2c9:	55                   	push   %ebp
c002a2ca:	57                   	push   %edi
c002a2cb:	56                   	push   %esi
c002a2cc:	53                   	push   %ebx
c002a2cd:	83 ec 2c             	sub    $0x2c,%esp
  ASSERT (!thread_mlfqs);
c002a2d0:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002a2d7:	0f 85 17 01 00 00    	jne    c002a3f4 <test_alarm_simultaneous+0x12b>
  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002a2dd:	83 ec 04             	sub    $0x4,%esp
c002a2e0:	6a 05                	push   $0x5
c002a2e2:	6a 03                	push   $0x3
c002a2e4:	68 f0 f8 02 c0       	push   $0xc002f8f0
c002a2e9:	e8 f1 fa ff ff       	call   c0029ddf <msg>
  msg ("Each thread sleeps 10 ticks each time.");
c002a2ee:	c7 04 24 b0 fa 02 c0 	movl   $0xc002fab0,(%esp)
c002a2f5:	e8 e5 fa ff ff       	call   c0029ddf <msg>
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002a2fa:	c7 04 24 d8 fa 02 c0 	movl   $0xc002fad8,(%esp)
c002a301:	e8 d9 fa ff ff       	call   c0029ddf <msg>
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002a306:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
c002a30d:	e8 b1 93 ff ff       	call   c00236c3 <malloc>
c002a312:	89 c6                	mov    %eax,%esi
  if (output == NULL)
c002a314:	83 c4 10             	add    $0x10,%esp
c002a317:	85 c0                	test   %eax,%eax
c002a319:	0f 84 f3 00 00 00    	je     c002a412 <test_alarm_simultaneous+0x149>
  test.start = timer_ticks () + 100;
c002a31f:	e8 7e 9b ff ff       	call   c0023ea2 <timer_ticks>
c002a324:	83 c0 64             	add    $0x64,%eax
c002a327:	83 d2 00             	adc    $0x0,%edx
c002a32a:	89 04 24             	mov    %eax,(%esp)
c002a32d:	89 54 24 04          	mov    %edx,0x4(%esp)
  test.iterations = iterations;
c002a331:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
c002a338:	00 
  test.output_pos = output;
c002a339:	89 74 24 0c          	mov    %esi,0xc(%esp)
  for (i = 0; i < thread_cnt; i++)
c002a33d:	bb 00 00 00 00       	mov    $0x0,%ebx
      snprintf (name, sizeof name, "thread %d", i);
c002a342:	8d 7c 24 10          	lea    0x10(%esp),%edi
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002a346:	89 e5                	mov    %esp,%ebp
      snprintf (name, sizeof name, "thread %d", i);
c002a348:	53                   	push   %ebx
c002a349:	68 a2 f8 02 c0       	push   $0xc002f8a2
c002a34e:	6a 10                	push   $0x10
c002a350:	57                   	push   %edi
c002a351:	e8 95 cc ff ff       	call   c0026feb <snprintf>
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002a356:	55                   	push   %ebp
c002a357:	68 5b a2 02 c0       	push   $0xc002a25b
c002a35c:	6a 1f                	push   $0x1f
c002a35e:	57                   	push   %edi
c002a35f:	e8 6b 70 ff ff       	call   c00213cf <thread_create>
  for (i = 0; i < thread_cnt; i++)
c002a364:	43                   	inc    %ebx
c002a365:	83 c4 20             	add    $0x20,%esp
c002a368:	83 fb 03             	cmp    $0x3,%ebx
c002a36b:	75 db                	jne    c002a348 <test_alarm_simultaneous+0x7f>
  timer_sleep (100 + iterations * 10 + 100);
c002a36d:	83 ec 08             	sub    $0x8,%esp
c002a370:	6a 00                	push   $0x0
c002a372:	68 fa 00 00 00       	push   $0xfa
c002a377:	e8 6b 9b ff ff       	call   c0023ee7 <timer_sleep>
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002a37c:	83 c4 08             	add    $0x8,%esp
c002a37f:	ff 36                	pushl  (%esi)
c002a381:	68 1c fb 02 c0       	push   $0xc002fb1c
c002a386:	e8 54 fa ff ff       	call   c0029ddf <msg>
  for (i = 1; i < test.output_pos - output; i++) 
c002a38b:	89 f5                	mov    %esi,%ebp
c002a38d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a391:	29 f0                	sub    %esi,%eax
c002a393:	83 c4 10             	add    $0x10,%esp
c002a396:	83 f8 07             	cmp    $0x7,%eax
c002a399:	7e 48                	jle    c002a3e3 <test_alarm_simultaneous+0x11a>
c002a39b:	bb 01 00 00 00       	mov    $0x1,%ebx
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002a3a0:	bf 03 00 00 00       	mov    $0x3,%edi
c002a3a5:	8b 04 9e             	mov    (%esi,%ebx,4),%eax
c002a3a8:	2b 44 9e fc          	sub    -0x4(%esi,%ebx,4),%eax
c002a3ac:	50                   	push   %eax
c002a3ad:	89 d8                	mov    %ebx,%eax
c002a3af:	99                   	cltd   
c002a3b0:	f7 ff                	idiv   %edi
c002a3b2:	52                   	push   %edx
c002a3b3:	b8 56 55 55 55       	mov    $0x55555556,%eax
c002a3b8:	f7 eb                	imul   %ebx
c002a3ba:	89 d1                	mov    %edx,%ecx
c002a3bc:	89 d8                	mov    %ebx,%eax
c002a3be:	c1 f8 1f             	sar    $0x1f,%eax
c002a3c1:	89 c2                	mov    %eax,%edx
c002a3c3:	89 c8                	mov    %ecx,%eax
c002a3c5:	29 d0                	sub    %edx,%eax
c002a3c7:	50                   	push   %eax
c002a3c8:	68 4c fb 02 c0       	push   $0xc002fb4c
c002a3cd:	e8 0d fa ff ff       	call   c0029ddf <msg>
  for (i = 1; i < test.output_pos - output; i++) 
c002a3d2:	43                   	inc    %ebx
c002a3d3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a3d7:	29 e8                	sub    %ebp,%eax
c002a3d9:	c1 f8 02             	sar    $0x2,%eax
c002a3dc:	83 c4 10             	add    $0x10,%esp
c002a3df:	39 c3                	cmp    %eax,%ebx
c002a3e1:	7c c2                	jl     c002a3a5 <test_alarm_simultaneous+0xdc>
  free (output);
c002a3e3:	83 ec 0c             	sub    $0xc,%esp
c002a3e6:	56                   	push   %esi
c002a3e7:	e8 7a 94 ff ff       	call   c0023866 <free>
}
c002a3ec:	83 c4 3c             	add    $0x3c,%esp
c002a3ef:	5b                   	pop    %ebx
c002a3f0:	5e                   	pop    %esi
c002a3f1:	5f                   	pop    %edi
c002a3f2:	5d                   	pop    %ebp
c002a3f3:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002a3f4:	83 ec 0c             	sub    $0xc,%esp
c002a3f7:	68 94 f8 02 c0       	push   $0xc002f894
c002a3fc:	68 3f d9 02 c0       	push   $0xc002d93f
c002a401:	68 04 d7 02 c0       	push   $0xc002d704
c002a406:	6a 28                	push   $0x28
c002a408:	68 84 fa 02 c0       	push   $0xc002fa84
c002a40d:	e8 fb de ff ff       	call   c002830d <debug_panic>
    PANIC ("couldn't allocate memory for test");
c002a412:	68 d4 f9 02 c0       	push   $0xc002f9d4
c002a417:	68 04 d7 02 c0       	push   $0xc002d704
c002a41c:	6a 31                	push   $0x31
c002a41e:	68 84 fa 02 c0       	push   $0xc002fa84
c002a423:	e8 e5 de ff ff       	call   c002830d <debug_panic>

c002a428 <alarm_priority_thread>:
    sema_down (&wait_sema);
}

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002a428:	57                   	push   %edi
c002a429:	56                   	push   %esi
c002a42a:	83 ec 04             	sub    $0x4,%esp
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002a42d:	e8 70 9a ff ff       	call   c0023ea2 <timer_ticks>
c002a432:	89 c6                	mov    %eax,%esi
c002a434:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) == 0)
c002a436:	83 ec 08             	sub    $0x8,%esp
c002a439:	57                   	push   %edi
c002a43a:	56                   	push   %esi
c002a43b:	e8 8b 9a ff ff       	call   c0023ecb <timer_elapsed>
c002a440:	83 c4 10             	add    $0x10,%esp
c002a443:	09 c2                	or     %eax,%edx
c002a445:	74 ef                	je     c002a436 <alarm_priority_thread+0xe>
    continue;

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002a447:	8b 35 d0 9e 03 c0    	mov    0xc0039ed0,%esi
c002a44d:	8b 3d d4 9e 03 c0    	mov    0xc0039ed4,%edi
c002a453:	e8 4a 9a ff ff       	call   c0023ea2 <timer_ticks>
c002a458:	83 ec 08             	sub    $0x8,%esp
c002a45b:	29 c6                	sub    %eax,%esi
c002a45d:	19 d7                	sbb    %edx,%edi
c002a45f:	57                   	push   %edi
c002a460:	56                   	push   %esi
c002a461:	e8 81 9a ff ff       	call   c0023ee7 <timer_sleep>

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002a466:	e8 ca 66 ff ff       	call   c0020b35 <thread_name>
c002a46b:	83 c4 08             	add    $0x8,%esp
c002a46e:	50                   	push   %eax
c002a46f:	68 7c fb 02 c0       	push   $0xc002fb7c
c002a474:	e8 66 f9 ff ff       	call   c0029ddf <msg>

  sema_up (&wait_sema);
c002a479:	c7 04 24 b8 9e 03 c0 	movl   $0xc0039eb8,(%esp)
c002a480:	e8 ee 83 ff ff       	call   c0022873 <sema_up>
}
c002a485:	83 c4 14             	add    $0x14,%esp
c002a488:	5e                   	pop    %esi
c002a489:	5f                   	pop    %edi
c002a48a:	c3                   	ret    

c002a48b <test_alarm_priority>:
{
c002a48b:	55                   	push   %ebp
c002a48c:	57                   	push   %edi
c002a48d:	56                   	push   %esi
c002a48e:	53                   	push   %ebx
c002a48f:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT (!thread_mlfqs);
c002a492:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002a499:	0f 85 94 00 00 00    	jne    c002a533 <test_alarm_priority+0xa8>
  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002a49f:	e8 fe 99 ff ff       	call   c0023ea2 <timer_ticks>
c002a4a4:	05 f4 01 00 00       	add    $0x1f4,%eax
c002a4a9:	83 d2 00             	adc    $0x0,%edx
c002a4ac:	a3 d0 9e 03 c0       	mov    %eax,0xc0039ed0
c002a4b1:	89 15 d4 9e 03 c0    	mov    %edx,0xc0039ed4
  sema_init (&wait_sema, 0);
c002a4b7:	83 ec 08             	sub    $0x8,%esp
c002a4ba:	6a 00                	push   $0x0
c002a4bc:	68 b8 9e 03 c0       	push   $0xc0039eb8
c002a4c1:	e8 5e 82 ff ff       	call   c0022724 <sema_init>
c002a4c6:	83 c4 10             	add    $0x10,%esp
c002a4c9:	bb 05 00 00 00       	mov    $0x5,%ebx
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002a4ce:	bd 0a 00 00 00       	mov    $0xa,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002a4d3:	89 e7                	mov    %esp,%edi
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002a4d5:	89 d8                	mov    %ebx,%eax
c002a4d7:	99                   	cltd   
c002a4d8:	f7 fd                	idiv   %ebp
c002a4da:	be 1e 00 00 00       	mov    $0x1e,%esi
c002a4df:	29 d6                	sub    %edx,%esi
      snprintf (name, sizeof name, "priority %d", priority);
c002a4e1:	56                   	push   %esi
c002a4e2:	68 8f fb 02 c0       	push   $0xc002fb8f
c002a4e7:	6a 10                	push   $0x10
c002a4e9:	57                   	push   %edi
c002a4ea:	e8 fc ca ff ff       	call   c0026feb <snprintf>
      thread_create (name, priority, alarm_priority_thread, NULL);
c002a4ef:	6a 00                	push   $0x0
c002a4f1:	68 28 a4 02 c0       	push   $0xc002a428
c002a4f6:	56                   	push   %esi
c002a4f7:	57                   	push   %edi
c002a4f8:	e8 d2 6e ff ff       	call   c00213cf <thread_create>
c002a4fd:	43                   	inc    %ebx
  for (i = 0; i < 10; i++) 
c002a4fe:	83 c4 20             	add    $0x20,%esp
c002a501:	83 fb 0f             	cmp    $0xf,%ebx
c002a504:	75 cf                	jne    c002a4d5 <test_alarm_priority+0x4a>
  thread_set_priority (PRI_MIN);
c002a506:	83 ec 0c             	sub    $0xc,%esp
c002a509:	6a 00                	push   $0x0
c002a50b:	e8 da 6f ff ff       	call   c00214ea <thread_set_priority>
c002a510:	83 c4 10             	add    $0x10,%esp
c002a513:	bb 0a 00 00 00       	mov    $0xa,%ebx
    sema_down (&wait_sema);
c002a518:	83 ec 0c             	sub    $0xc,%esp
c002a51b:	68 b8 9e 03 c0       	push   $0xc0039eb8
c002a520:	e8 6d 82 ff ff       	call   c0022792 <sema_down>
  for (i = 0; i < 10; i++)
c002a525:	83 c4 10             	add    $0x10,%esp
c002a528:	4b                   	dec    %ebx
c002a529:	75 ed                	jne    c002a518 <test_alarm_priority+0x8d>
}
c002a52b:	83 c4 1c             	add    $0x1c,%esp
c002a52e:	5b                   	pop    %ebx
c002a52f:	5e                   	pop    %esi
c002a530:	5f                   	pop    %edi
c002a531:	5d                   	pop    %ebp
c002a532:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002a533:	83 ec 0c             	sub    $0xc,%esp
c002a536:	68 94 f8 02 c0       	push   $0xc002f894
c002a53b:	68 3f d9 02 c0       	push   $0xc002d93f
c002a540:	68 10 d7 02 c0       	push   $0xc002d710
c002a545:	6a 16                	push   $0x16
c002a547:	68 9c fb 02 c0       	push   $0xc002fb9c
c002a54c:	e8 bc dd ff ff       	call   c002830d <debug_panic>

c002a551 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002a551:	83 ec 14             	sub    $0x14,%esp
  timer_sleep (0);
c002a554:	6a 00                	push   $0x0
c002a556:	6a 00                	push   $0x0
c002a558:	e8 8a 99 ff ff       	call   c0023ee7 <timer_sleep>
  pass ();
c002a55d:	e8 67 f9 ff ff       	call   c0029ec9 <pass>
}
c002a562:	83 c4 1c             	add    $0x1c,%esp
c002a565:	c3                   	ret    

c002a566 <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002a566:	83 ec 14             	sub    $0x14,%esp
  timer_sleep (-100);
c002a569:	6a ff                	push   $0xffffffff
c002a56b:	6a 9c                	push   $0xffffff9c
c002a56d:	e8 75 99 ff ff       	call   c0023ee7 <timer_sleep>
  pass ();
c002a572:	e8 52 f9 ff ff       	call   c0029ec9 <pass>
}
c002a577:	83 c4 1c             	add    $0x1c,%esp
c002a57a:	c3                   	ret    

c002a57b <changing_thread>:
  msg ("Thread 2 should have just exited.");
}

static void
changing_thread (void *aux UNUSED) 
{
c002a57b:	83 ec 18             	sub    $0x18,%esp
  msg ("Thread 2 now lowering priority.");
c002a57e:	68 c4 fb 02 c0       	push   $0xc002fbc4
c002a583:	e8 57 f8 ff ff       	call   c0029ddf <msg>
  thread_set_priority (PRI_DEFAULT - 1);
c002a588:	c7 04 24 1e 00 00 00 	movl   $0x1e,(%esp)
c002a58f:	e8 56 6f ff ff       	call   c00214ea <thread_set_priority>
  msg ("Thread 2 exiting.");
c002a594:	c7 04 24 82 fc 02 c0 	movl   $0xc002fc82,(%esp)
c002a59b:	e8 3f f8 ff ff       	call   c0029ddf <msg>
}
c002a5a0:	83 c4 1c             	add    $0x1c,%esp
c002a5a3:	c3                   	ret    

c002a5a4 <test_priority_change>:
{
c002a5a4:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (!thread_mlfqs);
c002a5a7:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002a5ae:	75 49                	jne    c002a5f9 <test_priority_change+0x55>
  msg ("Creating a high-priority thread 2.");
c002a5b0:	83 ec 0c             	sub    $0xc,%esp
c002a5b3:	68 0c fc 02 c0       	push   $0xc002fc0c
c002a5b8:	e8 22 f8 ff ff       	call   c0029ddf <msg>
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002a5bd:	6a 00                	push   $0x0
c002a5bf:	68 7b a5 02 c0       	push   $0xc002a57b
c002a5c4:	6a 20                	push   $0x20
c002a5c6:	68 94 fc 02 c0       	push   $0xc002fc94
c002a5cb:	e8 ff 6d ff ff       	call   c00213cf <thread_create>
  msg ("Thread 2 should have just lowered its priority.");
c002a5d0:	83 c4 14             	add    $0x14,%esp
c002a5d3:	68 30 fc 02 c0       	push   $0xc002fc30
c002a5d8:	e8 02 f8 ff ff       	call   c0029ddf <msg>
  thread_set_priority (PRI_DEFAULT - 2);
c002a5dd:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
c002a5e4:	e8 01 6f ff ff       	call   c00214ea <thread_set_priority>
  msg ("Thread 2 should have just exited.");
c002a5e9:	c7 04 24 60 fc 02 c0 	movl   $0xc002fc60,(%esp)
c002a5f0:	e8 ea f7 ff ff       	call   c0029ddf <msg>
}
c002a5f5:	83 c4 1c             	add    $0x1c,%esp
c002a5f8:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002a5f9:	83 ec 0c             	sub    $0xc,%esp
c002a5fc:	68 94 f8 02 c0       	push   $0xc002f894
c002a601:	68 3f d9 02 c0       	push   $0xc002d93f
c002a606:	68 24 d7 02 c0       	push   $0xc002d724
c002a60b:	6a 10                	push   $0x10
c002a60d:	68 e4 fb 02 c0       	push   $0xc002fbe4
c002a612:	e8 f6 dc ff ff       	call   c002830d <debug_panic>

c002a617 <acquire2_thread_func>:
  msg ("acquire1: done");
}

static void
acquire2_thread_func (void *lock_) 
{
c002a617:	53                   	push   %ebx
c002a618:	83 ec 14             	sub    $0x14,%esp
c002a61b:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a61f:	53                   	push   %ebx
c002a620:	e8 4d 85 ff ff       	call   c0022b72 <lock_acquire>
  msg ("acquire2: got the lock");
c002a625:	c7 04 24 9d fc 02 c0 	movl   $0xc002fc9d,(%esp)
c002a62c:	e8 ae f7 ff ff       	call   c0029ddf <msg>
  lock_release (lock);
c002a631:	89 1c 24             	mov    %ebx,(%esp)
c002a634:	e8 d6 86 ff ff       	call   c0022d0f <lock_release>
  msg ("acquire2: done");
c002a639:	c7 04 24 b4 fc 02 c0 	movl   $0xc002fcb4,(%esp)
c002a640:	e8 9a f7 ff ff       	call   c0029ddf <msg>
}
c002a645:	83 c4 18             	add    $0x18,%esp
c002a648:	5b                   	pop    %ebx
c002a649:	c3                   	ret    

c002a64a <acquire1_thread_func>:
{
c002a64a:	53                   	push   %ebx
c002a64b:	83 ec 14             	sub    $0x14,%esp
c002a64e:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_acquire (lock);
c002a652:	53                   	push   %ebx
c002a653:	e8 1a 85 ff ff       	call   c0022b72 <lock_acquire>
  msg ("acquire1: got the lock");
c002a658:	c7 04 24 c3 fc 02 c0 	movl   $0xc002fcc3,(%esp)
c002a65f:	e8 7b f7 ff ff       	call   c0029ddf <msg>
  lock_release (lock);
c002a664:	89 1c 24             	mov    %ebx,(%esp)
c002a667:	e8 a3 86 ff ff       	call   c0022d0f <lock_release>
  msg ("acquire1: done");
c002a66c:	c7 04 24 da fc 02 c0 	movl   $0xc002fcda,(%esp)
c002a673:	e8 67 f7 ff ff       	call   c0029ddf <msg>
}
c002a678:	83 c4 18             	add    $0x18,%esp
c002a67b:	5b                   	pop    %ebx
c002a67c:	c3                   	ret    

c002a67d <test_priority_donate_one>:
{
c002a67d:	53                   	push   %ebx
c002a67e:	83 ec 48             	sub    $0x48,%esp
  ASSERT (!thread_mlfqs);
c002a681:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002a688:	0f 85 9c 00 00 00    	jne    c002a72a <test_priority_donate_one+0xad>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a68e:	e8 cc 66 ff ff       	call   c0020d5f <thread_get_priority>
c002a693:	83 f8 1f             	cmp    $0x1f,%eax
c002a696:	0f 85 ac 00 00 00    	jne    c002a748 <test_priority_donate_one+0xcb>
  lock_init (&lock);
c002a69c:	83 ec 0c             	sub    $0xc,%esp
c002a69f:	8d 5c 24 18          	lea    0x18(%esp),%ebx
c002a6a3:	53                   	push   %ebx
c002a6a4:	e8 55 83 ff ff       	call   c00229fe <lock_init>
  lock_acquire (&lock);
c002a6a9:	89 1c 24             	mov    %ebx,(%esp)
c002a6ac:	e8 c1 84 ff ff       	call   c0022b72 <lock_acquire>
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002a6b1:	53                   	push   %ebx
c002a6b2:	68 4a a6 02 c0       	push   $0xc002a64a
c002a6b7:	6a 20                	push   $0x20
c002a6b9:	68 e9 fc 02 c0       	push   $0xc002fce9
c002a6be:	e8 0c 6d ff ff       	call   c00213cf <thread_create>
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002a6c3:	83 c4 20             	add    $0x20,%esp
c002a6c6:	e8 94 66 ff ff       	call   c0020d5f <thread_get_priority>
c002a6cb:	83 ec 04             	sub    $0x4,%esp
c002a6ce:	50                   	push   %eax
c002a6cf:	6a 20                	push   $0x20
c002a6d1:	68 50 fd 02 c0       	push   $0xc002fd50
c002a6d6:	e8 04 f7 ff ff       	call   c0029ddf <msg>
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002a6db:	53                   	push   %ebx
c002a6dc:	68 17 a6 02 c0       	push   $0xc002a617
c002a6e1:	6a 21                	push   $0x21
c002a6e3:	68 f2 fc 02 c0       	push   $0xc002fcf2
c002a6e8:	e8 e2 6c ff ff       	call   c00213cf <thread_create>
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002a6ed:	83 c4 20             	add    $0x20,%esp
c002a6f0:	e8 6a 66 ff ff       	call   c0020d5f <thread_get_priority>
c002a6f5:	83 ec 04             	sub    $0x4,%esp
c002a6f8:	50                   	push   %eax
c002a6f9:	6a 21                	push   $0x21
c002a6fb:	68 50 fd 02 c0       	push   $0xc002fd50
c002a700:	e8 da f6 ff ff       	call   c0029ddf <msg>
  lock_release (&lock);
c002a705:	89 1c 24             	mov    %ebx,(%esp)
c002a708:	e8 02 86 ff ff       	call   c0022d0f <lock_release>
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002a70d:	c7 04 24 8c fd 02 c0 	movl   $0xc002fd8c,(%esp)
c002a714:	e8 c6 f6 ff ff       	call   c0029ddf <msg>
  msg ("This should be the last line before finishing this test.");
c002a719:	c7 04 24 cc fd 02 c0 	movl   $0xc002fdcc,(%esp)
c002a720:	e8 ba f6 ff ff       	call   c0029ddf <msg>
}
c002a725:	83 c4 58             	add    $0x58,%esp
c002a728:	5b                   	pop    %ebx
c002a729:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002a72a:	83 ec 0c             	sub    $0xc,%esp
c002a72d:	68 94 f8 02 c0       	push   $0xc002f894
c002a732:	68 3f d9 02 c0       	push   $0xc002d93f
c002a737:	68 3c d7 02 c0       	push   $0xc002d73c
c002a73c:	6a 1b                	push   $0x1b
c002a73e:	68 fc fc 02 c0       	push   $0xc002fcfc
c002a743:	e8 c5 db ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a748:	83 ec 0c             	sub    $0xc,%esp
c002a74b:	68 28 fd 02 c0       	push   $0xc002fd28
c002a750:	68 3f d9 02 c0       	push   $0xc002d93f
c002a755:	68 3c d7 02 c0       	push   $0xc002d73c
c002a75a:	6a 1e                	push   $0x1e
c002a75c:	68 fc fc 02 c0       	push   $0xc002fcfc
c002a761:	e8 a7 db ff ff       	call   c002830d <debug_panic>

c002a766 <b_thread_func>:
  msg ("Thread a finished.");
}

static void
b_thread_func (void *lock_) 
{
c002a766:	53                   	push   %ebx
c002a767:	83 ec 14             	sub    $0x14,%esp
c002a76a:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a76e:	53                   	push   %ebx
c002a76f:	e8 fe 83 ff ff       	call   c0022b72 <lock_acquire>
  msg ("Thread b acquired lock b.");
c002a774:	c7 04 24 05 fe 02 c0 	movl   $0xc002fe05,(%esp)
c002a77b:	e8 5f f6 ff ff       	call   c0029ddf <msg>
  lock_release (lock);
c002a780:	89 1c 24             	mov    %ebx,(%esp)
c002a783:	e8 87 85 ff ff       	call   c0022d0f <lock_release>
  msg ("Thread b finished.");
c002a788:	c7 04 24 1f fe 02 c0 	movl   $0xc002fe1f,(%esp)
c002a78f:	e8 4b f6 ff ff       	call   c0029ddf <msg>
}
c002a794:	83 c4 18             	add    $0x18,%esp
c002a797:	5b                   	pop    %ebx
c002a798:	c3                   	ret    

c002a799 <a_thread_func>:
{
c002a799:	53                   	push   %ebx
c002a79a:	83 ec 14             	sub    $0x14,%esp
c002a79d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_acquire (lock);
c002a7a1:	53                   	push   %ebx
c002a7a2:	e8 cb 83 ff ff       	call   c0022b72 <lock_acquire>
  msg ("Thread a acquired lock a.");
c002a7a7:	c7 04 24 32 fe 02 c0 	movl   $0xc002fe32,(%esp)
c002a7ae:	e8 2c f6 ff ff       	call   c0029ddf <msg>
  lock_release (lock);
c002a7b3:	89 1c 24             	mov    %ebx,(%esp)
c002a7b6:	e8 54 85 ff ff       	call   c0022d0f <lock_release>
  msg ("Thread a finished.");
c002a7bb:	c7 04 24 4c fe 02 c0 	movl   $0xc002fe4c,(%esp)
c002a7c2:	e8 18 f6 ff ff       	call   c0029ddf <msg>
}
c002a7c7:	83 c4 18             	add    $0x18,%esp
c002a7ca:	5b                   	pop    %ebx
c002a7cb:	c3                   	ret    

c002a7cc <test_priority_donate_multiple>:
{
c002a7cc:	56                   	push   %esi
c002a7cd:	53                   	push   %ebx
c002a7ce:	83 ec 74             	sub    $0x74,%esp
  ASSERT (!thread_mlfqs);
c002a7d1:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002a7d8:	0f 85 e7 00 00 00    	jne    c002a8c5 <test_priority_donate_multiple+0xf9>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a7de:	e8 7c 65 ff ff       	call   c0020d5f <thread_get_priority>
c002a7e3:	83 f8 1f             	cmp    $0x1f,%eax
c002a7e6:	0f 85 f7 00 00 00    	jne    c002a8e3 <test_priority_donate_multiple+0x117>
  lock_init (&a);
c002a7ec:	83 ec 0c             	sub    $0xc,%esp
c002a7ef:	8d 5c 24 48          	lea    0x48(%esp),%ebx
c002a7f3:	53                   	push   %ebx
c002a7f4:	e8 05 82 ff ff       	call   c00229fe <lock_init>
  lock_init (&b);
c002a7f9:	83 c4 04             	add    $0x4,%esp
c002a7fc:	8d 74 24 14          	lea    0x14(%esp),%esi
c002a800:	56                   	push   %esi
c002a801:	e8 f8 81 ff ff       	call   c00229fe <lock_init>
  lock_acquire (&a);
c002a806:	89 1c 24             	mov    %ebx,(%esp)
c002a809:	e8 64 83 ff ff       	call   c0022b72 <lock_acquire>
  lock_acquire (&b);
c002a80e:	89 34 24             	mov    %esi,(%esp)
c002a811:	e8 5c 83 ff ff       	call   c0022b72 <lock_acquire>
  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002a816:	53                   	push   %ebx
c002a817:	68 99 a7 02 c0       	push   $0xc002a799
c002a81c:	6a 20                	push   $0x20
c002a81e:	68 83 ea 02 c0       	push   $0xc002ea83
c002a823:	e8 a7 6b ff ff       	call   c00213cf <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a828:	83 c4 20             	add    $0x20,%esp
c002a82b:	e8 2f 65 ff ff       	call   c0020d5f <thread_get_priority>
c002a830:	83 ec 04             	sub    $0x4,%esp
c002a833:	50                   	push   %eax
c002a834:	6a 20                	push   $0x20
c002a836:	68 90 fe 02 c0       	push   $0xc002fe90
c002a83b:	e8 9f f5 ff ff       	call   c0029ddf <msg>
  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002a840:	56                   	push   %esi
c002a841:	68 66 a7 02 c0       	push   $0xc002a766
c002a846:	6a 21                	push   $0x21
c002a848:	68 d3 f3 02 c0       	push   $0xc002f3d3
c002a84d:	e8 7d 6b ff ff       	call   c00213cf <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a852:	83 c4 20             	add    $0x20,%esp
c002a855:	e8 05 65 ff ff       	call   c0020d5f <thread_get_priority>
c002a85a:	83 ec 04             	sub    $0x4,%esp
c002a85d:	50                   	push   %eax
c002a85e:	6a 21                	push   $0x21
c002a860:	68 90 fe 02 c0       	push   $0xc002fe90
c002a865:	e8 75 f5 ff ff       	call   c0029ddf <msg>
  lock_release (&b);
c002a86a:	89 34 24             	mov    %esi,(%esp)
c002a86d:	e8 9d 84 ff ff       	call   c0022d0f <lock_release>
  msg ("Thread b should have just finished.");
c002a872:	c7 04 24 cc fe 02 c0 	movl   $0xc002fecc,(%esp)
c002a879:	e8 61 f5 ff ff       	call   c0029ddf <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a87e:	e8 dc 64 ff ff       	call   c0020d5f <thread_get_priority>
c002a883:	83 c4 0c             	add    $0xc,%esp
c002a886:	50                   	push   %eax
c002a887:	6a 20                	push   $0x20
c002a889:	68 90 fe 02 c0       	push   $0xc002fe90
c002a88e:	e8 4c f5 ff ff       	call   c0029ddf <msg>
  lock_release (&a);
c002a893:	89 1c 24             	mov    %ebx,(%esp)
c002a896:	e8 74 84 ff ff       	call   c0022d0f <lock_release>
  msg ("Thread a should have just finished.");
c002a89b:	c7 04 24 f0 fe 02 c0 	movl   $0xc002fef0,(%esp)
c002a8a2:	e8 38 f5 ff ff       	call   c0029ddf <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a8a7:	e8 b3 64 ff ff       	call   c0020d5f <thread_get_priority>
c002a8ac:	83 c4 0c             	add    $0xc,%esp
c002a8af:	50                   	push   %eax
c002a8b0:	6a 1f                	push   $0x1f
c002a8b2:	68 90 fe 02 c0       	push   $0xc002fe90
c002a8b7:	e8 23 f5 ff ff       	call   c0029ddf <msg>
}
c002a8bc:	81 c4 84 00 00 00    	add    $0x84,%esp
c002a8c2:	5b                   	pop    %ebx
c002a8c3:	5e                   	pop    %esi
c002a8c4:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002a8c5:	83 ec 0c             	sub    $0xc,%esp
c002a8c8:	68 94 f8 02 c0       	push   $0xc002f894
c002a8cd:	68 3f d9 02 c0       	push   $0xc002d93f
c002a8d2:	68 58 d7 02 c0       	push   $0xc002d758
c002a8d7:	6a 1b                	push   $0x1b
c002a8d9:	68 60 fe 02 c0       	push   $0xc002fe60
c002a8de:	e8 2a da ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a8e3:	83 ec 0c             	sub    $0xc,%esp
c002a8e6:	68 28 fd 02 c0       	push   $0xc002fd28
c002a8eb:	68 3f d9 02 c0       	push   $0xc002d93f
c002a8f0:	68 58 d7 02 c0       	push   $0xc002d758
c002a8f5:	6a 1e                	push   $0x1e
c002a8f7:	68 60 fe 02 c0       	push   $0xc002fe60
c002a8fc:	e8 0c da ff ff       	call   c002830d <debug_panic>

c002a901 <c_thread_func>:
  msg ("Thread b finished.");
}

static void
c_thread_func (void *a_ UNUSED) 
{
c002a901:	83 ec 18             	sub    $0x18,%esp
  msg ("Thread c finished.");
c002a904:	68 14 ff 02 c0       	push   $0xc002ff14
c002a909:	e8 d1 f4 ff ff       	call   c0029ddf <msg>
}
c002a90e:	83 c4 1c             	add    $0x1c,%esp
c002a911:	c3                   	ret    

c002a912 <b_thread_func>:
{
c002a912:	53                   	push   %ebx
c002a913:	83 ec 14             	sub    $0x14,%esp
c002a916:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_acquire (lock);
c002a91a:	53                   	push   %ebx
c002a91b:	e8 52 82 ff ff       	call   c0022b72 <lock_acquire>
  msg ("Thread b acquired lock b.");
c002a920:	c7 04 24 05 fe 02 c0 	movl   $0xc002fe05,(%esp)
c002a927:	e8 b3 f4 ff ff       	call   c0029ddf <msg>
  lock_release (lock);
c002a92c:	89 1c 24             	mov    %ebx,(%esp)
c002a92f:	e8 db 83 ff ff       	call   c0022d0f <lock_release>
  msg ("Thread b finished.");
c002a934:	c7 04 24 1f fe 02 c0 	movl   $0xc002fe1f,(%esp)
c002a93b:	e8 9f f4 ff ff       	call   c0029ddf <msg>
}
c002a940:	83 c4 18             	add    $0x18,%esp
c002a943:	5b                   	pop    %ebx
c002a944:	c3                   	ret    

c002a945 <a_thread_func>:
{
c002a945:	53                   	push   %ebx
c002a946:	83 ec 14             	sub    $0x14,%esp
c002a949:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_acquire (lock);
c002a94d:	53                   	push   %ebx
c002a94e:	e8 1f 82 ff ff       	call   c0022b72 <lock_acquire>
  msg ("Thread a acquired lock a.");
c002a953:	c7 04 24 32 fe 02 c0 	movl   $0xc002fe32,(%esp)
c002a95a:	e8 80 f4 ff ff       	call   c0029ddf <msg>
  lock_release (lock);
c002a95f:	89 1c 24             	mov    %ebx,(%esp)
c002a962:	e8 a8 83 ff ff       	call   c0022d0f <lock_release>
  msg ("Thread a finished.");
c002a967:	c7 04 24 4c fe 02 c0 	movl   $0xc002fe4c,(%esp)
c002a96e:	e8 6c f4 ff ff       	call   c0029ddf <msg>
}
c002a973:	83 c4 18             	add    $0x18,%esp
c002a976:	5b                   	pop    %ebx
c002a977:	c3                   	ret    

c002a978 <test_priority_donate_multiple2>:
{
c002a978:	56                   	push   %esi
c002a979:	53                   	push   %ebx
c002a97a:	83 ec 74             	sub    $0x74,%esp
  ASSERT (!thread_mlfqs);
c002a97d:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002a984:	0f 85 ee 00 00 00    	jne    c002aa78 <test_priority_donate_multiple2+0x100>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a98a:	e8 d0 63 ff ff       	call   c0020d5f <thread_get_priority>
c002a98f:	83 f8 1f             	cmp    $0x1f,%eax
c002a992:	0f 85 fe 00 00 00    	jne    c002aa96 <test_priority_donate_multiple2+0x11e>
  lock_init (&a);
c002a998:	83 ec 0c             	sub    $0xc,%esp
c002a99b:	8d 74 24 48          	lea    0x48(%esp),%esi
c002a99f:	56                   	push   %esi
c002a9a0:	e8 59 80 ff ff       	call   c00229fe <lock_init>
  lock_init (&b);
c002a9a5:	83 c4 04             	add    $0x4,%esp
c002a9a8:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c002a9ac:	53                   	push   %ebx
c002a9ad:	e8 4c 80 ff ff       	call   c00229fe <lock_init>
  lock_acquire (&a);
c002a9b2:	89 34 24             	mov    %esi,(%esp)
c002a9b5:	e8 b8 81 ff ff       	call   c0022b72 <lock_acquire>
  lock_acquire (&b);
c002a9ba:	89 1c 24             	mov    %ebx,(%esp)
c002a9bd:	e8 b0 81 ff ff       	call   c0022b72 <lock_acquire>
  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002a9c2:	56                   	push   %esi
c002a9c3:	68 45 a9 02 c0       	push   $0xc002a945
c002a9c8:	6a 22                	push   $0x22
c002a9ca:	68 83 ea 02 c0       	push   $0xc002ea83
c002a9cf:	e8 fb 69 ff ff       	call   c00213cf <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a9d4:	83 c4 20             	add    $0x20,%esp
c002a9d7:	e8 83 63 ff ff       	call   c0020d5f <thread_get_priority>
c002a9dc:	83 ec 04             	sub    $0x4,%esp
c002a9df:	50                   	push   %eax
c002a9e0:	6a 22                	push   $0x22
c002a9e2:	68 90 fe 02 c0       	push   $0xc002fe90
c002a9e7:	e8 f3 f3 ff ff       	call   c0029ddf <msg>
  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002a9ec:	6a 00                	push   $0x0
c002a9ee:	68 01 a9 02 c0       	push   $0xc002a901
c002a9f3:	6a 20                	push   $0x20
c002a9f5:	68 6e ee 02 c0       	push   $0xc002ee6e
c002a9fa:	e8 d0 69 ff ff       	call   c00213cf <thread_create>
  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002a9ff:	83 c4 20             	add    $0x20,%esp
c002aa02:	53                   	push   %ebx
c002aa03:	68 12 a9 02 c0       	push   $0xc002a912
c002aa08:	6a 24                	push   $0x24
c002aa0a:	68 d3 f3 02 c0       	push   $0xc002f3d3
c002aa0f:	e8 bb 69 ff ff       	call   c00213cf <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002aa14:	e8 46 63 ff ff       	call   c0020d5f <thread_get_priority>
c002aa19:	83 c4 0c             	add    $0xc,%esp
c002aa1c:	50                   	push   %eax
c002aa1d:	6a 24                	push   $0x24
c002aa1f:	68 90 fe 02 c0       	push   $0xc002fe90
c002aa24:	e8 b6 f3 ff ff       	call   c0029ddf <msg>
  lock_release (&a);
c002aa29:	89 34 24             	mov    %esi,(%esp)
c002aa2c:	e8 de 82 ff ff       	call   c0022d0f <lock_release>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002aa31:	e8 29 63 ff ff       	call   c0020d5f <thread_get_priority>
c002aa36:	83 c4 0c             	add    $0xc,%esp
c002aa39:	50                   	push   %eax
c002aa3a:	6a 24                	push   $0x24
c002aa3c:	68 90 fe 02 c0       	push   $0xc002fe90
c002aa41:	e8 99 f3 ff ff       	call   c0029ddf <msg>
  lock_release (&b);
c002aa46:	89 1c 24             	mov    %ebx,(%esp)
c002aa49:	e8 c1 82 ff ff       	call   c0022d0f <lock_release>
  msg ("Threads b, a, c should have just finished, in that order.");
c002aa4e:	c7 04 24 58 ff 02 c0 	movl   $0xc002ff58,(%esp)
c002aa55:	e8 85 f3 ff ff       	call   c0029ddf <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002aa5a:	e8 00 63 ff ff       	call   c0020d5f <thread_get_priority>
c002aa5f:	83 c4 0c             	add    $0xc,%esp
c002aa62:	50                   	push   %eax
c002aa63:	6a 1f                	push   $0x1f
c002aa65:	68 90 fe 02 c0       	push   $0xc002fe90
c002aa6a:	e8 70 f3 ff ff       	call   c0029ddf <msg>
}
c002aa6f:	81 c4 84 00 00 00    	add    $0x84,%esp
c002aa75:	5b                   	pop    %ebx
c002aa76:	5e                   	pop    %esi
c002aa77:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002aa78:	83 ec 0c             	sub    $0xc,%esp
c002aa7b:	68 94 f8 02 c0       	push   $0xc002f894
c002aa80:	68 3f d9 02 c0       	push   $0xc002d93f
c002aa85:	68 78 d7 02 c0       	push   $0xc002d778
c002aa8a:	6a 21                	push   $0x21
c002aa8c:	68 28 ff 02 c0       	push   $0xc002ff28
c002aa91:	e8 77 d8 ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002aa96:	83 ec 0c             	sub    $0xc,%esp
c002aa99:	68 28 fd 02 c0       	push   $0xc002fd28
c002aa9e:	68 3f d9 02 c0       	push   $0xc002d93f
c002aaa3:	68 78 d7 02 c0       	push   $0xc002d778
c002aaa8:	6a 24                	push   $0x24
c002aaaa:	68 28 ff 02 c0       	push   $0xc002ff28
c002aaaf:	e8 59 d8 ff ff       	call   c002830d <debug_panic>

c002aab4 <high_thread_func>:
  msg ("Middle thread finished.");
}

static void
high_thread_func (void *lock_) 
{
c002aab4:	53                   	push   %ebx
c002aab5:	83 ec 14             	sub    $0x14,%esp
c002aab8:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002aabc:	53                   	push   %ebx
c002aabd:	e8 b0 80 ff ff       	call   c0022b72 <lock_acquire>
  msg ("High thread got the lock.");
c002aac2:	c7 04 24 92 ff 02 c0 	movl   $0xc002ff92,(%esp)
c002aac9:	e8 11 f3 ff ff       	call   c0029ddf <msg>
  lock_release (lock);
c002aace:	89 1c 24             	mov    %ebx,(%esp)
c002aad1:	e8 39 82 ff ff       	call   c0022d0f <lock_release>
  msg ("High thread finished.");
c002aad6:	c7 04 24 ac ff 02 c0 	movl   $0xc002ffac,(%esp)
c002aadd:	e8 fd f2 ff ff       	call   c0029ddf <msg>
}
c002aae2:	83 c4 18             	add    $0x18,%esp
c002aae5:	5b                   	pop    %ebx
c002aae6:	c3                   	ret    

c002aae7 <medium_thread_func>:
{
c002aae7:	53                   	push   %ebx
c002aae8:	83 ec 14             	sub    $0x14,%esp
c002aaeb:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_acquire (locks->b);
c002aaef:	ff 73 04             	pushl  0x4(%ebx)
c002aaf2:	e8 7b 80 ff ff       	call   c0022b72 <lock_acquire>
  lock_acquire (locks->a);
c002aaf7:	83 c4 04             	add    $0x4,%esp
c002aafa:	ff 33                	pushl  (%ebx)
c002aafc:	e8 71 80 ff ff       	call   c0022b72 <lock_acquire>
  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002ab01:	e8 59 62 ff ff       	call   c0020d5f <thread_get_priority>
c002ab06:	83 c4 0c             	add    $0xc,%esp
c002ab09:	50                   	push   %eax
c002ab0a:	6a 21                	push   $0x21
c002ab0c:	68 04 00 03 c0       	push   $0xc0030004
c002ab11:	e8 c9 f2 ff ff       	call   c0029ddf <msg>
  msg ("Medium thread got the lock.");
c002ab16:	c7 04 24 c2 ff 02 c0 	movl   $0xc002ffc2,(%esp)
c002ab1d:	e8 bd f2 ff ff       	call   c0029ddf <msg>
  lock_release (locks->a);
c002ab22:	83 c4 04             	add    $0x4,%esp
c002ab25:	ff 33                	pushl  (%ebx)
c002ab27:	e8 e3 81 ff ff       	call   c0022d0f <lock_release>
  thread_yield ();
c002ab2c:	e8 be 67 ff ff       	call   c00212ef <thread_yield>
  lock_release (locks->b);
c002ab31:	83 c4 04             	add    $0x4,%esp
c002ab34:	ff 73 04             	pushl  0x4(%ebx)
c002ab37:	e8 d3 81 ff ff       	call   c0022d0f <lock_release>
  thread_yield ();
c002ab3c:	e8 ae 67 ff ff       	call   c00212ef <thread_yield>
  msg ("High thread should have just finished.");
c002ab41:	c7 04 24 44 00 03 c0 	movl   $0xc0030044,(%esp)
c002ab48:	e8 92 f2 ff ff       	call   c0029ddf <msg>
  msg ("Middle thread finished.");
c002ab4d:	c7 04 24 de ff 02 c0 	movl   $0xc002ffde,(%esp)
c002ab54:	e8 86 f2 ff ff       	call   c0029ddf <msg>
}
c002ab59:	83 c4 18             	add    $0x18,%esp
c002ab5c:	5b                   	pop    %ebx
c002ab5d:	c3                   	ret    

c002ab5e <test_priority_donate_nest>:
{
c002ab5e:	56                   	push   %esi
c002ab5f:	53                   	push   %ebx
c002ab60:	83 ec 74             	sub    $0x74,%esp
  ASSERT (!thread_mlfqs);
c002ab63:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002ab6a:	0f 85 d1 00 00 00    	jne    c002ac41 <test_priority_donate_nest+0xe3>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ab70:	e8 ea 61 ff ff       	call   c0020d5f <thread_get_priority>
c002ab75:	83 f8 1f             	cmp    $0x1f,%eax
c002ab78:	0f 85 e1 00 00 00    	jne    c002ac5f <test_priority_donate_nest+0x101>
  lock_init (&a);
c002ab7e:	83 ec 0c             	sub    $0xc,%esp
c002ab81:	8d 5c 24 48          	lea    0x48(%esp),%ebx
c002ab85:	53                   	push   %ebx
c002ab86:	e8 73 7e ff ff       	call   c00229fe <lock_init>
  lock_init (&b);
c002ab8b:	83 c4 04             	add    $0x4,%esp
c002ab8e:	8d 74 24 14          	lea    0x14(%esp),%esi
c002ab92:	56                   	push   %esi
c002ab93:	e8 66 7e ff ff       	call   c00229fe <lock_init>
  lock_acquire (&a);
c002ab98:	89 1c 24             	mov    %ebx,(%esp)
c002ab9b:	e8 d2 7f ff ff       	call   c0022b72 <lock_acquire>
  locks.a = &a;
c002aba0:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  locks.b = &b;
c002aba4:	89 74 24 14          	mov    %esi,0x14(%esp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002aba8:	8d 44 24 10          	lea    0x10(%esp),%eax
c002abac:	50                   	push   %eax
c002abad:	68 e7 aa 02 c0       	push   $0xc002aae7
c002abb2:	6a 20                	push   $0x20
c002abb4:	68 f6 ff 02 c0       	push   $0xc002fff6
c002abb9:	e8 11 68 ff ff       	call   c00213cf <thread_create>
  thread_yield ();
c002abbe:	83 c4 20             	add    $0x20,%esp
c002abc1:	e8 29 67 ff ff       	call   c00212ef <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002abc6:	e8 94 61 ff ff       	call   c0020d5f <thread_get_priority>
c002abcb:	83 ec 04             	sub    $0x4,%esp
c002abce:	50                   	push   %eax
c002abcf:	6a 20                	push   $0x20
c002abd1:	68 98 00 03 c0       	push   $0xc0030098
c002abd6:	e8 04 f2 ff ff       	call   c0029ddf <msg>
  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002abdb:	56                   	push   %esi
c002abdc:	68 b4 aa 02 c0       	push   $0xc002aab4
c002abe1:	6a 21                	push   $0x21
c002abe3:	68 fd ff 02 c0       	push   $0xc002fffd
c002abe8:	e8 e2 67 ff ff       	call   c00213cf <thread_create>
  thread_yield ();
c002abed:	83 c4 20             	add    $0x20,%esp
c002abf0:	e8 fa 66 ff ff       	call   c00212ef <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002abf5:	e8 65 61 ff ff       	call   c0020d5f <thread_get_priority>
c002abfa:	83 ec 04             	sub    $0x4,%esp
c002abfd:	50                   	push   %eax
c002abfe:	6a 21                	push   $0x21
c002ac00:	68 98 00 03 c0       	push   $0xc0030098
c002ac05:	e8 d5 f1 ff ff       	call   c0029ddf <msg>
  lock_release (&a);
c002ac0a:	89 1c 24             	mov    %ebx,(%esp)
c002ac0d:	e8 fd 80 ff ff       	call   c0022d0f <lock_release>
  thread_yield ();
c002ac12:	e8 d8 66 ff ff       	call   c00212ef <thread_yield>
  msg ("Medium thread should just have finished.");
c002ac17:	c7 04 24 d4 00 03 c0 	movl   $0xc00300d4,(%esp)
c002ac1e:	e8 bc f1 ff ff       	call   c0029ddf <msg>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002ac23:	e8 37 61 ff ff       	call   c0020d5f <thread_get_priority>
c002ac28:	83 c4 0c             	add    $0xc,%esp
c002ac2b:	50                   	push   %eax
c002ac2c:	6a 1f                	push   $0x1f
c002ac2e:	68 98 00 03 c0       	push   $0xc0030098
c002ac33:	e8 a7 f1 ff ff       	call   c0029ddf <msg>
}
c002ac38:	81 c4 84 00 00 00    	add    $0x84,%esp
c002ac3e:	5b                   	pop    %ebx
c002ac3f:	5e                   	pop    %esi
c002ac40:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002ac41:	83 ec 0c             	sub    $0xc,%esp
c002ac44:	68 94 f8 02 c0       	push   $0xc002f894
c002ac49:	68 3f d9 02 c0       	push   $0xc002d93f
c002ac4e:	68 98 d7 02 c0       	push   $0xc002d798
c002ac53:	6a 22                	push   $0x22
c002ac55:	68 6c 00 03 c0       	push   $0xc003006c
c002ac5a:	e8 ae d6 ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ac5f:	83 ec 0c             	sub    $0xc,%esp
c002ac62:	68 28 fd 02 c0       	push   $0xc002fd28
c002ac67:	68 3f d9 02 c0       	push   $0xc002d93f
c002ac6c:	68 98 d7 02 c0       	push   $0xc002d798
c002ac71:	6a 25                	push   $0x25
c002ac73:	68 6c 00 03 c0       	push   $0xc003006c
c002ac78:	e8 90 d6 ff ff       	call   c002830d <debug_panic>

c002ac7d <h_thread_func>:
  msg ("Thread M finished.");
}

static void
h_thread_func (void *ls_) 
{
c002ac7d:	53                   	push   %ebx
c002ac7e:	83 ec 14             	sub    $0x14,%esp
c002ac81:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock_and_sema *ls = ls_;

  lock_acquire (&ls->lock);
c002ac85:	53                   	push   %ebx
c002ac86:	e8 e7 7e ff ff       	call   c0022b72 <lock_acquire>
  msg ("Thread H acquired lock.");
c002ac8b:	c7 04 24 fd 00 03 c0 	movl   $0xc00300fd,(%esp)
c002ac92:	e8 48 f1 ff ff       	call   c0029ddf <msg>

  sema_up (&ls->sema);
c002ac97:	8d 43 34             	lea    0x34(%ebx),%eax
c002ac9a:	89 04 24             	mov    %eax,(%esp)
c002ac9d:	e8 d1 7b ff ff       	call   c0022873 <sema_up>
  lock_release (&ls->lock);
c002aca2:	89 1c 24             	mov    %ebx,(%esp)
c002aca5:	e8 65 80 ff ff       	call   c0022d0f <lock_release>
  msg ("Thread H finished.");
c002acaa:	c7 04 24 15 01 03 c0 	movl   $0xc0030115,(%esp)
c002acb1:	e8 29 f1 ff ff       	call   c0029ddf <msg>
}
c002acb6:	83 c4 18             	add    $0x18,%esp
c002acb9:	5b                   	pop    %ebx
c002acba:	c3                   	ret    

c002acbb <m_thread_func>:
{
c002acbb:	83 ec 18             	sub    $0x18,%esp
  sema_down (&ls->sema);
c002acbe:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002acc2:	83 c0 34             	add    $0x34,%eax
c002acc5:	50                   	push   %eax
c002acc6:	e8 c7 7a ff ff       	call   c0022792 <sema_down>
  msg ("Thread M finished.");
c002accb:	c7 04 24 28 01 03 c0 	movl   $0xc0030128,(%esp)
c002acd2:	e8 08 f1 ff ff       	call   c0029ddf <msg>
}
c002acd7:	83 c4 1c             	add    $0x1c,%esp
c002acda:	c3                   	ret    

c002acdb <l_thread_func>:
{
c002acdb:	53                   	push   %ebx
c002acdc:	83 ec 14             	sub    $0x14,%esp
c002acdf:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_acquire (&ls->lock);
c002ace3:	53                   	push   %ebx
c002ace4:	e8 89 7e ff ff       	call   c0022b72 <lock_acquire>
  msg ("Thread L acquired lock.");
c002ace9:	c7 04 24 3b 01 03 c0 	movl   $0xc003013b,(%esp)
c002acf0:	e8 ea f0 ff ff       	call   c0029ddf <msg>
  sema_down (&ls->sema);
c002acf5:	8d 43 34             	lea    0x34(%ebx),%eax
c002acf8:	89 04 24             	mov    %eax,(%esp)
c002acfb:	e8 92 7a ff ff       	call   c0022792 <sema_down>
  msg ("Thread L downed semaphore.");
c002ad00:	c7 04 24 53 01 03 c0 	movl   $0xc0030153,(%esp)
c002ad07:	e8 d3 f0 ff ff       	call   c0029ddf <msg>
  lock_release (&ls->lock);
c002ad0c:	89 1c 24             	mov    %ebx,(%esp)
c002ad0f:	e8 fb 7f ff ff       	call   c0022d0f <lock_release>
  msg ("Thread L finished.");
c002ad14:	c7 04 24 6e 01 03 c0 	movl   $0xc003016e,(%esp)
c002ad1b:	e8 bf f0 ff ff       	call   c0029ddf <msg>
}
c002ad20:	83 c4 18             	add    $0x18,%esp
c002ad23:	5b                   	pop    %ebx
c002ad24:	c3                   	ret    

c002ad25 <test_priority_donate_sema>:
{
c002ad25:	56                   	push   %esi
c002ad26:	53                   	push   %ebx
c002ad27:	83 ec 54             	sub    $0x54,%esp
  ASSERT (!thread_mlfqs);
c002ad2a:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002ad31:	75 7e                	jne    c002adb1 <test_priority_donate_sema+0x8c>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ad33:	e8 27 60 ff ff       	call   c0020d5f <thread_get_priority>
c002ad38:	83 f8 1f             	cmp    $0x1f,%eax
c002ad3b:	0f 85 8e 00 00 00    	jne    c002adcf <test_priority_donate_sema+0xaa>
  lock_init (&ls.lock);
c002ad41:	83 ec 0c             	sub    $0xc,%esp
c002ad44:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c002ad48:	53                   	push   %ebx
c002ad49:	e8 b0 7c ff ff       	call   c00229fe <lock_init>
  sema_init (&ls.sema, 0);
c002ad4e:	83 c4 08             	add    $0x8,%esp
c002ad51:	6a 00                	push   $0x0
c002ad53:	8d 74 24 48          	lea    0x48(%esp),%esi
c002ad57:	56                   	push   %esi
c002ad58:	e8 c7 79 ff ff       	call   c0022724 <sema_init>
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002ad5d:	53                   	push   %ebx
c002ad5e:	68 db ac 02 c0       	push   $0xc002acdb
c002ad63:	6a 20                	push   $0x20
c002ad65:	68 81 01 03 c0       	push   $0xc0030181
c002ad6a:	e8 60 66 ff ff       	call   c00213cf <thread_create>
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002ad6f:	83 c4 20             	add    $0x20,%esp
c002ad72:	53                   	push   %ebx
c002ad73:	68 bb ac 02 c0       	push   $0xc002acbb
c002ad78:	6a 22                	push   $0x22
c002ad7a:	68 85 01 03 c0       	push   $0xc0030185
c002ad7f:	e8 4b 66 ff ff       	call   c00213cf <thread_create>
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002ad84:	53                   	push   %ebx
c002ad85:	68 7d ac 02 c0       	push   $0xc002ac7d
c002ad8a:	6a 24                	push   $0x24
c002ad8c:	68 fd ff 02 c0       	push   $0xc002fffd
c002ad91:	e8 39 66 ff ff       	call   c00213cf <thread_create>
  sema_up (&ls.sema);
c002ad96:	83 c4 14             	add    $0x14,%esp
c002ad99:	56                   	push   %esi
c002ad9a:	e8 d4 7a ff ff       	call   c0022873 <sema_up>
  msg ("Main thread finished.");
c002ad9f:	c7 04 24 89 01 03 c0 	movl   $0xc0030189,(%esp)
c002ada6:	e8 34 f0 ff ff       	call   c0029ddf <msg>
}
c002adab:	83 c4 64             	add    $0x64,%esp
c002adae:	5b                   	pop    %ebx
c002adaf:	5e                   	pop    %esi
c002adb0:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002adb1:	83 ec 0c             	sub    $0xc,%esp
c002adb4:	68 94 f8 02 c0       	push   $0xc002f894
c002adb9:	68 3f d9 02 c0       	push   $0xc002d93f
c002adbe:	68 b4 d7 02 c0       	push   $0xc002d7b4
c002adc3:	6a 23                	push   $0x23
c002adc5:	68 a0 01 03 c0       	push   $0xc00301a0
c002adca:	e8 3e d5 ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002adcf:	83 ec 0c             	sub    $0xc,%esp
c002add2:	68 28 fd 02 c0       	push   $0xc002fd28
c002add7:	68 3f d9 02 c0       	push   $0xc002d93f
c002addc:	68 b4 d7 02 c0       	push   $0xc002d7b4
c002ade1:	6a 26                	push   $0x26
c002ade3:	68 a0 01 03 c0       	push   $0xc00301a0
c002ade8:	e8 20 d5 ff ff       	call   c002830d <debug_panic>

c002aded <acquire_thread_func>:
       PRI_DEFAULT - 10, thread_get_priority ());
}

static void
acquire_thread_func (void *lock_) 
{
c002aded:	53                   	push   %ebx
c002adee:	83 ec 14             	sub    $0x14,%esp
c002adf1:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002adf5:	53                   	push   %ebx
c002adf6:	e8 77 7d ff ff       	call   c0022b72 <lock_acquire>
  msg ("acquire: got the lock");
c002adfb:	c7 04 24 cb 01 03 c0 	movl   $0xc00301cb,(%esp)
c002ae02:	e8 d8 ef ff ff       	call   c0029ddf <msg>
  lock_release (lock);
c002ae07:	89 1c 24             	mov    %ebx,(%esp)
c002ae0a:	e8 00 7f ff ff       	call   c0022d0f <lock_release>
  msg ("acquire: done");
c002ae0f:	c7 04 24 e1 01 03 c0 	movl   $0xc00301e1,(%esp)
c002ae16:	e8 c4 ef ff ff       	call   c0029ddf <msg>
}
c002ae1b:	83 c4 18             	add    $0x18,%esp
c002ae1e:	5b                   	pop    %ebx
c002ae1f:	c3                   	ret    

c002ae20 <test_priority_donate_lower>:
{
c002ae20:	53                   	push   %ebx
c002ae21:	83 ec 48             	sub    $0x48,%esp
  ASSERT (!thread_mlfqs);
c002ae24:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002ae2b:	0f 85 a8 00 00 00    	jne    c002aed9 <test_priority_donate_lower+0xb9>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ae31:	e8 29 5f ff ff       	call   c0020d5f <thread_get_priority>
c002ae36:	83 f8 1f             	cmp    $0x1f,%eax
c002ae39:	0f 85 b8 00 00 00    	jne    c002aef7 <test_priority_donate_lower+0xd7>
  lock_init (&lock);
c002ae3f:	83 ec 0c             	sub    $0xc,%esp
c002ae42:	8d 5c 24 18          	lea    0x18(%esp),%ebx
c002ae46:	53                   	push   %ebx
c002ae47:	e8 b2 7b ff ff       	call   c00229fe <lock_init>
  lock_acquire (&lock);
c002ae4c:	89 1c 24             	mov    %ebx,(%esp)
c002ae4f:	e8 1e 7d ff ff       	call   c0022b72 <lock_acquire>
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002ae54:	53                   	push   %ebx
c002ae55:	68 ed ad 02 c0       	push   $0xc002aded
c002ae5a:	6a 29                	push   $0x29
c002ae5c:	68 ef 01 03 c0       	push   $0xc00301ef
c002ae61:	e8 69 65 ff ff       	call   c00213cf <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ae66:	83 c4 20             	add    $0x20,%esp
c002ae69:	e8 f1 5e ff ff       	call   c0020d5f <thread_get_priority>
c002ae6e:	83 ec 04             	sub    $0x4,%esp
c002ae71:	50                   	push   %eax
c002ae72:	6a 29                	push   $0x29
c002ae74:	68 90 fe 02 c0       	push   $0xc002fe90
c002ae79:	e8 61 ef ff ff       	call   c0029ddf <msg>
  msg ("Lowering base priority...");
c002ae7e:	c7 04 24 f7 01 03 c0 	movl   $0xc00301f7,(%esp)
c002ae85:	e8 55 ef ff ff       	call   c0029ddf <msg>
  thread_set_priority (PRI_DEFAULT - 10);
c002ae8a:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
c002ae91:	e8 54 66 ff ff       	call   c00214ea <thread_set_priority>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ae96:	e8 c4 5e ff ff       	call   c0020d5f <thread_get_priority>
c002ae9b:	83 c4 0c             	add    $0xc,%esp
c002ae9e:	50                   	push   %eax
c002ae9f:	6a 29                	push   $0x29
c002aea1:	68 90 fe 02 c0       	push   $0xc002fe90
c002aea6:	e8 34 ef ff ff       	call   c0029ddf <msg>
  lock_release (&lock);
c002aeab:	89 1c 24             	mov    %ebx,(%esp)
c002aeae:	e8 5c 7e ff ff       	call   c0022d0f <lock_release>
  msg ("acquire must already have finished.");
c002aeb3:	c7 04 24 40 02 03 c0 	movl   $0xc0030240,(%esp)
c002aeba:	e8 20 ef ff ff       	call   c0029ddf <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002aebf:	e8 9b 5e ff ff       	call   c0020d5f <thread_get_priority>
c002aec4:	83 c4 0c             	add    $0xc,%esp
c002aec7:	50                   	push   %eax
c002aec8:	6a 15                	push   $0x15
c002aeca:	68 90 fe 02 c0       	push   $0xc002fe90
c002aecf:	e8 0b ef ff ff       	call   c0029ddf <msg>
}
c002aed4:	83 c4 58             	add    $0x58,%esp
c002aed7:	5b                   	pop    %ebx
c002aed8:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002aed9:	83 ec 0c             	sub    $0xc,%esp
c002aedc:	68 94 f8 02 c0       	push   $0xc002f894
c002aee1:	68 3f d9 02 c0       	push   $0xc002d93f
c002aee6:	68 d0 d7 02 c0       	push   $0xc002d7d0
c002aeeb:	6a 15                	push   $0x15
c002aeed:	68 14 02 03 c0       	push   $0xc0030214
c002aef2:	e8 16 d4 ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002aef7:	83 ec 0c             	sub    $0xc,%esp
c002aefa:	68 28 fd 02 c0       	push   $0xc002fd28
c002aeff:	68 3f d9 02 c0       	push   $0xc002d93f
c002af04:	68 d0 d7 02 c0       	push   $0xc002d7d0
c002af09:	6a 18                	push   $0x18
c002af0b:	68 14 02 03 c0       	push   $0xc0030214
c002af10:	e8 f8 d3 ff ff       	call   c002830d <debug_panic>

c002af15 <simple_thread_func>:
    }
}

static void 
simple_thread_func (void *data_) 
{
c002af15:	56                   	push   %esi
c002af16:	53                   	push   %ebx
c002af17:	83 ec 04             	sub    $0x4,%esp
c002af1a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002af1e:	be 10 00 00 00       	mov    $0x10,%esi
  struct simple_thread_data *data = data_;
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
    {
      lock_acquire (data->lock);
c002af23:	83 ec 0c             	sub    $0xc,%esp
c002af26:	ff 73 08             	pushl  0x8(%ebx)
c002af29:	e8 44 7c ff ff       	call   c0022b72 <lock_acquire>
      *(*data->op)++ = data->id;
c002af2e:	8b 53 0c             	mov    0xc(%ebx),%edx
c002af31:	8b 02                	mov    (%edx),%eax
c002af33:	8d 48 04             	lea    0x4(%eax),%ecx
c002af36:	89 0a                	mov    %ecx,(%edx)
c002af38:	8b 13                	mov    (%ebx),%edx
c002af3a:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002af3c:	83 c4 04             	add    $0x4,%esp
c002af3f:	ff 73 08             	pushl  0x8(%ebx)
c002af42:	e8 c8 7d ff ff       	call   c0022d0f <lock_release>
      thread_yield ();
c002af47:	e8 a3 63 ff ff       	call   c00212ef <thread_yield>
  for (i = 0; i < ITER_CNT; i++) 
c002af4c:	83 c4 10             	add    $0x10,%esp
c002af4f:	4e                   	dec    %esi
c002af50:	75 d1                	jne    c002af23 <simple_thread_func+0xe>
    }
}
c002af52:	83 c4 04             	add    $0x4,%esp
c002af55:	5b                   	pop    %ebx
c002af56:	5e                   	pop    %esi
c002af57:	c3                   	ret    

c002af58 <test_priority_fifo>:
{
c002af58:	55                   	push   %ebp
c002af59:	57                   	push   %edi
c002af5a:	56                   	push   %esi
c002af5b:	53                   	push   %ebx
c002af5c:	81 ec 6c 01 00 00    	sub    $0x16c,%esp
  ASSERT (!thread_mlfqs);
c002af62:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002af69:	0f 85 f1 00 00 00    	jne    c002b060 <test_priority_fifo+0x108>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002af6f:	e8 eb 5d ff ff       	call   c0020d5f <thread_get_priority>
c002af74:	83 f8 1f             	cmp    $0x1f,%eax
c002af77:	0f 85 01 01 00 00    	jne    c002b07e <test_priority_fifo+0x126>
  msg ("%d threads will iterate %d times in the same order each time.",
c002af7d:	83 ec 04             	sub    $0x4,%esp
c002af80:	6a 10                	push   $0x10
c002af82:	6a 10                	push   $0x10
c002af84:	68 c8 02 03 c0       	push   $0xc00302c8
c002af89:	e8 51 ee ff ff       	call   c0029ddf <msg>
  msg ("If the order varies then there is a bug.");
c002af8e:	c7 04 24 08 03 03 c0 	movl   $0xc0030308,(%esp)
c002af95:	e8 45 ee ff ff       	call   c0029ddf <msg>
  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002af9a:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
c002afa1:	e8 1d 87 ff ff       	call   c00236c3 <malloc>
c002afa6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002afaa:	89 44 24 38          	mov    %eax,0x38(%esp)
  ASSERT (output != NULL);
c002afae:	83 c4 10             	add    $0x10,%esp
c002afb1:	85 c0                	test   %eax,%eax
c002afb3:	0f 84 e3 00 00 00    	je     c002b09c <test_priority_fifo+0x144>
  lock_init (&lock);
c002afb9:	83 ec 0c             	sub    $0xc,%esp
c002afbc:	8d 44 24 38          	lea    0x38(%esp),%eax
c002afc0:	50                   	push   %eax
c002afc1:	e8 38 7a ff ff       	call   c00229fe <lock_init>
  thread_set_priority (PRI_DEFAULT + 2);
c002afc6:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c002afcd:	e8 18 65 ff ff       	call   c00214ea <thread_set_priority>
c002afd2:	8d 5c 24 70          	lea    0x70(%esp),%ebx
c002afd6:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002afd9:	be 00 00 00 00       	mov    $0x0,%esi
      snprintf (name, sizeof name, "%d", i);
c002afde:	8d 7c 24 18          	lea    0x18(%esp),%edi
      d->lock = &lock;
c002afe2:	8d 6c 24 2c          	lea    0x2c(%esp),%ebp
      snprintf (name, sizeof name, "%d", i);
c002afe6:	56                   	push   %esi
c002afe7:	68 a9 f8 02 c0       	push   $0xc002f8a9
c002afec:	6a 10                	push   $0x10
c002afee:	57                   	push   %edi
c002afef:	e8 f7 bf ff ff       	call   c0026feb <snprintf>
      d->id = i;
c002aff4:	89 33                	mov    %esi,(%ebx)
      d->iterations = 0;
c002aff6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
      d->lock = &lock;
c002affd:	89 6b 08             	mov    %ebp,0x8(%ebx)
      d->op = &op;
c002b000:	8d 44 24 38          	lea    0x38(%esp),%eax
c002b004:	89 43 0c             	mov    %eax,0xc(%ebx)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002b007:	53                   	push   %ebx
c002b008:	68 15 af 02 c0       	push   $0xc002af15
c002b00d:	6a 20                	push   $0x20
c002b00f:	57                   	push   %edi
c002b010:	e8 ba 63 ff ff       	call   c00213cf <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002b015:	46                   	inc    %esi
c002b016:	83 c3 10             	add    $0x10,%ebx
c002b019:	83 c4 20             	add    $0x20,%esp
c002b01c:	83 fe 10             	cmp    $0x10,%esi
c002b01f:	75 c5                	jne    c002afe6 <test_priority_fifo+0x8e>
  thread_set_priority (PRI_DEFAULT);
c002b021:	83 ec 0c             	sub    $0xc,%esp
c002b024:	6a 1f                	push   $0x1f
c002b026:	e8 bf 64 ff ff       	call   c00214ea <thread_set_priority>
  ASSERT (lock.holder == NULL);
c002b02b:	83 c4 10             	add    $0x10,%esp
c002b02e:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c002b033:	0f 85 81 00 00 00    	jne    c002b0ba <test_priority_fifo+0x162>
  for (; output < op; output++) 
c002b039:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b03d:	3b 44 24 28          	cmp    0x28(%esp),%eax
c002b041:	0f 83 0f 01 00 00    	jae    c002b156 <test_priority_fifo+0x1fe>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002b047:	8b 18                	mov    (%eax),%ebx
c002b049:	83 fb 0f             	cmp    $0xf,%ebx
c002b04c:	0f 87 86 00 00 00    	ja     c002b0d8 <test_priority_fifo+0x180>
c002b052:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002b056:	be 00 00 00 00       	mov    $0x0,%esi
c002b05b:	e9 bb 00 00 00       	jmp    c002b11b <test_priority_fifo+0x1c3>
  ASSERT (!thread_mlfqs);
c002b060:	83 ec 0c             	sub    $0xc,%esp
c002b063:	68 94 f8 02 c0       	push   $0xc002f894
c002b068:	68 3f d9 02 c0       	push   $0xc002d93f
c002b06d:	68 ec d7 02 c0       	push   $0xc002d7ec
c002b072:	6a 28                	push   $0x28
c002b074:	68 a4 02 03 c0       	push   $0xc00302a4
c002b079:	e8 8f d2 ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002b07e:	83 ec 0c             	sub    $0xc,%esp
c002b081:	68 28 fd 02 c0       	push   $0xc002fd28
c002b086:	68 3f d9 02 c0       	push   $0xc002d93f
c002b08b:	68 ec d7 02 c0       	push   $0xc002d7ec
c002b090:	6a 2b                	push   $0x2b
c002b092:	68 a4 02 03 c0       	push   $0xc00302a4
c002b097:	e8 71 d2 ff ff       	call   c002830d <debug_panic>
  ASSERT (output != NULL);
c002b09c:	83 ec 0c             	sub    $0xc,%esp
c002b09f:	68 64 02 03 c0       	push   $0xc0030264
c002b0a4:	68 3f d9 02 c0       	push   $0xc002d93f
c002b0a9:	68 ec d7 02 c0       	push   $0xc002d7ec
c002b0ae:	6a 32                	push   $0x32
c002b0b0:	68 a4 02 03 c0       	push   $0xc00302a4
c002b0b5:	e8 53 d2 ff ff       	call   c002830d <debug_panic>
  ASSERT (lock.holder == NULL);
c002b0ba:	83 ec 0c             	sub    $0xc,%esp
c002b0bd:	68 73 02 03 c0       	push   $0xc0030273
c002b0c2:	68 3f d9 02 c0       	push   $0xc002d93f
c002b0c7:	68 ec d7 02 c0       	push   $0xc002d7ec
c002b0cc:	6a 44                	push   $0x44
c002b0ce:	68 a4 02 03 c0       	push   $0xc00302a4
c002b0d3:	e8 35 d2 ff ff       	call   c002830d <debug_panic>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002b0d8:	83 ec 0c             	sub    $0xc,%esp
c002b0db:	68 34 03 03 c0       	push   $0xc0030334
c002b0e0:	68 3f d9 02 c0       	push   $0xc002d93f
c002b0e5:	68 ec d7 02 c0       	push   $0xc002d7ec
c002b0ea:	6a 4b                	push   $0x4b
c002b0ec:	68 a4 02 03 c0       	push   $0xc00302a4
c002b0f1:	e8 17 d2 ff ff       	call   c002830d <debug_panic>
        printf ("(priority-fifo) iteration:");
c002b0f6:	83 ec 0c             	sub    $0xc,%esp
c002b0f9:	68 87 02 03 c0       	push   $0xc0030287
c002b0fe:	e8 5c b7 ff ff       	call   c002685f <printf>
c002b103:	83 c4 10             	add    $0x10,%esp
c002b106:	eb 24                	jmp    c002b12c <test_priority_fifo+0x1d4>
      d->iterations++;
c002b108:	ff 43 04             	incl   0x4(%ebx)
  for (; output < op; output++) 
c002b10b:	83 c7 04             	add    $0x4,%edi
c002b10e:	39 7c 24 28          	cmp    %edi,0x28(%esp)
c002b112:	76 42                	jbe    c002b156 <test_priority_fifo+0x1fe>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002b114:	8b 1f                	mov    (%edi),%ebx
c002b116:	83 fb 0f             	cmp    $0xf,%ebx
c002b119:	77 bd                	ja     c002b0d8 <test_priority_fifo+0x180>
      d = data + *output;
c002b11b:	c1 e3 04             	shl    $0x4,%ebx
c002b11e:	8d 44 24 60          	lea    0x60(%esp),%eax
c002b122:	01 c3                	add    %eax,%ebx
      if (cnt % THREAD_CNT == 0)
c002b124:	f7 c6 0f 00 00 00    	test   $0xf,%esi
c002b12a:	74 ca                	je     c002b0f6 <test_priority_fifo+0x19e>
      printf (" %d", d->id);
c002b12c:	83 ec 08             	sub    $0x8,%esp
c002b12f:	ff 33                	pushl  (%ebx)
c002b131:	68 a8 f8 02 c0       	push   $0xc002f8a8
c002b136:	e8 24 b7 ff ff       	call   c002685f <printf>
      if (++cnt % THREAD_CNT == 0)
c002b13b:	46                   	inc    %esi
c002b13c:	83 c4 10             	add    $0x10,%esp
c002b13f:	f7 c6 0f 00 00 00    	test   $0xf,%esi
c002b145:	75 c1                	jne    c002b108 <test_priority_fifo+0x1b0>
        printf ("\n");
c002b147:	83 ec 0c             	sub    $0xc,%esp
c002b14a:	6a 0a                	push   $0xa
c002b14c:	e8 6f ec ff ff       	call   c0029dc0 <putchar>
c002b151:	83 c4 10             	add    $0x10,%esp
c002b154:	eb b2                	jmp    c002b108 <test_priority_fifo+0x1b0>
}
c002b156:	81 c4 6c 01 00 00    	add    $0x16c,%esp
c002b15c:	5b                   	pop    %ebx
c002b15d:	5e                   	pop    %esi
c002b15e:	5f                   	pop    %edi
c002b15f:	5d                   	pop    %ebp
c002b160:	c3                   	ret    

c002b161 <simple_thread_func>:
  msg ("The high-priority thread should have already completed.");
}

static void 
simple_thread_func (void *aux UNUSED) 
{
c002b161:	53                   	push   %ebx
c002b162:	83 ec 08             	sub    $0x8,%esp
  int i;
  
  for (i = 0; i < 5; i++) 
c002b165:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002b16a:	e8 c6 59 ff ff       	call   c0020b35 <thread_name>
c002b16f:	83 ec 04             	sub    $0x4,%esp
c002b172:	53                   	push   %ebx
c002b173:	50                   	push   %eax
c002b174:	68 59 03 03 c0       	push   $0xc0030359
c002b179:	e8 61 ec ff ff       	call   c0029ddf <msg>
      thread_yield ();
c002b17e:	e8 6c 61 ff ff       	call   c00212ef <thread_yield>
  for (i = 0; i < 5; i++) 
c002b183:	43                   	inc    %ebx
c002b184:	83 c4 10             	add    $0x10,%esp
c002b187:	83 fb 05             	cmp    $0x5,%ebx
c002b18a:	75 de                	jne    c002b16a <simple_thread_func+0x9>
    }
  msg ("Thread %s done!", thread_name ());
c002b18c:	e8 a4 59 ff ff       	call   c0020b35 <thread_name>
c002b191:	83 ec 08             	sub    $0x8,%esp
c002b194:	50                   	push   %eax
c002b195:	68 70 03 03 c0       	push   $0xc0030370
c002b19a:	e8 40 ec ff ff       	call   c0029ddf <msg>
}
c002b19f:	83 c4 18             	add    $0x18,%esp
c002b1a2:	5b                   	pop    %ebx
c002b1a3:	c3                   	ret    

c002b1a4 <test_priority_preempt>:
{
c002b1a4:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (!thread_mlfqs);
c002b1a7:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002b1ae:	75 2d                	jne    c002b1dd <test_priority_preempt+0x39>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002b1b0:	e8 aa 5b ff ff       	call   c0020d5f <thread_get_priority>
c002b1b5:	83 f8 1f             	cmp    $0x1f,%eax
c002b1b8:	75 41                	jne    c002b1fb <test_priority_preempt+0x57>
  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002b1ba:	6a 00                	push   $0x0
c002b1bc:	68 61 b1 02 c0       	push   $0xc002b161
c002b1c1:	6a 20                	push   $0x20
c002b1c3:	68 80 03 03 c0       	push   $0xc0030380
c002b1c8:	e8 02 62 ff ff       	call   c00213cf <thread_create>
  msg ("The high-priority thread should have already completed.");
c002b1cd:	c7 04 24 b8 03 03 c0 	movl   $0xc00303b8,(%esp)
c002b1d4:	e8 06 ec ff ff       	call   c0029ddf <msg>
}
c002b1d9:	83 c4 1c             	add    $0x1c,%esp
c002b1dc:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b1dd:	83 ec 0c             	sub    $0xc,%esp
c002b1e0:	68 94 f8 02 c0       	push   $0xc002f894
c002b1e5:	68 3f d9 02 c0       	push   $0xc002d93f
c002b1ea:	68 00 d8 02 c0       	push   $0xc002d800
c002b1ef:	6a 15                	push   $0x15
c002b1f1:	68 90 03 03 c0       	push   $0xc0030390
c002b1f6:	e8 12 d1 ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002b1fb:	83 ec 0c             	sub    $0xc,%esp
c002b1fe:	68 28 fd 02 c0       	push   $0xc002fd28
c002b203:	68 3f d9 02 c0       	push   $0xc002d93f
c002b208:	68 00 d8 02 c0       	push   $0xc002d800
c002b20d:	6a 18                	push   $0x18
c002b20f:	68 90 03 03 c0       	push   $0xc0030390
c002b214:	e8 f4 d0 ff ff       	call   c002830d <debug_panic>

c002b219 <priority_sema_thread>:
    }
}

static void
priority_sema_thread (void *aux UNUSED) 
{
c002b219:	83 ec 18             	sub    $0x18,%esp
  sema_down (&sema);
c002b21c:	68 d8 9e 03 c0       	push   $0xc0039ed8
c002b221:	e8 6c 75 ff ff       	call   c0022792 <sema_down>
  msg ("Thread %s woke up.", thread_name ());
c002b226:	e8 0a 59 ff ff       	call   c0020b35 <thread_name>
c002b22b:	83 c4 08             	add    $0x8,%esp
c002b22e:	50                   	push   %eax
c002b22f:	68 7c fb 02 c0       	push   $0xc002fb7c
c002b234:	e8 a6 eb ff ff       	call   c0029ddf <msg>
}
c002b239:	83 c4 1c             	add    $0x1c,%esp
c002b23c:	c3                   	ret    

c002b23d <test_priority_sema>:
{
c002b23d:	55                   	push   %ebp
c002b23e:	57                   	push   %edi
c002b23f:	56                   	push   %esi
c002b240:	53                   	push   %ebx
c002b241:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT (!thread_mlfqs);
c002b244:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002b24b:	0f 85 87 00 00 00    	jne    c002b2d8 <test_priority_sema+0x9b>
  sema_init (&sema, 0);
c002b251:	83 ec 08             	sub    $0x8,%esp
c002b254:	6a 00                	push   $0x0
c002b256:	68 d8 9e 03 c0       	push   $0xc0039ed8
c002b25b:	e8 c4 74 ff ff       	call   c0022724 <sema_init>
  thread_set_priority (PRI_MIN);
c002b260:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002b267:	e8 7e 62 ff ff       	call   c00214ea <thread_set_priority>
c002b26c:	83 c4 10             	add    $0x10,%esp
c002b26f:	bb 03 00 00 00       	mov    $0x3,%ebx
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002b274:	bd 0a 00 00 00       	mov    $0xa,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002b279:	89 e7                	mov    %esp,%edi
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002b27b:	89 d8                	mov    %ebx,%eax
c002b27d:	99                   	cltd   
c002b27e:	f7 fd                	idiv   %ebp
c002b280:	be 1e 00 00 00       	mov    $0x1e,%esi
c002b285:	29 d6                	sub    %edx,%esi
      snprintf (name, sizeof name, "priority %d", priority);
c002b287:	56                   	push   %esi
c002b288:	68 8f fb 02 c0       	push   $0xc002fb8f
c002b28d:	6a 10                	push   $0x10
c002b28f:	57                   	push   %edi
c002b290:	e8 56 bd ff ff       	call   c0026feb <snprintf>
      thread_create (name, priority, priority_sema_thread, NULL);
c002b295:	6a 00                	push   $0x0
c002b297:	68 19 b2 02 c0       	push   $0xc002b219
c002b29c:	56                   	push   %esi
c002b29d:	57                   	push   %edi
c002b29e:	e8 2c 61 ff ff       	call   c00213cf <thread_create>
c002b2a3:	43                   	inc    %ebx
  for (i = 0; i < 10; i++) 
c002b2a4:	83 c4 20             	add    $0x20,%esp
c002b2a7:	83 fb 0d             	cmp    $0xd,%ebx
c002b2aa:	75 cf                	jne    c002b27b <test_priority_sema+0x3e>
c002b2ac:	bb 0a 00 00 00       	mov    $0xa,%ebx
      sema_up (&sema);
c002b2b1:	83 ec 0c             	sub    $0xc,%esp
c002b2b4:	68 d8 9e 03 c0       	push   $0xc0039ed8
c002b2b9:	e8 b5 75 ff ff       	call   c0022873 <sema_up>
      msg ("Back in main thread."); 
c002b2be:	c7 04 24 f0 03 03 c0 	movl   $0xc00303f0,(%esp)
c002b2c5:	e8 15 eb ff ff       	call   c0029ddf <msg>
  for (i = 0; i < 10; i++) 
c002b2ca:	83 c4 10             	add    $0x10,%esp
c002b2cd:	4b                   	dec    %ebx
c002b2ce:	75 e1                	jne    c002b2b1 <test_priority_sema+0x74>
}
c002b2d0:	83 c4 1c             	add    $0x1c,%esp
c002b2d3:	5b                   	pop    %ebx
c002b2d4:	5e                   	pop    %esi
c002b2d5:	5f                   	pop    %edi
c002b2d6:	5d                   	pop    %ebp
c002b2d7:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b2d8:	83 ec 0c             	sub    $0xc,%esp
c002b2db:	68 94 f8 02 c0       	push   $0xc002f894
c002b2e0:	68 3f d9 02 c0       	push   $0xc002d93f
c002b2e5:	68 18 d8 02 c0       	push   $0xc002d818
c002b2ea:	6a 15                	push   $0x15
c002b2ec:	68 08 04 03 c0       	push   $0xc0030408
c002b2f1:	e8 17 d0 ff ff       	call   c002830d <debug_panic>

c002b2f6 <priority_condvar_thread>:
    }
}

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002b2f6:	83 ec 0c             	sub    $0xc,%esp
  msg ("Thread %s starting.", thread_name ());
c002b2f9:	e8 37 58 ff ff       	call   c0020b35 <thread_name>
c002b2fe:	83 ec 08             	sub    $0x8,%esp
c002b301:	50                   	push   %eax
c002b302:	68 2c 04 03 c0       	push   $0xc003042c
c002b307:	e8 d3 ea ff ff       	call   c0029ddf <msg>
  lock_acquire (&lock);
c002b30c:	c7 04 24 20 9f 03 c0 	movl   $0xc0039f20,(%esp)
c002b313:	e8 5a 78 ff ff       	call   c0022b72 <lock_acquire>
  cond_wait (&condition, &lock);
c002b318:	83 c4 08             	add    $0x8,%esp
c002b31b:	68 20 9f 03 c0       	push   $0xc0039f20
c002b320:	68 00 9f 03 c0       	push   $0xc0039f00
c002b325:	e8 79 7b ff ff       	call   c0022ea3 <cond_wait>
  msg ("Thread %s woke up.", thread_name ());
c002b32a:	e8 06 58 ff ff       	call   c0020b35 <thread_name>
c002b32f:	83 c4 08             	add    $0x8,%esp
c002b332:	50                   	push   %eax
c002b333:	68 7c fb 02 c0       	push   $0xc002fb7c
c002b338:	e8 a2 ea ff ff       	call   c0029ddf <msg>
  lock_release (&lock);
c002b33d:	c7 04 24 20 9f 03 c0 	movl   $0xc0039f20,(%esp)
c002b344:	e8 c6 79 ff ff       	call   c0022d0f <lock_release>
}
c002b349:	83 c4 1c             	add    $0x1c,%esp
c002b34c:	c3                   	ret    

c002b34d <test_priority_condvar>:
{
c002b34d:	55                   	push   %ebp
c002b34e:	57                   	push   %edi
c002b34f:	56                   	push   %esi
c002b350:	53                   	push   %ebx
c002b351:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT (!thread_mlfqs);
c002b354:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002b35b:	0f 85 af 00 00 00    	jne    c002b410 <test_priority_condvar+0xc3>
  lock_init (&lock);
c002b361:	83 ec 0c             	sub    $0xc,%esp
c002b364:	68 20 9f 03 c0       	push   $0xc0039f20
c002b369:	e8 90 76 ff ff       	call   c00229fe <lock_init>
  cond_init (&condition);
c002b36e:	c7 04 24 00 9f 03 c0 	movl   $0xc0039f00,(%esp)
c002b375:	e8 f0 7a ff ff       	call   c0022e6a <cond_init>
  thread_set_priority (PRI_MIN);
c002b37a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002b381:	e8 64 61 ff ff       	call   c00214ea <thread_set_priority>
c002b386:	83 c4 10             	add    $0x10,%esp
c002b389:	bb 07 00 00 00       	mov    $0x7,%ebx
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002b38e:	bd 0a 00 00 00       	mov    $0xa,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002b393:	89 e7                	mov    %esp,%edi
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002b395:	89 d8                	mov    %ebx,%eax
c002b397:	99                   	cltd   
c002b398:	f7 fd                	idiv   %ebp
c002b39a:	be 1e 00 00 00       	mov    $0x1e,%esi
c002b39f:	29 d6                	sub    %edx,%esi
      snprintf (name, sizeof name, "priority %d", priority);
c002b3a1:	56                   	push   %esi
c002b3a2:	68 8f fb 02 c0       	push   $0xc002fb8f
c002b3a7:	6a 10                	push   $0x10
c002b3a9:	57                   	push   %edi
c002b3aa:	e8 3c bc ff ff       	call   c0026feb <snprintf>
      thread_create (name, priority, priority_condvar_thread, NULL);
c002b3af:	6a 00                	push   $0x0
c002b3b1:	68 f6 b2 02 c0       	push   $0xc002b2f6
c002b3b6:	56                   	push   %esi
c002b3b7:	57                   	push   %edi
c002b3b8:	e8 12 60 ff ff       	call   c00213cf <thread_create>
c002b3bd:	43                   	inc    %ebx
  for (i = 0; i < 10; i++) 
c002b3be:	83 c4 20             	add    $0x20,%esp
c002b3c1:	83 fb 11             	cmp    $0x11,%ebx
c002b3c4:	75 cf                	jne    c002b395 <test_priority_condvar+0x48>
c002b3c6:	bb 0a 00 00 00       	mov    $0xa,%ebx
      lock_acquire (&lock);
c002b3cb:	83 ec 0c             	sub    $0xc,%esp
c002b3ce:	68 20 9f 03 c0       	push   $0xc0039f20
c002b3d3:	e8 9a 77 ff ff       	call   c0022b72 <lock_acquire>
      msg ("Signaling...");
c002b3d8:	c7 04 24 40 04 03 c0 	movl   $0xc0030440,(%esp)
c002b3df:	e8 fb e9 ff ff       	call   c0029ddf <msg>
      cond_signal (&condition, &lock);
c002b3e4:	83 c4 08             	add    $0x8,%esp
c002b3e7:	68 20 9f 03 c0       	push   $0xc0039f20
c002b3ec:	68 00 9f 03 c0       	push   $0xc0039f00
c002b3f1:	e8 b3 7b ff ff       	call   c0022fa9 <cond_signal>
      lock_release (&lock);
c002b3f6:	c7 04 24 20 9f 03 c0 	movl   $0xc0039f20,(%esp)
c002b3fd:	e8 0d 79 ff ff       	call   c0022d0f <lock_release>
  for (i = 0; i < 10; i++) 
c002b402:	83 c4 10             	add    $0x10,%esp
c002b405:	4b                   	dec    %ebx
c002b406:	75 c3                	jne    c002b3cb <test_priority_condvar+0x7e>
}
c002b408:	83 c4 1c             	add    $0x1c,%esp
c002b40b:	5b                   	pop    %ebx
c002b40c:	5e                   	pop    %esi
c002b40d:	5f                   	pop    %edi
c002b40e:	5d                   	pop    %ebp
c002b40f:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b410:	83 ec 0c             	sub    $0xc,%esp
c002b413:	68 94 f8 02 c0       	push   $0xc002f894
c002b418:	68 3f d9 02 c0       	push   $0xc002d93f
c002b41d:	68 2c d8 02 c0       	push   $0xc002d82c
c002b422:	6a 16                	push   $0x16
c002b424:	68 50 04 03 c0       	push   $0xc0030450
c002b429:	e8 df ce ff ff       	call   c002830d <debug_panic>

c002b42e <interloper_thread_func>:
                                         thread_get_priority ());
}

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002b42e:	83 ec 0c             	sub    $0xc,%esp
  msg ("%s finished.", thread_name ());
c002b431:	e8 ff 56 ff ff       	call   c0020b35 <thread_name>
c002b436:	83 ec 08             	sub    $0x8,%esp
c002b439:	50                   	push   %eax
c002b43a:	68 77 04 03 c0       	push   $0xc0030477
c002b43f:	e8 9b e9 ff ff       	call   c0029ddf <msg>
}
c002b444:	83 c4 1c             	add    $0x1c,%esp
c002b447:	c3                   	ret    

c002b448 <donor_thread_func>:
{
c002b448:	56                   	push   %esi
c002b449:	53                   	push   %ebx
c002b44a:	83 ec 04             	sub    $0x4,%esp
c002b44d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (locks->first)
c002b451:	8b 43 04             	mov    0x4(%ebx),%eax
c002b454:	85 c0                	test   %eax,%eax
c002b456:	74 0c                	je     c002b464 <donor_thread_func+0x1c>
    lock_acquire (locks->first);
c002b458:	83 ec 0c             	sub    $0xc,%esp
c002b45b:	50                   	push   %eax
c002b45c:	e8 11 77 ff ff       	call   c0022b72 <lock_acquire>
c002b461:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->second);
c002b464:	83 ec 0c             	sub    $0xc,%esp
c002b467:	ff 33                	pushl  (%ebx)
c002b469:	e8 04 77 ff ff       	call   c0022b72 <lock_acquire>
  msg ("%s got lock", thread_name ());
c002b46e:	e8 c2 56 ff ff       	call   c0020b35 <thread_name>
c002b473:	83 c4 08             	add    $0x8,%esp
c002b476:	50                   	push   %eax
c002b477:	68 84 04 03 c0       	push   $0xc0030484
c002b47c:	e8 5e e9 ff ff       	call   c0029ddf <msg>
  lock_release (locks->second);
c002b481:	83 c4 04             	add    $0x4,%esp
c002b484:	ff 33                	pushl  (%ebx)
c002b486:	e8 84 78 ff ff       	call   c0022d0f <lock_release>
  msg ("%s should have priority %d. Actual priority: %d", 
c002b48b:	e8 cf 58 ff ff       	call   c0020d5f <thread_get_priority>
c002b490:	89 c6                	mov    %eax,%esi
c002b492:	e8 9e 56 ff ff       	call   c0020b35 <thread_name>
c002b497:	56                   	push   %esi
c002b498:	6a 15                	push   $0x15
c002b49a:	50                   	push   %eax
c002b49b:	68 ac 04 03 c0       	push   $0xc00304ac
c002b4a0:	e8 3a e9 ff ff       	call   c0029ddf <msg>
  if (locks->first)
c002b4a5:	8b 43 04             	mov    0x4(%ebx),%eax
c002b4a8:	83 c4 20             	add    $0x20,%esp
c002b4ab:	85 c0                	test   %eax,%eax
c002b4ad:	74 0c                	je     c002b4bb <donor_thread_func+0x73>
    lock_release (locks->first);
c002b4af:	83 ec 0c             	sub    $0xc,%esp
c002b4b2:	50                   	push   %eax
c002b4b3:	e8 57 78 ff ff       	call   c0022d0f <lock_release>
c002b4b8:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002b4bb:	e8 9f 58 ff ff       	call   c0020d5f <thread_get_priority>
c002b4c0:	89 c3                	mov    %eax,%ebx
c002b4c2:	e8 6e 56 ff ff       	call   c0020b35 <thread_name>
c002b4c7:	83 ec 04             	sub    $0x4,%esp
c002b4ca:	53                   	push   %ebx
c002b4cb:	50                   	push   %eax
c002b4cc:	68 dc 04 03 c0       	push   $0xc00304dc
c002b4d1:	e8 09 e9 ff ff       	call   c0029ddf <msg>
}
c002b4d6:	83 c4 14             	add    $0x14,%esp
c002b4d9:	5b                   	pop    %ebx
c002b4da:	5e                   	pop    %esi
c002b4db:	c3                   	ret    

c002b4dc <test_priority_donate_chain>:
{
c002b4dc:	55                   	push   %ebp
c002b4dd:	57                   	push   %edi
c002b4de:	56                   	push   %esi
c002b4df:	53                   	push   %ebx
c002b4e0:	81 ec dc 01 00 00    	sub    $0x1dc,%esp
  ASSERT (!thread_mlfqs);
c002b4e6:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002b4ed:	75 73                	jne    c002b562 <test_priority_donate_chain+0x86>
  thread_set_priority (PRI_MIN);
c002b4ef:	83 ec 0c             	sub    $0xc,%esp
c002b4f2:	6a 00                	push   $0x0
c002b4f4:	e8 f1 5f ff ff       	call   c00214ea <thread_set_priority>
c002b4f9:	8d 5c 24 74          	lea    0x74(%esp),%ebx
c002b4fd:	8d b4 24 e0 01 00 00 	lea    0x1e0(%esp),%esi
c002b504:	83 c4 10             	add    $0x10,%esp
    lock_init (&locks[i]);
c002b507:	83 ec 0c             	sub    $0xc,%esp
c002b50a:	53                   	push   %ebx
c002b50b:	e8 ee 74 ff ff       	call   c00229fe <lock_init>
c002b510:	83 c3 34             	add    $0x34,%ebx
  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002b513:	83 c4 10             	add    $0x10,%esp
c002b516:	39 f3                	cmp    %esi,%ebx
c002b518:	75 ed                	jne    c002b507 <test_priority_donate_chain+0x2b>
  lock_acquire (&locks[0]);
c002b51a:	83 ec 0c             	sub    $0xc,%esp
c002b51d:	8d 44 24 70          	lea    0x70(%esp),%eax
c002b521:	50                   	push   %eax
c002b522:	e8 4b 76 ff ff       	call   c0022b72 <lock_acquire>
  msg ("%s got lock.", thread_name ());
c002b527:	e8 09 56 ff ff       	call   c0020b35 <thread_name>
c002b52c:	83 c4 08             	add    $0x8,%esp
c002b52f:	50                   	push   %eax
c002b530:	68 90 04 03 c0       	push   $0xc0030490
c002b535:	e8 a5 e8 ff ff       	call   c0029ddf <msg>
c002b53a:	8d 84 24 a8 00 00 00 	lea    0xa8(%esp),%eax
c002b541:	89 44 24 14          	mov    %eax,0x14(%esp)
c002b545:	8d 74 24 3c          	lea    0x3c(%esp),%esi
c002b549:	83 c4 10             	add    $0x10,%esp
c002b54c:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
c002b553:	00 
  for (i = 1; i < NESTING_DEPTH; i++)
c002b554:	bb 01 00 00 00       	mov    $0x1,%ebx
      snprintf (name, sizeof name, "thread %d", i);
c002b559:	8d 6c 24 14          	lea    0x14(%esp),%ebp
c002b55d:	e9 97 00 00 00       	jmp    c002b5f9 <test_priority_donate_chain+0x11d>
  ASSERT (!thread_mlfqs);
c002b562:	83 ec 0c             	sub    $0xc,%esp
c002b565:	68 94 f8 02 c0       	push   $0xc002f894
c002b56a:	68 3f d9 02 c0       	push   $0xc002d93f
c002b56f:	68 44 d8 02 c0       	push   $0xc002d844
c002b574:	6a 34                	push   $0x34
c002b576:	68 fc 04 03 c0       	push   $0xc00304fc
c002b57b:	e8 8d cd ff ff       	call   c002830d <debug_panic>
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002b580:	b8 00 00 00 00       	mov    $0x0,%eax
c002b585:	89 46 04             	mov    %eax,0x4(%esi)
      lock_pairs[i].second = locks + i - 1;
c002b588:	8b 44 24 04          	mov    0x4(%esp),%eax
c002b58c:	83 e8 34             	sub    $0x34,%eax
c002b58f:	89 06                	mov    %eax,(%esi)
      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002b591:	56                   	push   %esi
c002b592:	68 48 b4 02 c0       	push   $0xc002b448
c002b597:	57                   	push   %edi
c002b598:	55                   	push   %ebp
c002b599:	e8 31 5e ff ff       	call   c00213cf <thread_create>
      msg ("%s should have priority %d.  Actual priority: %d.",
c002b59e:	e8 bc 57 ff ff       	call   c0020d5f <thread_get_priority>
c002b5a3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002b5a7:	e8 89 55 ff ff       	call   c0020b35 <thread_name>
c002b5ac:	ff 74 24 1c          	pushl  0x1c(%esp)
c002b5b0:	57                   	push   %edi
c002b5b1:	50                   	push   %eax
c002b5b2:	68 28 05 03 c0       	push   $0xc0030528
c002b5b7:	e8 23 e8 ff ff       	call   c0029ddf <msg>
      snprintf (name, sizeof name, "interloper %d", i);
c002b5bc:	83 c4 20             	add    $0x20,%esp
c002b5bf:	53                   	push   %ebx
c002b5c0:	68 9d 04 03 c0       	push   $0xc003049d
c002b5c5:	6a 10                	push   $0x10
c002b5c7:	55                   	push   %ebp
c002b5c8:	e8 1e ba ff ff       	call   c0026feb <snprintf>
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002b5cd:	6a 00                	push   $0x0
c002b5cf:	68 2e b4 02 c0       	push   $0xc002b42e
c002b5d4:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002b5d8:	57                   	push   %edi
c002b5d9:	55                   	push   %ebp
c002b5da:	e8 f0 5d ff ff       	call   c00213cf <thread_create>
  for (i = 1; i < NESTING_DEPTH; i++)
c002b5df:	43                   	inc    %ebx
c002b5e0:	83 44 24 24 34       	addl   $0x34,0x24(%esp)
c002b5e5:	83 c6 08             	add    $0x8,%esi
c002b5e8:	89 f8                	mov    %edi,%eax
c002b5ea:	83 c0 03             	add    $0x3,%eax
c002b5ed:	89 44 24 28          	mov    %eax,0x28(%esp)
c002b5f1:	83 c4 20             	add    $0x20,%esp
c002b5f4:	83 fb 08             	cmp    $0x8,%ebx
c002b5f7:	74 29                	je     c002b622 <test_priority_donate_chain+0x146>
      snprintf (name, sizeof name, "thread %d", i);
c002b5f9:	53                   	push   %ebx
c002b5fa:	68 a2 f8 02 c0       	push   $0xc002f8a2
c002b5ff:	6a 10                	push   $0x10
c002b601:	55                   	push   %ebp
c002b602:	e8 e4 b9 ff ff       	call   c0026feb <snprintf>
c002b607:	8d 04 1b             	lea    (%ebx,%ebx,1),%eax
c002b60a:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002b60d:	83 c4 10             	add    $0x10,%esp
c002b610:	83 fb 06             	cmp    $0x6,%ebx
c002b613:	0f 8f 67 ff ff ff    	jg     c002b580 <test_priority_donate_chain+0xa4>
c002b619:	8b 44 24 04          	mov    0x4(%esp),%eax
c002b61d:	e9 63 ff ff ff       	jmp    c002b585 <test_priority_donate_chain+0xa9>
  lock_release (&locks[0]);
c002b622:	83 ec 0c             	sub    $0xc,%esp
c002b625:	8d 44 24 70          	lea    0x70(%esp),%eax
c002b629:	50                   	push   %eax
c002b62a:	e8 e0 76 ff ff       	call   c0022d0f <lock_release>
  msg ("%s finishing with priority %d.", thread_name (),
c002b62f:	e8 2b 57 ff ff       	call   c0020d5f <thread_get_priority>
c002b634:	89 c3                	mov    %eax,%ebx
c002b636:	e8 fa 54 ff ff       	call   c0020b35 <thread_name>
c002b63b:	83 c4 0c             	add    $0xc,%esp
c002b63e:	53                   	push   %ebx
c002b63f:	50                   	push   %eax
c002b640:	68 dc 04 03 c0       	push   $0xc00304dc
c002b645:	e8 95 e7 ff ff       	call   c0029ddf <msg>
}
c002b64a:	81 c4 ec 01 00 00    	add    $0x1ec,%esp
c002b650:	5b                   	pop    %ebx
c002b651:	5e                   	pop    %esi
c002b652:	5f                   	pop    %edi
c002b653:	5d                   	pop    %ebp
c002b654:	c3                   	ret    

c002b655 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002b655:	55                   	push   %ebp
c002b656:	57                   	push   %edi
c002b657:	56                   	push   %esi
c002b658:	53                   	push   %ebx
c002b659:	83 ec 0c             	sub    $0xc,%esp
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002b65c:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002b663:	74 1b                	je     c002b680 <test_mlfqs_load_1+0x2b>

  msg ("spinning for up to 45 seconds, please wait...");
c002b665:	83 ec 0c             	sub    $0xc,%esp
c002b668:	68 a8 05 03 c0       	push   $0xc00305a8
c002b66d:	e8 6d e7 ff ff       	call   c0029ddf <msg>

  start_time = timer_ticks ();
c002b672:	e8 2b 88 ff ff       	call   c0023ea2 <timer_ticks>
c002b677:	89 c6                	mov    %eax,%esi
c002b679:	89 d7                	mov    %edx,%edi
c002b67b:	83 c4 10             	add    $0x10,%esp
c002b67e:	eb 6a                	jmp    c002b6ea <test_mlfqs_load_1+0x95>
  ASSERT (thread_mlfqs);
c002b680:	83 ec 0c             	sub    $0xc,%esp
c002b683:	68 95 f8 02 c0       	push   $0xc002f895
c002b688:	68 3f d9 02 c0       	push   $0xc002d93f
c002b68d:	68 60 d8 02 c0       	push   $0xc002d860
c002b692:	6a 18                	push   $0x18
c002b694:	68 84 05 03 c0       	push   $0xc0030584
c002b699:	e8 6f cc ff ff       	call   c002830d <debug_panic>
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
      ASSERT (load_avg >= 0);
c002b69e:	83 ec 0c             	sub    $0xc,%esp
c002b6a1:	68 5a 05 03 c0       	push   $0xc003055a
c002b6a6:	68 3f d9 02 c0       	push   $0xc002d93f
c002b6ab:	68 60 d8 02 c0       	push   $0xc002d860
c002b6b0:	6a 20                	push   $0x20
c002b6b2:	68 84 05 03 c0       	push   $0xc0030584
c002b6b7:	e8 51 cc ff ff       	call   c002830d <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
      if (load_avg > 100)
        fail ("load average is %d.%02d "
c002b6bc:	50                   	push   %eax
c002b6bd:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002b6c2:	f7 eb                	imul   %ebx
c002b6c4:	89 d0                	mov    %edx,%eax
c002b6c6:	c1 f8 05             	sar    $0x5,%eax
c002b6c9:	89 da                	mov    %ebx,%edx
c002b6cb:	c1 fa 1f             	sar    $0x1f,%edx
c002b6ce:	29 d0                	sub    %edx,%eax
c002b6d0:	8d 14 80             	lea    (%eax,%eax,4),%edx
c002b6d3:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002b6d6:	c1 e2 02             	shl    $0x2,%edx
c002b6d9:	29 d3                	sub    %edx,%ebx
c002b6db:	53                   	push   %ebx
c002b6dc:	50                   	push   %eax
c002b6dd:	68 d8 05 03 c0       	push   $0xc00305d8
c002b6e2:	e8 9c e7 ff ff       	call   c0029e83 <fail>
c002b6e7:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002b6ea:	e8 ae 56 ff ff       	call   c0020d9d <thread_get_load_avg>
c002b6ef:	89 c3                	mov    %eax,%ebx
      ASSERT (load_avg >= 0);
c002b6f1:	85 c0                	test   %eax,%eax
c002b6f3:	78 a9                	js     c002b69e <test_mlfqs_load_1+0x49>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002b6f5:	83 ec 08             	sub    $0x8,%esp
c002b6f8:	57                   	push   %edi
c002b6f9:	56                   	push   %esi
c002b6fa:	e8 cc 87 ff ff       	call   c0023ecb <timer_elapsed>
c002b6ff:	6a 00                	push   $0x0
c002b701:	6a 64                	push   $0x64
c002b703:	52                   	push   %edx
c002b704:	50                   	push   %eax
c002b705:	e8 1d c6 ff ff       	call   c0027d27 <__divdi3>
c002b70a:	89 c5                	mov    %eax,%ebp
      if (load_avg > 100)
c002b70c:	83 c4 20             	add    $0x20,%esp
c002b70f:	83 fb 64             	cmp    $0x64,%ebx
c002b712:	7f a8                	jg     c002b6bc <test_mlfqs_load_1+0x67>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c002b714:	83 fb 32             	cmp    $0x32,%ebx
c002b717:	7f 17                	jg     c002b730 <test_mlfqs_load_1+0xdb>
        break;
      else if (elapsed > 45)
c002b719:	83 f8 2d             	cmp    $0x2d,%eax
c002b71c:	7e cc                	jle    c002b6ea <test_mlfqs_load_1+0x95>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002b71e:	83 ec 0c             	sub    $0xc,%esp
c002b721:	68 24 06 03 c0       	push   $0xc0030624
c002b726:	e8 58 e7 ff ff       	call   c0029e83 <fail>
c002b72b:	83 c4 10             	add    $0x10,%esp
c002b72e:	eb ba                	jmp    c002b6ea <test_mlfqs_load_1+0x95>
    }

  if (elapsed < 38)
c002b730:	83 f8 25             	cmp    $0x25,%eax
c002b733:	7e 76                	jle    c002b7ab <test_mlfqs_load_1+0x156>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002b735:	83 ec 08             	sub    $0x8,%esp
c002b738:	55                   	push   %ebp
c002b739:	68 90 06 03 c0       	push   $0xc0030690
c002b73e:	e8 9c e6 ff ff       	call   c0029ddf <msg>

  msg ("sleeping for another 10 seconds, please wait...");
c002b743:	c7 04 24 bc 06 03 c0 	movl   $0xc00306bc,(%esp)
c002b74a:	e8 90 e6 ff ff       	call   c0029ddf <msg>
  timer_sleep (TIMER_FREQ * 10);
c002b74f:	83 c4 08             	add    $0x8,%esp
c002b752:	6a 00                	push   $0x0
c002b754:	68 e8 03 00 00       	push   $0x3e8
c002b759:	e8 89 87 ff ff       	call   c0023ee7 <timer_sleep>

  load_avg = thread_get_load_avg ();
c002b75e:	e8 3a 56 ff ff       	call   c0020d9d <thread_get_load_avg>
c002b763:	89 c3                	mov    %eax,%ebx
  if (load_avg < 0)
c002b765:	83 c4 10             	add    $0x10,%esp
c002b768:	85 c0                	test   %eax,%eax
c002b76a:	78 55                	js     c002b7c1 <test_mlfqs_load_1+0x16c>
    fail ("load average fell below 0");
  if (load_avg > 50)
c002b76c:	83 fb 32             	cmp    $0x32,%ebx
c002b76f:	7f 62                	jg     c002b7d3 <test_mlfqs_load_1+0x17e>
    fail ("load average stayed above 0.5 for more than 10 seconds");
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002b771:	83 ec 04             	sub    $0x4,%esp
c002b774:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002b779:	f7 eb                	imul   %ebx
c002b77b:	89 d0                	mov    %edx,%eax
c002b77d:	c1 f8 05             	sar    $0x5,%eax
c002b780:	89 da                	mov    %ebx,%edx
c002b782:	c1 fa 1f             	sar    $0x1f,%edx
c002b785:	29 d0                	sub    %edx,%eax
c002b787:	8d 14 80             	lea    (%eax,%eax,4),%edx
c002b78a:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002b78d:	c1 e2 02             	shl    $0x2,%edx
c002b790:	29 d3                	sub    %edx,%ebx
c002b792:	53                   	push   %ebx
c002b793:	50                   	push   %eax
c002b794:	68 24 07 03 c0       	push   $0xc0030724
c002b799:	e8 41 e6 ff ff       	call   c0029ddf <msg>
       load_avg / 100, load_avg % 100);

  pass ();
c002b79e:	e8 26 e7 ff ff       	call   c0029ec9 <pass>
}
c002b7a3:	83 c4 1c             	add    $0x1c,%esp
c002b7a6:	5b                   	pop    %ebx
c002b7a7:	5e                   	pop    %esi
c002b7a8:	5f                   	pop    %edi
c002b7a9:	5d                   	pop    %ebp
c002b7aa:	c3                   	ret    
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002b7ab:	83 ec 08             	sub    $0x8,%esp
c002b7ae:	50                   	push   %eax
c002b7af:	68 5c 06 03 c0       	push   $0xc003065c
c002b7b4:	e8 ca e6 ff ff       	call   c0029e83 <fail>
c002b7b9:	83 c4 10             	add    $0x10,%esp
c002b7bc:	e9 74 ff ff ff       	jmp    c002b735 <test_mlfqs_load_1+0xe0>
    fail ("load average fell below 0");
c002b7c1:	83 ec 0c             	sub    $0xc,%esp
c002b7c4:	68 68 05 03 c0       	push   $0xc0030568
c002b7c9:	e8 b5 e6 ff ff       	call   c0029e83 <fail>
c002b7ce:	83 c4 10             	add    $0x10,%esp
c002b7d1:	eb 99                	jmp    c002b76c <test_mlfqs_load_1+0x117>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002b7d3:	83 ec 0c             	sub    $0xc,%esp
c002b7d6:	68 ec 06 03 c0       	push   $0xc00306ec
c002b7db:	e8 a3 e6 ff ff       	call   c0029e83 <fail>
c002b7e0:	83 c4 10             	add    $0x10,%esp
c002b7e3:	eb 8c                	jmp    c002b771 <test_mlfqs_load_1+0x11c>

c002b7e5 <load_thread>:
    }
}

static void
load_thread (void *aux UNUSED) 
{
c002b7e5:	53                   	push   %ebx
c002b7e6:	83 ec 14             	sub    $0x14,%esp
  int64_t sleep_time = 10 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;

  thread_set_nice (20);
c002b7e9:	6a 14                	push   $0x14
c002b7eb:	e8 17 55 ff ff       	call   c0020d07 <thread_set_nice>
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002b7f0:	83 c4 08             	add    $0x8,%esp
c002b7f3:	ff 35 5c 9f 03 c0    	pushl  0xc0039f5c
c002b7f9:	ff 35 58 9f 03 c0    	pushl  0xc0039f58
c002b7ff:	e8 c7 86 ff ff       	call   c0023ecb <timer_elapsed>
c002b804:	83 c4 08             	add    $0x8,%esp
c002b807:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c002b80c:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b811:	29 c1                	sub    %eax,%ecx
c002b813:	19 d3                	sbb    %edx,%ebx
c002b815:	53                   	push   %ebx
c002b816:	51                   	push   %ecx
c002b817:	e8 cb 86 ff ff       	call   c0023ee7 <timer_sleep>
  while (timer_elapsed (start_time) < spin_time)
c002b81c:	83 c4 10             	add    $0x10,%esp
c002b81f:	83 ec 08             	sub    $0x8,%esp
c002b822:	ff 35 5c 9f 03 c0    	pushl  0xc0039f5c
c002b828:	ff 35 58 9f 03 c0    	pushl  0xc0039f58
c002b82e:	e8 98 86 ff ff       	call   c0023ecb <timer_elapsed>
c002b833:	83 c4 10             	add    $0x10,%esp
c002b836:	85 d2                	test   %edx,%edx
c002b838:	78 e5                	js     c002b81f <load_thread+0x3a>
c002b83a:	85 d2                	test   %edx,%edx
c002b83c:	7e 31                	jle    c002b86f <load_thread+0x8a>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002b83e:	83 ec 08             	sub    $0x8,%esp
c002b841:	ff 35 5c 9f 03 c0    	pushl  0xc0039f5c
c002b847:	ff 35 58 9f 03 c0    	pushl  0xc0039f58
c002b84d:	e8 79 86 ff ff       	call   c0023ecb <timer_elapsed>
c002b852:	83 c4 08             	add    $0x8,%esp
c002b855:	b9 c8 32 00 00       	mov    $0x32c8,%ecx
c002b85a:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b85f:	29 c1                	sub    %eax,%ecx
c002b861:	19 d3                	sbb    %edx,%ebx
c002b863:	53                   	push   %ebx
c002b864:	51                   	push   %ecx
c002b865:	e8 7d 86 ff ff       	call   c0023ee7 <timer_sleep>
}
c002b86a:	83 c4 18             	add    $0x18,%esp
c002b86d:	5b                   	pop    %ebx
c002b86e:	c3                   	ret    
  while (timer_elapsed (start_time) < spin_time)
c002b86f:	3d 57 1b 00 00       	cmp    $0x1b57,%eax
c002b874:	76 a9                	jbe    c002b81f <load_thread+0x3a>
c002b876:	eb c6                	jmp    c002b83e <load_thread+0x59>

c002b878 <test_mlfqs_load_60>:
{
c002b878:	55                   	push   %ebp
c002b879:	57                   	push   %edi
c002b87a:	56                   	push   %esi
c002b87b:	53                   	push   %ebx
c002b87c:	83 ec 2c             	sub    $0x2c,%esp
  ASSERT (thread_mlfqs);
c002b87f:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002b886:	0f 84 2c 01 00 00    	je     c002b9b8 <test_mlfqs_load_60+0x140>
  start_time = timer_ticks ();
c002b88c:	e8 11 86 ff ff       	call   c0023ea2 <timer_ticks>
c002b891:	a3 58 9f 03 c0       	mov    %eax,0xc0039f58
c002b896:	89 15 5c 9f 03 c0    	mov    %edx,0xc0039f5c
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002b89c:	83 ec 08             	sub    $0x8,%esp
c002b89f:	6a 3c                	push   $0x3c
c002b8a1:	68 80 07 03 c0       	push   $0xc0030780
c002b8a6:	e8 34 e5 ff ff       	call   c0029ddf <msg>
c002b8ab:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002b8ae:	bb 00 00 00 00       	mov    $0x0,%ebx
      snprintf(name, sizeof name, "load %d", i);
c002b8b3:	8d 74 24 10          	lea    0x10(%esp),%esi
c002b8b7:	53                   	push   %ebx
c002b8b8:	68 52 07 03 c0       	push   $0xc0030752
c002b8bd:	6a 10                	push   $0x10
c002b8bf:	56                   	push   %esi
c002b8c0:	e8 26 b7 ff ff       	call   c0026feb <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002b8c5:	6a 00                	push   $0x0
c002b8c7:	68 e5 b7 02 c0       	push   $0xc002b7e5
c002b8cc:	6a 1f                	push   $0x1f
c002b8ce:	56                   	push   %esi
c002b8cf:	e8 fb 5a ff ff       	call   c00213cf <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002b8d4:	43                   	inc    %ebx
c002b8d5:	83 c4 20             	add    $0x20,%esp
c002b8d8:	83 fb 3c             	cmp    $0x3c,%ebx
c002b8db:	75 da                	jne    c002b8b7 <test_mlfqs_load_60+0x3f>
       timer_elapsed (start_time) / TIMER_FREQ);
c002b8dd:	83 ec 08             	sub    $0x8,%esp
c002b8e0:	ff 35 5c 9f 03 c0    	pushl  0xc0039f5c
c002b8e6:	ff 35 58 9f 03 c0    	pushl  0xc0039f58
c002b8ec:	e8 da 85 ff ff       	call   c0023ecb <timer_elapsed>
  msg ("Starting threads took %d seconds.",
c002b8f1:	6a 00                	push   $0x0
c002b8f3:	6a 64                	push   $0x64
c002b8f5:	52                   	push   %edx
c002b8f6:	50                   	push   %eax
c002b8f7:	e8 2b c4 ff ff       	call   c0027d27 <__divdi3>
c002b8fc:	83 c4 1c             	add    $0x1c,%esp
c002b8ff:	52                   	push   %edx
c002b900:	50                   	push   %eax
c002b901:	68 a4 07 03 c0       	push   $0xc00307a4
c002b906:	e8 d4 e4 ff ff       	call   c0029ddf <msg>
c002b90b:	83 c4 10             	add    $0x10,%esp
c002b90e:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b913:	be e8 03 00 00       	mov    $0x3e8,%esi
c002b918:	bf 00 00 00 00       	mov    $0x0,%edi
      msg ("After %d seconds, load average=%d.%02d.",
c002b91d:	bd 1f 85 eb 51       	mov    $0x51eb851f,%ebp
c002b922:	89 5c 24 04          	mov    %ebx,0x4(%esp)
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002b926:	89 f0                	mov    %esi,%eax
c002b928:	89 fa                	mov    %edi,%edx
c002b92a:	03 05 58 9f 03 c0    	add    0xc0039f58,%eax
c002b930:	13 15 5c 9f 03 c0    	adc    0xc0039f5c,%edx
c002b936:	89 44 24 08          	mov    %eax,0x8(%esp)
c002b93a:	89 54 24 0c          	mov    %edx,0xc(%esp)
      timer_sleep (sleep_until - timer_ticks ());
c002b93e:	e8 5f 85 ff ff       	call   c0023ea2 <timer_ticks>
c002b943:	83 ec 08             	sub    $0x8,%esp
c002b946:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002b94a:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002b94e:	29 c1                	sub    %eax,%ecx
c002b950:	19 d3                	sbb    %edx,%ebx
c002b952:	53                   	push   %ebx
c002b953:	51                   	push   %ecx
c002b954:	e8 8e 85 ff ff       	call   c0023ee7 <timer_sleep>
      load_avg = thread_get_load_avg ();
c002b959:	e8 3f 54 ff ff       	call   c0020d9d <thread_get_load_avg>
c002b95e:	89 c1                	mov    %eax,%ecx
      msg ("After %d seconds, load average=%d.%02d.",
c002b960:	f7 ed                	imul   %ebp
c002b962:	89 d0                	mov    %edx,%eax
c002b964:	c1 f8 05             	sar    $0x5,%eax
c002b967:	89 ca                	mov    %ecx,%edx
c002b969:	c1 fa 1f             	sar    $0x1f,%edx
c002b96c:	29 d0                	sub    %edx,%eax
c002b96e:	8d 14 80             	lea    (%eax,%eax,4),%edx
c002b971:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002b974:	c1 e2 02             	shl    $0x2,%edx
c002b977:	29 d1                	sub    %edx,%ecx
c002b979:	51                   	push   %ecx
c002b97a:	50                   	push   %eax
c002b97b:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002b97f:	53                   	push   %ebx
c002b980:	68 c8 07 03 c0       	push   $0xc00307c8
c002b985:	e8 55 e4 ff ff       	call   c0029ddf <msg>
c002b98a:	81 c6 c8 00 00 00    	add    $0xc8,%esi
c002b990:	83 d7 00             	adc    $0x0,%edi
c002b993:	89 d8                	mov    %ebx,%eax
c002b995:	83 c0 02             	add    $0x2,%eax
c002b998:	89 44 24 24          	mov    %eax,0x24(%esp)
  for (i = 0; i < 90; i++) 
c002b99c:	83 c4 20             	add    $0x20,%esp
c002b99f:	89 f0                	mov    %esi,%eax
c002b9a1:	35 38 4a 00 00       	xor    $0x4a38,%eax
c002b9a6:	89 fa                	mov    %edi,%edx
c002b9a8:	09 c2                	or     %eax,%edx
c002b9aa:	0f 85 76 ff ff ff    	jne    c002b926 <test_mlfqs_load_60+0xae>
}
c002b9b0:	83 c4 2c             	add    $0x2c,%esp
c002b9b3:	5b                   	pop    %ebx
c002b9b4:	5e                   	pop    %esi
c002b9b5:	5f                   	pop    %edi
c002b9b6:	5d                   	pop    %ebp
c002b9b7:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002b9b8:	83 ec 0c             	sub    $0xc,%esp
c002b9bb:	68 95 f8 02 c0       	push   $0xc002f895
c002b9c0:	68 3f d9 02 c0       	push   $0xc002d93f
c002b9c5:	68 74 d8 02 c0       	push   $0xc002d874
c002b9ca:	6a 77                	push   $0x77
c002b9cc:	68 5c 07 03 c0       	push   $0xc003075c
c002b9d1:	e8 37 c9 ff ff       	call   c002830d <debug_panic>

c002b9d6 <load_thread>:
    }
}

static void
load_thread (void *seq_no_) 
{
c002b9d6:	57                   	push   %edi
c002b9d7:	56                   	push   %esi
c002b9d8:	53                   	push   %ebx
c002b9d9:	8b 44 24 10          	mov    0x10(%esp),%eax
  int seq_no = (int) seq_no_;
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002b9dd:	8d 44 80 32          	lea    0x32(%eax,%eax,4),%eax
c002b9e1:	8d 34 80             	lea    (%eax,%eax,4),%esi
c002b9e4:	c1 e6 02             	shl    $0x2,%esi
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002b9e7:	8d 9e 70 17 00 00    	lea    0x1770(%esi),%ebx
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002b9ed:	83 ec 08             	sub    $0x8,%esp
c002b9f0:	ff 35 64 9f 03 c0    	pushl  0xc0039f64
c002b9f6:	ff 35 60 9f 03 c0    	pushl  0xc0039f60
c002b9fc:	e8 ca 84 ff ff       	call   c0023ecb <timer_elapsed>
c002ba01:	83 c4 08             	add    $0x8,%esp
c002ba04:	89 f7                	mov    %esi,%edi
c002ba06:	c1 ff 1f             	sar    $0x1f,%edi
c002ba09:	29 c6                	sub    %eax,%esi
c002ba0b:	19 d7                	sbb    %edx,%edi
c002ba0d:	57                   	push   %edi
c002ba0e:	56                   	push   %esi
c002ba0f:	e8 d3 84 ff ff       	call   c0023ee7 <timer_sleep>
  while (timer_elapsed (start_time) < spin_time)
c002ba14:	83 c4 10             	add    $0x10,%esp
c002ba17:	89 df                	mov    %ebx,%edi
c002ba19:	c1 ff 1f             	sar    $0x1f,%edi
c002ba1c:	83 ec 08             	sub    $0x8,%esp
c002ba1f:	ff 35 64 9f 03 c0    	pushl  0xc0039f64
c002ba25:	ff 35 60 9f 03 c0    	pushl  0xc0039f60
c002ba2b:	e8 9b 84 ff ff       	call   c0023ecb <timer_elapsed>
c002ba30:	83 c4 10             	add    $0x10,%esp
c002ba33:	39 fa                	cmp    %edi,%edx
c002ba35:	7c e5                	jl     c002ba1c <load_thread+0x46>
c002ba37:	7f 04                	jg     c002ba3d <load_thread+0x67>
c002ba39:	39 d8                	cmp    %ebx,%eax
c002ba3b:	72 df                	jb     c002ba1c <load_thread+0x46>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002ba3d:	83 ec 08             	sub    $0x8,%esp
c002ba40:	ff 35 64 9f 03 c0    	pushl  0xc0039f64
c002ba46:	ff 35 60 9f 03 c0    	pushl  0xc0039f60
c002ba4c:	e8 7a 84 ff ff       	call   c0023ecb <timer_elapsed>
c002ba51:	83 c4 08             	add    $0x8,%esp
c002ba54:	b9 e0 2e 00 00       	mov    $0x2ee0,%ecx
c002ba59:	bb 00 00 00 00       	mov    $0x0,%ebx
c002ba5e:	29 c1                	sub    %eax,%ecx
c002ba60:	19 d3                	sbb    %edx,%ebx
c002ba62:	53                   	push   %ebx
c002ba63:	51                   	push   %ecx
c002ba64:	e8 7e 84 ff ff       	call   c0023ee7 <timer_sleep>
}
c002ba69:	83 c4 10             	add    $0x10,%esp
c002ba6c:	5b                   	pop    %ebx
c002ba6d:	5e                   	pop    %esi
c002ba6e:	5f                   	pop    %edi
c002ba6f:	c3                   	ret    

c002ba70 <test_mlfqs_load_avg>:
{
c002ba70:	55                   	push   %ebp
c002ba71:	57                   	push   %edi
c002ba72:	56                   	push   %esi
c002ba73:	53                   	push   %ebx
c002ba74:	83 ec 2c             	sub    $0x2c,%esp
  ASSERT (thread_mlfqs);
c002ba77:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002ba7e:	0f 84 37 01 00 00    	je     c002bbbb <test_mlfqs_load_avg+0x14b>
  start_time = timer_ticks ();
c002ba84:	e8 19 84 ff ff       	call   c0023ea2 <timer_ticks>
c002ba89:	a3 60 9f 03 c0       	mov    %eax,0xc0039f60
c002ba8e:	89 15 64 9f 03 c0    	mov    %edx,0xc0039f64
  msg ("Starting %d load threads...", THREAD_CNT);
c002ba94:	83 ec 08             	sub    $0x8,%esp
c002ba97:	6a 3c                	push   $0x3c
c002ba99:	68 f0 07 03 c0       	push   $0xc00307f0
c002ba9e:	e8 3c e3 ff ff       	call   c0029ddf <msg>
c002baa3:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002baa6:	bb 00 00 00 00       	mov    $0x0,%ebx
      snprintf(name, sizeof name, "load %d", i);
c002baab:	8d 74 24 10          	lea    0x10(%esp),%esi
c002baaf:	53                   	push   %ebx
c002bab0:	68 52 07 03 c0       	push   $0xc0030752
c002bab5:	6a 10                	push   $0x10
c002bab7:	56                   	push   %esi
c002bab8:	e8 2e b5 ff ff       	call   c0026feb <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002babd:	53                   	push   %ebx
c002babe:	68 d6 b9 02 c0       	push   $0xc002b9d6
c002bac3:	6a 1f                	push   $0x1f
c002bac5:	56                   	push   %esi
c002bac6:	e8 04 59 ff ff       	call   c00213cf <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002bacb:	43                   	inc    %ebx
c002bacc:	83 c4 20             	add    $0x20,%esp
c002bacf:	83 fb 3c             	cmp    $0x3c,%ebx
c002bad2:	75 db                	jne    c002baaf <test_mlfqs_load_avg+0x3f>
       timer_elapsed (start_time) / TIMER_FREQ);
c002bad4:	83 ec 08             	sub    $0x8,%esp
c002bad7:	ff 35 64 9f 03 c0    	pushl  0xc0039f64
c002badd:	ff 35 60 9f 03 c0    	pushl  0xc0039f60
c002bae3:	e8 e3 83 ff ff       	call   c0023ecb <timer_elapsed>
  msg ("Starting threads took %d seconds.",
c002bae8:	6a 00                	push   $0x0
c002baea:	6a 64                	push   $0x64
c002baec:	52                   	push   %edx
c002baed:	50                   	push   %eax
c002baee:	e8 34 c2 ff ff       	call   c0027d27 <__divdi3>
c002baf3:	83 c4 1c             	add    $0x1c,%esp
c002baf6:	52                   	push   %edx
c002baf7:	50                   	push   %eax
c002baf8:	68 a4 07 03 c0       	push   $0xc00307a4
c002bafd:	e8 dd e2 ff ff       	call   c0029ddf <msg>
  thread_set_nice (-20);
c002bb02:	c7 04 24 ec ff ff ff 	movl   $0xffffffec,(%esp)
c002bb09:	e8 f9 51 ff ff       	call   c0020d07 <thread_set_nice>
c002bb0e:	83 c4 10             	add    $0x10,%esp
c002bb11:	bb 00 00 00 00       	mov    $0x0,%ebx
c002bb16:	be e8 03 00 00       	mov    $0x3e8,%esi
c002bb1b:	bf 00 00 00 00       	mov    $0x0,%edi
      msg ("After %d seconds, load average=%d.%02d.",
c002bb20:	bd 1f 85 eb 51       	mov    $0x51eb851f,%ebp
c002bb25:	89 5c 24 04          	mov    %ebx,0x4(%esp)
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002bb29:	89 f0                	mov    %esi,%eax
c002bb2b:	89 fa                	mov    %edi,%edx
c002bb2d:	03 05 60 9f 03 c0    	add    0xc0039f60,%eax
c002bb33:	13 15 64 9f 03 c0    	adc    0xc0039f64,%edx
c002bb39:	89 44 24 08          	mov    %eax,0x8(%esp)
c002bb3d:	89 54 24 0c          	mov    %edx,0xc(%esp)
      timer_sleep (sleep_until - timer_ticks ());
c002bb41:	e8 5c 83 ff ff       	call   c0023ea2 <timer_ticks>
c002bb46:	83 ec 08             	sub    $0x8,%esp
c002bb49:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002bb4d:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002bb51:	29 c1                	sub    %eax,%ecx
c002bb53:	19 d3                	sbb    %edx,%ebx
c002bb55:	53                   	push   %ebx
c002bb56:	51                   	push   %ecx
c002bb57:	e8 8b 83 ff ff       	call   c0023ee7 <timer_sleep>
      load_avg = thread_get_load_avg ();
c002bb5c:	e8 3c 52 ff ff       	call   c0020d9d <thread_get_load_avg>
c002bb61:	89 c1                	mov    %eax,%ecx
      msg ("After %d seconds, load average=%d.%02d.",
c002bb63:	f7 ed                	imul   %ebp
c002bb65:	89 d0                	mov    %edx,%eax
c002bb67:	c1 f8 05             	sar    $0x5,%eax
c002bb6a:	89 ca                	mov    %ecx,%edx
c002bb6c:	c1 fa 1f             	sar    $0x1f,%edx
c002bb6f:	29 d0                	sub    %edx,%eax
c002bb71:	8d 14 80             	lea    (%eax,%eax,4),%edx
c002bb74:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002bb77:	c1 e2 02             	shl    $0x2,%edx
c002bb7a:	29 d1                	sub    %edx,%ecx
c002bb7c:	51                   	push   %ecx
c002bb7d:	50                   	push   %eax
c002bb7e:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002bb82:	53                   	push   %ebx
c002bb83:	68 c8 07 03 c0       	push   $0xc00307c8
c002bb88:	e8 52 e2 ff ff       	call   c0029ddf <msg>
c002bb8d:	81 c6 c8 00 00 00    	add    $0xc8,%esi
c002bb93:	83 d7 00             	adc    $0x0,%edi
c002bb96:	89 d8                	mov    %ebx,%eax
c002bb98:	83 c0 02             	add    $0x2,%eax
c002bb9b:	89 44 24 24          	mov    %eax,0x24(%esp)
  for (i = 0; i < 90; i++) 
c002bb9f:	83 c4 20             	add    $0x20,%esp
c002bba2:	89 f0                	mov    %esi,%eax
c002bba4:	35 38 4a 00 00       	xor    $0x4a38,%eax
c002bba9:	89 fa                	mov    %edi,%edx
c002bbab:	09 c2                	or     %eax,%edx
c002bbad:	0f 85 76 ff ff ff    	jne    c002bb29 <test_mlfqs_load_avg+0xb9>
}
c002bbb3:	83 c4 2c             	add    $0x2c,%esp
c002bbb6:	5b                   	pop    %ebx
c002bbb7:	5e                   	pop    %esi
c002bbb8:	5f                   	pop    %edi
c002bbb9:	5d                   	pop    %ebp
c002bbba:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002bbbb:	83 ec 0c             	sub    $0xc,%esp
c002bbbe:	68 95 f8 02 c0       	push   $0xc002f895
c002bbc3:	68 3f d9 02 c0       	push   $0xc002d93f
c002bbc8:	68 88 d8 02 c0       	push   $0xc002d888
c002bbcd:	68 82 00 00 00       	push   $0x82
c002bbd2:	68 0c 08 03 c0       	push   $0xc003080c
c002bbd7:	e8 31 c7 ff ff       	call   c002830d <debug_panic>

c002bbdc <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002bbdc:	55                   	push   %ebp
c002bbdd:	57                   	push   %edi
c002bbde:	56                   	push   %esi
c002bbdf:	53                   	push   %ebx
c002bbe0:	83 ec 1c             	sub    $0x1c,%esp
  int64_t start_time;
  int last_elapsed = 0;
  
  ASSERT (thread_mlfqs);
c002bbe3:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002bbea:	74 5c                	je     c002bc48 <test_mlfqs_recent_1+0x6c>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002bbec:	83 ec 0c             	sub    $0xc,%esp
c002bbef:	68 5c 08 03 c0       	push   $0xc003085c
c002bbf4:	e8 e6 e1 ff ff       	call   c0029ddf <msg>
      start_time = timer_ticks ();
c002bbf9:	e8 a4 82 ff ff       	call   c0023ea2 <timer_ticks>
c002bbfe:	89 c6                	mov    %eax,%esi
c002bc00:	89 d7                	mov    %edx,%edi
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002bc02:	83 c0 63             	add    $0x63,%eax
c002bc05:	83 d2 00             	adc    $0x0,%edx
c002bc08:	6a 00                	push   $0x0
c002bc0a:	6a 64                	push   $0x64
c002bc0c:	52                   	push   %edx
c002bc0d:	50                   	push   %eax
c002bc0e:	e8 14 c1 ff ff       	call   c0027d27 <__divdi3>
c002bc13:	83 c4 18             	add    $0x18,%esp
c002bc16:	29 f0                	sub    %esi,%eax
c002bc18:	19 fa                	sbb    %edi,%edx
c002bc1a:	05 e8 03 00 00       	add    $0x3e8,%eax
c002bc1f:	83 d2 00             	adc    $0x0,%edx
c002bc22:	52                   	push   %edx
c002bc23:	50                   	push   %eax
c002bc24:	e8 be 82 ff ff       	call   c0023ee7 <timer_sleep>
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002bc29:	e8 a3 52 ff ff       	call   c0020ed1 <thread_get_recent_cpu>
c002bc2e:	83 c4 10             	add    $0x10,%esp
c002bc31:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002bc36:	7f b4                	jg     c002bbec <test_mlfqs_recent_1+0x10>

  start_time = timer_ticks ();
c002bc38:	e8 65 82 ff ff       	call   c0023ea2 <timer_ticks>
c002bc3d:	89 c6                	mov    %eax,%esi
c002bc3f:	89 d7                	mov    %edx,%edi
  int last_elapsed = 0;
c002bc41:	bd 00 00 00 00       	mov    $0x0,%ebp
c002bc46:	eb 20                	jmp    c002bc68 <test_mlfqs_recent_1+0x8c>
  ASSERT (thread_mlfqs);
c002bc48:	83 ec 0c             	sub    $0xc,%esp
c002bc4b:	68 95 f8 02 c0       	push   $0xc002f895
c002bc50:	68 3f d9 02 c0       	push   $0xc002d93f
c002bc55:	68 9c d8 02 c0       	push   $0xc002d89c
c002bc5a:	6a 73                	push   $0x73
c002bc5c:	68 34 08 03 c0       	push   $0xc0030834
c002bc61:	e8 a7 c6 ff ff       	call   c002830d <debug_panic>
{
c002bc66:	89 dd                	mov    %ebx,%ebp
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c002bc68:	83 ec 08             	sub    $0x8,%esp
c002bc6b:	57                   	push   %edi
c002bc6c:	56                   	push   %esi
c002bc6d:	e8 59 82 ff ff       	call   c0023ecb <timer_elapsed>
c002bc72:	89 c3                	mov    %eax,%ebx
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002bc74:	b9 c8 00 00 00       	mov    $0xc8,%ecx
c002bc79:	99                   	cltd   
c002bc7a:	f7 f9                	idiv   %ecx
c002bc7c:	83 c4 10             	add    $0x10,%esp
c002bc7f:	85 d2                	test   %edx,%edx
c002bc81:	75 e3                	jne    c002bc66 <test_mlfqs_recent_1+0x8a>
c002bc83:	39 dd                	cmp    %ebx,%ebp
c002bc85:	7d df                	jge    c002bc66 <test_mlfqs_recent_1+0x8a>
        {
          int recent_cpu = thread_get_recent_cpu ();
c002bc87:	e8 45 52 ff ff       	call   c0020ed1 <thread_get_recent_cpu>
c002bc8c:	89 44 24 0c          	mov    %eax,0xc(%esp)
          int load_avg = thread_get_load_avg ();
c002bc90:	e8 08 51 ff ff       	call   c0020d9d <thread_get_load_avg>
c002bc95:	89 c1                	mov    %eax,%ecx
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002bc97:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002bc9c:	f7 eb                	imul   %ebx
c002bc9e:	89 d5                	mov    %edx,%ebp
c002bca0:	c1 fd 05             	sar    $0x5,%ebp
c002bca3:	89 d8                	mov    %ebx,%eax
c002bca5:	c1 f8 1f             	sar    $0x1f,%eax
c002bca8:	29 c5                	sub    %eax,%ebp
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002bcaa:	83 ec 08             	sub    $0x8,%esp
c002bcad:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002bcb2:	f7 e9                	imul   %ecx
c002bcb4:	89 d0                	mov    %edx,%eax
c002bcb6:	c1 f8 05             	sar    $0x5,%eax
c002bcb9:	89 ca                	mov    %ecx,%edx
c002bcbb:	c1 fa 1f             	sar    $0x1f,%edx
c002bcbe:	29 d0                	sub    %edx,%eax
c002bcc0:	8d 14 80             	lea    (%eax,%eax,4),%edx
c002bcc3:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002bcc6:	c1 e2 02             	shl    $0x2,%edx
c002bcc9:	29 d1                	sub    %edx,%ecx
c002bccb:	51                   	push   %ecx
c002bccc:	50                   	push   %eax
c002bccd:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002bcd2:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002bcd6:	f7 e9                	imul   %ecx
c002bcd8:	89 d0                	mov    %edx,%eax
c002bcda:	c1 f8 05             	sar    $0x5,%eax
c002bcdd:	89 ca                	mov    %ecx,%edx
c002bcdf:	c1 fa 1f             	sar    $0x1f,%edx
c002bce2:	29 d0                	sub    %edx,%eax
c002bce4:	8d 14 80             	lea    (%eax,%eax,4),%edx
c002bce7:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002bcea:	c1 e2 02             	shl    $0x2,%edx
c002bced:	29 d1                	sub    %edx,%ecx
c002bcef:	51                   	push   %ecx
c002bcf0:	50                   	push   %eax
c002bcf1:	55                   	push   %ebp
c002bcf2:	68 a0 08 03 c0       	push   $0xc00308a0
c002bcf7:	e8 e3 e0 ff ff       	call   c0029ddf <msg>
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002bcfc:	83 c4 20             	add    $0x20,%esp
c002bcff:	81 fd b3 00 00 00    	cmp    $0xb3,%ebp
c002bd05:	0f 8e 5b ff ff ff    	jle    c002bc66 <test_mlfqs_recent_1+0x8a>
            break;
        } 
      last_elapsed = elapsed;
    }
}
c002bd0b:	83 c4 1c             	add    $0x1c,%esp
c002bd0e:	5b                   	pop    %ebx
c002bd0f:	5e                   	pop    %esi
c002bd10:	5f                   	pop    %edi
c002bd11:	5d                   	pop    %ebp
c002bd12:	c3                   	ret    

c002bd13 <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002bd13:	55                   	push   %ebp
c002bd14:	57                   	push   %edi
c002bd15:	56                   	push   %esi
c002bd16:	53                   	push   %ebx
c002bd17:	81 ec 6c 01 00 00    	sub    $0x16c,%esp
c002bd1d:	89 44 24 08          	mov    %eax,0x8(%esp)
c002bd21:	89 54 24 04          	mov    %edx,0x4(%esp)
c002bd25:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002bd29:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002bd30:	0f 84 23 01 00 00    	je     c002be59 <test_mlfqs_fair+0x146>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002bd36:	83 7c 24 08 14       	cmpl   $0x14,0x8(%esp)
c002bd3b:	0f 8f 36 01 00 00    	jg     c002be77 <test_mlfqs_fair+0x164>
  ASSERT (nice_min >= -10);
c002bd41:	83 7c 24 04 f6       	cmpl   $0xfffffff6,0x4(%esp)
c002bd46:	0f 8c 49 01 00 00    	jl     c002be95 <test_mlfqs_fair+0x182>
  ASSERT (nice_step >= 0);
c002bd4c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c002bd51:	0f 88 5c 01 00 00    	js     c002beb3 <test_mlfqs_fair+0x1a0>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002bd57:	8b 44 24 08          	mov    0x8(%esp),%eax
c002bd5b:	48                   	dec    %eax
c002bd5c:	0f af 44 24 0c       	imul   0xc(%esp),%eax
c002bd61:	03 44 24 04          	add    0x4(%esp),%eax
c002bd65:	83 f8 14             	cmp    $0x14,%eax
c002bd68:	0f 8f 63 01 00 00    	jg     c002bed1 <test_mlfqs_fair+0x1be>

  thread_set_nice (-20);
c002bd6e:	83 ec 0c             	sub    $0xc,%esp
c002bd71:	6a ec                	push   $0xffffffec
c002bd73:	e8 8f 4f ff ff       	call   c0020d07 <thread_set_nice>

  start_time = timer_ticks ();
c002bd78:	e8 25 81 ff ff       	call   c0023ea2 <timer_ticks>
c002bd7d:	89 c6                	mov    %eax,%esi
c002bd7f:	89 d7                	mov    %edx,%edi
  msg ("Starting %d threads...", thread_cnt);
c002bd81:	83 c4 08             	add    $0x8,%esp
c002bd84:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002bd88:	53                   	push   %ebx
c002bd89:	68 1a 09 03 c0       	push   $0xc003091a
c002bd8e:	e8 4c e0 ff ff       	call   c0029ddf <msg>
  nice = nice_min;
  for (i = 0; i < thread_cnt; i++) 
c002bd93:	83 c4 10             	add    $0x10,%esp
c002bd96:	85 db                	test   %ebx,%ebx
c002bd98:	0f 8e 51 01 00 00    	jle    c002beef <test_mlfqs_fair+0x1dc>
c002bd9e:	8d 5c 24 20          	lea    0x20(%esp),%ebx
c002bda2:	bd 00 00 00 00       	mov    $0x0,%ebp
    {
      struct thread_info *ti = &info[i];
      char name[16];

      ti->start_time = start_time;
c002bda7:	89 33                	mov    %esi,(%ebx)
c002bda9:	89 7b 04             	mov    %edi,0x4(%ebx)
      ti->tick_count = 0;
c002bdac:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
      ti->nice = nice;
c002bdb3:	8b 44 24 04          	mov    0x4(%esp),%eax
c002bdb7:	89 43 0c             	mov    %eax,0xc(%ebx)

      snprintf(name, sizeof name, "load %d", i);
c002bdba:	55                   	push   %ebp
c002bdbb:	68 52 07 03 c0       	push   $0xc0030752
c002bdc0:	6a 10                	push   $0x10
c002bdc2:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bdc6:	52                   	push   %edx
c002bdc7:	e8 1f b2 ff ff       	call   c0026feb <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002bdcc:	53                   	push   %ebx
c002bdcd:	68 2b bf 02 c0       	push   $0xc002bf2b
c002bdd2:	6a 1f                	push   $0x1f
c002bdd4:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
c002bdd8:	51                   	push   %ecx
c002bdd9:	e8 f1 55 ff ff       	call   c00213cf <thread_create>

      nice += nice_step;
c002bdde:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c002bde2:	01 54 24 24          	add    %edx,0x24(%esp)
  for (i = 0; i < thread_cnt; i++) 
c002bde6:	45                   	inc    %ebp
c002bde7:	83 c3 10             	add    $0x10,%ebx
c002bdea:	83 c4 20             	add    $0x20,%esp
c002bded:	39 6c 24 08          	cmp    %ebp,0x8(%esp)
c002bdf1:	75 b4                	jne    c002bda7 <test_mlfqs_fair+0x94>
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002bdf3:	83 ec 08             	sub    $0x8,%esp
c002bdf6:	57                   	push   %edi
c002bdf7:	56                   	push   %esi
c002bdf8:	e8 ce 80 ff ff       	call   c0023ecb <timer_elapsed>
c002bdfd:	83 c4 0c             	add    $0xc,%esp
c002be00:	52                   	push   %edx
c002be01:	50                   	push   %eax
c002be02:	68 a4 09 03 c0       	push   $0xc00309a4
c002be07:	e8 d3 df ff ff       	call   c0029ddf <msg>

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002be0c:	c7 04 24 c8 09 03 c0 	movl   $0xc00309c8,(%esp)
c002be13:	e8 c7 df ff ff       	call   c0029ddf <msg>
  timer_sleep (40 * TIMER_FREQ);
c002be18:	83 c4 08             	add    $0x8,%esp
c002be1b:	6a 00                	push   $0x0
c002be1d:	68 a0 0f 00 00       	push   $0xfa0
c002be22:	e8 c0 80 ff ff       	call   c0023ee7 <timer_sleep>
c002be27:	8d 74 24 38          	lea    0x38(%esp),%esi
c002be2b:	83 c4 10             	add    $0x10,%esp
c002be2e:	bb 00 00 00 00       	mov    $0x0,%ebx
  
  for (i = 0; i < thread_cnt; i++)
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002be33:	83 ec 04             	sub    $0x4,%esp
c002be36:	ff 36                	pushl  (%esi)
c002be38:	53                   	push   %ebx
c002be39:	68 31 09 03 c0       	push   $0xc0030931
c002be3e:	e8 9c df ff ff       	call   c0029ddf <msg>
  for (i = 0; i < thread_cnt; i++)
c002be43:	43                   	inc    %ebx
c002be44:	83 c6 10             	add    $0x10,%esi
c002be47:	83 c4 10             	add    $0x10,%esp
c002be4a:	39 dd                	cmp    %ebx,%ebp
c002be4c:	75 e5                	jne    c002be33 <test_mlfqs_fair+0x120>
}
c002be4e:	81 c4 6c 01 00 00    	add    $0x16c,%esp
c002be54:	5b                   	pop    %ebx
c002be55:	5e                   	pop    %esi
c002be56:	5f                   	pop    %edi
c002be57:	5d                   	pop    %ebp
c002be58:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002be59:	83 ec 0c             	sub    $0xc,%esp
c002be5c:	68 95 f8 02 c0       	push   $0xc002f895
c002be61:	68 3f d9 02 c0       	push   $0xc002d93f
c002be66:	68 b0 d8 02 c0       	push   $0xc002d8b0
c002be6b:	6a 49                	push   $0x49
c002be6d:	68 50 09 03 c0       	push   $0xc0030950
c002be72:	e8 96 c4 ff ff       	call   c002830d <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002be77:	83 ec 0c             	sub    $0xc,%esp
c002be7a:	68 de 08 03 c0       	push   $0xc00308de
c002be7f:	68 3f d9 02 c0       	push   $0xc002d93f
c002be84:	68 b0 d8 02 c0       	push   $0xc002d8b0
c002be89:	6a 4a                	push   $0x4a
c002be8b:	68 50 09 03 c0       	push   $0xc0030950
c002be90:	e8 78 c4 ff ff       	call   c002830d <debug_panic>
  ASSERT (nice_min >= -10);
c002be95:	83 ec 0c             	sub    $0xc,%esp
c002be98:	68 fb 08 03 c0       	push   $0xc00308fb
c002be9d:	68 3f d9 02 c0       	push   $0xc002d93f
c002bea2:	68 b0 d8 02 c0       	push   $0xc002d8b0
c002bea7:	6a 4b                	push   $0x4b
c002bea9:	68 50 09 03 c0       	push   $0xc0030950
c002beae:	e8 5a c4 ff ff       	call   c002830d <debug_panic>
  ASSERT (nice_step >= 0);
c002beb3:	83 ec 0c             	sub    $0xc,%esp
c002beb6:	68 0b 09 03 c0       	push   $0xc003090b
c002bebb:	68 3f d9 02 c0       	push   $0xc002d93f
c002bec0:	68 b0 d8 02 c0       	push   $0xc002d8b0
c002bec5:	6a 4c                	push   $0x4c
c002bec7:	68 50 09 03 c0       	push   $0xc0030950
c002becc:	e8 3c c4 ff ff       	call   c002830d <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002bed1:	83 ec 0c             	sub    $0xc,%esp
c002bed4:	68 74 09 03 c0       	push   $0xc0030974
c002bed9:	68 3f d9 02 c0       	push   $0xc002d93f
c002bede:	68 b0 d8 02 c0       	push   $0xc002d8b0
c002bee3:	6a 4d                	push   $0x4d
c002bee5:	68 50 09 03 c0       	push   $0xc0030950
c002beea:	e8 1e c4 ff ff       	call   c002830d <debug_panic>
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002beef:	83 ec 08             	sub    $0x8,%esp
c002bef2:	57                   	push   %edi
c002bef3:	56                   	push   %esi
c002bef4:	e8 d2 7f ff ff       	call   c0023ecb <timer_elapsed>
c002bef9:	83 c4 0c             	add    $0xc,%esp
c002befc:	52                   	push   %edx
c002befd:	50                   	push   %eax
c002befe:	68 a4 09 03 c0       	push   $0xc00309a4
c002bf03:	e8 d7 de ff ff       	call   c0029ddf <msg>
  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002bf08:	c7 04 24 c8 09 03 c0 	movl   $0xc00309c8,(%esp)
c002bf0f:	e8 cb de ff ff       	call   c0029ddf <msg>
  timer_sleep (40 * TIMER_FREQ);
c002bf14:	83 c4 08             	add    $0x8,%esp
c002bf17:	6a 00                	push   $0x0
c002bf19:	68 a0 0f 00 00       	push   $0xfa0
c002bf1e:	e8 c4 7f ff ff       	call   c0023ee7 <timer_sleep>
c002bf23:	83 c4 10             	add    $0x10,%esp
c002bf26:	e9 23 ff ff ff       	jmp    c002be4e <test_mlfqs_fair+0x13b>

c002bf2b <load_thread>:

static void
load_thread (void *ti_) 
{
c002bf2b:	57                   	push   %edi
c002bf2c:	56                   	push   %esi
c002bf2d:	53                   	push   %ebx
c002bf2e:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct thread_info *ti = ti_;
  int64_t sleep_time = 5 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;

  thread_set_nice (ti->nice);
c002bf32:	83 ec 0c             	sub    $0xc,%esp
c002bf35:	ff 77 0c             	pushl  0xc(%edi)
c002bf38:	e8 ca 4d ff ff       	call   c0020d07 <thread_set_nice>
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002bf3d:	83 c4 08             	add    $0x8,%esp
c002bf40:	ff 77 04             	pushl  0x4(%edi)
c002bf43:	ff 37                	pushl  (%edi)
c002bf45:	e8 81 7f ff ff       	call   c0023ecb <timer_elapsed>
c002bf4a:	83 c4 08             	add    $0x8,%esp
c002bf4d:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
c002bf52:	bb 00 00 00 00       	mov    $0x0,%ebx
c002bf57:	29 c1                	sub    %eax,%ecx
c002bf59:	19 d3                	sbb    %edx,%ebx
c002bf5b:	53                   	push   %ebx
c002bf5c:	51                   	push   %ecx
c002bf5d:	e8 85 7f ff ff       	call   c0023ee7 <timer_sleep>
  while (timer_elapsed (ti->start_time) < spin_time) 
c002bf62:	83 c4 10             	add    $0x10,%esp
  int64_t last_time = 0;
c002bf65:	be 00 00 00 00       	mov    $0x0,%esi
c002bf6a:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (timer_elapsed (ti->start_time) < spin_time) 
c002bf6f:	eb 1b                	jmp    c002bf8c <load_thread+0x61>
c002bf71:	3d ab 0d 00 00       	cmp    $0xdab,%eax
c002bf76:	77 2c                	ja     c002bfa4 <load_thread+0x79>
    {
      int64_t cur_time = timer_ticks ();
c002bf78:	e8 25 7f ff ff       	call   c0023ea2 <timer_ticks>
      if (cur_time != last_time)
c002bf7d:	31 c6                	xor    %eax,%esi
c002bf7f:	31 d3                	xor    %edx,%ebx
c002bf81:	09 f3                	or     %esi,%ebx
c002bf83:	74 03                	je     c002bf88 <load_thread+0x5d>
        ti->tick_count++;
c002bf85:	ff 47 08             	incl   0x8(%edi)
{
c002bf88:	89 c6                	mov    %eax,%esi
c002bf8a:	89 d3                	mov    %edx,%ebx
  while (timer_elapsed (ti->start_time) < spin_time) 
c002bf8c:	83 ec 08             	sub    $0x8,%esp
c002bf8f:	ff 77 04             	pushl  0x4(%edi)
c002bf92:	ff 37                	pushl  (%edi)
c002bf94:	e8 32 7f ff ff       	call   c0023ecb <timer_elapsed>
c002bf99:	83 c4 10             	add    $0x10,%esp
c002bf9c:	85 d2                	test   %edx,%edx
c002bf9e:	78 d8                	js     c002bf78 <load_thread+0x4d>
c002bfa0:	85 d2                	test   %edx,%edx
c002bfa2:	7e cd                	jle    c002bf71 <load_thread+0x46>
      last_time = cur_time;
    }
}
c002bfa4:	5b                   	pop    %ebx
c002bfa5:	5e                   	pop    %esi
c002bfa6:	5f                   	pop    %edi
c002bfa7:	c3                   	ret    

c002bfa8 <test_mlfqs_fair_2>:
{
c002bfa8:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (2, 0, 0);
c002bfab:	b9 00 00 00 00       	mov    $0x0,%ecx
c002bfb0:	ba 00 00 00 00       	mov    $0x0,%edx
c002bfb5:	b8 02 00 00 00       	mov    $0x2,%eax
c002bfba:	e8 54 fd ff ff       	call   c002bd13 <test_mlfqs_fair>
}
c002bfbf:	83 c4 0c             	add    $0xc,%esp
c002bfc2:	c3                   	ret    

c002bfc3 <test_mlfqs_fair_20>:
{
c002bfc3:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (20, 0, 0);
c002bfc6:	b9 00 00 00 00       	mov    $0x0,%ecx
c002bfcb:	ba 00 00 00 00       	mov    $0x0,%edx
c002bfd0:	b8 14 00 00 00       	mov    $0x14,%eax
c002bfd5:	e8 39 fd ff ff       	call   c002bd13 <test_mlfqs_fair>
}
c002bfda:	83 c4 0c             	add    $0xc,%esp
c002bfdd:	c3                   	ret    

c002bfde <test_mlfqs_nice_2>:
{
c002bfde:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (2, 0, 5);
c002bfe1:	b9 05 00 00 00       	mov    $0x5,%ecx
c002bfe6:	ba 00 00 00 00       	mov    $0x0,%edx
c002bfeb:	b8 02 00 00 00       	mov    $0x2,%eax
c002bff0:	e8 1e fd ff ff       	call   c002bd13 <test_mlfqs_fair>
}
c002bff5:	83 c4 0c             	add    $0xc,%esp
c002bff8:	c3                   	ret    

c002bff9 <test_mlfqs_nice_10>:
{
c002bff9:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (10, 0, 1);
c002bffc:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c001:	ba 00 00 00 00       	mov    $0x0,%edx
c002c006:	b8 0a 00 00 00       	mov    $0xa,%eax
c002c00b:	e8 03 fd ff ff       	call   c002bd13 <test_mlfqs_fair>
}
c002c010:	83 c4 0c             	add    $0xc,%esp
c002c013:	c3                   	ret    

c002c014 <block_thread>:
  msg ("Block thread should have already acquired lock.");
}

static void
block_thread (void *lock_) 
{
c002c014:	57                   	push   %edi
c002c015:	56                   	push   %esi
c002c016:	83 ec 10             	sub    $0x10,%esp
  struct lock *lock = lock_;
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002c019:	68 00 0a 03 c0       	push   $0xc0030a00
c002c01e:	e8 bc dd ff ff       	call   c0029ddf <msg>
  start_time = timer_ticks ();
c002c023:	e8 7a 7e ff ff       	call   c0023ea2 <timer_ticks>
c002c028:	89 c6                	mov    %eax,%esi
c002c02a:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002c02c:	83 c4 10             	add    $0x10,%esp
c002c02f:	83 ec 08             	sub    $0x8,%esp
c002c032:	57                   	push   %edi
c002c033:	56                   	push   %esi
c002c034:	e8 92 7e ff ff       	call   c0023ecb <timer_elapsed>
c002c039:	83 c4 10             	add    $0x10,%esp
c002c03c:	85 d2                	test   %edx,%edx
c002c03e:	78 ef                	js     c002c02f <block_thread+0x1b>
c002c040:	85 d2                	test   %edx,%edx
c002c042:	7e 2b                	jle    c002c06f <block_thread+0x5b>
    continue;

  msg ("Block thread acquiring lock...");
c002c044:	83 ec 0c             	sub    $0xc,%esp
c002c047:	68 28 0a 03 c0       	push   $0xc0030a28
c002c04c:	e8 8e dd ff ff       	call   c0029ddf <msg>
  lock_acquire (lock);
c002c051:	83 c4 04             	add    $0x4,%esp
c002c054:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c058:	e8 15 6b ff ff       	call   c0022b72 <lock_acquire>

  msg ("...got it.");
c002c05d:	c7 04 24 00 0b 03 c0 	movl   $0xc0030b00,(%esp)
c002c064:	e8 76 dd ff ff       	call   c0029ddf <msg>
}
c002c069:	83 c4 14             	add    $0x14,%esp
c002c06c:	5e                   	pop    %esi
c002c06d:	5f                   	pop    %edi
c002c06e:	c3                   	ret    
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002c06f:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c002c074:	76 b9                	jbe    c002c02f <block_thread+0x1b>
c002c076:	eb cc                	jmp    c002c044 <block_thread+0x30>

c002c078 <test_mlfqs_block>:
{
c002c078:	57                   	push   %edi
c002c079:	56                   	push   %esi
c002c07a:	53                   	push   %ebx
c002c07b:	83 ec 40             	sub    $0x40,%esp
  ASSERT (thread_mlfqs);
c002c07e:	80 3d 6c 9f 03 c0 00 	cmpb   $0x0,0xc0039f6c
c002c085:	0f 84 a9 00 00 00    	je     c002c134 <test_mlfqs_block+0xbc>
  msg ("Main thread acquiring lock.");
c002c08b:	83 ec 0c             	sub    $0xc,%esp
c002c08e:	68 0b 0b 03 c0       	push   $0xc0030b0b
c002c093:	e8 47 dd ff ff       	call   c0029ddf <msg>
  lock_init (&lock);
c002c098:	83 c4 04             	add    $0x4,%esp
c002c09b:	8d 5c 24 18          	lea    0x18(%esp),%ebx
c002c09f:	53                   	push   %ebx
c002c0a0:	e8 59 69 ff ff       	call   c00229fe <lock_init>
  lock_acquire (&lock);
c002c0a5:	89 1c 24             	mov    %ebx,(%esp)
c002c0a8:	e8 c5 6a ff ff       	call   c0022b72 <lock_acquire>
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002c0ad:	c7 04 24 6c 0a 03 c0 	movl   $0xc0030a6c,(%esp)
c002c0b4:	e8 26 dd ff ff       	call   c0029ddf <msg>
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002c0b9:	53                   	push   %ebx
c002c0ba:	68 14 c0 02 c0       	push   $0xc002c014
c002c0bf:	6a 1f                	push   $0x1f
c002c0c1:	68 8e f8 02 c0       	push   $0xc002f88e
c002c0c6:	e8 04 53 ff ff       	call   c00213cf <thread_create>
  timer_sleep (25 * TIMER_FREQ);
c002c0cb:	83 c4 18             	add    $0x18,%esp
c002c0ce:	6a 00                	push   $0x0
c002c0d0:	68 c4 09 00 00       	push   $0x9c4
c002c0d5:	e8 0d 7e ff ff       	call   c0023ee7 <timer_sleep>
  msg ("Main thread spinning for 5 seconds...");
c002c0da:	c7 04 24 a8 0a 03 c0 	movl   $0xc0030aa8,(%esp)
c002c0e1:	e8 f9 dc ff ff       	call   c0029ddf <msg>
  start_time = timer_ticks ();
c002c0e6:	e8 b7 7d ff ff       	call   c0023ea2 <timer_ticks>
c002c0eb:	89 c6                	mov    %eax,%esi
c002c0ed:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002c0ef:	83 c4 10             	add    $0x10,%esp
c002c0f2:	83 ec 08             	sub    $0x8,%esp
c002c0f5:	57                   	push   %edi
c002c0f6:	56                   	push   %esi
c002c0f7:	e8 cf 7d ff ff       	call   c0023ecb <timer_elapsed>
c002c0fc:	83 c4 10             	add    $0x10,%esp
c002c0ff:	85 d2                	test   %edx,%edx
c002c101:	78 ef                	js     c002c0f2 <test_mlfqs_block+0x7a>
c002c103:	85 d2                	test   %edx,%edx
c002c105:	7e 4b                	jle    c002c152 <test_mlfqs_block+0xda>
  msg ("Main thread releasing lock.");
c002c107:	83 ec 0c             	sub    $0xc,%esp
c002c10a:	68 27 0b 03 c0       	push   $0xc0030b27
c002c10f:	e8 cb dc ff ff       	call   c0029ddf <msg>
  lock_release (&lock);
c002c114:	83 c4 04             	add    $0x4,%esp
c002c117:	8d 44 24 18          	lea    0x18(%esp),%eax
c002c11b:	50                   	push   %eax
c002c11c:	e8 ee 6b ff ff       	call   c0022d0f <lock_release>
  msg ("Block thread should have already acquired lock.");
c002c121:	c7 04 24 d0 0a 03 c0 	movl   $0xc0030ad0,(%esp)
c002c128:	e8 b2 dc ff ff       	call   c0029ddf <msg>
}
c002c12d:	83 c4 50             	add    $0x50,%esp
c002c130:	5b                   	pop    %ebx
c002c131:	5e                   	pop    %esi
c002c132:	5f                   	pop    %edi
c002c133:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002c134:	83 ec 0c             	sub    $0xc,%esp
c002c137:	68 95 f8 02 c0       	push   $0xc002f895
c002c13c:	68 3f d9 02 c0       	push   $0xc002d93f
c002c141:	68 c0 d8 02 c0       	push   $0xc002d8c0
c002c146:	6a 1c                	push   $0x1c
c002c148:	68 48 0a 03 c0       	push   $0xc0030a48
c002c14d:	e8 bb c1 ff ff       	call   c002830d <debug_panic>
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002c152:	3d f3 01 00 00       	cmp    $0x1f3,%eax
c002c157:	76 99                	jbe    c002c0f2 <test_mlfqs_block+0x7a>
c002c159:	eb ac                	jmp    c002c107 <test_mlfqs_block+0x8f>
