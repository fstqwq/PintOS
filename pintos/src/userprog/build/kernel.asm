
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020058 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020058:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002005d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002005f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020060:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020062:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020064:	66 05 00 04          	add    $0x400,%ax
c0020068:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002006a:	66 3d 00 00          	cmp    $0x0,%ax
c002006e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020070:	76 06                	jbe    c0020078 <start+0x20>
	mov $0x10000, %eax
c0020072:	66 b8 00 00          	mov    $0x0,%ax
c0020076:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020078:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002007c:	67 66 a3 5e 01       	addr16 mov %ax,0x15e
c0020081:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c0020083:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020085:	a8 02                	test   $0x2,%al
	jnz 1b
c0020087:	75 fa                	jne    c0020083 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c0020089:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c002008b:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c002008d:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c002008f:	a8 02                	test   $0x2,%al
	jnz 1b
c0020091:	75 fa                	jne    c002008d <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c0020093:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c0020095:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c0020097:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020099:	a8 02                	test   $0x2,%al
	jnz 1b
c002009b:	75 fa                	jne    c0020097 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c002009d:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200a2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200a5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200a8:	66 b9 00 04          	mov    $0x400,%cx
c00200ac:	00 00                	add    %al,(%eax)
	rep stosl
c00200ae:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200b1:	66 b8 07 00          	mov    $0x7,%ax
c00200b5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200b7:	66 b9 11 00          	mov    $0x11,%cx
c00200bb:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200bd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200c0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200c7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200c8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200cb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200d2:	00 e2                	add    %ah,%dl
	loop 1b
c00200d4:	eb b8                	jmp    c002008e <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200d6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200d8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200da:	66 b8 07 00          	mov    $0x7,%ax
c00200de:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c00200e0:	66 b9 00 40          	mov    $0x4000,%cx
c00200e4:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200e6:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e9:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c00200f0:	66 
	addw $4, %di
	addl $0x1000, %eax
c00200f1:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c00200f6:	e2 f1                	loop   c00200e9 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c00200f8:	66 b8 00 f0          	mov    $0xf000,%ax
c00200fc:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c00200fe:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020101:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020102:	67 66 0f 01 15       	lgdtw  (%di)
c0020107:	58                   	pop    %eax
c0020108:	01 00                	add    %eax,(%eax)
c002010a:	00 0f                	add    %cl,(%edi)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002010c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002010e:	66 0d 05 00          	or     $0x5,%ax
c0020112:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020118:	ea 1f 01 02 c0 08 00 	ljmp   $0x8,$0xc002011f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002011f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020123:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020125:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020127:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020129:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002012b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002012d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020133:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020138:	e8 03 01 00 00       	call   c0020240 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002013d:	eb fe                	jmp    c002013d <start+0xe5>
	...

c0020140 <gdt>:
	...
c0020148:	ff                   	(bad)  
c0020149:	ff 00                	incl   (%eax)
c002014b:	00 00                	add    %al,(%eax)
c002014d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020154:	00                   	.byte 0x0
c0020155:	92                   	xchg   %eax,%edx
c0020156:	cf                   	iret   
	...

c0020158 <gdtdesc>:
c0020158:	17                   	pop    %ss
c0020159:	00 40 01             	add    %al,0x1(%eax)
c002015c:	02 c0                	add    %al,%al

c002015e <init_ram_pages>:
c002015e:	00 00                	add    %al,(%eax)
	...

c0020162 <locate_block_device>:
   block device with the given NAME, if NAME is non-null,
   otherwise the first block device in probe order of type
   ROLE. */
static void
locate_block_device (enum block_type role, const char *name)
{
c0020162:	57                   	push   %edi
c0020163:	56                   	push   %esi
c0020164:	53                   	push   %ebx
c0020165:	89 c6                	mov    %eax,%esi
  struct block *block = NULL;

  if (name != NULL)
c0020167:	85 d2                	test   %edx,%edx
c0020169:	74 64                	je     c00201cf <locate_block_device+0x6d>
c002016b:	89 d7                	mov    %edx,%edi
    {
      block = block_get_by_name (name);
c002016d:	83 ec 0c             	sub    $0xc,%esp
c0020170:	52                   	push   %edx
c0020171:	e8 bd 4a 00 00       	call   c0024c33 <block_get_by_name>
c0020176:	89 c3                	mov    %eax,%ebx
      if (block == NULL)
c0020178:	83 c4 10             	add    $0x10,%esp
c002017b:	85 c0                	test   %eax,%eax
c002017d:	74 33                	je     c00201b2 <locate_block_device+0x50>
          break;
    }

  if (block != NULL)
    {
      printf ("%s: using %s\n", block_type_name (role), block_name (block));
c002017f:	83 ec 0c             	sub    $0xc,%esp
c0020182:	53                   	push   %ebx
c0020183:	e8 a2 4b 00 00       	call   c0024d2a <block_name>
c0020188:	89 c7                	mov    %eax,%edi
c002018a:	89 34 24             	mov    %esi,(%esp)
c002018d:	e8 9d 49 00 00       	call   c0024b2f <block_type_name>
c0020192:	83 c4 0c             	add    $0xc,%esp
c0020195:	57                   	push   %edi
c0020196:	50                   	push   %eax
c0020197:	68 a1 00 03 c0       	push   $0xc00300a1
c002019c:	e8 d8 69 00 00       	call   c0026b79 <printf>
      block_set_role (role, block);
c00201a1:	83 c4 08             	add    $0x8,%esp
c00201a4:	53                   	push   %ebx
c00201a5:	56                   	push   %esi
c00201a6:	e8 ee 49 00 00       	call   c0024b99 <block_set_role>
c00201ab:	83 c4 10             	add    $0x10,%esp
    }
}
c00201ae:	5b                   	pop    %ebx
c00201af:	5e                   	pop    %esi
c00201b0:	5f                   	pop    %edi
c00201b1:	c3                   	ret    
        PANIC ("No such block device \"%s\"", name);
c00201b2:	83 ec 0c             	sub    $0xc,%esp
c00201b5:	57                   	push   %edi
c00201b6:	68 72 00 03 c0       	push   $0xc0030072
c00201bb:	68 34 e9 02 c0       	push   $0xc002e934
c00201c0:	68 c9 01 00 00       	push   $0x1c9
c00201c5:	68 8c 00 03 c0       	push   $0xc003008c
c00201ca:	e8 58 84 00 00       	call   c0028627 <debug_panic>
      for (block = block_first (); block != NULL; block = block_next (block))
c00201cf:	e8 fe 49 00 00       	call   c0024bd2 <block_first>
c00201d4:	89 c3                	mov    %eax,%ebx
c00201d6:	85 c0                	test   %eax,%eax
c00201d8:	74 d4                	je     c00201ae <locate_block_device+0x4c>
        if (block_type (block) == role)
c00201da:	83 ec 0c             	sub    $0xc,%esp
c00201dd:	53                   	push   %ebx
c00201de:	e8 4f 4b 00 00       	call   c0024d32 <block_type>
c00201e3:	83 c4 10             	add    $0x10,%esp
c00201e6:	39 f0                	cmp    %esi,%eax
c00201e8:	74 14                	je     c00201fe <locate_block_device+0x9c>
      for (block = block_first (); block != NULL; block = block_next (block))
c00201ea:	83 ec 0c             	sub    $0xc,%esp
c00201ed:	53                   	push   %ebx
c00201ee:	e8 10 4a 00 00       	call   c0024c03 <block_next>
c00201f3:	89 c3                	mov    %eax,%ebx
c00201f5:	83 c4 10             	add    $0x10,%esp
c00201f8:	85 c0                	test   %eax,%eax
c00201fa:	75 de                	jne    c00201da <locate_block_device+0x78>
c00201fc:	eb b0                	jmp    c00201ae <locate_block_device+0x4c>
  if (block != NULL)
c00201fe:	85 db                	test   %ebx,%ebx
c0020200:	74 ac                	je     c00201ae <locate_block_device+0x4c>
c0020202:	e9 78 ff ff ff       	jmp    c002017f <locate_block_device+0x1d>

c0020207 <run_task>:
{
c0020207:	53                   	push   %ebx
c0020208:	83 ec 10             	sub    $0x10,%esp
  const char *task = argv[1];
c002020b:	8b 44 24 18          	mov    0x18(%esp),%eax
c002020f:	8b 58 04             	mov    0x4(%eax),%ebx
  printf ("Executing '%s':\n", task);
c0020212:	53                   	push   %ebx
c0020213:	68 af 00 03 c0       	push   $0xc00300af
c0020218:	e8 5c 69 00 00       	call   c0026b79 <printf>
  process_wait (process_execute (task));
c002021d:	89 1c 24             	mov    %ebx,(%esp)
c0020220:	e8 c3 9f 00 00       	call   c002a1e8 <process_execute>
c0020225:	89 04 24             	mov    %eax,(%esp)
c0020228:	e8 8a a0 00 00       	call   c002a2b7 <process_wait>
  printf ("Execution of '%s' complete.\n", task);
c002022d:	83 c4 08             	add    $0x8,%esp
c0020230:	53                   	push   %ebx
c0020231:	68 c0 00 03 c0       	push   $0xc00300c0
c0020236:	e8 3e 69 00 00       	call   c0026b79 <printf>
}
c002023b:	83 c4 18             	add    $0x18,%esp
c002023e:	5b                   	pop    %ebx
c002023f:	c3                   	ret    

c0020240 <pintos_init>:
{
c0020240:	55                   	push   %ebp
c0020241:	57                   	push   %edi
c0020242:	56                   	push   %esi
c0020243:	53                   	push   %ebx
c0020244:	83 ec 2c             	sub    $0x2c,%esp
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c0020247:	b9 9d 55 04 c0       	mov    $0xc004559d,%ecx
c002024c:	81 e9 50 b0 03 c0    	sub    $0xc003b050,%ecx
c0020252:	ba 50 b0 03 c0       	mov    $0xc003b050,%edx
c0020257:	b0 00                	mov    $0x0,%al
c0020259:	89 d7                	mov    %edx,%edi
c002025b:	f3 aa                	rep stos %al,%es:(%edi)
  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c002025d:	8b 3d 3a 7d 00 c0    	mov    0xc0007d3a,%edi
  for (i = 0; i < argc; i++) 
c0020263:	85 ff                	test   %edi,%edi
c0020265:	0f 8e 5e 06 00 00    	jle    c00208c9 <pintos_init+0x689>
c002026b:	be 00 00 00 00       	mov    $0x0,%esi
c0020270:	bb 3e 7d 00 c0       	mov    $0xc0007d3e,%ebx
      p += strnlen (p, end - p) + 1;
c0020275:	bd be 7d 00 c0       	mov    $0xc0007dbe,%ebp
c002027a:	eb 08                	jmp    c0020284 <pintos_init+0x44>
      if (p >= end)
c002027c:	81 fb bd 7d 00 c0    	cmp    $0xc0007dbd,%ebx
c0020282:	77 43                	ja     c00202c7 <pintos_init+0x87>
      argv[i] = p;
c0020284:	89 1c b5 60 b0 03 c0 	mov    %ebx,-0x3ffc4fa0(,%esi,4)
      p += strnlen (p, end - p) + 1;
c002028b:	83 ec 08             	sub    $0x8,%esp
c002028e:	89 e8                	mov    %ebp,%eax
c0020290:	29 d8                	sub    %ebx,%eax
c0020292:	50                   	push   %eax
c0020293:	53                   	push   %ebx
c0020294:	e8 5d 7a 00 00       	call   c0027cf6 <strnlen>
c0020299:	8d 5c 03 01          	lea    0x1(%ebx,%eax,1),%ebx
  for (i = 0; i < argc; i++) 
c002029d:	46                   	inc    %esi
c002029e:	83 c4 10             	add    $0x10,%esp
c00202a1:	39 f7                	cmp    %esi,%edi
c00202a3:	75 d7                	jne    c002027c <pintos_init+0x3c>
  argv[argc] = NULL;
c00202a5:	c7 04 b5 60 b0 03 c0 	movl   $0x0,-0x3ffc4fa0(,%esi,4)
c00202ac:	00 00 00 00 
  printf ("Kernel command line:");
c00202b0:	83 ec 0c             	sub    $0xc,%esp
c00202b3:	68 b1 01 03 c0       	push   $0xc00301b1
c00202b8:	e8 bc 68 00 00       	call   c0026b79 <printf>
c00202bd:	83 c4 10             	add    $0x10,%esp
c00202c0:	bb 00 00 00 00       	mov    $0x0,%ebx
c00202c5:	eb 33                	jmp    c00202fa <pintos_init+0xba>
        PANIC ("command line arguments overflow");
c00202c7:	68 e0 01 03 c0       	push   $0xc00301e0
c00202cc:	68 6c e9 02 c0       	push   $0xc002e96c
c00202d1:	68 fa 00 00 00       	push   $0xfa
c00202d6:	68 8c 00 03 c0       	push   $0xc003008c
c00202db:	e8 47 83 00 00       	call   c0028627 <debug_panic>
      printf (" %s", argv[i]);
c00202e0:	83 ec 08             	sub    $0x8,%esp
c00202e3:	56                   	push   %esi
c00202e4:	68 b7 11 03 c0       	push   $0xc00311b7
c00202e9:	e8 8b 68 00 00       	call   c0026b79 <printf>
c00202ee:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00202f1:	43                   	inc    %ebx
c00202f2:	39 df                	cmp    %ebx,%edi
c00202f4:	0f 84 ea 05 00 00    	je     c00208e4 <pintos_init+0x6a4>
    if (strchr (argv[i], ' ') == NULL)
c00202fa:	8b 34 9d 60 b0 03 c0 	mov    -0x3ffc4fa0(,%ebx,4),%esi
c0020301:	83 ec 08             	sub    $0x8,%esp
c0020304:	6a 20                	push   $0x20
c0020306:	56                   	push   %esi
c0020307:	e8 33 77 00 00       	call   c0027a3f <strchr>
c002030c:	83 c4 10             	add    $0x10,%esp
c002030f:	85 c0                	test   %eax,%eax
c0020311:	74 cd                	je     c00202e0 <pintos_init+0xa0>
      printf (" '%s'", argv[i]);
c0020313:	83 ec 08             	sub    $0x8,%esp
c0020316:	56                   	push   %esi
c0020317:	68 dd 00 03 c0       	push   $0xc00300dd
c002031c:	e8 58 68 00 00       	call   c0026b79 <printf>
c0020321:	83 c4 10             	add    $0x10,%esp
c0020324:	eb cb                	jmp    c00202f1 <pintos_init+0xb1>
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020326:	83 ec 0c             	sub    $0xc,%esp
c0020329:	68 00 02 03 c0       	push   $0xc0030200
c002032e:	e8 db 9d 00 00       	call   c002a10e <puts>
  shutdown_power_off ();
c0020333:	e8 f5 60 00 00       	call   c002642d <shutdown_power_off>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c0020338:	83 ec 0c             	sub    $0xc,%esp
c002033b:	6a 01                	push   $0x1
c002033d:	e8 75 60 00 00       	call   c00263b7 <shutdown_configure>
c0020342:	83 c4 10             	add    $0x10,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020345:	83 c5 04             	add    $0x4,%ebp
c0020348:	8b 45 00             	mov    0x0(%ebp),%eax
c002034b:	85 c0                	test   %eax,%eax
c002034d:	0f 84 b2 01 00 00    	je     c0020505 <pintos_init+0x2c5>
c0020353:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020356:	0f 85 a9 01 00 00    	jne    c0020505 <pintos_init+0x2c5>
      char *name = strtok_r (*argv, "=", &save_ptr);
c002035c:	83 ec 04             	sub    $0x4,%esp
c002035f:	53                   	push   %ebx
c0020360:	68 4a 10 03 c0       	push   $0xc003104a
c0020365:	50                   	push   %eax
c0020366:	e8 dc 77 00 00       	call   c0027b47 <strtok_r>
c002036b:	89 c6                	mov    %eax,%esi
c002036d:	89 44 24 10          	mov    %eax,0x10(%esp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020371:	83 c4 0c             	add    $0xc,%esp
c0020374:	53                   	push   %ebx
c0020375:	68 f8 20 03 c0       	push   $0xc00320f8
c002037a:	6a 00                	push   $0x0
c002037c:	e8 c6 77 00 00       	call   c0027b47 <strtok_r>
c0020381:	89 44 24 14          	mov    %eax,0x14(%esp)
      if (!strcmp (name, "-h"))
c0020385:	bf e3 00 03 c0       	mov    $0xc00300e3,%edi
c002038a:	b9 03 00 00 00       	mov    $0x3,%ecx
c002038f:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020391:	0f 97 c2             	seta   %dl
c0020394:	0f 92 c0             	setb   %al
c0020397:	83 c4 10             	add    $0x10,%esp
c002039a:	38 c2                	cmp    %al,%dl
c002039c:	74 88                	je     c0020326 <pintos_init+0xe6>
      else if (!strcmp (name, "-q"))
c002039e:	bf e6 00 03 c0       	mov    $0xc00300e6,%edi
c00203a3:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203a8:	8b 34 24             	mov    (%esp),%esi
c00203ab:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203ad:	0f 97 c2             	seta   %dl
c00203b0:	0f 92 c0             	setb   %al
c00203b3:	38 c2                	cmp    %al,%dl
c00203b5:	74 81                	je     c0020338 <pintos_init+0xf8>
      else if (!strcmp (name, "-r"))
c00203b7:	bf e9 00 03 c0       	mov    $0xc00300e9,%edi
c00203bc:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203c1:	8b 34 24             	mov    (%esp),%esi
c00203c4:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203c6:	0f 97 c2             	seta   %dl
c00203c9:	0f 92 c0             	setb   %al
c00203cc:	38 c2                	cmp    %al,%dl
c00203ce:	74 25                	je     c00203f5 <pintos_init+0x1b5>
      else if (!strcmp (name, "-f"))
c00203d0:	bf ec 00 03 c0       	mov    $0xc00300ec,%edi
c00203d5:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203da:	8b 34 24             	mov    (%esp),%esi
c00203dd:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203df:	0f 97 c2             	seta   %dl
c00203e2:	0f 92 c0             	setb   %al
c00203e5:	38 c2                	cmp    %al,%dl
c00203e7:	75 1e                	jne    c0020407 <pintos_init+0x1c7>
        format_filesys = true;
c00203e9:	c6 05 08 b2 03 c0 01 	movb   $0x1,0xc003b208
c00203f0:	e9 50 ff ff ff       	jmp    c0020345 <pintos_init+0x105>
        shutdown_configure (SHUTDOWN_REBOOT);
c00203f5:	83 ec 0c             	sub    $0xc,%esp
c00203f8:	6a 02                	push   $0x2
c00203fa:	e8 b8 5f 00 00       	call   c00263b7 <shutdown_configure>
c00203ff:	83 c4 10             	add    $0x10,%esp
c0020402:	e9 3e ff ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-filesys"))
c0020407:	bf ef 00 03 c0       	mov    $0xc00300ef,%edi
c002040c:	b9 09 00 00 00       	mov    $0x9,%ecx
c0020411:	8b 34 24             	mov    (%esp),%esi
c0020414:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020416:	0f 97 c2             	seta   %dl
c0020419:	0f 92 c0             	setb   %al
c002041c:	38 c2                	cmp    %al,%dl
c002041e:	75 0e                	jne    c002042e <pintos_init+0x1ee>
        filesys_bdev_name = value;
c0020420:	8b 44 24 04          	mov    0x4(%esp),%eax
c0020424:	a3 04 b2 03 c0       	mov    %eax,0xc003b204
c0020429:	e9 17 ff ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-scratch"))
c002042e:	bf f8 00 03 c0       	mov    $0xc00300f8,%edi
c0020433:	b9 09 00 00 00       	mov    $0x9,%ecx
c0020438:	8b 34 24             	mov    (%esp),%esi
c002043b:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002043d:	0f 97 c2             	seta   %dl
c0020440:	0f 92 c0             	setb   %al
c0020443:	38 c2                	cmp    %al,%dl
c0020445:	75 0e                	jne    c0020455 <pintos_init+0x215>
        scratch_bdev_name = value;
c0020447:	8b 44 24 04          	mov    0x4(%esp),%eax
c002044b:	a3 00 b2 03 c0       	mov    %eax,0xc003b200
c0020450:	e9 f0 fe ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-rs"))
c0020455:	bf 01 01 03 c0       	mov    $0xc0030101,%edi
c002045a:	b9 04 00 00 00       	mov    $0x4,%ecx
c002045f:	8b 34 24             	mov    (%esp),%esi
c0020462:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020464:	0f 97 c2             	seta   %dl
c0020467:	0f 92 c0             	setb   %al
c002046a:	38 c2                	cmp    %al,%dl
c002046c:	74 25                	je     c0020493 <pintos_init+0x253>
      else if (!strcmp (name, "-mlfqs"))
c002046e:	bf 05 01 03 c0       	mov    $0xc0030105,%edi
c0020473:	b9 07 00 00 00       	mov    $0x7,%ecx
c0020478:	8b 34 24             	mov    (%esp),%esi
c002047b:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002047d:	0f 97 c2             	seta   %dl
c0020480:	0f 92 c0             	setb   %al
c0020483:	38 c2                	cmp    %al,%dl
c0020485:	75 28                	jne    c00204af <pintos_init+0x26f>
        thread_mlfqs = true;
c0020487:	c6 05 9c 55 04 c0 01 	movb   $0x1,0xc004559c
c002048e:	e9 b2 fe ff ff       	jmp    c0020345 <pintos_init+0x105>
        random_init (atoi (value));
c0020493:	83 ec 0c             	sub    $0xc,%esp
c0020496:	ff 74 24 10          	pushl  0x10(%esp)
c002049a:	e8 24 72 00 00       	call   c00276c3 <atoi>
c002049f:	89 04 24             	mov    %eax,(%esp)
c00204a2:	e8 4f 61 00 00       	call   c00265f6 <random_init>
c00204a7:	83 c4 10             	add    $0x10,%esp
c00204aa:	e9 96 fe ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-ul"))
c00204af:	83 ec 08             	sub    $0x8,%esp
c00204b2:	68 0c 01 03 c0       	push   $0xc003010c
c00204b7:	ff 74 24 0c          	pushl  0xc(%esp)
c00204bb:	e8 1c 75 00 00       	call   c00279dc <strcmp>
c00204c0:	83 c4 10             	add    $0x10,%esp
c00204c3:	85 c0                	test   %eax,%eax
c00204c5:	75 19                	jne    c00204e0 <pintos_init+0x2a0>
        user_page_limit = atoi (value);
c00204c7:	83 ec 0c             	sub    $0xc,%esp
c00204ca:	ff 74 24 10          	pushl  0x10(%esp)
c00204ce:	e8 f0 71 00 00       	call   c00276c3 <atoi>
c00204d3:	a3 08 ac 03 c0       	mov    %eax,0xc003ac08
c00204d8:	83 c4 10             	add    $0x10,%esp
c00204db:	e9 65 fe ff ff       	jmp    c0020345 <pintos_init+0x105>
        PANIC ("unknown option `%s' (use -h for help)", name);
c00204e0:	83 ec 0c             	sub    $0xc,%esp
c00204e3:	ff 74 24 0c          	pushl  0xc(%esp)
c00204e7:	68 28 06 03 c0       	push   $0xc0030628
c00204ec:	68 5c e9 02 c0       	push   $0xc002e95c
c00204f1:	68 33 01 00 00       	push   $0x133
c00204f6:	68 8c 00 03 c0       	push   $0xc003008c
c00204fb:	e8 27 81 00 00       	call   c0028627 <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020500:	bd 60 b0 03 c0       	mov    $0xc003b060,%ebp
  random_init (rtc_get_time ());
c0020505:	e8 1a 5d 00 00       	call   c0026224 <rtc_get_time>
c002050a:	83 ec 0c             	sub    $0xc,%esp
c002050d:	50                   	push   %eax
c002050e:	e8 e3 60 00 00       	call   c00265f6 <random_init>
  thread_init ();
c0020513:	e8 c7 06 00 00       	call   c0020bdf <thread_init>
  console_init ();
c0020518:	e8 80 9b 00 00       	call   c002a09d <console_init>
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c002051d:	83 c4 08             	add    $0x8,%esp
          init_ram_pages * PGSIZE / 1024);
c0020520:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c0020525:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c0020528:	c1 e8 0a             	shr    $0xa,%eax
c002052b:	50                   	push   %eax
c002052c:	68 50 06 03 c0       	push   $0xc0030650
c0020531:	e8 43 66 00 00       	call   c0026b79 <printf>
  palloc_init (user_page_limit);
c0020536:	83 c4 04             	add    $0x4,%esp
c0020539:	ff 35 08 ac 03 c0    	pushl  0xc003ac08
c002053f:	e8 eb 2f 00 00       	call   c002352f <palloc_init>
  malloc_init ();
c0020544:	e8 95 33 00 00       	call   c00238de <malloc_init>
  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020549:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0020550:	e8 03 31 00 00       	call   c0023658 <palloc_get_page>
c0020555:	89 44 24 18          	mov    %eax,0x18(%esp)
c0020559:	a3 94 55 04 c0       	mov    %eax,0xc0045594
  for (page = 0; page < init_ram_pages; page++)
c002055e:	83 c4 10             	add    $0x10,%esp
c0020561:	83 3d 5e 01 02 c0 00 	cmpl   $0x0,0xc002015e
c0020568:	0f 84 23 01 00 00    	je     c0020691 <pintos_init+0x451>
c002056e:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
c0020573:	b8 00 00 00 00       	mov    $0x0,%eax
c0020578:	be 00 00 00 00       	mov    $0x0,%esi
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c002057d:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
c0020581:	eb 5c                	jmp    c00205df <pintos_init+0x39f>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020583:	bd 60 b0 03 c0       	mov    $0xc003b060,%ebp
c0020588:	e9 78 ff ff ff       	jmp    c0020505 <pintos_init+0x2c5>
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c002058d:	b1 00                	mov    $0x0,%cl
c002058f:	83 e1 01             	and    $0x1,%ecx
c0020592:	88 4c 24 04          	mov    %cl,0x4(%esp)
      if (pd[pde_idx] == 0)
c0020596:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002059a:	8d 2c 91             	lea    (%ecx,%edx,4),%ebp
c002059d:	83 7d 00 00          	cmpl   $0x0,0x0(%ebp)
c00205a1:	74 62                	je     c0020605 <pintos_init+0x3c5>
      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c00205a3:	8d 0c 98             	lea    (%eax,%ebx,4),%ecx
/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
  ASSERT (is_kernel_vaddr (vaddr));
c00205a6:	81 3c 24 ff ff ff bf 	cmpl   $0xbfffffff,(%esp)
c00205ad:	0f 86 bc 00 00 00    	jbe    c002066f <pintos_init+0x42f>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00205b3:	8d 97 00 00 00 40    	lea    0x40000000(%edi),%edx
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
  ASSERT (pg_ofs (page) == 0);
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c00205b9:	8a 5c 24 04          	mov    0x4(%esp),%bl
c00205bd:	83 f3 01             	xor    $0x1,%ebx
c00205c0:	0f b6 db             	movzbl %bl,%ebx
c00205c3:	d1 e3                	shl    %ebx
c00205c5:	83 ca 01             	or     $0x1,%edx
c00205c8:	09 da                	or     %ebx,%edx
c00205ca:	89 11                	mov    %edx,(%ecx)
  for (page = 0; page < init_ram_pages; page++)
c00205cc:	46                   	inc    %esi
c00205cd:	3b 35 5e 01 02 c0    	cmp    0xc002015e,%esi
c00205d3:	0f 83 b4 00 00 00    	jae    c002068d <pintos_init+0x44d>
c00205d9:	81 c7 00 10 00 00    	add    $0x1000,%edi
  return (uintptr_t) va >> PDSHIFT;
c00205df:	89 fa                	mov    %edi,%edx
c00205e1:	c1 ea 16             	shr    $0x16,%edx
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c00205e4:	89 fb                	mov    %edi,%ebx
c00205e6:	c1 eb 0c             	shr    $0xc,%ebx
c00205e9:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
c00205ef:	89 3c 24             	mov    %edi,(%esp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c00205f2:	81 ff 00 00 02 c0    	cmp    $0xc0020000,%edi
c00205f8:	72 93                	jb     c002058d <pintos_init+0x34d>
c00205fa:	81 ff 00 30 03 c0    	cmp    $0xc0033000,%edi
c0020600:	0f 92 c1             	setb   %cl
c0020603:	eb 8a                	jmp    c002058f <pintos_init+0x34f>
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020605:	83 ec 0c             	sub    $0xc,%esp
c0020608:	6a 03                	push   $0x3
c002060a:	e8 49 30 00 00       	call   c0023658 <palloc_get_page>
  return (uintptr_t) va & PGMASK;
c002060f:	89 c2                	mov    %eax,%edx
  ASSERT (pg_ofs (pt) == 0);
c0020611:	83 c4 10             	add    $0x10,%esp
c0020614:	a9 ff 0f 00 00       	test   $0xfff,%eax
c0020619:	75 18                	jne    c0020633 <pintos_init+0x3f3>
  ASSERT (is_kernel_vaddr (vaddr));
c002061b:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020620:	76 2f                	jbe    c0020651 <pintos_init+0x411>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020622:	81 c2 00 00 00 40    	add    $0x40000000,%edx
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020628:	83 ca 07             	or     $0x7,%edx
c002062b:	89 55 00             	mov    %edx,0x0(%ebp)
c002062e:	e9 70 ff ff ff       	jmp    c00205a3 <pintos_init+0x363>
  ASSERT (pg_ofs (pt) == 0);
c0020633:	83 ec 0c             	sub    $0xc,%esp
c0020636:	68 10 01 03 c0       	push   $0xc0030110
c002063b:	68 21 01 03 c0       	push   $0xc0030121
c0020640:	68 50 e9 02 c0       	push   $0xc002e950
c0020645:	6a 48                	push   $0x48
c0020647:	68 38 01 03 c0       	push   $0xc0030138
c002064c:	e8 d6 7f 00 00       	call   c0028627 <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c0020651:	83 ec 0c             	sub    $0xc,%esp
c0020654:	68 4c 01 03 c0       	push   $0xc003014c
c0020659:	68 21 01 03 c0       	push   $0xc0030121
c002065e:	68 48 e9 02 c0       	push   $0xc002e948
c0020663:	6a 54                	push   $0x54
c0020665:	68 64 01 03 c0       	push   $0xc0030164
c002066a:	e8 b8 7f 00 00       	call   c0028627 <debug_panic>
c002066f:	83 ec 0c             	sub    $0xc,%esp
c0020672:	68 4c 01 03 c0       	push   $0xc003014c
c0020677:	68 21 01 03 c0       	push   $0xc0030121
c002067c:	68 48 e9 02 c0       	push   $0xc002e948
c0020681:	6a 54                	push   $0x54
c0020683:	68 64 01 03 c0       	push   $0xc0030164
c0020688:	e8 9a 7f 00 00       	call   c0028627 <debug_panic>
c002068d:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c0020691:	a1 94 55 04 c0       	mov    0xc0045594,%eax
c0020696:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002069b:	0f 86 a5 00 00 00    	jbe    c0020746 <pintos_init+0x506>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00206a1:	05 00 00 00 40       	add    $0x40000000,%eax
c00206a6:	0f 22 d8             	mov    %eax,%cr3
  tss_init ();
c00206a9:	e8 26 ba 00 00       	call   c002c0d4 <tss_init>
  gdt_init ();
c00206ae:	e8 f9 b8 00 00       	call   c002bfac <gdt_init>
  intr_init ();
c00206b3:	e8 6a 13 00 00       	call   c0021a22 <intr_init>
  timer_init ();
c00206b8:	e8 00 3a 00 00       	call   c00240bd <timer_init>
  kbd_init ();
c00206bd:	e8 bf 3e 00 00       	call   c0024581 <kbd_init>
  input_init ();
c00206c2:	e8 56 56 00 00       	call   c0025d1d <input_init>
  exception_init ();
c00206c7:	e8 82 ac 00 00       	call   c002b34e <exception_init>
  syscall_init ();
c00206cc:	e8 1e ae 00 00       	call   c002b4ef <syscall_init>
  thread_start ();
c00206d1:	e8 c8 0f 00 00       	call   c002169e <thread_start>
  serial_init_queue ();
c00206d6:	e8 aa 42 00 00       	call   c0024985 <serial_init_queue>
  timer_calibrate ();
c00206db:	e8 03 3a 00 00       	call   c00240e3 <timer_calibrate>
  ide_init ();
c00206e0:	e8 6c 51 00 00       	call   c0025851 <ide_init>
  locate_block_device (BLOCK_FILESYS, filesys_bdev_name);
c00206e5:	8b 15 04 b2 03 c0    	mov    0xc003b204,%edx
c00206eb:	b8 01 00 00 00       	mov    $0x1,%eax
c00206f0:	e8 6d fa ff ff       	call   c0020162 <locate_block_device>
  locate_block_device (BLOCK_SCRATCH, scratch_bdev_name);
c00206f5:	8b 15 00 b2 03 c0    	mov    0xc003b200,%edx
c00206fb:	b8 02 00 00 00       	mov    $0x2,%eax
c0020700:	e8 5d fa ff ff       	call   c0020162 <locate_block_device>
  filesys_init (format_filesys);
c0020705:	83 ec 0c             	sub    $0xc,%esp
c0020708:	0f b6 05 08 b2 03 c0 	movzbl 0xc003b208,%eax
c002070f:	50                   	push   %eax
c0020710:	e8 e3 b9 00 00       	call   c002c0f8 <filesys_init>
  thread_init_dir ();
c0020715:	e8 3f 11 00 00       	call   c0021859 <thread_init_dir>
	lock_init(&filesys_lock);
c002071a:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c0020721:	e8 e3 25 00 00       	call   c0022d09 <lock_init>
  printf ("Boot complete.\n");
c0020726:	c7 04 24 7a 01 03 c0 	movl   $0xc003017a,(%esp)
c002072d:	e8 dc 99 00 00       	call   c002a10e <puts>
  if (*argv != NULL) {
c0020732:	8b 75 00             	mov    0x0(%ebp),%esi
c0020735:	83 c4 10             	add    $0x10,%esp
c0020738:	85 f6                	test   %esi,%esi
c002073a:	74 28                	je     c0020764 <pintos_init+0x524>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002073c:	bf c6 09 03 c0       	mov    $0xc00309c6,%edi
c0020741:	e9 87 00 00 00       	jmp    c00207cd <pintos_init+0x58d>
  ASSERT (is_kernel_vaddr (vaddr));
c0020746:	83 ec 0c             	sub    $0xc,%esp
c0020749:	68 4c 01 03 c0       	push   $0xc003014c
c002074e:	68 21 01 03 c0       	push   $0xc0030121
c0020753:	68 48 e9 02 c0       	push   $0xc002e948
c0020758:	6a 54                	push   $0x54
c002075a:	68 64 01 03 c0       	push   $0xc0030164
c002075f:	e8 c3 7e 00 00       	call   c0028627 <debug_panic>
c0020764:	bb 00 00 00 00       	mov    $0x0,%ebx
        failed_cnt = 0;
c0020769:	bd 00 00 00 00       	mov    $0x0,%ebp
c002076e:	e9 aa 00 00 00       	jmp    c002081d <pintos_init+0x5dd>
      for (i = 1; i < a->argc; i++)
c0020773:	8b 53 04             	mov    0x4(%ebx),%edx
c0020776:	83 fa 01             	cmp    $0x1,%edx
c0020779:	7e 36                	jle    c00207b1 <pintos_init+0x571>
        if (argv[i] == NULL)
c002077b:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c002077f:	74 11                	je     c0020792 <pintos_init+0x552>
c0020781:	b8 01 00 00 00       	mov    $0x1,%eax
      for (i = 1; i < a->argc; i++)
c0020786:	40                   	inc    %eax
c0020787:	39 d0                	cmp    %edx,%eax
c0020789:	74 26                	je     c00207b1 <pintos_init+0x571>
        if (argv[i] == NULL)
c002078b:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c0020790:	75 f4                	jne    c0020786 <pintos_init+0x546>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020792:	83 ec 08             	sub    $0x8,%esp
c0020795:	4a                   	dec    %edx
c0020796:	52                   	push   %edx
c0020797:	56                   	push   %esi
c0020798:	68 9c 06 03 c0       	push   $0xc003069c
c002079d:	68 c0 e8 02 c0       	push   $0xc002e8c0
c00207a2:	68 7c 01 00 00       	push   $0x17c
c00207a7:	68 8c 00 03 c0       	push   $0xc003008c
c00207ac:	e8 76 7e 00 00       	call   c0028627 <debug_panic>
      a->function (argv);
c00207b1:	83 ec 0c             	sub    $0xc,%esp
c00207b4:	55                   	push   %ebp
c00207b5:	ff 53 08             	call   *0x8(%ebx)
      argv += a->argc;
c00207b8:	8b 43 04             	mov    0x4(%ebx),%eax
c00207bb:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
  while (*argv != NULL)
c00207bf:	8b 75 00             	mov    0x0(%ebp),%esi
c00207c2:	83 c4 10             	add    $0x10,%esp
c00207c5:	85 f6                	test   %esi,%esi
c00207c7:	0f 84 f2 00 00 00    	je     c00208bf <pintos_init+0x67f>
c00207cd:	89 f8                	mov    %edi,%eax
c00207cf:	bb e0 e8 02 c0       	mov    $0xc002e8e0,%ebx
        else if (!strcmp (*argv, a->name))
c00207d4:	83 ec 08             	sub    $0x8,%esp
c00207d7:	50                   	push   %eax
c00207d8:	56                   	push   %esi
c00207d9:	e8 fe 71 00 00       	call   c00279dc <strcmp>
c00207de:	83 c4 10             	add    $0x10,%esp
c00207e1:	85 c0                	test   %eax,%eax
c00207e3:	74 8e                	je     c0020773 <pintos_init+0x533>
      for (a = actions; ; a++)
c00207e5:	83 c3 0c             	add    $0xc,%ebx
        if (a->name == NULL)
c00207e8:	8b 03                	mov    (%ebx),%eax
c00207ea:	85 c0                	test   %eax,%eax
c00207ec:	75 e6                	jne    c00207d4 <pintos_init+0x594>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c00207ee:	83 ec 0c             	sub    $0xc,%esp
c00207f1:	56                   	push   %esi
c00207f2:	68 74 06 03 c0       	push   $0xc0030674
c00207f7:	68 c0 e8 02 c0       	push   $0xc002e8c0
c00207fc:	68 75 01 00 00       	push   $0x175
c0020801:	68 8c 00 03 c0       	push   $0xc003008c
c0020806:	e8 1c 7e 00 00       	call   c0028627 <debug_panic>
        puts ("I am Pintakina!");
c002080b:	83 ec 0c             	sub    $0xc,%esp
c002080e:	68 9c 01 03 c0       	push   $0xc003019c
c0020813:	e8 f6 98 00 00       	call   c002a10e <puts>
c0020818:	83 c4 10             	add    $0x10,%esp
        failed_cnt = 0;
c002081b:	89 eb                	mov    %ebp,%ebx
      printf("Pintakina$ ");
c002081d:	83 ec 0c             	sub    $0xc,%esp
c0020820:	68 89 01 03 c0       	push   $0xc0030189
c0020825:	e8 4f 63 00 00       	call   c0026b79 <printf>
      input_getline (cmd, MAX_CMD_LENGTH);
c002082a:	83 c4 08             	add    $0x8,%esp
c002082d:	68 80 00 00 00       	push   $0x80
c0020832:	68 80 b1 03 c0       	push   $0xc003b180
c0020837:	e8 d9 55 00 00       	call   c0025e15 <input_getline>
      if (strcmp(cmd, "whoami") == 0) {
c002083c:	be 80 b1 03 c0       	mov    $0xc003b180,%esi
c0020841:	bf 95 01 03 c0       	mov    $0xc0030195,%edi
c0020846:	b9 07 00 00 00       	mov    $0x7,%ecx
c002084b:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002084d:	0f 97 c2             	seta   %dl
c0020850:	0f 92 c0             	setb   %al
c0020853:	83 c4 10             	add    $0x10,%esp
c0020856:	38 c2                	cmp    %al,%dl
c0020858:	74 b1                	je     c002080b <pintos_init+0x5cb>
      } else if (strcmp(cmd, "exit") == 0){
c002085a:	be 80 b1 03 c0       	mov    $0xc003b180,%esi
c002085f:	bf ac 01 03 c0       	mov    $0xc00301ac,%edi
c0020864:	b9 05 00 00 00       	mov    $0x5,%ecx
c0020869:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002086b:	0f 97 c2             	seta   %dl
c002086e:	0f 92 c0             	setb   %al
c0020871:	38 c2                	cmp    %al,%dl
c0020873:	74 3d                	je     c00208b2 <pintos_init+0x672>
      } else if (strcmp(cmd, "") != 0){
c0020875:	80 3d 80 b1 03 c0 00 	cmpb   $0x0,0xc003b180
c002087c:	74 9d                	je     c002081b <pintos_init+0x5db>
        failed_cnt ++;
c002087e:	8d 73 01             	lea    0x1(%ebx),%esi
        for (i = 0; i < failed_cnt; i++) putchar ('?');
c0020881:	85 f6                	test   %esi,%esi
c0020883:	7e 19                	jle    c002089e <pintos_init+0x65e>
c0020885:	89 f7                	mov    %esi,%edi
c0020887:	bb 00 00 00 00       	mov    $0x0,%ebx
c002088c:	83 ec 0c             	sub    $0xc,%esp
c002088f:	6a 3f                	push   $0x3f
c0020891:	e8 e4 98 00 00       	call   c002a17a <putchar>
c0020896:	43                   	inc    %ebx
c0020897:	83 c4 10             	add    $0x10,%esp
c002089a:	39 fb                	cmp    %edi,%ebx
c002089c:	75 ee                	jne    c002088c <pintos_init+0x64c>
        putchar ('\n');
c002089e:	83 ec 0c             	sub    $0xc,%esp
c00208a1:	6a 0a                	push   $0xa
c00208a3:	e8 d2 98 00 00       	call   c002a17a <putchar>
c00208a8:	83 c4 10             	add    $0x10,%esp
        failed_cnt ++;
c00208ab:	89 f3                	mov    %esi,%ebx
c00208ad:	e9 6b ff ff ff       	jmp    c002081d <pintos_init+0x5dd>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c00208b2:	83 ec 0c             	sub    $0xc,%esp
c00208b5:	6a 01                	push   $0x1
c00208b7:	e8 fb 5a 00 00       	call   c00263b7 <shutdown_configure>
        break;
c00208bc:	83 c4 10             	add    $0x10,%esp
  shutdown ();
c00208bf:	e8 f7 5b 00 00       	call   c00264bb <shutdown>
  thread_exit ();
c00208c4:	e8 8b 0e 00 00       	call   c0021754 <thread_exit>
  argv[argc] = NULL;
c00208c9:	c7 04 bd 60 b0 03 c0 	movl   $0x0,-0x3ffc4fa0(,%edi,4)
c00208d0:	00 00 00 00 
  printf ("Kernel command line:");
c00208d4:	83 ec 0c             	sub    $0xc,%esp
c00208d7:	68 b1 01 03 c0       	push   $0xc00301b1
c00208dc:	e8 98 62 00 00       	call   c0026b79 <printf>
c00208e1:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c00208e4:	83 ec 0c             	sub    $0xc,%esp
c00208e7:	6a 0a                	push   $0xa
c00208e9:	e8 8c 98 00 00       	call   c002a17a <putchar>
  for (; *argv != NULL && **argv == '-'; argv++)
c00208ee:	a1 60 b0 03 c0       	mov    0xc003b060,%eax
c00208f3:	83 c4 10             	add    $0x10,%esp
c00208f6:	85 c0                	test   %eax,%eax
c00208f8:	0f 84 02 fc ff ff    	je     c0020500 <pintos_init+0x2c0>
c00208fe:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020901:	0f 85 7c fc ff ff    	jne    c0020583 <pintos_init+0x343>
c0020907:	bd 60 b0 03 c0       	mov    $0xc003b060,%ebp
      char *name = strtok_r (*argv, "=", &save_ptr);
c002090c:	8d 5c 24 1c          	lea    0x1c(%esp),%ebx
c0020910:	e9 47 fa ff ff       	jmp    c002035c <pintos_init+0x11c>

c0020915 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c0020915:	57                   	push   %edi
c0020916:	56                   	push   %esi
c0020917:	53                   	push   %ebx
c0020918:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level;

	ASSERT (t != NULL);
c002091b:	85 c0                	test   %eax,%eax
c002091d:	0f 84 1c 01 00 00    	je     c0020a3f <init_thread+0x12a>
c0020923:	89 c3                	mov    %eax,%ebx
c0020925:	89 ce                	mov    %ecx,%esi
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020927:	83 f9 3f             	cmp    $0x3f,%ecx
c002092a:	0f 87 30 01 00 00    	ja     c0020a60 <init_thread+0x14b>
  ASSERT (name != NULL);
c0020930:	85 d2                	test   %edx,%edx
c0020932:	0f 84 49 01 00 00    	je     c0020a81 <init_thread+0x16c>

  memset (t, 0, sizeof *t);
c0020938:	b9 39 00 00 00       	mov    $0x39,%ecx
c002093d:	b8 00 00 00 00       	mov    $0x0,%eax
c0020942:	89 df                	mov    %ebx,%edi
c0020944:	f3 ab                	rep stos %eax,%es:(%edi)
  t->status = THREAD_BLOCKED;
c0020946:	c7 43 08 02 00 00 00 	movl   $0x2,0x8(%ebx)
  strlcpy (t->name, name, sizeof t->name);
c002094d:	83 ec 04             	sub    $0x4,%esp
c0020950:	6a 10                	push   $0x10
c0020952:	52                   	push   %edx
c0020953:	8d 43 0c             	lea    0xc(%ebx),%eax
c0020956:	50                   	push   %eax
c0020957:	e8 c5 73 00 00       	call   c0027d21 <strlcpy>
  t->stack = (uint8_t *) t + PGSIZE;
c002095c:	8d 83 00 10 00 00    	lea    0x1000(%ebx),%eax
c0020962:	89 43 1c             	mov    %eax,0x1c(%ebx)
  t->priority = priority;
c0020965:	89 73 20             	mov    %esi,0x20(%ebx)
/* fstqwq */
  t->sleep_remain = 0;
c0020968:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)

  if (thread_mlfqs) {
c002096f:	83 c4 10             	add    $0x10,%esp
c0020972:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c0020979:	0f 85 23 01 00 00    	jne    c0020aa2 <init_thread+0x18d>
    t->nice = 0;
    t->recent_cpu = fixed32_init(0);
    t->priority = 0;
  }

  list_init (&t->lock_list);
c002097f:	83 ec 0c             	sub    $0xc,%esp
c0020982:	8d 43 30             	lea    0x30(%ebx),%eax
c0020985:	50                   	push   %eax
c0020986:	e8 43 7d 00 00       	call   c00286ce <list_init>
  t->priority_to_set = -1;
c002098b:	c7 43 44 ff ff ff ff 	movl   $0xffffffff,0x44(%ebx)
  t->max_donate_delta = 0;
c0020992:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  t->father = 0;
c0020999:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)

/* end fstqwq */

  t->magic = THREAD_MAGIC;
c00209a0:	c7 83 e0 00 00 00 4b 	movl   $0xcd6abf4b,0xe0(%ebx)
c00209a7:	bf 6a cd 

  /* yveh */
#ifdef USERPROG
	t->ret_status = -1;
c00209aa:	c7 43 68 ff ff ff ff 	movl   $0xffffffff,0x68(%ebx)
  t->load_success = false;
c00209b1:	c6 83 a0 00 00 00 00 	movb   $0x0,0xa0(%ebx)
  sema_init(&t->load_sema, 0);
c00209b8:	83 c4 08             	add    $0x8,%esp
c00209bb:	6a 00                	push   $0x0
c00209bd:	8d 43 78             	lea    0x78(%ebx),%eax
c00209c0:	50                   	push   %eax
c00209c1:	e8 69 20 00 00       	call   c0022a2f <sema_init>
  sema_init(&t->wait_sema, 0);
c00209c6:	83 c4 08             	add    $0x8,%esp
c00209c9:	6a 00                	push   $0x0
c00209cb:	8d 83 8c 00 00 00    	lea    0x8c(%ebx),%eax
c00209d1:	50                   	push   %eax
c00209d2:	e8 58 20 00 00       	call   c0022a2f <sema_init>
  t->wait_tid = -1;
c00209d7:	c7 43 74 ff ff ff ff 	movl   $0xffffffff,0x74(%ebx)
  t->file_cnt = 2;
c00209de:	c7 43 6c 02 00 00 00 	movl   $0x2,0x6c(%ebx)
  asm ("mov %%esp, %0" : "=g" (esp));
c00209e5:	89 e0                	mov    %esp,%eax
  return (void *) ((uintptr_t) va & ~PGMASK);
c00209e7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00209ec:	89 83 a4 00 00 00    	mov    %eax,0xa4(%ebx)
  t->parent = running_thread();
  t->self = NULL;
c00209f2:	c7 83 b8 00 00 00 00 	movl   $0x0,0xb8(%ebx)
c00209f9:	00 00 00 
  list_init(&t->files);
c00209fc:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
c0020a02:	89 04 24             	mov    %eax,(%esp)
c0020a05:	e8 c4 7c 00 00       	call   c00286ce <list_init>
  list_init(&t->children);
c0020a0a:	8d 83 a8 00 00 00    	lea    0xa8(%ebx),%eax
c0020a10:	89 04 24             	mov    %eax,(%esp)
c0020a13:	e8 b6 7c 00 00       	call   c00286ce <list_init>
  t->mapping_cnt = 2;
  list_init(&t->mappings);
#endif
  /* end yveh */

  old_level = intr_disable ();
c0020a18:	e8 e4 0f 00 00       	call   c0021a01 <intr_disable>
c0020a1d:	89 c6                	mov    %eax,%esi
  list_push_back (&all_list, &t->allelem);
c0020a1f:	83 c4 08             	add    $0x8,%esp
c0020a22:	83 c3 54             	add    $0x54,%ebx
c0020a25:	53                   	push   %ebx
c0020a26:	68 7c b2 03 c0       	push   $0xc003b27c
c0020a2b:	e8 ea 80 00 00       	call   c0028b1a <list_push_back>
  intr_set_level (old_level);
c0020a30:	89 34 24             	mov    %esi,(%esp)
c0020a33:	e8 d0 0f 00 00       	call   c0021a08 <intr_set_level>
}
c0020a38:	83 c4 20             	add    $0x20,%esp
c0020a3b:	5b                   	pop    %ebx
c0020a3c:	5e                   	pop    %esi
c0020a3d:	5f                   	pop    %edi
c0020a3e:	c3                   	ret    
	ASSERT (t != NULL);
c0020a3f:	83 ec 0c             	sub    $0xc,%esp
c0020a42:	68 1b 1c 03 c0       	push   $0xc0031c1b
c0020a47:	68 21 01 03 c0       	push   $0xc0030121
c0020a4c:	68 d4 ea 02 c0       	push   $0xc002ead4
c0020a51:	68 8c 02 00 00       	push   $0x28c
c0020a56:	68 c0 06 03 c0       	push   $0xc00306c0
c0020a5b:	e8 c7 7b 00 00       	call   c0028627 <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020a60:	83 ec 0c             	sub    $0xc,%esp
c0020a63:	68 18 08 03 c0       	push   $0xc0030818
c0020a68:	68 21 01 03 c0       	push   $0xc0030121
c0020a6d:	68 d4 ea 02 c0       	push   $0xc002ead4
c0020a72:	68 8d 02 00 00       	push   $0x28d
c0020a77:	68 c0 06 03 c0       	push   $0xc00306c0
c0020a7c:	e8 a6 7b 00 00       	call   c0028627 <debug_panic>
  ASSERT (name != NULL);
c0020a81:	83 ec 0c             	sub    $0xc,%esp
c0020a84:	68 d7 06 03 c0       	push   $0xc00306d7
c0020a89:	68 21 01 03 c0       	push   $0xc0030121
c0020a8e:	68 d4 ea 02 c0       	push   $0xc002ead4
c0020a93:	68 8e 02 00 00       	push   $0x28e
c0020a98:	68 c0 06 03 c0       	push   $0xc00306c0
c0020a9d:	e8 85 7b 00 00       	call   c0028627 <debug_panic>
    t->nice = 0;
c0020aa2:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
    t->recent_cpu = fixed32_init(0);
c0020aa9:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020aad:	83 ec 08             	sub    $0x8,%esp
c0020ab0:	6a 00                	push   $0x0
c0020ab2:	50                   	push   %eax
c0020ab3:	e8 0e 32 00 00       	call   c0023cc6 <fixed32_init>
c0020ab8:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020abc:	89 43 2c             	mov    %eax,0x2c(%ebx)
    t->priority = 0;
c0020abf:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
c0020ac6:	83 c4 0c             	add    $0xc,%esp
c0020ac9:	e9 b1 fe ff ff       	jmp    c002097f <init_thread+0x6a>

c0020ace <is_thread>:
{
c0020ace:	53                   	push   %ebx
c0020acf:	83 ec 08             	sub    $0x8,%esp
c0020ad2:	89 c3                	mov    %eax,%ebx
  if (!(t != NULL && t->magic == THREAD_MAGIC)) {
c0020ad4:	85 c0                	test   %eax,%eax
c0020ad6:	74 44                	je     c0020b1c <is_thread+0x4e>
c0020ad8:	81 b8 e0 00 00 00 4b 	cmpl   $0xcd6abf4b,0xe0(%eax)
c0020adf:	bf 6a cd 
c0020ae2:	74 2a                	je     c0020b0e <is_thread+0x40>
    printf("is thread failed : %u", t);
c0020ae4:	83 ec 08             	sub    $0x8,%esp
c0020ae7:	50                   	push   %eax
c0020ae8:	68 e4 06 03 c0       	push   $0xc00306e4
c0020aed:	e8 87 60 00 00       	call   c0026b79 <printf>
  return t != NULL && t->magic == THREAD_MAGIC;
c0020af2:	83 c4 10             	add    $0x10,%esp
c0020af5:	81 bb e0 00 00 00 4b 	cmpl   $0xcd6abf4b,0xe0(%ebx)
c0020afc:	bf 6a cd 
c0020aff:	74 14                	je     c0020b15 <is_thread+0x47>
c0020b01:	b8 00 00 00 00       	mov    $0x0,%eax
c0020b06:	83 e0 01             	and    $0x1,%eax
}
c0020b09:	83 c4 08             	add    $0x8,%esp
c0020b0c:	5b                   	pop    %ebx
c0020b0d:	c3                   	ret    
  return t != NULL && t->magic == THREAD_MAGIC;
c0020b0e:	b8 01 00 00 00       	mov    $0x1,%eax
c0020b13:	eb f1                	jmp    c0020b06 <is_thread+0x38>
c0020b15:	b8 01 00 00 00       	mov    $0x1,%eax
c0020b1a:	eb ea                	jmp    c0020b06 <is_thread+0x38>
    printf("is thread failed : %u", t);
c0020b1c:	83 ec 08             	sub    $0x8,%esp
c0020b1f:	50                   	push   %eax
c0020b20:	68 e4 06 03 c0       	push   $0xc00306e4
c0020b25:	e8 4f 60 00 00       	call   c0026b79 <printf>
c0020b2a:	83 c4 10             	add    $0x10,%esp
c0020b2d:	eb d2                	jmp    c0020b01 <is_thread+0x33>

c0020b2f <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c0020b2f:	56                   	push   %esi
c0020b30:	53                   	push   %ebx
c0020b31:	83 ec 04             	sub    $0x4,%esp
c0020b34:	89 c3                	mov    %eax,%ebx
c0020b36:	89 d6                	mov    %edx,%esi
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c0020b38:	e8 91 ff ff ff       	call   c0020ace <is_thread>
c0020b3d:	84 c0                	test   %al,%al
c0020b3f:	74 16                	je     c0020b57 <alloc_frame+0x28>
  ASSERT (size % sizeof (uint32_t) == 0);
c0020b41:	f7 c6 03 00 00 00    	test   $0x3,%esi
c0020b47:	75 2f                	jne    c0020b78 <alloc_frame+0x49>

  t->stack -= size;
c0020b49:	8b 43 1c             	mov    0x1c(%ebx),%eax
c0020b4c:	29 f0                	sub    %esi,%eax
c0020b4e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  return t->stack;
}
c0020b51:	83 c4 04             	add    $0x4,%esp
c0020b54:	5b                   	pop    %ebx
c0020b55:	5e                   	pop    %esi
c0020b56:	c3                   	ret    
  ASSERT (is_thread (t));
c0020b57:	83 ec 0c             	sub    $0xc,%esp
c0020b5a:	68 fa 06 03 c0       	push   $0xc00306fa
c0020b5f:	68 21 01 03 c0       	push   $0xc0030121
c0020b64:	68 a8 ea 02 c0       	push   $0xc002eaa8
c0020b69:	68 c5 02 00 00       	push   $0x2c5
c0020b6e:	68 c0 06 03 c0       	push   $0xc00306c0
c0020b73:	e8 af 7a 00 00       	call   c0028627 <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c0020b78:	83 ec 0c             	sub    $0xc,%esp
c0020b7b:	68 08 07 03 c0       	push   $0xc0030708
c0020b80:	68 21 01 03 c0       	push   $0xc0030121
c0020b85:	68 a8 ea 02 c0       	push   $0xc002eaa8
c0020b8a:	68 c6 02 00 00       	push   $0x2c6
c0020b8f:	68 c0 06 03 c0       	push   $0xc00306c0
c0020b94:	e8 8e 7a 00 00       	call   c0028627 <debug_panic>

c0020b99 <thread_update_priority>:
thread_update_priority(struct thread* t, void* aux UNUSED){
c0020b99:	53                   	push   %ebx
c0020b9a:	83 ec 18             	sub    $0x18,%esp
c0020b9d:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  if(t != idle_thread) {
c0020ba1:	39 1d 78 b2 03 c0    	cmp    %ebx,0xc003b278
c0020ba7:	74 31                	je     c0020bda <thread_update_priority+0x41>
                - fixed32_trunc(fixed32_div_int(t->recent_cpu, 4))
c0020ba9:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020bad:	83 ec 04             	sub    $0x4,%esp
c0020bb0:	6a 04                	push   $0x4
c0020bb2:	ff 73 2c             	pushl  0x2c(%ebx)
c0020bb5:	50                   	push   %eax
c0020bb6:	e8 bf 32 00 00       	call   c0023e7a <fixed32_div_int>
c0020bbb:	ff 74 24 18          	pushl  0x18(%esp)
c0020bbf:	e8 12 31 00 00       	call   c0023cd6 <fixed32_trunc>
c0020bc4:	ba 3f 00 00 00       	mov    $0x3f,%edx
c0020bc9:	29 c2                	sub    %eax,%edx
c0020bcb:	89 d0                	mov    %edx,%eax
                - t->nice * 2;
c0020bcd:	8b 53 28             	mov    0x28(%ebx),%edx
c0020bd0:	01 d2                	add    %edx,%edx
c0020bd2:	29 d0                	sub    %edx,%eax
c0020bd4:	89 43 20             	mov    %eax,0x20(%ebx)
    t->priority = PRI_MAX
c0020bd7:	83 c4 10             	add    $0x10,%esp
}
c0020bda:	83 c4 18             	add    $0x18,%esp
c0020bdd:	5b                   	pop    %ebx
c0020bde:	c3                   	ret    

c0020bdf <thread_init>:
{
c0020bdf:	56                   	push   %esi
c0020be0:	53                   	push   %ebx
c0020be1:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0020be4:	e8 db 0d 00 00       	call   c00219c4 <intr_get_level>
c0020be9:	85 c0                	test   %eax,%eax
c0020beb:	75 7c                	jne    c0020c69 <thread_init+0x8a>
  lock_init (&tid_lock);
c0020bed:	83 ec 0c             	sub    $0xc,%esp
c0020bf0:	68 40 b2 03 c0       	push   $0xc003b240
c0020bf5:	e8 0f 21 00 00       	call   c0022d09 <lock_init>
  list_init (&ready_list);
c0020bfa:	c7 04 24 8c b2 03 c0 	movl   $0xc003b28c,(%esp)
c0020c01:	e8 c8 7a 00 00       	call   c00286ce <list_init>
  list_init (&all_list);
c0020c06:	c7 04 24 7c b2 03 c0 	movl   $0xc003b27c,(%esp)
c0020c0d:	e8 bc 7a 00 00       	call   c00286ce <list_init>
  asm ("mov %%esp, %0" : "=g" (esp));
c0020c12:	89 e0                	mov    %esp,%eax
c0020c14:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  initial_thread = running_thread ();
c0020c19:	a3 74 b2 03 c0       	mov    %eax,0xc003b274
  init_thread (initial_thread, "main", PRI_DEFAULT);
c0020c1e:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c0020c23:	ba 44 07 03 c0       	mov    $0xc0030744,%edx
c0020c28:	e8 e8 fc ff ff       	call   c0020915 <init_thread>
  initial_thread->status = THREAD_RUNNING;
c0020c2d:	8b 1d 74 b2 03 c0    	mov    0xc003b274,%ebx
c0020c33:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
allocate_tid (void) 
{
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c0020c3a:	c7 04 24 40 b2 03 c0 	movl   $0xc003b240,(%esp)
c0020c41:	e8 37 22 00 00       	call   c0022e7d <lock_acquire>
  tid = next_tid++;
c0020c46:	8b 35 0c ac 03 c0    	mov    0xc003ac0c,%esi
c0020c4c:	8d 46 01             	lea    0x1(%esi),%eax
c0020c4f:	a3 0c ac 03 c0       	mov    %eax,0xc003ac0c
  lock_release (&tid_lock);
c0020c54:	c7 04 24 40 b2 03 c0 	movl   $0xc003b240,(%esp)
c0020c5b:	e8 ba 23 00 00       	call   c002301a <lock_release>
  initial_thread->tid = allocate_tid ();
c0020c60:	89 73 04             	mov    %esi,0x4(%ebx)
}
c0020c63:	83 c4 14             	add    $0x14,%esp
c0020c66:	5b                   	pop    %ebx
c0020c67:	5e                   	pop    %esi
c0020c68:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0020c69:	83 ec 0c             	sub    $0xc,%esp
c0020c6c:	68 26 07 03 c0       	push   $0xc0030726
c0020c71:	68 21 01 03 c0       	push   $0xc0030121
c0020c76:	68 e0 ea 02 c0       	push   $0xc002eae0
c0020c7b:	6a 77                	push   $0x77
c0020c7d:	68 c0 06 03 c0       	push   $0xc00306c0
c0020c82:	e8 a0 79 00 00       	call   c0028627 <debug_panic>

c0020c87 <thread_print_stats>:
{
c0020c87:	83 ec 10             	sub    $0x10,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020c8a:	ff 35 2c b2 03 c0    	pushl  0xc003b22c
c0020c90:	ff 35 28 b2 03 c0    	pushl  0xc003b228
c0020c96:	ff 35 34 b2 03 c0    	pushl  0xc003b234
c0020c9c:	ff 35 30 b2 03 c0    	pushl  0xc003b230
c0020ca2:	ff 35 3c b2 03 c0    	pushl  0xc003b23c
c0020ca8:	ff 35 38 b2 03 c0    	pushl  0xc003b238
c0020cae:	68 44 08 03 c0       	push   $0xc0030844
c0020cb3:	e8 c1 5e 00 00       	call   c0026b79 <printf>
}
c0020cb8:	83 c4 2c             	add    $0x2c,%esp
c0020cbb:	c3                   	ret    

c0020cbc <thread_current>:
{
c0020cbc:	53                   	push   %ebx
c0020cbd:	83 ec 08             	sub    $0x8,%esp
  asm ("mov %%esp, %0" : "=g" (esp));
c0020cc0:	89 e3                	mov    %esp,%ebx
c0020cc2:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  ASSERT (is_thread (t));
c0020cc8:	89 d8                	mov    %ebx,%eax
c0020cca:	e8 ff fd ff ff       	call   c0020ace <is_thread>
c0020ccf:	84 c0                	test   %al,%al
c0020cd1:	74 0d                	je     c0020ce0 <thread_current+0x24>
  ASSERT (t->status == THREAD_RUNNING);
c0020cd3:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c0020cd7:	75 28                	jne    c0020d01 <thread_current+0x45>
}
c0020cd9:	89 d8                	mov    %ebx,%eax
c0020cdb:	83 c4 08             	add    $0x8,%esp
c0020cde:	5b                   	pop    %ebx
c0020cdf:	c3                   	ret    
  ASSERT (is_thread (t));
c0020ce0:	83 ec 0c             	sub    $0xc,%esp
c0020ce3:	68 fa 06 03 c0       	push   $0xc00306fa
c0020ce8:	68 21 01 03 c0       	push   $0xc0030121
c0020ced:	68 6c ea 02 c0       	push   $0xc002ea6c
c0020cf2:	68 44 01 00 00       	push   $0x144
c0020cf7:	68 c0 06 03 c0       	push   $0xc00306c0
c0020cfc:	e8 26 79 00 00       	call   c0028627 <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020d01:	83 ec 0c             	sub    $0xc,%esp
c0020d04:	68 49 07 03 c0       	push   $0xc0030749
c0020d09:	68 21 01 03 c0       	push   $0xc0030121
c0020d0e:	68 6c ea 02 c0       	push   $0xc002ea6c
c0020d13:	68 45 01 00 00       	push   $0x145
c0020d18:	68 c0 06 03 c0       	push   $0xc00306c0
c0020d1d:	e8 05 79 00 00       	call   c0028627 <debug_panic>

c0020d22 <thread_tick>:
{
c0020d22:	83 ec 0c             	sub    $0xc,%esp
  struct thread *t = thread_current ();
c0020d25:	e8 92 ff ff ff       	call   c0020cbc <thread_current>
  if (t == idle_thread)
c0020d2a:	3b 05 78 b2 03 c0    	cmp    0xc003b278,%eax
c0020d30:	74 28                	je     c0020d5a <thread_tick+0x38>
  else if (t->pagedir != NULL)
c0020d32:	83 78 64 00          	cmpl   $0x0,0x64(%eax)
c0020d36:	74 32                	je     c0020d6a <thread_tick+0x48>
    user_ticks++;
c0020d38:	83 05 28 b2 03 c0 01 	addl   $0x1,0xc003b228
c0020d3f:	83 15 2c b2 03 c0 00 	adcl   $0x0,0xc003b22c
  if (++thread_ticks >= TIME_SLICE)
c0020d46:	a1 20 b2 03 c0       	mov    0xc003b220,%eax
c0020d4b:	40                   	inc    %eax
c0020d4c:	a3 20 b2 03 c0       	mov    %eax,0xc003b220
c0020d51:	83 f8 03             	cmp    $0x3,%eax
c0020d54:	77 24                	ja     c0020d7a <thread_tick+0x58>
}
c0020d56:	83 c4 0c             	add    $0xc,%esp
c0020d59:	c3                   	ret    
    idle_ticks++;
c0020d5a:	83 05 38 b2 03 c0 01 	addl   $0x1,0xc003b238
c0020d61:	83 15 3c b2 03 c0 00 	adcl   $0x0,0xc003b23c
c0020d68:	eb dc                	jmp    c0020d46 <thread_tick+0x24>
    kernel_ticks++;
c0020d6a:	83 05 30 b2 03 c0 01 	addl   $0x1,0xc003b230
c0020d71:	83 15 34 b2 03 c0 00 	adcl   $0x0,0xc003b234
c0020d78:	eb cc                	jmp    c0020d46 <thread_tick+0x24>
    intr_yield_on_return ();
c0020d7a:	e8 a9 0e 00 00       	call   c0021c28 <intr_yield_on_return>
}
c0020d7f:	eb d5                	jmp    c0020d56 <thread_tick+0x34>

c0020d81 <thread_name>:
{
c0020d81:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->name;
c0020d84:	e8 33 ff ff ff       	call   c0020cbc <thread_current>
c0020d89:	83 c0 0c             	add    $0xc,%eax
}
c0020d8c:	83 c4 0c             	add    $0xc,%esp
c0020d8f:	c3                   	ret    

c0020d90 <thread_tid>:
{
c0020d90:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->tid;
c0020d93:	e8 24 ff ff ff       	call   c0020cbc <thread_current>
c0020d98:	8b 40 04             	mov    0x4(%eax),%eax
}
c0020d9b:	83 c4 0c             	add    $0xc,%esp
c0020d9e:	c3                   	ret    

c0020d9f <thread_foreach>:
{
c0020d9f:	57                   	push   %edi
c0020da0:	56                   	push   %esi
c0020da1:	53                   	push   %ebx
c0020da2:	8b 74 24 10          	mov    0x10(%esp),%esi
c0020da6:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c0020daa:	e8 15 0c 00 00       	call   c00219c4 <intr_get_level>
c0020daf:	85 c0                	test   %eax,%eax
c0020db1:	75 14                	jne    c0020dc7 <thread_foreach+0x28>
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020db3:	83 ec 0c             	sub    $0xc,%esp
c0020db6:	68 7c b2 03 c0       	push   $0xc003b27c
c0020dbb:	e8 51 79 00 00       	call   c0028711 <list_begin>
c0020dc0:	89 c3                	mov    %eax,%ebx
c0020dc2:	83 c4 10             	add    $0x10,%esp
c0020dc5:	eb 38                	jmp    c0020dff <thread_foreach+0x60>
  ASSERT (intr_get_level () == INTR_OFF);
c0020dc7:	83 ec 0c             	sub    $0xc,%esp
c0020dca:	68 26 07 03 c0       	push   $0xc0030726
c0020dcf:	68 21 01 03 c0       	push   $0xc0030121
c0020dd4:	68 40 ea 02 c0       	push   $0xc002ea40
c0020dd9:	68 88 01 00 00       	push   $0x188
c0020dde:	68 c0 06 03 c0       	push   $0xc00306c0
c0020de3:	e8 3f 78 00 00       	call   c0028627 <debug_panic>
      func (t, aux);
c0020de8:	83 ec 08             	sub    $0x8,%esp
c0020deb:	57                   	push   %edi
      struct thread *t = list_entry (e, struct thread, allelem);
c0020dec:	8d 43 ac             	lea    -0x54(%ebx),%eax
      func (t, aux);
c0020def:	50                   	push   %eax
c0020df0:	ff d6                	call   *%esi
       e = list_next (e))
c0020df2:	89 1c 24             	mov    %ebx,(%esp)
c0020df5:	e8 47 79 00 00       	call   c0028741 <list_next>
c0020dfa:	89 c3                	mov    %eax,%ebx
c0020dfc:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020dff:	83 ec 0c             	sub    $0xc,%esp
c0020e02:	68 7c b2 03 c0       	push   $0xc003b27c
c0020e07:	e8 7d 79 00 00       	call   c0028789 <list_end>
c0020e0c:	83 c4 10             	add    $0x10,%esp
c0020e0f:	39 c3                	cmp    %eax,%ebx
c0020e11:	75 d5                	jne    c0020de8 <thread_foreach+0x49>
}
c0020e13:	5b                   	pop    %ebx
c0020e14:	5e                   	pop    %esi
c0020e15:	5f                   	pop    %edi
c0020e16:	c3                   	ret    

c0020e17 <thread_ready_list_get_min>:
thread_ready_list_get_min() {
c0020e17:	83 ec 18             	sub    $0x18,%esp
  ASSERT (! list_empty(&ready_list));
c0020e1a:	68 8c b2 03 c0       	push   $0xc003b28c
c0020e1f:	e8 9e 7d 00 00       	call   c0028bc2 <list_empty>
c0020e24:	83 c4 10             	add    $0x10,%esp
c0020e27:	84 c0                	test   %al,%al
c0020e29:	75 18                	jne    c0020e43 <thread_ready_list_get_min+0x2c>
  struct list_elem* e = list_min(&ready_list, thread_priority_greater, NULL);
c0020e2b:	83 ec 04             	sub    $0x4,%esp
c0020e2e:	6a 00                	push   $0x0
c0020e30:	68 c0 0f 02 c0       	push   $0xc0020fc0
c0020e35:	68 8c b2 03 c0       	push   $0xc003b28c
c0020e3a:	e8 cf 83 00 00       	call   c002920e <list_min>
}
c0020e3f:	83 c4 1c             	add    $0x1c,%esp
c0020e42:	c3                   	ret    
  ASSERT (! list_empty(&ready_list));
c0020e43:	83 ec 0c             	sub    $0xc,%esp
c0020e46:	68 65 07 03 c0       	push   $0xc0030765
c0020e4b:	68 21 01 03 c0       	push   $0xc0030121
c0020e50:	68 24 ea 02 c0       	push   $0xc002ea24
c0020e55:	68 95 01 00 00       	push   $0x195
c0020e5a:	68 c0 06 03 c0       	push   $0xc00306c0
c0020e5f:	e8 c3 77 00 00       	call   c0028627 <debug_panic>

c0020e64 <thread_insert_ready_list>:
thread_insert_ready_list(struct list_elem* elem) {
c0020e64:	83 ec 14             	sub    $0x14,%esp
    list_push_back(&ready_list, elem);
c0020e67:	ff 74 24 18          	pushl  0x18(%esp)
c0020e6b:	68 8c b2 03 c0       	push   $0xc003b28c
c0020e70:	e8 a5 7c 00 00       	call   c0028b1a <list_push_back>
}
c0020e75:	83 c4 1c             	add    $0x1c,%esp
c0020e78:	c3                   	ret    

c0020e79 <thread_unblock>:
{
c0020e79:	56                   	push   %esi
c0020e7a:	53                   	push   %ebx
c0020e7b:	83 ec 04             	sub    $0x4,%esp
c0020e7e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (is_thread (t));
c0020e82:	89 d8                	mov    %ebx,%eax
c0020e84:	e8 45 fc ff ff       	call   c0020ace <is_thread>
c0020e89:	84 c0                	test   %al,%al
c0020e8b:	74 2e                	je     c0020ebb <thread_unblock+0x42>
  old_level = intr_disable ();
c0020e8d:	e8 6f 0b 00 00       	call   c0021a01 <intr_disable>
c0020e92:	89 c6                	mov    %eax,%esi
  ASSERT (t->status == THREAD_BLOCKED);
c0020e94:	83 7b 08 02          	cmpl   $0x2,0x8(%ebx)
c0020e98:	75 42                	jne    c0020edc <thread_unblock+0x63>
  thread_insert_ready_list(&t->elem);
c0020e9a:	83 ec 0c             	sub    $0xc,%esp
c0020e9d:	8d 43 5c             	lea    0x5c(%ebx),%eax
c0020ea0:	50                   	push   %eax
c0020ea1:	e8 be ff ff ff       	call   c0020e64 <thread_insert_ready_list>
  t->status = THREAD_READY;
c0020ea6:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
  intr_set_level (old_level);
c0020ead:	89 34 24             	mov    %esi,(%esp)
c0020eb0:	e8 53 0b 00 00       	call   c0021a08 <intr_set_level>
}
c0020eb5:	83 c4 14             	add    $0x14,%esp
c0020eb8:	5b                   	pop    %ebx
c0020eb9:	5e                   	pop    %esi
c0020eba:	c3                   	ret    
  ASSERT (is_thread (t));
c0020ebb:	83 ec 0c             	sub    $0xc,%esp
c0020ebe:	68 fa 06 03 c0       	push   $0xc00306fa
c0020ec3:	68 21 01 03 c0       	push   $0xc0030121
c0020ec8:	68 7c ea 02 c0       	push   $0xc002ea7c
c0020ecd:	68 19 01 00 00       	push   $0x119
c0020ed2:	68 c0 06 03 c0       	push   $0xc00306c0
c0020ed7:	e8 4b 77 00 00       	call   c0028627 <debug_panic>
  ASSERT (t->status == THREAD_BLOCKED);
c0020edc:	83 ec 0c             	sub    $0xc,%esp
c0020edf:	68 7f 07 03 c0       	push   $0xc003077f
c0020ee4:	68 21 01 03 c0       	push   $0xc0030121
c0020ee9:	68 7c ea 02 c0       	push   $0xc002ea7c
c0020eee:	68 1c 01 00 00       	push   $0x11c
c0020ef3:	68 c0 06 03 c0       	push   $0xc00306c0
c0020ef8:	e8 2a 77 00 00       	call   c0028627 <debug_panic>

c0020efd <thread_update_sleep>:
{
c0020efd:	53                   	push   %ebx
c0020efe:	83 ec 08             	sub    $0x8,%esp
c0020f01:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (is_thread(t));
c0020f05:	89 d8                	mov    %ebx,%eax
c0020f07:	e8 c2 fb ff ff       	call   c0020ace <is_thread>
c0020f0c:	84 c0                	test   %al,%al
c0020f0e:	74 14                	je     c0020f24 <thread_update_sleep+0x27>
  if (t->sleep_remain > 0) {
c0020f10:	8b 43 24             	mov    0x24(%ebx),%eax
c0020f13:	85 c0                	test   %eax,%eax
c0020f15:	7e 08                	jle    c0020f1f <thread_update_sleep+0x22>
    if (!--(t->sleep_remain)) {
c0020f17:	48                   	dec    %eax
c0020f18:	89 43 24             	mov    %eax,0x24(%ebx)
c0020f1b:	85 c0                	test   %eax,%eax
c0020f1d:	74 26                	je     c0020f45 <thread_update_sleep+0x48>
}
c0020f1f:	83 c4 08             	add    $0x8,%esp
c0020f22:	5b                   	pop    %ebx
c0020f23:	c3                   	ret    
  ASSERT (is_thread(t));
c0020f24:	83 ec 0c             	sub    $0xc,%esp
c0020f27:	68 9b 07 03 c0       	push   $0xc003079b
c0020f2c:	68 21 01 03 c0       	push   $0xc0030121
c0020f31:	68 cc e9 02 c0       	push   $0xc002e9cc
c0020f36:	68 33 02 00 00       	push   $0x233
c0020f3b:	68 c0 06 03 c0       	push   $0xc00306c0
c0020f40:	e8 e2 76 00 00       	call   c0028627 <debug_panic>
      thread_unblock (t);
c0020f45:	83 ec 0c             	sub    $0xc,%esp
c0020f48:	53                   	push   %ebx
c0020f49:	e8 2b ff ff ff       	call   c0020e79 <thread_unblock>
c0020f4e:	83 c4 10             	add    $0x10,%esp
}
c0020f51:	eb cc                	jmp    c0020f1f <thread_update_sleep+0x22>

c0020f53 <thread_set_nice>:
{
c0020f53:	83 ec 0c             	sub    $0xc,%esp
  thread_current()->nice = nice;
c0020f56:	e8 61 fd ff ff       	call   c0020cbc <thread_current>
c0020f5b:	8b 54 24 10          	mov    0x10(%esp),%edx
c0020f5f:	89 50 28             	mov    %edx,0x28(%eax)
  if (thread_mlfqs) {
c0020f62:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c0020f69:	75 04                	jne    c0020f6f <thread_set_nice+0x1c>
}
c0020f6b:	83 c4 0c             	add    $0xc,%esp
c0020f6e:	c3                   	ret    
    thread_update_priority(thread_current(), NULL);
c0020f6f:	e8 48 fd ff ff       	call   c0020cbc <thread_current>
c0020f74:	83 ec 08             	sub    $0x8,%esp
c0020f77:	6a 00                	push   $0x0
c0020f79:	50                   	push   %eax
c0020f7a:	e8 1a fc ff ff       	call   c0020b99 <thread_update_priority>
c0020f7f:	83 c4 10             	add    $0x10,%esp
}
c0020f82:	eb e7                	jmp    c0020f6b <thread_set_nice+0x18>

c0020f84 <thread_get_nice>:
{
c0020f84:	83 ec 0c             	sub    $0xc,%esp
  return thread_current()->nice;
c0020f87:	e8 30 fd ff ff       	call   c0020cbc <thread_current>
c0020f8c:	8b 40 28             	mov    0x28(%eax),%eax
}
c0020f8f:	83 c4 0c             	add    $0xc,%esp
c0020f92:	c3                   	ret    

c0020f93 <thread_get_certain_priority>:
{
c0020f93:	8b 54 24 04          	mov    0x4(%esp),%edx
  if (thread_mlfqs) {
c0020f97:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c0020f9e:	75 07                	jne    c0020fa7 <thread_get_certain_priority+0x14>
    return t->max_donate_delta + t->priority;
c0020fa0:	8b 42 20             	mov    0x20(%edx),%eax
c0020fa3:	03 42 40             	add    0x40(%edx),%eax
}
c0020fa6:	c3                   	ret    
    return t->priority;
c0020fa7:	8b 42 20             	mov    0x20(%edx),%eax
c0020faa:	c3                   	ret    

c0020fab <thread_get_priority>:
{
c0020fab:	83 ec 0c             	sub    $0xc,%esp
  return thread_get_certain_priority (thread_current ());
c0020fae:	e8 09 fd ff ff       	call   c0020cbc <thread_current>
c0020fb3:	83 ec 0c             	sub    $0xc,%esp
c0020fb6:	50                   	push   %eax
c0020fb7:	e8 d7 ff ff ff       	call   c0020f93 <thread_get_certain_priority>
}
c0020fbc:	83 c4 1c             	add    $0x1c,%esp
c0020fbf:	c3                   	ret    

c0020fc0 <thread_priority_greater>:
{
c0020fc0:	53                   	push   %ebx
  return thread_get_certain_priority (list_entry (a_, struct thread, elem))
c0020fc1:	8b 44 24 08          	mov    0x8(%esp),%eax
c0020fc5:	83 e8 5c             	sub    $0x5c,%eax
c0020fc8:	50                   	push   %eax
c0020fc9:	e8 c5 ff ff ff       	call   c0020f93 <thread_get_certain_priority>
c0020fce:	89 c3                	mov    %eax,%ebx
       > thread_get_certain_priority (list_entry (b_, struct thread, elem));
c0020fd0:	8b 44 24 10          	mov    0x10(%esp),%eax
c0020fd4:	83 e8 5c             	sub    $0x5c,%eax
c0020fd7:	89 04 24             	mov    %eax,(%esp)
c0020fda:	e8 b4 ff ff ff       	call   c0020f93 <thread_get_certain_priority>
c0020fdf:	83 c4 04             	add    $0x4,%esp
c0020fe2:	39 c3                	cmp    %eax,%ebx
c0020fe4:	0f 9f c0             	setg   %al
}
c0020fe7:	5b                   	pop    %ebx
c0020fe8:	c3                   	ret    

c0020fe9 <thread_get_load_avg>:
{
c0020fe9:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT(thread_mlfqs);
c0020fec:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c0020ff3:	74 22                	je     c0021017 <thread_get_load_avg+0x2e>
  return fixed32_round(fixed32_mul_int(load_avg, 100));
c0020ff5:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020ff9:	83 ec 04             	sub    $0x4,%esp
c0020ffc:	6a 64                	push   $0x64
c0020ffe:	ff 35 9c b2 03 c0    	pushl  0xc003b29c
c0021004:	50                   	push   %eax
c0021005:	e8 2c 2e 00 00       	call   c0023e36 <fixed32_mul_int>
c002100a:	ff 74 24 18          	pushl  0x18(%esp)
c002100e:	e8 d9 2c 00 00       	call   c0023cec <fixed32_round>
}
c0021013:	83 c4 2c             	add    $0x2c,%esp
c0021016:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0021017:	83 ec 0c             	sub    $0xc,%esp
c002101a:	68 a8 07 03 c0       	push   $0xc00307a8
c002101f:	68 21 01 03 c0       	push   $0xc0030121
c0021024:	68 10 ea 02 c0       	push   $0xc002ea10
c0021029:	68 f7 01 00 00       	push   $0x1f7
c002102e:	68 c0 06 03 c0       	push   $0xc00306c0
c0021033:	e8 ef 75 00 00       	call   c0028627 <debug_panic>

c0021038 <thread_update_recent_cpu>:
{
c0021038:	57                   	push   %edi
c0021039:	56                   	push   %esi
c002103a:	53                   	push   %ebx
c002103b:	83 ec 10             	sub    $0x10,%esp
c002103e:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  ASSERT(thread_mlfqs);
c0021042:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c0021049:	74 48                	je     c0021093 <thread_update_recent_cpu+0x5b>
  int load_avg_2 = thread_get_load_avg() * 2;
c002104b:	e8 99 ff ff ff       	call   c0020fe9 <thread_get_load_avg>
c0021050:	01 c0                	add    %eax,%eax
  t->recent_cpu = fixed32_add_int(
c0021052:	8b 7b 28             	mov    0x28(%ebx),%edi
c0021055:	8d 74 24 0c          	lea    0xc(%esp),%esi
c0021059:	83 ec 04             	sub    $0x4,%esp
c002105c:	8d 50 64             	lea    0x64(%eax),%edx
c002105f:	52                   	push   %edx
c0021060:	50                   	push   %eax
c0021061:	56                   	push   %esi
c0021062:	e8 27 2e 00 00       	call   c0023e8e <fixed32_div_int_int>
c0021067:	83 ec 08             	sub    $0x8,%esp
c002106a:	ff 73 2c             	pushl  0x2c(%ebx)
c002106d:	ff 74 24 24          	pushl  0x24(%esp)
c0021071:	56                   	push   %esi
c0021072:	e8 72 2d 00 00       	call   c0023de9 <fixed32_mul>
c0021077:	83 c4 08             	add    $0x8,%esp
c002107a:	57                   	push   %edi
c002107b:	ff 74 24 24          	pushl  0x24(%esp)
c002107f:	56                   	push   %esi
c0021080:	e8 29 2d 00 00       	call   c0023dae <fixed32_add_int>
c0021085:	8b 44 24 28          	mov    0x28(%esp),%eax
c0021089:	89 43 2c             	mov    %eax,0x2c(%ebx)
}
c002108c:	83 c4 2c             	add    $0x2c,%esp
c002108f:	5b                   	pop    %ebx
c0021090:	5e                   	pop    %esi
c0021091:	5f                   	pop    %edi
c0021092:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0021093:	83 ec 0c             	sub    $0xc,%esp
c0021096:	68 a8 07 03 c0       	push   $0xc00307a8
c002109b:	68 21 01 03 c0       	push   $0xc0030121
c00210a0:	68 b0 e9 02 c0       	push   $0xc002e9b0
c00210a5:	68 0a 02 00 00       	push   $0x20a
c00210aa:	68 c0 06 03 c0       	push   $0xc00306c0
c00210af:	e8 73 75 00 00       	call   c0028627 <debug_panic>

c00210b4 <thread_add_recent_cpu>:
{
c00210b4:	53                   	push   %ebx
c00210b5:	83 ec 18             	sub    $0x18,%esp
  ASSERT(thread_mlfqs);
c00210b8:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c00210bf:	74 3b                	je     c00210fc <thread_add_recent_cpu+0x48>
  struct thread* t = thread_current();
c00210c1:	e8 f6 fb ff ff       	call   c0020cbc <thread_current>
c00210c6:	89 c3                	mov    %eax,%ebx
  if (t != idle_thread) {
c00210c8:	3b 05 78 b2 03 c0    	cmp    0xc003b278,%eax
c00210ce:	74 1c                	je     c00210ec <thread_add_recent_cpu+0x38>
    t->recent_cpu = fixed32_add_int(t->recent_cpu, 1);
c00210d0:	8d 44 24 0c          	lea    0xc(%esp),%eax
c00210d4:	83 ec 04             	sub    $0x4,%esp
c00210d7:	6a 01                	push   $0x1
c00210d9:	ff 73 2c             	pushl  0x2c(%ebx)
c00210dc:	50                   	push   %eax
c00210dd:	e8 cc 2c 00 00       	call   c0023dae <fixed32_add_int>
c00210e2:	8b 44 24 18          	mov    0x18(%esp),%eax
c00210e6:	89 43 2c             	mov    %eax,0x2c(%ebx)
c00210e9:	83 c4 0c             	add    $0xc,%esp
  thread_update_priority(t, NULL);
c00210ec:	83 ec 08             	sub    $0x8,%esp
c00210ef:	6a 00                	push   $0x0
c00210f1:	53                   	push   %ebx
c00210f2:	e8 a2 fa ff ff       	call   c0020b99 <thread_update_priority>
}
c00210f7:	83 c4 28             	add    $0x28,%esp
c00210fa:	5b                   	pop    %ebx
c00210fb:	c3                   	ret    
  ASSERT(thread_mlfqs);
c00210fc:	83 ec 0c             	sub    $0xc,%esp
c00210ff:	68 a8 07 03 c0       	push   $0xc00307a8
c0021104:	68 21 01 03 c0       	push   $0xc0030121
c0021109:	68 f8 e9 02 c0       	push   $0xc002e9f8
c002110e:	68 fe 01 00 00       	push   $0x1fe
c0021113:	68 c0 06 03 c0       	push   $0xc00306c0
c0021118:	e8 0a 75 00 00       	call   c0028627 <debug_panic>

c002111d <thread_get_recent_cpu>:
{
c002111d:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT(thread_mlfqs);
c0021120:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c0021127:	74 24                	je     c002114d <thread_get_recent_cpu+0x30>
  return fixed32_trunc(fixed32_mul_int(thread_current()->recent_cpu, 100));
c0021129:	e8 8e fb ff ff       	call   c0020cbc <thread_current>
c002112e:	8d 54 24 0c          	lea    0xc(%esp),%edx
c0021132:	83 ec 04             	sub    $0x4,%esp
c0021135:	6a 64                	push   $0x64
c0021137:	ff 70 2c             	pushl  0x2c(%eax)
c002113a:	52                   	push   %edx
c002113b:	e8 f6 2c 00 00       	call   c0023e36 <fixed32_mul_int>
c0021140:	ff 74 24 18          	pushl  0x18(%esp)
c0021144:	e8 8d 2b 00 00       	call   c0023cd6 <fixed32_trunc>
}
c0021149:	83 c4 2c             	add    $0x2c,%esp
c002114c:	c3                   	ret    
  ASSERT(thread_mlfqs);
c002114d:	83 ec 0c             	sub    $0xc,%esp
c0021150:	68 a8 07 03 c0       	push   $0xc00307a8
c0021155:	68 21 01 03 c0       	push   $0xc0030121
c002115a:	68 e0 e9 02 c0       	push   $0xc002e9e0
c002115f:	68 16 02 00 00       	push   $0x216
c0021164:	68 c0 06 03 c0       	push   $0xc00306c0
c0021169:	e8 b9 74 00 00       	call   c0028627 <debug_panic>

c002116e <thread_tick_events>:
void thread_tick_events(bool a_second) {
c002116e:	56                   	push   %esi
c002116f:	53                   	push   %ebx
c0021170:	83 ec 14             	sub    $0x14,%esp
c0021173:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  if (thread_mlfqs) {
c0021177:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c002117e:	75 15                	jne    c0021195 <thread_tick_events+0x27>
  thread_foreach(thread_update_sleep, NULL);
c0021180:	83 ec 08             	sub    $0x8,%esp
c0021183:	6a 00                	push   $0x0
c0021185:	68 fd 0e 02 c0       	push   $0xc0020efd
c002118a:	e8 10 fc ff ff       	call   c0020d9f <thread_foreach>
}
c002118f:	83 c4 24             	add    $0x24,%esp
c0021192:	5b                   	pop    %ebx
c0021193:	5e                   	pop    %esi
c0021194:	c3                   	ret    
    thread_add_recent_cpu();
c0021195:	e8 1a ff ff ff       	call   c00210b4 <thread_add_recent_cpu>
    if (a_second) {
c002119a:	84 db                	test   %bl,%bl
c002119c:	74 e2                	je     c0021180 <thread_tick_events+0x12>
  ASSERT(thread_mlfqs);
c002119e:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c00211a5:	74 19                	je     c00211c0 <thread_tick_events+0x52>
  for (e = list_begin (&all_list); e != list_end (&all_list); e = list_next (e)) {
c00211a7:	83 ec 0c             	sub    $0xc,%esp
c00211aa:	68 7c b2 03 c0       	push   $0xc003b27c
c00211af:	e8 5d 75 00 00       	call   c0028711 <list_begin>
c00211b4:	89 c3                	mov    %eax,%ebx
c00211b6:	83 c4 10             	add    $0x10,%esp
  int ready_count = 0;
c00211b9:	be 00 00 00 00       	mov    $0x0,%esi
c00211be:	eb 2f                	jmp    c00211ef <thread_tick_events+0x81>
  ASSERT(thread_mlfqs);
c00211c0:	83 ec 0c             	sub    $0xc,%esp
c00211c3:	68 a8 07 03 c0       	push   $0xc00307a8
c00211c8:	68 21 01 03 c0       	push   $0xc0030121
c00211cd:	68 98 e9 02 c0       	push   $0xc002e998
c00211d2:	68 d0 01 00 00       	push   $0x1d0
c00211d7:	68 c0 06 03 c0       	push   $0xc00306c0
c00211dc:	e8 46 74 00 00       	call   c0028627 <debug_panic>
  for (e = list_begin (&all_list); e != list_end (&all_list); e = list_next (e)) {
c00211e1:	83 ec 0c             	sub    $0xc,%esp
c00211e4:	53                   	push   %ebx
c00211e5:	e8 57 75 00 00       	call   c0028741 <list_next>
c00211ea:	89 c3                	mov    %eax,%ebx
c00211ec:	83 c4 10             	add    $0x10,%esp
c00211ef:	83 ec 0c             	sub    $0xc,%esp
c00211f2:	68 7c b2 03 c0       	push   $0xc003b27c
c00211f7:	e8 8d 75 00 00       	call   c0028789 <list_end>
c00211fc:	83 c4 10             	add    $0x10,%esp
c00211ff:	39 c3                	cmp    %eax,%ebx
c0021201:	74 14                	je     c0021217 <thread_tick_events+0xa9>
    if ((t->status == THREAD_RUNNING || t->status == THREAD_READY) && t != idle_thread) {
c0021203:	83 7b b4 01          	cmpl   $0x1,-0x4c(%ebx)
c0021207:	77 d8                	ja     c00211e1 <thread_tick_events+0x73>
    struct thread *t = list_entry (e, struct thread, allelem);
c0021209:	8d 43 ac             	lea    -0x54(%ebx),%eax
    if ((t->status == THREAD_RUNNING || t->status == THREAD_READY) && t != idle_thread) {
c002120c:	39 05 78 b2 03 c0    	cmp    %eax,0xc003b278
c0021212:	74 cd                	je     c00211e1 <thread_tick_events+0x73>
      ready_count++;
c0021214:	46                   	inc    %esi
c0021215:	eb ca                	jmp    c00211e1 <thread_tick_events+0x73>
  load_avg = fixed32_div_int(
c0021217:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
c002121b:	83 ec 04             	sub    $0x4,%esp
c002121e:	6a 3b                	push   $0x3b
c0021220:	ff 35 9c b2 03 c0    	pushl  0xc003b29c
c0021226:	53                   	push   %ebx
c0021227:	e8 0a 2c 00 00       	call   c0023e36 <fixed32_mul_int>
c002122c:	83 ec 08             	sub    $0x8,%esp
c002122f:	56                   	push   %esi
c0021230:	ff 74 24 24          	pushl  0x24(%esp)
c0021234:	53                   	push   %ebx
c0021235:	e8 74 2b 00 00       	call   c0023dae <fixed32_add_int>
c002123a:	83 c4 08             	add    $0x8,%esp
c002123d:	6a 3c                	push   $0x3c
c002123f:	ff 74 24 24          	pushl  0x24(%esp)
c0021243:	53                   	push   %ebx
c0021244:	e8 31 2c 00 00       	call   c0023e7a <fixed32_div_int>
c0021249:	8b 44 24 28          	mov    0x28(%esp),%eax
c002124d:	a3 9c b2 03 c0       	mov    %eax,0xc003b29c
      thread_foreach(thread_update_recent_cpu, NULL);
c0021252:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0021259:	68 38 10 02 c0       	push   $0xc0021038
c002125e:	e8 3c fb ff ff       	call   c0020d9f <thread_foreach>
      thread_foreach(thread_update_priority, NULL);
c0021263:	83 c4 18             	add    $0x18,%esp
c0021266:	6a 00                	push   $0x0
c0021268:	68 99 0b 02 c0       	push   $0xc0020b99
c002126d:	e8 2d fb ff ff       	call   c0020d9f <thread_foreach>
c0021272:	83 c4 10             	add    $0x10,%esp
c0021275:	e9 06 ff ff ff       	jmp    c0021180 <thread_tick_events+0x12>

c002127a <thread_schedule_tail>:
{
c002127a:	56                   	push   %esi
c002127b:	53                   	push   %ebx
c002127c:	83 ec 04             	sub    $0x4,%esp
c002127f:	8b 74 24 10          	mov    0x10(%esp),%esi
  asm ("mov %%esp, %0" : "=g" (esp));
c0021283:	89 e3                	mov    %esp,%ebx
c0021285:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c002128b:	e8 34 07 00 00       	call   c00219c4 <intr_get_level>
c0021290:	85 c0                	test   %eax,%eax
c0021292:	75 26                	jne    c00212ba <thread_schedule_tail+0x40>
  cur->status = THREAD_RUNNING;
c0021294:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  thread_ticks = 0;
c002129b:	c7 05 20 b2 03 c0 00 	movl   $0x0,0xc003b220
c00212a2:	00 00 00 
  process_activate ();
c00212a5:	e8 82 91 00 00       	call   c002a42c <process_activate>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c00212aa:	85 f6                	test   %esi,%esi
c00212ac:	74 06                	je     c00212b4 <thread_schedule_tail+0x3a>
c00212ae:	83 7e 08 03          	cmpl   $0x3,0x8(%esi)
c00212b2:	74 27                	je     c00212db <thread_schedule_tail+0x61>
}
c00212b4:	83 c4 04             	add    $0x4,%esp
c00212b7:	5b                   	pop    %ebx
c00212b8:	5e                   	pop    %esi
c00212b9:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00212ba:	83 ec 0c             	sub    $0xc,%esp
c00212bd:	68 26 07 03 c0       	push   $0xc0030726
c00212c2:	68 21 01 03 c0       	push   $0xc0030121
c00212c7:	68 80 e9 02 c0       	push   $0xc002e980
c00212cc:	68 f2 02 00 00       	push   $0x2f2
c00212d1:	68 c0 06 03 c0       	push   $0xc00306c0
c00212d6:	e8 4c 73 00 00       	call   c0028627 <debug_panic>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c00212db:	3b 35 74 b2 03 c0    	cmp    0xc003b274,%esi
c00212e1:	74 d1                	je     c00212b4 <thread_schedule_tail+0x3a>
      ASSERT (prev != cur);
c00212e3:	39 de                	cmp    %ebx,%esi
c00212e5:	74 0e                	je     c00212f5 <thread_schedule_tail+0x7b>
      palloc_free_page (prev);
c00212e7:	83 ec 0c             	sub    $0xc,%esp
c00212ea:	56                   	push   %esi
c00212eb:	e8 92 24 00 00       	call   c0023782 <palloc_free_page>
c00212f0:	83 c4 10             	add    $0x10,%esp
}
c00212f3:	eb bf                	jmp    c00212b4 <thread_schedule_tail+0x3a>
      ASSERT (prev != cur);
c00212f5:	83 ec 0c             	sub    $0xc,%esp
c00212f8:	68 b5 07 03 c0       	push   $0xc00307b5
c00212fd:	68 21 01 03 c0       	push   $0xc0030121
c0021302:	68 80 e9 02 c0       	push   $0xc002e980
c0021307:	68 06 03 00 00       	push   $0x306
c002130c:	68 c0 06 03 c0       	push   $0xc00306c0
c0021311:	e8 11 73 00 00       	call   c0028627 <debug_panic>

c0021316 <schedule>:
{
c0021316:	56                   	push   %esi
c0021317:	53                   	push   %ebx
c0021318:	83 ec 10             	sub    $0x10,%esp
  asm ("mov %%esp, %0" : "=g" (esp));
c002131b:	89 e3                	mov    %esp,%ebx
c002131d:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  if (list_empty (&ready_list))
c0021323:	68 8c b2 03 c0       	push   $0xc003b28c
c0021328:	e8 95 78 00 00       	call   c0028bc2 <list_empty>
c002132d:	83 c4 10             	add    $0x10,%esp
c0021330:	84 c0                	test   %al,%al
c0021332:	74 44                	je     c0021378 <schedule+0x62>
    return idle_thread;
c0021334:	8b 35 78 b2 03 c0    	mov    0xc003b278,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c002133a:	e8 85 06 00 00       	call   c00219c4 <intr_get_level>
c002133f:	85 c0                	test   %eax,%eax
c0021341:	75 4d                	jne    c0021390 <schedule+0x7a>
  ASSERT (cur->status != THREAD_RUNNING);
c0021343:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c0021347:	74 68                	je     c00213b1 <schedule+0x9b>
  ASSERT (is_thread (next));
c0021349:	89 f0                	mov    %esi,%eax
c002134b:	e8 7e f7 ff ff       	call   c0020ace <is_thread>
c0021350:	84 c0                	test   %al,%al
c0021352:	74 7e                	je     c00213d2 <schedule+0xbc>
  if (cur != next)
c0021354:	39 de                	cmp    %ebx,%esi
c0021356:	0f 84 97 00 00 00    	je     c00213f3 <schedule+0xdd>
    prev = switch_threads (cur, next);
c002135c:	83 ec 08             	sub    $0x8,%esp
c002135f:	56                   	push   %esi
c0021360:	53                   	push   %ebx
c0021361:	e8 0d 05 00 00       	call   c0021873 <switch_threads>
c0021366:	83 c4 10             	add    $0x10,%esp
  thread_schedule_tail (prev);
c0021369:	83 ec 0c             	sub    $0xc,%esp
c002136c:	50                   	push   %eax
c002136d:	e8 08 ff ff ff       	call   c002127a <thread_schedule_tail>
}
c0021372:	83 c4 14             	add    $0x14,%esp
c0021375:	5b                   	pop    %ebx
c0021376:	5e                   	pop    %esi
c0021377:	c3                   	ret    
    struct list_elem* e = thread_ready_list_get_min();
c0021378:	e8 9a fa ff ff       	call   c0020e17 <thread_ready_list_get_min>
c002137d:	89 c6                	mov    %eax,%esi
    list_remove(e);
c002137f:	83 ec 0c             	sub    $0xc,%esp
c0021382:	50                   	push   %eax
c0021383:	e8 af 77 00 00       	call   c0028b37 <list_remove>
    return list_entry (e, struct thread, elem);
c0021388:	83 ee 5c             	sub    $0x5c,%esi
c002138b:	83 c4 10             	add    $0x10,%esp
c002138e:	eb aa                	jmp    c002133a <schedule+0x24>
  ASSERT (intr_get_level () == INTR_OFF);
c0021390:	83 ec 0c             	sub    $0xc,%esp
c0021393:	68 26 07 03 c0       	push   $0xc0030726
c0021398:	68 21 01 03 c0       	push   $0xc0030121
c002139d:	68 8c ea 02 c0       	push   $0xc002ea8c
c00213a2:	68 19 03 00 00       	push   $0x319
c00213a7:	68 c0 06 03 c0       	push   $0xc00306c0
c00213ac:	e8 76 72 00 00       	call   c0028627 <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c00213b1:	83 ec 0c             	sub    $0xc,%esp
c00213b4:	68 c1 07 03 c0       	push   $0xc00307c1
c00213b9:	68 21 01 03 c0       	push   $0xc0030121
c00213be:	68 8c ea 02 c0       	push   $0xc002ea8c
c00213c3:	68 1a 03 00 00       	push   $0x31a
c00213c8:	68 c0 06 03 c0       	push   $0xc00306c0
c00213cd:	e8 55 72 00 00       	call   c0028627 <debug_panic>
  ASSERT (is_thread (next));
c00213d2:	83 ec 0c             	sub    $0xc,%esp
c00213d5:	68 df 07 03 c0       	push   $0xc00307df
c00213da:	68 21 01 03 c0       	push   $0xc0030121
c00213df:	68 8c ea 02 c0       	push   $0xc002ea8c
c00213e4:	68 1b 03 00 00       	push   $0x31b
c00213e9:	68 c0 06 03 c0       	push   $0xc00306c0
c00213ee:	e8 34 72 00 00       	call   c0028627 <debug_panic>
  struct thread *prev = NULL;
c00213f3:	b8 00 00 00 00       	mov    $0x0,%eax
c00213f8:	e9 6c ff ff ff       	jmp    c0021369 <schedule+0x53>

c00213fd <thread_block>:
{
c00213fd:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (!intr_context ());
c0021400:	e8 1d 08 00 00       	call   c0021c22 <intr_context>
c0021405:	84 c0                	test   %al,%al
c0021407:	75 1e                	jne    c0021427 <thread_block+0x2a>
  ASSERT (intr_get_level () == INTR_OFF);
c0021409:	e8 b6 05 00 00       	call   c00219c4 <intr_get_level>
c002140e:	85 c0                	test   %eax,%eax
c0021410:	75 36                	jne    c0021448 <thread_block+0x4b>
  thread_current ()->status = THREAD_BLOCKED;
c0021412:	e8 a5 f8 ff ff       	call   c0020cbc <thread_current>
c0021417:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
  schedule ();
c002141e:	e8 f3 fe ff ff       	call   c0021316 <schedule>
}
c0021423:	83 c4 0c             	add    $0xc,%esp
c0021426:	c3                   	ret    
  ASSERT (!intr_context ());
c0021427:	83 ec 0c             	sub    $0xc,%esp
c002142a:	68 f0 07 03 c0       	push   $0xc00307f0
c002142f:	68 21 01 03 c0       	push   $0xc0030121
c0021434:	68 98 ea 02 c0       	push   $0xc002ea98
c0021439:	68 05 01 00 00       	push   $0x105
c002143e:	68 c0 06 03 c0       	push   $0xc00306c0
c0021443:	e8 df 71 00 00       	call   c0028627 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0021448:	83 ec 0c             	sub    $0xc,%esp
c002144b:	68 26 07 03 c0       	push   $0xc0030726
c0021450:	68 21 01 03 c0       	push   $0xc0030121
c0021455:	68 98 ea 02 c0       	push   $0xc002ea98
c002145a:	68 06 01 00 00       	push   $0x106
c002145f:	68 c0 06 03 c0       	push   $0xc00306c0
c0021464:	e8 be 71 00 00       	call   c0028627 <debug_panic>

c0021469 <idle>:
{
c0021469:	83 ec 0c             	sub    $0xc,%esp
  idle_thread = thread_current ();
c002146c:	e8 4b f8 ff ff       	call   c0020cbc <thread_current>
c0021471:	a3 78 b2 03 c0       	mov    %eax,0xc003b278
  sema_up (idle_started);
c0021476:	83 ec 0c             	sub    $0xc,%esp
c0021479:	ff 74 24 1c          	pushl  0x1c(%esp)
c002147d:	e8 fc 16 00 00       	call   c0022b7e <sema_up>
c0021482:	83 c4 10             	add    $0x10,%esp
      intr_disable ();
c0021485:	e8 77 05 00 00       	call   c0021a01 <intr_disable>
      thread_block ();
c002148a:	e8 6e ff ff ff       	call   c00213fd <thread_block>
      asm volatile ("sti; hlt" : : : "memory");
c002148f:	fb                   	sti    
c0021490:	f4                   	hlt    
c0021491:	eb f2                	jmp    c0021485 <idle+0x1c>

c0021493 <thread_yield>:
{
c0021493:	56                   	push   %esi
c0021494:	53                   	push   %ebx
c0021495:	83 ec 04             	sub    $0x4,%esp
  struct thread *cur = thread_current ();
c0021498:	e8 1f f8 ff ff       	call   c0020cbc <thread_current>
c002149d:	89 c3                	mov    %eax,%ebx
  ASSERT (!intr_context ());
c002149f:	e8 7e 07 00 00       	call   c0021c22 <intr_context>
c00214a4:	84 c0                	test   %al,%al
c00214a6:	75 39                	jne    c00214e1 <thread_yield+0x4e>
  old_level = intr_disable ();
c00214a8:	e8 54 05 00 00       	call   c0021a01 <intr_disable>
c00214ad:	89 c6                	mov    %eax,%esi
  if (cur != idle_thread) 
c00214af:	3b 1d 78 b2 03 c0    	cmp    0xc003b278,%ebx
c00214b5:	74 0f                	je     c00214c6 <thread_yield+0x33>
    thread_insert_ready_list (&cur->elem);
c00214b7:	83 ec 0c             	sub    $0xc,%esp
c00214ba:	8d 43 5c             	lea    0x5c(%ebx),%eax
c00214bd:	50                   	push   %eax
c00214be:	e8 a1 f9 ff ff       	call   c0020e64 <thread_insert_ready_list>
c00214c3:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c00214c6:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
  schedule ();
c00214cd:	e8 44 fe ff ff       	call   c0021316 <schedule>
  intr_set_level (old_level);
c00214d2:	83 ec 0c             	sub    $0xc,%esp
c00214d5:	56                   	push   %esi
c00214d6:	e8 2d 05 00 00       	call   c0021a08 <intr_set_level>
}
c00214db:	83 c4 14             	add    $0x14,%esp
c00214de:	5b                   	pop    %ebx
c00214df:	5e                   	pop    %esi
c00214e0:	c3                   	ret    
  ASSERT (!intr_context ());
c00214e1:	83 ec 0c             	sub    $0xc,%esp
c00214e4:	68 f0 07 03 c0       	push   $0xc00307f0
c00214e9:	68 21 01 03 c0       	push   $0xc0030121
c00214ee:	68 50 ea 02 c0       	push   $0xc002ea50
c00214f3:	68 77 01 00 00       	push   $0x177
c00214f8:	68 c0 06 03 c0       	push   $0xc00306c0
c00214fd:	e8 25 71 00 00       	call   c0028627 <debug_panic>

c0021502 <thread_check_switch>:
void thread_check_switch() {
c0021502:	56                   	push   %esi
c0021503:	53                   	push   %ebx
c0021504:	83 ec 04             	sub    $0x4,%esp
	enum intr_level old_level = intr_disable();
c0021507:	e8 f5 04 00 00       	call   c0021a01 <intr_disable>
c002150c:	89 c3                	mov    %eax,%ebx
  if (thread_current () != idle_thread &&
c002150e:	e8 a9 f7 ff ff       	call   c0020cbc <thread_current>
c0021513:	3b 05 78 b2 03 c0    	cmp    0xc003b278,%eax
c0021519:	74 14                	je     c002152f <thread_check_switch+0x2d>
   !list_empty (&ready_list) && 
c002151b:	83 ec 0c             	sub    $0xc,%esp
c002151e:	68 8c b2 03 c0       	push   $0xc003b28c
c0021523:	e8 9a 76 00 00       	call   c0028bc2 <list_empty>
  if (thread_current () != idle_thread &&
c0021528:	83 c4 10             	add    $0x10,%esp
c002152b:	84 c0                	test   %al,%al
c002152d:	74 12                	je     c0021541 <thread_check_switch+0x3f>
    intr_set_level (old_level);
c002152f:	83 ec 0c             	sub    $0xc,%esp
c0021532:	53                   	push   %ebx
c0021533:	e8 d0 04 00 00       	call   c0021a08 <intr_set_level>
c0021538:	83 c4 10             	add    $0x10,%esp
}
c002153b:	83 c4 04             	add    $0x4,%esp
c002153e:	5b                   	pop    %ebx
c002153f:	5e                   	pop    %esi
c0021540:	c3                   	ret    
   thread_get_priority () <
c0021541:	e8 65 fa ff ff       	call   c0020fab <thread_get_priority>
c0021546:	89 c6                	mov    %eax,%esi
   thread_get_certain_priority (list_entry (thread_ready_list_get_min(), struct thread, elem))) {
c0021548:	e8 ca f8 ff ff       	call   c0020e17 <thread_ready_list_get_min>
c002154d:	83 ec 0c             	sub    $0xc,%esp
c0021550:	83 e8 5c             	sub    $0x5c,%eax
c0021553:	50                   	push   %eax
c0021554:	e8 3a fa ff ff       	call   c0020f93 <thread_get_certain_priority>
c0021559:	83 c4 10             	add    $0x10,%esp
   !list_empty (&ready_list) && 
c002155c:	39 c6                	cmp    %eax,%esi
c002155e:	7d cf                	jge    c002152f <thread_check_switch+0x2d>
    intr_set_level (old_level);
c0021560:	83 ec 0c             	sub    $0xc,%esp
c0021563:	53                   	push   %ebx
c0021564:	e8 9f 04 00 00       	call   c0021a08 <intr_set_level>
    thread_yield ();
c0021569:	e8 25 ff ff ff       	call   c0021493 <thread_yield>
c002156e:	83 c4 10             	add    $0x10,%esp
c0021571:	eb c8                	jmp    c002153b <thread_check_switch+0x39>

c0021573 <thread_create>:
{
c0021573:	57                   	push   %edi
c0021574:	56                   	push   %esi
c0021575:	53                   	push   %ebx
c0021576:	8b 7c 24 18          	mov    0x18(%esp),%edi
  ASSERT (function != NULL);
c002157a:	85 ff                	test   %edi,%edi
c002157c:	0f 84 f4 00 00 00    	je     c0021676 <thread_create+0x103>
  t = palloc_get_page (PAL_ZERO);
c0021582:	83 ec 0c             	sub    $0xc,%esp
c0021585:	6a 02                	push   $0x2
c0021587:	e8 cc 20 00 00       	call   c0023658 <palloc_get_page>
c002158c:	89 c3                	mov    %eax,%ebx
  if (t == NULL)
c002158e:	83 c4 10             	add    $0x10,%esp
c0021591:	85 c0                	test   %eax,%eax
c0021593:	0f 84 fe 00 00 00    	je     c0021697 <thread_create+0x124>
  init_thread (t, name, priority);
c0021599:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002159d:	8b 54 24 10          	mov    0x10(%esp),%edx
c00215a1:	e8 6f f3 ff ff       	call   c0020915 <init_thread>
  lock_acquire (&tid_lock);
c00215a6:	83 ec 0c             	sub    $0xc,%esp
c00215a9:	68 40 b2 03 c0       	push   $0xc003b240
c00215ae:	e8 ca 18 00 00       	call   c0022e7d <lock_acquire>
  tid = next_tid++;
c00215b3:	8b 35 0c ac 03 c0    	mov    0xc003ac0c,%esi
c00215b9:	8d 46 01             	lea    0x1(%esi),%eax
c00215bc:	a3 0c ac 03 c0       	mov    %eax,0xc003ac0c
  lock_release (&tid_lock);
c00215c1:	c7 04 24 40 b2 03 c0 	movl   $0xc003b240,(%esp)
c00215c8:	e8 4d 1a 00 00       	call   c002301a <lock_release>
  tid = t->tid = allocate_tid ();
c00215cd:	89 73 04             	mov    %esi,0x4(%ebx)
	struct child_process *ch = malloc(sizeof(*ch));
c00215d0:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c00215d7:	e8 f2 23 00 00       	call   c00239ce <malloc>
  ch->tid = t->tid;
c00215dc:	89 30                	mov    %esi,(%eax)
  ch->ret_status = t->ret_status;
c00215de:	8b 53 68             	mov    0x68(%ebx),%edx
c00215e1:	89 50 04             	mov    %edx,0x4(%eax)
  ch->done = false;
c00215e4:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  ch->waited = false;
c00215e8:	c6 40 09 00          	movb   $0x0,0x9(%eax)
  asm ("mov %%esp, %0" : "=g" (esp));
c00215ec:	89 e2                	mov    %esp,%edx
	list_push_back(&running_thread()->children, &ch->elem);
c00215ee:	83 c4 08             	add    $0x8,%esp
c00215f1:	83 c0 0c             	add    $0xc,%eax
c00215f4:	50                   	push   %eax
c00215f5:	89 d0                	mov    %edx,%eax
c00215f7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00215fc:	05 a8 00 00 00       	add    $0xa8,%eax
c0021601:	50                   	push   %eax
c0021602:	e8 13 75 00 00       	call   c0028b1a <list_push_back>
  t->dir = thread_current()->dir;
c0021607:	e8 b0 f6 ff ff       	call   c0020cbc <thread_current>
c002160c:	8b 80 dc 00 00 00    	mov    0xdc(%eax),%eax
c0021612:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
  kf = alloc_frame (t, sizeof *kf);
c0021618:	ba 0c 00 00 00       	mov    $0xc,%edx
c002161d:	89 d8                	mov    %ebx,%eax
c002161f:	e8 0b f5 ff ff       	call   c0020b2f <alloc_frame>
  kf->eip = NULL;
c0021624:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c002162a:	89 78 04             	mov    %edi,0x4(%eax)
  kf->aux = aux;
c002162d:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0021631:	89 50 08             	mov    %edx,0x8(%eax)
  ef = alloc_frame (t, sizeof *ef);
c0021634:	ba 04 00 00 00       	mov    $0x4,%edx
c0021639:	89 d8                	mov    %ebx,%eax
c002163b:	e8 ef f4 ff ff       	call   c0020b2f <alloc_frame>
  ef->eip = (void (*) (void)) kernel_thread;
c0021640:	c7 00 19 18 02 c0    	movl   $0xc0021819,(%eax)
  sf = alloc_frame (t, sizeof *sf);
c0021646:	ba 1c 00 00 00       	mov    $0x1c,%edx
c002164b:	89 d8                	mov    %ebx,%eax
c002164d:	e8 dd f4 ff ff       	call   c0020b2f <alloc_frame>
  sf->eip = switch_entry;
c0021652:	c7 40 10 90 18 02 c0 	movl   $0xc0021890,0x10(%eax)
  sf->ebp = 0;
c0021659:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  thread_unblock (t);
c0021660:	89 1c 24             	mov    %ebx,(%esp)
c0021663:	e8 11 f8 ff ff       	call   c0020e79 <thread_unblock>
  thread_check_switch();
c0021668:	e8 95 fe ff ff       	call   c0021502 <thread_check_switch>
	return tid;
c002166d:	83 c4 10             	add    $0x10,%esp
}
c0021670:	89 f0                	mov    %esi,%eax
c0021672:	5b                   	pop    %ebx
c0021673:	5e                   	pop    %esi
c0021674:	5f                   	pop    %edi
c0021675:	c3                   	ret    
  ASSERT (function != NULL);
c0021676:	83 ec 0c             	sub    $0xc,%esp
c0021679:	68 01 08 03 c0       	push   $0xc0030801
c002167e:	68 21 01 03 c0       	push   $0xc0030121
c0021683:	68 c4 ea 02 c0       	push   $0xc002eac4
c0021688:	68 cc 00 00 00       	push   $0xcc
c002168d:	68 c0 06 03 c0       	push   $0xc00306c0
c0021692:	e8 90 6f 00 00       	call   c0028627 <debug_panic>
    return TID_ERROR;
c0021697:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002169c:	eb d2                	jmp    c0021670 <thread_create+0xfd>

c002169e <thread_start>:
{
c002169e:	53                   	push   %ebx
c002169f:	83 ec 30             	sub    $0x30,%esp
  sema_init (&idle_started, 0);
c00216a2:	6a 00                	push   $0x0
c00216a4:	8d 5c 24 18          	lea    0x18(%esp),%ebx
c00216a8:	53                   	push   %ebx
c00216a9:	e8 81 13 00 00       	call   c0022a2f <sema_init>
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c00216ae:	53                   	push   %ebx
c00216af:	68 69 14 02 c0       	push   $0xc0021469
c00216b4:	6a 00                	push   $0x0
c00216b6:	68 12 08 03 c0       	push   $0xc0030812
c00216bb:	e8 b3 fe ff ff       	call   c0021573 <thread_create>
  intr_enable ();
c00216c0:	83 c4 20             	add    $0x20,%esp
c00216c3:	e8 05 03 00 00       	call   c00219cd <intr_enable>
  sema_down (&idle_started);
c00216c8:	83 ec 0c             	sub    $0xc,%esp
c00216cb:	53                   	push   %ebx
c00216cc:	e8 cc 13 00 00       	call   c0022a9d <sema_down>
}
c00216d1:	83 c4 38             	add    $0x38,%esp
c00216d4:	5b                   	pop    %ebx
c00216d5:	c3                   	ret    

c00216d6 <thread_set_priority>:
  if (thread_mlfqs) {
c00216d6:	80 3d 9c 55 04 c0 00 	cmpb   $0x0,0xc004559c
c00216dd:	74 01                	je     c00216e0 <thread_set_priority+0xa>
}
c00216df:	c3                   	ret    
{
c00216e0:	83 ec 0c             	sub    $0xc,%esp
  struct thread* t = thread_current ();
c00216e3:	e8 d4 f5 ff ff       	call   c0020cbc <thread_current>
  if (t->max_donate_delta) {
c00216e8:	83 78 40 00          	cmpl   $0x0,0x40(%eax)
c00216ec:	74 0c                	je     c00216fa <thread_set_priority+0x24>
    t->priority_to_set = new_priority;
c00216ee:	8b 54 24 10          	mov    0x10(%esp),%edx
c00216f2:	89 50 44             	mov    %edx,0x44(%eax)
}
c00216f5:	83 c4 0c             	add    $0xc,%esp
c00216f8:	eb e5                	jmp    c00216df <thread_set_priority+0x9>
    t->priority = new_priority;
c00216fa:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00216fe:	89 48 20             	mov    %ecx,0x20(%eax)
    thread_check_switch();
c0021701:	e8 fc fd ff ff       	call   c0021502 <thread_check_switch>
c0021706:	eb ed                	jmp    c00216f5 <thread_set_priority+0x1f>

c0021708 <get_child_by_tid>:
/* Offset of `stack' member within `struct thread'.
   Used by switch.S, which can't figure it out on its own. */
uint32_t thread_stack_ofs = offsetof (struct thread, stack);

struct child_process *
get_child_by_tid(struct list* children, tid_t tid) {
c0021708:	57                   	push   %edi
c0021709:	56                   	push   %esi
c002170a:	53                   	push   %ebx
c002170b:	8b 74 24 10          	mov    0x10(%esp),%esi
c002170f:	8b 7c 24 14          	mov    0x14(%esp),%edi
//	ASSERT (intr_get_level () == INTR_OFF);
	struct child_process *ch;
	for (struct list_elem *e = list_begin(children); e != list_end(children); e = list_next(e)) {
c0021713:	83 ec 0c             	sub    $0xc,%esp
c0021716:	56                   	push   %esi
c0021717:	e8 f5 6f 00 00       	call   c0028711 <list_begin>
c002171c:	89 c3                	mov    %eax,%ebx
c002171e:	83 c4 10             	add    $0x10,%esp
c0021721:	83 ec 0c             	sub    $0xc,%esp
c0021724:	56                   	push   %esi
c0021725:	e8 5f 70 00 00       	call   c0028789 <list_end>
c002172a:	83 c4 10             	add    $0x10,%esp
c002172d:	39 c3                	cmp    %eax,%ebx
c002172f:	74 1a                	je     c002174b <get_child_by_tid+0x43>
		ch = list_entry(e, struct child_process, elem);
		if (ch->tid == tid)
c0021731:	39 7b f4             	cmp    %edi,-0xc(%ebx)
c0021734:	74 10                	je     c0021746 <get_child_by_tid+0x3e>
	for (struct list_elem *e = list_begin(children); e != list_end(children); e = list_next(e)) {
c0021736:	83 ec 0c             	sub    $0xc,%esp
c0021739:	53                   	push   %ebx
c002173a:	e8 02 70 00 00       	call   c0028741 <list_next>
c002173f:	89 c3                	mov    %eax,%ebx
c0021741:	83 c4 10             	add    $0x10,%esp
c0021744:	eb db                	jmp    c0021721 <get_child_by_tid+0x19>
		ch = list_entry(e, struct child_process, elem);
c0021746:	8d 43 f4             	lea    -0xc(%ebx),%eax
c0021749:	eb 05                	jmp    c0021750 <get_child_by_tid+0x48>
			return ch;
	}
	return NULL;
c002174b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0021750:	5b                   	pop    %ebx
c0021751:	5e                   	pop    %esi
c0021752:	5f                   	pop    %edi
c0021753:	c3                   	ret    

c0021754 <thread_exit>:
{
c0021754:	56                   	push   %esi
c0021755:	53                   	push   %ebx
c0021756:	83 ec 04             	sub    $0x4,%esp
  ASSERT (!intr_context ());
c0021759:	e8 c4 04 00 00       	call   c0021c22 <intr_context>
c002175e:	84 c0                	test   %al,%al
c0021760:	74 21                	je     c0021783 <thread_exit+0x2f>
c0021762:	83 ec 0c             	sub    $0xc,%esp
c0021765:	68 f0 07 03 c0       	push   $0xc00307f0
c002176a:	68 21 01 03 c0       	push   $0xc0030121
c002176f:	68 60 ea 02 c0       	push   $0xc002ea60
c0021774:	68 56 01 00 00       	push   $0x156
c0021779:	68 c0 06 03 c0       	push   $0xc00306c0
c002177e:	e8 a4 6e 00 00       	call   c0028627 <debug_panic>
	enum intr_level old_level = intr_disable();
c0021783:	e8 79 02 00 00       	call   c0021a01 <intr_disable>
c0021788:	89 c6                	mov    %eax,%esi
	struct thread *t = thread_current();
c002178a:	e8 2d f5 ff ff       	call   c0020cbc <thread_current>
c002178f:	89 c3                	mov    %eax,%ebx
	if (t->parent->wait_tid == t->tid) {
c0021791:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c0021797:	8b 53 04             	mov    0x4(%ebx),%edx
c002179a:	39 50 74             	cmp    %edx,0x74(%eax)
c002179d:	74 67                	je     c0021806 <thread_exit+0xb2>
	struct child_process *ch = get_child_by_tid(&t->parent->children, t->tid);
c002179f:	83 ec 08             	sub    $0x8,%esp
c00217a2:	ff 73 04             	pushl  0x4(%ebx)
c00217a5:	8b 83 a4 00 00 00    	mov    0xa4(%ebx),%eax
c00217ab:	05 a8 00 00 00       	add    $0xa8,%eax
c00217b0:	50                   	push   %eax
c00217b1:	e8 52 ff ff ff       	call   c0021708 <get_child_by_tid>
	ch->done = true;
c00217b6:	c6 40 08 01          	movb   $0x1,0x8(%eax)
	intr_set_level(old_level);
c00217ba:	89 34 24             	mov    %esi,(%esp)
c00217bd:	e8 46 02 00 00       	call   c0021a08 <intr_set_level>
  process_exit ();
c00217c2:	e8 5f 8b 00 00       	call   c002a326 <process_exit>
	intr_disable ();
c00217c7:	e8 35 02 00 00       	call   c0021a01 <intr_disable>
	list_remove (&thread_current()->allelem);
c00217cc:	e8 eb f4 ff ff       	call   c0020cbc <thread_current>
c00217d1:	83 c0 54             	add    $0x54,%eax
c00217d4:	89 04 24             	mov    %eax,(%esp)
c00217d7:	e8 5b 73 00 00       	call   c0028b37 <list_remove>
	thread_current ()->status = THREAD_DYING;
c00217dc:	e8 db f4 ff ff       	call   c0020cbc <thread_current>
c00217e1:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	schedule ();
c00217e8:	e8 29 fb ff ff       	call   c0021316 <schedule>
	NOT_REACHED ();
c00217ed:	68 84 08 03 c0       	push   $0xc0030884
c00217f2:	68 60 ea 02 c0       	push   $0xc002ea60
c00217f7:	68 6c 01 00 00       	push   $0x16c
c00217fc:	68 c0 06 03 c0       	push   $0xc00306c0
c0021801:	e8 21 6e 00 00       	call   c0028627 <debug_panic>
		sema_up(&t->parent->wait_sema);
c0021806:	83 ec 0c             	sub    $0xc,%esp
c0021809:	05 8c 00 00 00       	add    $0x8c,%eax
c002180e:	50                   	push   %eax
c002180f:	e8 6a 13 00 00       	call   c0022b7e <sema_up>
c0021814:	83 c4 10             	add    $0x10,%esp
c0021817:	eb 86                	jmp    c002179f <thread_exit+0x4b>

c0021819 <kernel_thread>:
{
c0021819:	53                   	push   %ebx
c002181a:	83 ec 08             	sub    $0x8,%esp
c002181d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (function != NULL);
c0021821:	85 db                	test   %ebx,%ebx
c0021823:	74 13                	je     c0021838 <kernel_thread+0x1f>
  intr_enable ();       /* The scheduler runs with interrupts off. */
c0021825:	e8 a3 01 00 00       	call   c00219cd <intr_enable>
  function (aux);       /* Execute the thread function. */
c002182a:	83 ec 0c             	sub    $0xc,%esp
c002182d:	ff 74 24 20          	pushl  0x20(%esp)
c0021831:	ff d3                	call   *%ebx
  thread_exit ();       /* If function() returns, kill the thread. */
c0021833:	e8 1c ff ff ff       	call   c0021754 <thread_exit>
  ASSERT (function != NULL);
c0021838:	83 ec 0c             	sub    $0xc,%esp
c002183b:	68 01 08 03 c0       	push   $0xc0030801
c0021840:	68 21 01 03 c0       	push   $0xc0030121
c0021845:	68 b4 ea 02 c0       	push   $0xc002eab4
c002184a:	68 66 02 00 00       	push   $0x266
c002184f:	68 c0 06 03 c0       	push   $0xc00306c0
c0021854:	e8 ce 6d 00 00       	call   c0028627 <debug_panic>

c0021859 <thread_init_dir>:
#ifdef FILESYS
void
thread_init_dir () {
c0021859:	53                   	push   %ebx
c002185a:	83 ec 08             	sub    $0x8,%esp
  initial_thread->dir = dir_open_root();
c002185d:	8b 1d 74 b2 03 c0    	mov    0xc003b274,%ebx
c0021863:	e8 da b3 00 00       	call   c002cc42 <dir_open_root>
c0021868:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
}
c002186e:	83 c4 08             	add    $0x8,%esp
c0021871:	5b                   	pop    %ebx
c0021872:	c3                   	ret    

c0021873 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021873:	53                   	push   %ebx
	pushl %ebp
c0021874:	55                   	push   %ebp
	pushl %esi
c0021875:	56                   	push   %esi
	pushl %edi
c0021876:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c0021877:	8b 15 10 ac 03 c0    	mov    0xc003ac10,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c002187d:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021881:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021884:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021888:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c002188b:	5f                   	pop    %edi
	popl %esi
c002188c:	5e                   	pop    %esi
	popl %ebp
c002188d:	5d                   	pop    %ebp
	popl %ebx
c002188e:	5b                   	pop    %ebx
        ret
c002188f:	c3                   	ret    

c0021890 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021890:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021893:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021894:	e8 e1 f9 ff ff       	call   c002127a <thread_schedule_tail>
	addl $4, %esp
c0021899:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c002189c:	c3                   	ret    

c002189d <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c002189d:	83 ec 0c             	sub    $0xc,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00218a0:	85 c0                	test   %eax,%eax
c00218a2:	74 2b                	je     c00218cf <make_gate+0x32>
  ASSERT (dpl >= 0 && dpl <= 3);
c00218a4:	83 fa 03             	cmp    $0x3,%edx
c00218a7:	77 47                	ja     c00218f0 <make_gate+0x53>
  ASSERT (type >= 0 && type <= 15);
c00218a9:	83 f9 0f             	cmp    $0xf,%ecx
c00218ac:	77 63                	ja     c0021911 <make_gate+0x74>

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c00218ae:	c1 e1 08             	shl    $0x8,%ecx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00218b1:	80 cd 80             	or     $0x80,%ch
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c00218b4:	c1 e2 0d             	shl    $0xd,%edx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00218b7:	09 ca                	or     %ecx,%edx
c00218b9:	89 c1                	mov    %eax,%ecx
c00218bb:	81 e1 00 00 ff ff    	and    $0xffff0000,%ecx
c00218c1:	09 ca                	or     %ecx,%edx
  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c00218c3:	0f b7 c0             	movzwl %ax,%eax
c00218c6:	0d 00 00 08 00       	or     $0x80000,%eax

  return e0 | ((uint64_t) e1 << 32);
}
c00218cb:	83 c4 0c             	add    $0xc,%esp
c00218ce:	c3                   	ret    
  ASSERT (function != NULL);
c00218cf:	83 ec 0c             	sub    $0xc,%esp
c00218d2:	68 01 08 03 c0       	push   $0xc0030801
c00218d7:	68 21 01 03 c0       	push   $0xc0030121
c00218dc:	68 68 eb 02 c0       	push   $0xc002eb68
c00218e1:	68 2a 01 00 00       	push   $0x12a
c00218e6:	68 a6 08 03 c0       	push   $0xc00308a6
c00218eb:	e8 37 6d 00 00       	call   c0028627 <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c00218f0:	83 ec 0c             	sub    $0xc,%esp
c00218f3:	68 c0 08 03 c0       	push   $0xc00308c0
c00218f8:	68 21 01 03 c0       	push   $0xc0030121
c00218fd:	68 68 eb 02 c0       	push   $0xc002eb68
c0021902:	68 2b 01 00 00       	push   $0x12b
c0021907:	68 a6 08 03 c0       	push   $0xc00308a6
c002190c:	e8 16 6d 00 00       	call   c0028627 <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021911:	83 ec 0c             	sub    $0xc,%esp
c0021914:	68 d5 08 03 c0       	push   $0xc00308d5
c0021919:	68 21 01 03 c0       	push   $0xc0030121
c002191e:	68 68 eb 02 c0       	push   $0xc002eb68
c0021923:	68 2c 01 00 00       	push   $0x12c
c0021928:	68 a6 08 03 c0       	push   $0xc00308a6
c002192d:	e8 f5 6c 00 00       	call   c0028627 <debug_panic>

c0021932 <register_handler>:
{
c0021932:	53                   	push   %ebx
c0021933:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_handlers[vec_no] == NULL);
c0021936:	0f b6 d8             	movzbl %al,%ebx
c0021939:	83 3c 9d c0 ba 03 c0 	cmpl   $0x0,-0x3ffc4540(,%ebx,4)
c0021940:	00 
c0021941:	75 3f                	jne    c0021982 <register_handler+0x50>
  if (level == INTR_ON)
c0021943:	83 f9 01             	cmp    $0x1,%ecx
c0021946:	74 5b                	je     c00219a3 <register_handler+0x71>
/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 14);
c0021948:	8b 04 9d 14 ac 03 c0 	mov    -0x3ffc53ec(,%ebx,4),%eax
c002194f:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021954:	e8 44 ff ff ff       	call   c002189d <make_gate>
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021959:	89 04 dd c0 be 03 c0 	mov    %eax,-0x3ffc4140(,%ebx,8)
c0021960:	89 14 dd c4 be 03 c0 	mov    %edx,-0x3ffc413c(,%ebx,8)
  intr_handlers[vec_no] = handler;
c0021967:	8b 44 24 10          	mov    0x10(%esp),%eax
c002196b:	89 04 9d c0 ba 03 c0 	mov    %eax,-0x3ffc4540(,%ebx,4)
  intr_names[vec_no] = name;
c0021972:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021976:	89 04 9d c0 b6 03 c0 	mov    %eax,-0x3ffc4940(,%ebx,4)
}
c002197d:	83 c4 08             	add    $0x8,%esp
c0021980:	5b                   	pop    %ebx
c0021981:	c3                   	ret    
  ASSERT (intr_handlers[vec_no] == NULL);
c0021982:	83 ec 0c             	sub    $0xc,%esp
c0021985:	68 ed 08 03 c0       	push   $0xc00308ed
c002198a:	68 21 01 03 c0       	push   $0xc0030121
c002198f:	68 40 eb 02 c0       	push   $0xc002eb40
c0021994:	68 a8 00 00 00       	push   $0xa8
c0021999:	68 a6 08 03 c0       	push   $0xc00308a6
c002199e:	e8 84 6c 00 00       	call   c0028627 <debug_panic>
/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 15);
c00219a3:	8b 04 9d 14 ac 03 c0 	mov    -0x3ffc53ec(,%ebx,4),%eax
c00219aa:	b9 0f 00 00 00       	mov    $0xf,%ecx
c00219af:	e8 e9 fe ff ff       	call   c002189d <make_gate>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c00219b4:	89 04 dd c0 be 03 c0 	mov    %eax,-0x3ffc4140(,%ebx,8)
c00219bb:	89 14 dd c4 be 03 c0 	mov    %edx,-0x3ffc413c(,%ebx,8)
c00219c2:	eb a3                	jmp    c0021967 <register_handler+0x35>

c00219c4 <intr_get_level>:
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c00219c4:	9c                   	pushf  
c00219c5:	58                   	pop    %eax
  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c00219c6:	c1 e8 09             	shr    $0x9,%eax
c00219c9:	83 e0 01             	and    $0x1,%eax
}
c00219cc:	c3                   	ret    

c00219cd <intr_enable>:
{
c00219cd:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_get_level ();
c00219d0:	e8 ef ff ff ff       	call   c00219c4 <intr_get_level>
  ASSERT (!intr_context ());
c00219d5:	80 3d a1 b2 03 c0 00 	cmpb   $0x0,0xc003b2a1
c00219dc:	75 05                	jne    c00219e3 <intr_enable+0x16>
  asm volatile ("sti");
c00219de:	fb                   	sti    
}
c00219df:	83 c4 0c             	add    $0xc,%esp
c00219e2:	c3                   	ret    
  ASSERT (!intr_context ());
c00219e3:	83 ec 0c             	sub    $0xc,%esp
c00219e6:	68 f0 07 03 c0       	push   $0xc00307f0
c00219eb:	68 21 01 03 c0       	push   $0xc0030121
c00219f0:	68 74 eb 02 c0       	push   $0xc002eb74
c00219f5:	6a 5b                	push   $0x5b
c00219f7:	68 a6 08 03 c0       	push   $0xc00308a6
c00219fc:	e8 26 6c 00 00       	call   c0028627 <debug_panic>

c0021a01 <intr_disable>:
  enum intr_level old_level = intr_get_level ();
c0021a01:	e8 be ff ff ff       	call   c00219c4 <intr_get_level>
  asm volatile ("cli" : : : "memory");
c0021a06:	fa                   	cli    
}
c0021a07:	c3                   	ret    

c0021a08 <intr_set_level>:
{
c0021a08:	83 ec 0c             	sub    $0xc,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021a0b:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021a10:	74 09                	je     c0021a1b <intr_set_level+0x13>
c0021a12:	e8 ea ff ff ff       	call   c0021a01 <intr_disable>
}
c0021a17:	83 c4 0c             	add    $0xc,%esp
c0021a1a:	c3                   	ret    
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021a1b:	e8 ad ff ff ff       	call   c00219cd <intr_enable>
c0021a20:	eb f5                	jmp    c0021a17 <intr_set_level+0xf>

c0021a22 <intr_init>:
{
c0021a22:	53                   	push   %ebx
c0021a23:	83 ec 18             	sub    $0x18,%esp
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021a26:	b0 ff                	mov    $0xff,%al
c0021a28:	e6 21                	out    %al,$0x21
c0021a2a:	e6 a1                	out    %al,$0xa1
c0021a2c:	b0 11                	mov    $0x11,%al
c0021a2e:	e6 20                	out    %al,$0x20
c0021a30:	b0 20                	mov    $0x20,%al
c0021a32:	e6 21                	out    %al,$0x21
c0021a34:	b0 04                	mov    $0x4,%al
c0021a36:	e6 21                	out    %al,$0x21
c0021a38:	b0 01                	mov    $0x1,%al
c0021a3a:	e6 21                	out    %al,$0x21
c0021a3c:	b0 11                	mov    $0x11,%al
c0021a3e:	e6 a0                	out    %al,$0xa0
c0021a40:	b0 28                	mov    $0x28,%al
c0021a42:	e6 a1                	out    %al,$0xa1
c0021a44:	b0 02                	mov    $0x2,%al
c0021a46:	e6 a1                	out    %al,$0xa1
c0021a48:	b0 01                	mov    $0x1,%al
c0021a4a:	e6 a1                	out    %al,$0xa1
c0021a4c:	b0 00                	mov    $0x0,%al
c0021a4e:	e6 21                	out    %al,$0x21
c0021a50:	e6 a1                	out    %al,$0xa1
c0021a52:	bb 00 00 00 00       	mov    $0x0,%ebx
  return make_gate (function, dpl, 14);
c0021a57:	8b 83 14 ac 03 c0    	mov    -0x3ffc53ec(%ebx),%eax
c0021a5d:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021a62:	ba 00 00 00 00       	mov    $0x0,%edx
c0021a67:	e8 31 fe ff ff       	call   c002189d <make_gate>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021a6c:	89 84 1b c0 be 03 c0 	mov    %eax,-0x3ffc4140(%ebx,%ebx,1)
c0021a73:	89 94 1b c4 be 03 c0 	mov    %edx,-0x3ffc413c(%ebx,%ebx,1)
c0021a7a:	83 c3 04             	add    $0x4,%ebx
  for (i = 0; i < INTR_CNT; i++)
c0021a7d:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
c0021a83:	75 d2                	jne    c0021a57 <intr_init+0x35>
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021a85:	b8 c0 be 03 c0       	mov    $0xc003bec0,%eax
c0021a8a:	ba 00 00 00 00       	mov    $0x0,%edx
c0021a8f:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021a93:	c1 e0 10             	shl    $0x10,%eax
c0021a96:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021a9b:	89 44 24 08          	mov    %eax,0x8(%esp)
c0021a9f:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021aa3:	0f 01 5c 24 08       	lidtl  0x8(%esp)
c0021aa8:	b8 c0 b6 03 c0       	mov    $0xc003b6c0,%eax
c0021aad:	ba c0 ba 03 c0       	mov    $0xc003bac0,%edx
    intr_names[i] = "unknown";
c0021ab2:	c7 00 0b 09 03 c0    	movl   $0xc003090b,(%eax)
c0021ab8:	83 c0 04             	add    $0x4,%eax
  for (i = 0; i < INTR_CNT; i++)
c0021abb:	39 c2                	cmp    %eax,%edx
c0021abd:	75 f3                	jne    c0021ab2 <intr_init+0x90>
  intr_names[0] = "#DE Divide Error";
c0021abf:	c7 05 c0 b6 03 c0 13 	movl   $0xc0030913,0xc003b6c0
c0021ac6:	09 03 c0 
  intr_names[1] = "#DB Debug Exception";
c0021ac9:	c7 05 c4 b6 03 c0 24 	movl   $0xc0030924,0xc003b6c4
c0021ad0:	09 03 c0 
  intr_names[2] = "NMI Interrupt";
c0021ad3:	c7 05 c8 b6 03 c0 38 	movl   $0xc0030938,0xc003b6c8
c0021ada:	09 03 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c0021add:	c7 05 cc b6 03 c0 46 	movl   $0xc0030946,0xc003b6cc
c0021ae4:	09 03 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021ae7:	c7 05 d0 b6 03 c0 5f 	movl   $0xc003095f,0xc003b6d0
c0021aee:	09 03 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021af1:	c7 05 d4 b6 03 c0 9c 	movl   $0xc0030a9c,0xc003b6d4
c0021af8:	0a 03 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021afb:	c7 05 d8 b6 03 c0 76 	movl   $0xc0030976,0xc003b6d8
c0021b02:	09 03 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c0021b05:	c7 05 dc b6 03 c0 c0 	movl   $0xc0030ac0,0xc003b6dc
c0021b0c:	0a 03 c0 
  intr_names[8] = "#DF Double Fault Exception";
c0021b0f:	c7 05 e0 b6 03 c0 93 	movl   $0xc0030993,0xc003b6e0
c0021b16:	09 03 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c0021b19:	c7 05 e4 b6 03 c0 ae 	movl   $0xc00309ae,0xc003b6e4
c0021b20:	09 03 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c0021b23:	c7 05 e8 b6 03 c0 ca 	movl   $0xc00309ca,0xc003b6e8
c0021b2a:	09 03 c0 
  intr_names[11] = "#NP Segment Not Present";
c0021b2d:	c7 05 ec b6 03 c0 e4 	movl   $0xc00309e4,0xc003b6ec
c0021b34:	09 03 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c0021b37:	c7 05 f0 b6 03 c0 fc 	movl   $0xc00309fc,0xc003b6f0
c0021b3e:	09 03 c0 
  intr_names[13] = "#GP General Protection Exception";
c0021b41:	c7 05 f4 b6 03 c0 e4 	movl   $0xc0030ae4,0xc003b6f4
c0021b48:	0a 03 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c0021b4b:	c7 05 f8 b6 03 c0 16 	movl   $0xc0030a16,0xc003b6f8
c0021b52:	0a 03 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021b55:	c7 05 00 b7 03 c0 08 	movl   $0xc0030b08,0xc003b700
c0021b5c:	0b 03 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c0021b5f:	c7 05 04 b7 03 c0 2f 	movl   $0xc0030a2f,0xc003b704
c0021b66:	0a 03 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c0021b69:	c7 05 08 b7 03 c0 4d 	movl   $0xc0030a4d,0xc003b708
c0021b70:	0a 03 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021b73:	c7 05 0c b7 03 c0 2c 	movl   $0xc0030b2c,0xc003b70c
c0021b7a:	0b 03 c0 
}
c0021b7d:	83 c4 18             	add    $0x18,%esp
c0021b80:	5b                   	pop    %ebx
c0021b81:	c3                   	ret    

c0021b82 <intr_register_ext>:
{
c0021b82:	83 ec 0c             	sub    $0xc,%esp
c0021b85:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021b89:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021b8c:	80 fa 0f             	cmp    $0xf,%dl
c0021b8f:	77 21                	ja     c0021bb2 <intr_register_ext+0x30>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021b91:	0f b6 c0             	movzbl %al,%eax
c0021b94:	83 ec 08             	sub    $0x8,%esp
c0021b97:	ff 74 24 20          	pushl  0x20(%esp)
c0021b9b:	ff 74 24 20          	pushl  0x20(%esp)
c0021b9f:	b9 00 00 00 00       	mov    $0x0,%ecx
c0021ba4:	ba 00 00 00 00       	mov    $0x0,%edx
c0021ba9:	e8 84 fd ff ff       	call   c0021932 <register_handler>
}
c0021bae:	83 c4 1c             	add    $0x1c,%esp
c0021bb1:	c3                   	ret    
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021bb2:	83 ec 0c             	sub    $0xc,%esp
c0021bb5:	68 50 0b 03 c0       	push   $0xc0030b50
c0021bba:	68 21 01 03 c0       	push   $0xc0030121
c0021bbf:	68 54 eb 02 c0       	push   $0xc002eb54
c0021bc4:	68 b8 00 00 00       	push   $0xb8
c0021bc9:	68 a6 08 03 c0       	push   $0xc00308a6
c0021bce:	e8 54 6a 00 00       	call   c0028627 <debug_panic>

c0021bd3 <intr_register_int>:
{
c0021bd3:	83 ec 0c             	sub    $0xc,%esp
c0021bd6:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021bda:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021bdd:	80 fa 0f             	cmp    $0xf,%dl
c0021be0:	76 1f                	jbe    c0021c01 <intr_register_int+0x2e>
  register_handler (vec_no, dpl, level, handler, name);
c0021be2:	0f b6 c0             	movzbl %al,%eax
c0021be5:	83 ec 08             	sub    $0x8,%esp
c0021be8:	ff 74 24 28          	pushl  0x28(%esp)
c0021bec:	ff 74 24 28          	pushl  0x28(%esp)
c0021bf0:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0021bf4:	8b 54 24 24          	mov    0x24(%esp),%edx
c0021bf8:	e8 35 fd ff ff       	call   c0021932 <register_handler>
}
c0021bfd:	83 c4 1c             	add    $0x1c,%esp
c0021c00:	c3                   	ret    
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021c01:	83 ec 0c             	sub    $0xc,%esp
c0021c04:	68 74 0b 03 c0       	push   $0xc0030b74
c0021c09:	68 21 01 03 c0       	push   $0xc0030121
c0021c0e:	68 2c eb 02 c0       	push   $0xc002eb2c
c0021c13:	68 cd 00 00 00       	push   $0xcd
c0021c18:	68 a6 08 03 c0       	push   $0xc00308a6
c0021c1d:	e8 05 6a 00 00       	call   c0028627 <debug_panic>

c0021c22 <intr_context>:
}
c0021c22:	a0 a1 b2 03 c0       	mov    0xc003b2a1,%al
c0021c27:	c3                   	ret    

c0021c28 <intr_yield_on_return>:
  ASSERT (intr_context ());
c0021c28:	80 3d a1 b2 03 c0 00 	cmpb   $0x0,0xc003b2a1
c0021c2f:	74 08                	je     c0021c39 <intr_yield_on_return+0x11>
  yield_on_return = true;
c0021c31:	c6 05 a0 b2 03 c0 01 	movb   $0x1,0xc003b2a0
c0021c38:	c3                   	ret    
{
c0021c39:	83 ec 18             	sub    $0x18,%esp
  ASSERT (intr_context ());
c0021c3c:	68 f1 07 03 c0       	push   $0xc00307f1
c0021c41:	68 21 01 03 c0       	push   $0xc0030121
c0021c46:	68 14 eb 02 c0       	push   $0xc002eb14
c0021c4b:	68 e0 00 00 00       	push   $0xe0
c0021c50:	68 a6 08 03 c0       	push   $0xc00308a6
c0021c55:	e8 cd 69 00 00       	call   c0028627 <debug_panic>

c0021c5a <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021c5a:	56                   	push   %esi
c0021c5b:	53                   	push   %ebx
c0021c5c:	83 ec 04             	sub    $0x4,%esp
c0021c5f:	8b 74 24 10          	mov    0x10(%esp),%esi

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021c63:	8b 46 30             	mov    0x30(%esi),%eax
c0021c66:	8d 58 e0             	lea    -0x20(%eax),%ebx
  if (external) 
c0021c69:	83 fb 0f             	cmp    $0xf,%ebx
c0021c6c:	76 26                	jbe    c0021c94 <intr_handler+0x3a>
	else
    thread_current()->esp = frame->esp;
#endif

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021c6e:	8b 56 30             	mov    0x30(%esi),%edx
c0021c71:	8b 04 95 c0 ba 03 c0 	mov    -0x3ffc4540(,%edx,4),%eax
  if (handler != NULL)
c0021c78:	85 c0                	test   %eax,%eax
c0021c7a:	74 7c                	je     c0021cf8 <intr_handler+0x9e>
    handler (frame);
c0021c7c:	83 ec 0c             	sub    $0xc,%esp
c0021c7f:	56                   	push   %esi
c0021c80:	ff d0                	call   *%eax
c0021c82:	83 c4 10             	add    $0x10,%esp
    }
  else
    unexpected_interrupt (frame);

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021c85:	83 fb 0f             	cmp    $0xf,%ebx
c0021c88:	0f 86 aa 00 00 00    	jbe    c0021d38 <intr_handler+0xde>
      pic_end_of_interrupt (frame->vec_no); 

      if (yield_on_return) 
        thread_yield (); 
    }
}
c0021c8e:	83 c4 04             	add    $0x4,%esp
c0021c91:	5b                   	pop    %ebx
c0021c92:	5e                   	pop    %esi
c0021c93:	c3                   	ret    
      ASSERT (intr_get_level () == INTR_OFF);
c0021c94:	e8 2b fd ff ff       	call   c00219c4 <intr_get_level>
c0021c99:	85 c0                	test   %eax,%eax
c0021c9b:	75 19                	jne    c0021cb6 <intr_handler+0x5c>
      ASSERT (!intr_context ());
c0021c9d:	80 3d a1 b2 03 c0 00 	cmpb   $0x0,0xc003b2a1
c0021ca4:	75 31                	jne    c0021cd7 <intr_handler+0x7d>
      in_external_intr = true;
c0021ca6:	c6 05 a1 b2 03 c0 01 	movb   $0x1,0xc003b2a1
      yield_on_return = false;
c0021cad:	c6 05 a0 b2 03 c0 00 	movb   $0x0,0xc003b2a0
c0021cb4:	eb b8                	jmp    c0021c6e <intr_handler+0x14>
      ASSERT (intr_get_level () == INTR_OFF);
c0021cb6:	83 ec 0c             	sub    $0xc,%esp
c0021cb9:	68 26 07 03 c0       	push   $0xc0030726
c0021cbe:	68 21 01 03 c0       	push   $0xc0030121
c0021cc3:	68 04 eb 02 c0       	push   $0xc002eb04
c0021cc8:	68 65 01 00 00       	push   $0x165
c0021ccd:	68 a6 08 03 c0       	push   $0xc00308a6
c0021cd2:	e8 50 69 00 00       	call   c0028627 <debug_panic>
      ASSERT (!intr_context ());
c0021cd7:	83 ec 0c             	sub    $0xc,%esp
c0021cda:	68 f0 07 03 c0       	push   $0xc00307f0
c0021cdf:	68 21 01 03 c0       	push   $0xc0030121
c0021ce4:	68 04 eb 02 c0       	push   $0xc002eb04
c0021ce9:	68 66 01 00 00       	push   $0x166
c0021cee:	68 a6 08 03 c0       	push   $0xc00308a6
c0021cf3:	e8 2f 69 00 00       	call   c0028627 <debug_panic>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021cf8:	89 d0                	mov    %edx,%eax
c0021cfa:	83 e0 f7             	and    $0xfffffff7,%eax
c0021cfd:	83 f8 27             	cmp    $0x27,%eax
c0021d00:	74 83                	je     c0021c85 <intr_handler+0x2b>
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021d02:	8b 0c 95 c0 b2 03 c0 	mov    -0x3ffc4d40(,%edx,4),%ecx
c0021d09:	8d 41 01             	lea    0x1(%ecx),%eax
c0021d0c:	89 04 95 c0 b2 03 c0 	mov    %eax,-0x3ffc4d40(,%edx,4)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021d13:	85 c1                	test   %eax,%ecx
c0021d15:	0f 85 6a ff ff ff    	jne    c0021c85 <intr_handler+0x2b>
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021d1b:	83 ec 04             	sub    $0x4,%esp
c0021d1e:	ff 34 95 c0 b6 03 c0 	pushl  -0x3ffc4940(,%edx,4)
c0021d25:	52                   	push   %edx
c0021d26:	68 94 0b 03 c0       	push   $0xc0030b94
c0021d2b:	e8 49 4e 00 00       	call   c0026b79 <printf>
c0021d30:	83 c4 10             	add    $0x10,%esp
c0021d33:	e9 4d ff ff ff       	jmp    c0021c85 <intr_handler+0x2b>
      ASSERT (intr_get_level () == INTR_OFF);
c0021d38:	e8 87 fc ff ff       	call   c00219c4 <intr_get_level>
c0021d3d:	85 c0                	test   %eax,%eax
c0021d3f:	75 3d                	jne    c0021d7e <intr_handler+0x124>
      ASSERT (intr_context ());
c0021d41:	80 3d a1 b2 03 c0 00 	cmpb   $0x0,0xc003b2a1
c0021d48:	74 55                	je     c0021d9f <intr_handler+0x145>
      in_external_intr = false;
c0021d4a:	c6 05 a1 b2 03 c0 00 	movb   $0x0,0xc003b2a1
      pic_end_of_interrupt (frame->vec_no); 
c0021d51:	8b 56 30             	mov    0x30(%esi),%edx
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021d54:	8d 42 e0             	lea    -0x20(%edx),%eax
c0021d57:	83 f8 0f             	cmp    $0xf,%eax
c0021d5a:	77 64                	ja     c0021dc0 <intr_handler+0x166>
c0021d5c:	b0 20                	mov    $0x20,%al
c0021d5e:	e6 20                	out    %al,$0x20
  if (irq >= 0x28)
c0021d60:	83 fa 27             	cmp    $0x27,%edx
c0021d63:	7e 02                	jle    c0021d67 <intr_handler+0x10d>
c0021d65:	e6 a0                	out    %al,$0xa0
      if (yield_on_return) 
c0021d67:	80 3d a0 b2 03 c0 00 	cmpb   $0x0,0xc003b2a0
c0021d6e:	0f 84 1a ff ff ff    	je     c0021c8e <intr_handler+0x34>
        thread_yield (); 
c0021d74:	e8 1a f7 ff ff       	call   c0021493 <thread_yield>
}
c0021d79:	e9 10 ff ff ff       	jmp    c0021c8e <intr_handler+0x34>
      ASSERT (intr_get_level () == INTR_OFF);
c0021d7e:	83 ec 0c             	sub    $0xc,%esp
c0021d81:	68 26 07 03 c0       	push   $0xc0030726
c0021d86:	68 21 01 03 c0       	push   $0xc0030121
c0021d8b:	68 04 eb 02 c0       	push   $0xc002eb04
c0021d90:	68 80 01 00 00       	push   $0x180
c0021d95:	68 a6 08 03 c0       	push   $0xc00308a6
c0021d9a:	e8 88 68 00 00       	call   c0028627 <debug_panic>
      ASSERT (intr_context ());
c0021d9f:	83 ec 0c             	sub    $0xc,%esp
c0021da2:	68 f1 07 03 c0       	push   $0xc00307f1
c0021da7:	68 21 01 03 c0       	push   $0xc0030121
c0021dac:	68 04 eb 02 c0       	push   $0xc002eb04
c0021db1:	68 81 01 00 00       	push   $0x181
c0021db6:	68 a6 08 03 c0       	push   $0xc00308a6
c0021dbb:	e8 67 68 00 00       	call   c0028627 <debug_panic>
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021dc0:	83 ec 0c             	sub    $0xc,%esp
c0021dc3:	68 69 0a 03 c0       	push   $0xc0030a69
c0021dc8:	68 21 01 03 c0       	push   $0xc0030121
c0021dcd:	68 ec ea 02 c0       	push   $0xc002eaec
c0021dd2:	68 0b 01 00 00       	push   $0x10b
c0021dd7:	68 a6 08 03 c0       	push   $0xc00308a6
c0021ddc:	e8 46 68 00 00       	call   c0028627 <debug_panic>

c0021de1 <intr_dump_frame>:
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021de1:	56                   	push   %esi
c0021de2:	53                   	push   %ebx
c0021de3:	83 ec 04             	sub    $0x4,%esp
c0021de6:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021dea:	0f 20 d6             	mov    %cr2,%esi

  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021ded:	8b 43 30             	mov    0x30(%ebx),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021df0:	ff 73 3c             	pushl  0x3c(%ebx)
c0021df3:	ff 34 85 c0 b6 03 c0 	pushl  -0x3ffc4940(,%eax,4)
c0021dfa:	50                   	push   %eax
c0021dfb:	68 b8 0b 03 c0       	push   $0xc0030bb8
c0021e00:	e8 74 4d 00 00       	call   c0026b79 <printf>
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021e05:	83 c4 0c             	add    $0xc,%esp
c0021e08:	ff 73 34             	pushl  0x34(%ebx)
c0021e0b:	56                   	push   %esi
c0021e0c:	68 83 0a 03 c0       	push   $0xc0030a83
c0021e11:	e8 63 4d 00 00       	call   c0026b79 <printf>
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021e16:	83 c4 04             	add    $0x4,%esp
c0021e19:	ff 73 14             	pushl  0x14(%ebx)
c0021e1c:	ff 73 18             	pushl  0x18(%ebx)
c0021e1f:	ff 73 10             	pushl  0x10(%ebx)
c0021e22:	ff 73 1c             	pushl  0x1c(%ebx)
c0021e25:	68 d8 0b 03 c0       	push   $0xc0030bd8
c0021e2a:	e8 4a 4d 00 00       	call   c0026b79 <printf>
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021e2f:	83 c4 14             	add    $0x14,%esp
c0021e32:	ff 73 08             	pushl  0x8(%ebx)
c0021e35:	ff 73 48             	pushl  0x48(%ebx)
c0021e38:	ff 33                	pushl  (%ebx)
c0021e3a:	ff 73 04             	pushl  0x4(%ebx)
c0021e3d:	68 00 0c 03 c0       	push   $0xc0030c00
c0021e42:	e8 32 4d 00 00       	call   c0026b79 <printf>
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021e47:	83 c4 14             	add    $0x14,%esp
c0021e4a:	0f b7 43 4c          	movzwl 0x4c(%ebx),%eax
c0021e4e:	50                   	push   %eax
c0021e4f:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
c0021e53:	50                   	push   %eax
c0021e54:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
c0021e58:	50                   	push   %eax
c0021e59:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
c0021e5d:	50                   	push   %eax
c0021e5e:	68 28 0c 03 c0       	push   $0xc0030c28
c0021e63:	e8 11 4d 00 00       	call   c0026b79 <printf>
          f->cs, f->ds, f->es, f->ss);
}
c0021e68:	83 c4 24             	add    $0x24,%esp
c0021e6b:	5b                   	pop    %ebx
c0021e6c:	5e                   	pop    %esi
c0021e6d:	c3                   	ret    

c0021e6e <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
  return intr_names[vec];
c0021e6e:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0021e73:	8b 04 85 c0 b6 03 c0 	mov    -0x3ffc4940(,%eax,4),%eax
}
c0021e7a:	c3                   	ret    

c0021e7b <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021e7b:	1e                   	push   %ds
	pushl %es
c0021e7c:	06                   	push   %es
	pushl %fs
c0021e7d:	0f a0                	push   %fs
	pushl %gs
c0021e7f:	0f a8                	push   %gs
	pushal
c0021e81:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021e82:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021e83:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021e88:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021e8a:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021e8c:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021e90:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021e91:	e8 c4 fd ff ff       	call   c0021c5a <intr_handler>
	addl $4, %esp
c0021e96:	83 c4 04             	add    $0x4,%esp

c0021e99 <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021e99:	61                   	popa   
	popl %gs
c0021e9a:	0f a9                	pop    %gs
	popl %fs
c0021e9c:	0f a1                	pop    %fs
	popl %es
c0021e9e:	07                   	pop    %es
	popl %ds
c0021e9f:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021ea0:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021ea3:	cf                   	iret   

c0021ea4 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021ea4:	55                   	push   %ebp
c0021ea5:	6a 00                	push   $0x0
c0021ea7:	6a 00                	push   $0x0
c0021ea9:	eb d0                	jmp    c0021e7b <intr_entry>

c0021eab <intr01_stub>:
c0021eab:	55                   	push   %ebp
c0021eac:	6a 00                	push   $0x0
c0021eae:	6a 01                	push   $0x1
c0021eb0:	eb c9                	jmp    c0021e7b <intr_entry>

c0021eb2 <intr02_stub>:
c0021eb2:	55                   	push   %ebp
c0021eb3:	6a 00                	push   $0x0
c0021eb5:	6a 02                	push   $0x2
c0021eb7:	eb c2                	jmp    c0021e7b <intr_entry>

c0021eb9 <intr03_stub>:
c0021eb9:	55                   	push   %ebp
c0021eba:	6a 00                	push   $0x0
c0021ebc:	6a 03                	push   $0x3
c0021ebe:	eb bb                	jmp    c0021e7b <intr_entry>

c0021ec0 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021ec0:	55                   	push   %ebp
c0021ec1:	6a 00                	push   $0x0
c0021ec3:	6a 04                	push   $0x4
c0021ec5:	eb b4                	jmp    c0021e7b <intr_entry>

c0021ec7 <intr05_stub>:
c0021ec7:	55                   	push   %ebp
c0021ec8:	6a 00                	push   $0x0
c0021eca:	6a 05                	push   $0x5
c0021ecc:	eb ad                	jmp    c0021e7b <intr_entry>

c0021ece <intr06_stub>:
c0021ece:	55                   	push   %ebp
c0021ecf:	6a 00                	push   $0x0
c0021ed1:	6a 06                	push   $0x6
c0021ed3:	eb a6                	jmp    c0021e7b <intr_entry>

c0021ed5 <intr07_stub>:
c0021ed5:	55                   	push   %ebp
c0021ed6:	6a 00                	push   $0x0
c0021ed8:	6a 07                	push   $0x7
c0021eda:	eb 9f                	jmp    c0021e7b <intr_entry>

c0021edc <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021edc:	ff 34 24             	pushl  (%esp)
c0021edf:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021ee3:	6a 08                	push   $0x8
c0021ee5:	eb 94                	jmp    c0021e7b <intr_entry>

c0021ee7 <intr09_stub>:
c0021ee7:	55                   	push   %ebp
c0021ee8:	6a 00                	push   $0x0
c0021eea:	6a 09                	push   $0x9
c0021eec:	eb 8d                	jmp    c0021e7b <intr_entry>

c0021eee <intr0a_stub>:
c0021eee:	ff 34 24             	pushl  (%esp)
c0021ef1:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021ef5:	6a 0a                	push   $0xa
c0021ef7:	eb 82                	jmp    c0021e7b <intr_entry>

c0021ef9 <intr0b_stub>:
c0021ef9:	ff 34 24             	pushl  (%esp)
c0021efc:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f00:	6a 0b                	push   $0xb
c0021f02:	e9 74 ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f07 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021f07:	55                   	push   %ebp
c0021f08:	6a 00                	push   $0x0
c0021f0a:	6a 0c                	push   $0xc
c0021f0c:	e9 6a ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f11 <intr0d_stub>:
c0021f11:	ff 34 24             	pushl  (%esp)
c0021f14:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f18:	6a 0d                	push   $0xd
c0021f1a:	e9 5c ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f1f <intr0e_stub>:
c0021f1f:	ff 34 24             	pushl  (%esp)
c0021f22:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f26:	6a 0e                	push   $0xe
c0021f28:	e9 4e ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f2d <intr0f_stub>:
c0021f2d:	55                   	push   %ebp
c0021f2e:	6a 00                	push   $0x0
c0021f30:	6a 0f                	push   $0xf
c0021f32:	e9 44 ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f37 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021f37:	55                   	push   %ebp
c0021f38:	6a 00                	push   $0x0
c0021f3a:	6a 10                	push   $0x10
c0021f3c:	e9 3a ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f41 <intr11_stub>:
c0021f41:	ff 34 24             	pushl  (%esp)
c0021f44:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f48:	6a 11                	push   $0x11
c0021f4a:	e9 2c ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f4f <intr12_stub>:
c0021f4f:	55                   	push   %ebp
c0021f50:	6a 00                	push   $0x0
c0021f52:	6a 12                	push   $0x12
c0021f54:	e9 22 ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f59 <intr13_stub>:
c0021f59:	55                   	push   %ebp
c0021f5a:	6a 00                	push   $0x0
c0021f5c:	6a 13                	push   $0x13
c0021f5e:	e9 18 ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f63 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021f63:	55                   	push   %ebp
c0021f64:	6a 00                	push   $0x0
c0021f66:	6a 14                	push   $0x14
c0021f68:	e9 0e ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f6d <intr15_stub>:
c0021f6d:	55                   	push   %ebp
c0021f6e:	6a 00                	push   $0x0
c0021f70:	6a 15                	push   $0x15
c0021f72:	e9 04 ff ff ff       	jmp    c0021e7b <intr_entry>

c0021f77 <intr16_stub>:
c0021f77:	55                   	push   %ebp
c0021f78:	6a 00                	push   $0x0
c0021f7a:	6a 16                	push   $0x16
c0021f7c:	e9 fa fe ff ff       	jmp    c0021e7b <intr_entry>

c0021f81 <intr17_stub>:
c0021f81:	55                   	push   %ebp
c0021f82:	6a 00                	push   $0x0
c0021f84:	6a 17                	push   $0x17
c0021f86:	e9 f0 fe ff ff       	jmp    c0021e7b <intr_entry>

c0021f8b <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021f8b:	ff 34 24             	pushl  (%esp)
c0021f8e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f92:	6a 18                	push   $0x18
c0021f94:	e9 e2 fe ff ff       	jmp    c0021e7b <intr_entry>

c0021f99 <intr19_stub>:
c0021f99:	55                   	push   %ebp
c0021f9a:	6a 00                	push   $0x0
c0021f9c:	6a 19                	push   $0x19
c0021f9e:	e9 d8 fe ff ff       	jmp    c0021e7b <intr_entry>

c0021fa3 <intr1a_stub>:
c0021fa3:	ff 34 24             	pushl  (%esp)
c0021fa6:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021faa:	6a 1a                	push   $0x1a
c0021fac:	e9 ca fe ff ff       	jmp    c0021e7b <intr_entry>

c0021fb1 <intr1b_stub>:
c0021fb1:	ff 34 24             	pushl  (%esp)
c0021fb4:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021fb8:	6a 1b                	push   $0x1b
c0021fba:	e9 bc fe ff ff       	jmp    c0021e7b <intr_entry>

c0021fbf <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0021fbf:	55                   	push   %ebp
c0021fc0:	6a 00                	push   $0x0
c0021fc2:	6a 1c                	push   $0x1c
c0021fc4:	e9 b2 fe ff ff       	jmp    c0021e7b <intr_entry>

c0021fc9 <intr1d_stub>:
c0021fc9:	ff 34 24             	pushl  (%esp)
c0021fcc:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021fd0:	6a 1d                	push   $0x1d
c0021fd2:	e9 a4 fe ff ff       	jmp    c0021e7b <intr_entry>

c0021fd7 <intr1e_stub>:
c0021fd7:	ff 34 24             	pushl  (%esp)
c0021fda:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021fde:	6a 1e                	push   $0x1e
c0021fe0:	e9 96 fe ff ff       	jmp    c0021e7b <intr_entry>

c0021fe5 <intr1f_stub>:
c0021fe5:	55                   	push   %ebp
c0021fe6:	6a 00                	push   $0x0
c0021fe8:	6a 1f                	push   $0x1f
c0021fea:	e9 8c fe ff ff       	jmp    c0021e7b <intr_entry>

c0021fef <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0021fef:	55                   	push   %ebp
c0021ff0:	6a 00                	push   $0x0
c0021ff2:	6a 20                	push   $0x20
c0021ff4:	e9 82 fe ff ff       	jmp    c0021e7b <intr_entry>

c0021ff9 <intr21_stub>:
c0021ff9:	55                   	push   %ebp
c0021ffa:	6a 00                	push   $0x0
c0021ffc:	6a 21                	push   $0x21
c0021ffe:	e9 78 fe ff ff       	jmp    c0021e7b <intr_entry>

c0022003 <intr22_stub>:
c0022003:	55                   	push   %ebp
c0022004:	6a 00                	push   $0x0
c0022006:	6a 22                	push   $0x22
c0022008:	e9 6e fe ff ff       	jmp    c0021e7b <intr_entry>

c002200d <intr23_stub>:
c002200d:	55                   	push   %ebp
c002200e:	6a 00                	push   $0x0
c0022010:	6a 23                	push   $0x23
c0022012:	e9 64 fe ff ff       	jmp    c0021e7b <intr_entry>

c0022017 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0022017:	55                   	push   %ebp
c0022018:	6a 00                	push   $0x0
c002201a:	6a 24                	push   $0x24
c002201c:	e9 5a fe ff ff       	jmp    c0021e7b <intr_entry>

c0022021 <intr25_stub>:
c0022021:	55                   	push   %ebp
c0022022:	6a 00                	push   $0x0
c0022024:	6a 25                	push   $0x25
c0022026:	e9 50 fe ff ff       	jmp    c0021e7b <intr_entry>

c002202b <intr26_stub>:
c002202b:	55                   	push   %ebp
c002202c:	6a 00                	push   $0x0
c002202e:	6a 26                	push   $0x26
c0022030:	e9 46 fe ff ff       	jmp    c0021e7b <intr_entry>

c0022035 <intr27_stub>:
c0022035:	55                   	push   %ebp
c0022036:	6a 00                	push   $0x0
c0022038:	6a 27                	push   $0x27
c002203a:	e9 3c fe ff ff       	jmp    c0021e7b <intr_entry>

c002203f <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c002203f:	55                   	push   %ebp
c0022040:	6a 00                	push   $0x0
c0022042:	6a 28                	push   $0x28
c0022044:	e9 32 fe ff ff       	jmp    c0021e7b <intr_entry>

c0022049 <intr29_stub>:
c0022049:	55                   	push   %ebp
c002204a:	6a 00                	push   $0x0
c002204c:	6a 29                	push   $0x29
c002204e:	e9 28 fe ff ff       	jmp    c0021e7b <intr_entry>

c0022053 <intr2a_stub>:
c0022053:	55                   	push   %ebp
c0022054:	6a 00                	push   $0x0
c0022056:	6a 2a                	push   $0x2a
c0022058:	e9 1e fe ff ff       	jmp    c0021e7b <intr_entry>

c002205d <intr2b_stub>:
c002205d:	55                   	push   %ebp
c002205e:	6a 00                	push   $0x0
c0022060:	6a 2b                	push   $0x2b
c0022062:	e9 14 fe ff ff       	jmp    c0021e7b <intr_entry>

c0022067 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0022067:	55                   	push   %ebp
c0022068:	6a 00                	push   $0x0
c002206a:	6a 2c                	push   $0x2c
c002206c:	e9 0a fe ff ff       	jmp    c0021e7b <intr_entry>

c0022071 <intr2d_stub>:
c0022071:	55                   	push   %ebp
c0022072:	6a 00                	push   $0x0
c0022074:	6a 2d                	push   $0x2d
c0022076:	e9 00 fe ff ff       	jmp    c0021e7b <intr_entry>

c002207b <intr2e_stub>:
c002207b:	55                   	push   %ebp
c002207c:	6a 00                	push   $0x0
c002207e:	6a 2e                	push   $0x2e
c0022080:	e9 f6 fd ff ff       	jmp    c0021e7b <intr_entry>

c0022085 <intr2f_stub>:
c0022085:	55                   	push   %ebp
c0022086:	6a 00                	push   $0x0
c0022088:	6a 2f                	push   $0x2f
c002208a:	e9 ec fd ff ff       	jmp    c0021e7b <intr_entry>

c002208f <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c002208f:	55                   	push   %ebp
c0022090:	6a 00                	push   $0x0
c0022092:	6a 30                	push   $0x30
c0022094:	e9 e2 fd ff ff       	jmp    c0021e7b <intr_entry>

c0022099 <intr31_stub>:
c0022099:	55                   	push   %ebp
c002209a:	6a 00                	push   $0x0
c002209c:	6a 31                	push   $0x31
c002209e:	e9 d8 fd ff ff       	jmp    c0021e7b <intr_entry>

c00220a3 <intr32_stub>:
c00220a3:	55                   	push   %ebp
c00220a4:	6a 00                	push   $0x0
c00220a6:	6a 32                	push   $0x32
c00220a8:	e9 ce fd ff ff       	jmp    c0021e7b <intr_entry>

c00220ad <intr33_stub>:
c00220ad:	55                   	push   %ebp
c00220ae:	6a 00                	push   $0x0
c00220b0:	6a 33                	push   $0x33
c00220b2:	e9 c4 fd ff ff       	jmp    c0021e7b <intr_entry>

c00220b7 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c00220b7:	55                   	push   %ebp
c00220b8:	6a 00                	push   $0x0
c00220ba:	6a 34                	push   $0x34
c00220bc:	e9 ba fd ff ff       	jmp    c0021e7b <intr_entry>

c00220c1 <intr35_stub>:
c00220c1:	55                   	push   %ebp
c00220c2:	6a 00                	push   $0x0
c00220c4:	6a 35                	push   $0x35
c00220c6:	e9 b0 fd ff ff       	jmp    c0021e7b <intr_entry>

c00220cb <intr36_stub>:
c00220cb:	55                   	push   %ebp
c00220cc:	6a 00                	push   $0x0
c00220ce:	6a 36                	push   $0x36
c00220d0:	e9 a6 fd ff ff       	jmp    c0021e7b <intr_entry>

c00220d5 <intr37_stub>:
c00220d5:	55                   	push   %ebp
c00220d6:	6a 00                	push   $0x0
c00220d8:	6a 37                	push   $0x37
c00220da:	e9 9c fd ff ff       	jmp    c0021e7b <intr_entry>

c00220df <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c00220df:	55                   	push   %ebp
c00220e0:	6a 00                	push   $0x0
c00220e2:	6a 38                	push   $0x38
c00220e4:	e9 92 fd ff ff       	jmp    c0021e7b <intr_entry>

c00220e9 <intr39_stub>:
c00220e9:	55                   	push   %ebp
c00220ea:	6a 00                	push   $0x0
c00220ec:	6a 39                	push   $0x39
c00220ee:	e9 88 fd ff ff       	jmp    c0021e7b <intr_entry>

c00220f3 <intr3a_stub>:
c00220f3:	55                   	push   %ebp
c00220f4:	6a 00                	push   $0x0
c00220f6:	6a 3a                	push   $0x3a
c00220f8:	e9 7e fd ff ff       	jmp    c0021e7b <intr_entry>

c00220fd <intr3b_stub>:
c00220fd:	55                   	push   %ebp
c00220fe:	6a 00                	push   $0x0
c0022100:	6a 3b                	push   $0x3b
c0022102:	e9 74 fd ff ff       	jmp    c0021e7b <intr_entry>

c0022107 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0022107:	55                   	push   %ebp
c0022108:	6a 00                	push   $0x0
c002210a:	6a 3c                	push   $0x3c
c002210c:	e9 6a fd ff ff       	jmp    c0021e7b <intr_entry>

c0022111 <intr3d_stub>:
c0022111:	55                   	push   %ebp
c0022112:	6a 00                	push   $0x0
c0022114:	6a 3d                	push   $0x3d
c0022116:	e9 60 fd ff ff       	jmp    c0021e7b <intr_entry>

c002211b <intr3e_stub>:
c002211b:	55                   	push   %ebp
c002211c:	6a 00                	push   $0x0
c002211e:	6a 3e                	push   $0x3e
c0022120:	e9 56 fd ff ff       	jmp    c0021e7b <intr_entry>

c0022125 <intr3f_stub>:
c0022125:	55                   	push   %ebp
c0022126:	6a 00                	push   $0x0
c0022128:	6a 3f                	push   $0x3f
c002212a:	e9 4c fd ff ff       	jmp    c0021e7b <intr_entry>

c002212f <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c002212f:	55                   	push   %ebp
c0022130:	6a 00                	push   $0x0
c0022132:	6a 40                	push   $0x40
c0022134:	e9 42 fd ff ff       	jmp    c0021e7b <intr_entry>

c0022139 <intr41_stub>:
c0022139:	55                   	push   %ebp
c002213a:	6a 00                	push   $0x0
c002213c:	6a 41                	push   $0x41
c002213e:	e9 38 fd ff ff       	jmp    c0021e7b <intr_entry>

c0022143 <intr42_stub>:
c0022143:	55                   	push   %ebp
c0022144:	6a 00                	push   $0x0
c0022146:	6a 42                	push   $0x42
c0022148:	e9 2e fd ff ff       	jmp    c0021e7b <intr_entry>

c002214d <intr43_stub>:
c002214d:	55                   	push   %ebp
c002214e:	6a 00                	push   $0x0
c0022150:	6a 43                	push   $0x43
c0022152:	e9 24 fd ff ff       	jmp    c0021e7b <intr_entry>

c0022157 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0022157:	55                   	push   %ebp
c0022158:	6a 00                	push   $0x0
c002215a:	6a 44                	push   $0x44
c002215c:	e9 1a fd ff ff       	jmp    c0021e7b <intr_entry>

c0022161 <intr45_stub>:
c0022161:	55                   	push   %ebp
c0022162:	6a 00                	push   $0x0
c0022164:	6a 45                	push   $0x45
c0022166:	e9 10 fd ff ff       	jmp    c0021e7b <intr_entry>

c002216b <intr46_stub>:
c002216b:	55                   	push   %ebp
c002216c:	6a 00                	push   $0x0
c002216e:	6a 46                	push   $0x46
c0022170:	e9 06 fd ff ff       	jmp    c0021e7b <intr_entry>

c0022175 <intr47_stub>:
c0022175:	55                   	push   %ebp
c0022176:	6a 00                	push   $0x0
c0022178:	6a 47                	push   $0x47
c002217a:	e9 fc fc ff ff       	jmp    c0021e7b <intr_entry>

c002217f <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c002217f:	55                   	push   %ebp
c0022180:	6a 00                	push   $0x0
c0022182:	6a 48                	push   $0x48
c0022184:	e9 f2 fc ff ff       	jmp    c0021e7b <intr_entry>

c0022189 <intr49_stub>:
c0022189:	55                   	push   %ebp
c002218a:	6a 00                	push   $0x0
c002218c:	6a 49                	push   $0x49
c002218e:	e9 e8 fc ff ff       	jmp    c0021e7b <intr_entry>

c0022193 <intr4a_stub>:
c0022193:	55                   	push   %ebp
c0022194:	6a 00                	push   $0x0
c0022196:	6a 4a                	push   $0x4a
c0022198:	e9 de fc ff ff       	jmp    c0021e7b <intr_entry>

c002219d <intr4b_stub>:
c002219d:	55                   	push   %ebp
c002219e:	6a 00                	push   $0x0
c00221a0:	6a 4b                	push   $0x4b
c00221a2:	e9 d4 fc ff ff       	jmp    c0021e7b <intr_entry>

c00221a7 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c00221a7:	55                   	push   %ebp
c00221a8:	6a 00                	push   $0x0
c00221aa:	6a 4c                	push   $0x4c
c00221ac:	e9 ca fc ff ff       	jmp    c0021e7b <intr_entry>

c00221b1 <intr4d_stub>:
c00221b1:	55                   	push   %ebp
c00221b2:	6a 00                	push   $0x0
c00221b4:	6a 4d                	push   $0x4d
c00221b6:	e9 c0 fc ff ff       	jmp    c0021e7b <intr_entry>

c00221bb <intr4e_stub>:
c00221bb:	55                   	push   %ebp
c00221bc:	6a 00                	push   $0x0
c00221be:	6a 4e                	push   $0x4e
c00221c0:	e9 b6 fc ff ff       	jmp    c0021e7b <intr_entry>

c00221c5 <intr4f_stub>:
c00221c5:	55                   	push   %ebp
c00221c6:	6a 00                	push   $0x0
c00221c8:	6a 4f                	push   $0x4f
c00221ca:	e9 ac fc ff ff       	jmp    c0021e7b <intr_entry>

c00221cf <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c00221cf:	55                   	push   %ebp
c00221d0:	6a 00                	push   $0x0
c00221d2:	6a 50                	push   $0x50
c00221d4:	e9 a2 fc ff ff       	jmp    c0021e7b <intr_entry>

c00221d9 <intr51_stub>:
c00221d9:	55                   	push   %ebp
c00221da:	6a 00                	push   $0x0
c00221dc:	6a 51                	push   $0x51
c00221de:	e9 98 fc ff ff       	jmp    c0021e7b <intr_entry>

c00221e3 <intr52_stub>:
c00221e3:	55                   	push   %ebp
c00221e4:	6a 00                	push   $0x0
c00221e6:	6a 52                	push   $0x52
c00221e8:	e9 8e fc ff ff       	jmp    c0021e7b <intr_entry>

c00221ed <intr53_stub>:
c00221ed:	55                   	push   %ebp
c00221ee:	6a 00                	push   $0x0
c00221f0:	6a 53                	push   $0x53
c00221f2:	e9 84 fc ff ff       	jmp    c0021e7b <intr_entry>

c00221f7 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c00221f7:	55                   	push   %ebp
c00221f8:	6a 00                	push   $0x0
c00221fa:	6a 54                	push   $0x54
c00221fc:	e9 7a fc ff ff       	jmp    c0021e7b <intr_entry>

c0022201 <intr55_stub>:
c0022201:	55                   	push   %ebp
c0022202:	6a 00                	push   $0x0
c0022204:	6a 55                	push   $0x55
c0022206:	e9 70 fc ff ff       	jmp    c0021e7b <intr_entry>

c002220b <intr56_stub>:
c002220b:	55                   	push   %ebp
c002220c:	6a 00                	push   $0x0
c002220e:	6a 56                	push   $0x56
c0022210:	e9 66 fc ff ff       	jmp    c0021e7b <intr_entry>

c0022215 <intr57_stub>:
c0022215:	55                   	push   %ebp
c0022216:	6a 00                	push   $0x0
c0022218:	6a 57                	push   $0x57
c002221a:	e9 5c fc ff ff       	jmp    c0021e7b <intr_entry>

c002221f <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c002221f:	55                   	push   %ebp
c0022220:	6a 00                	push   $0x0
c0022222:	6a 58                	push   $0x58
c0022224:	e9 52 fc ff ff       	jmp    c0021e7b <intr_entry>

c0022229 <intr59_stub>:
c0022229:	55                   	push   %ebp
c002222a:	6a 00                	push   $0x0
c002222c:	6a 59                	push   $0x59
c002222e:	e9 48 fc ff ff       	jmp    c0021e7b <intr_entry>

c0022233 <intr5a_stub>:
c0022233:	55                   	push   %ebp
c0022234:	6a 00                	push   $0x0
c0022236:	6a 5a                	push   $0x5a
c0022238:	e9 3e fc ff ff       	jmp    c0021e7b <intr_entry>

c002223d <intr5b_stub>:
c002223d:	55                   	push   %ebp
c002223e:	6a 00                	push   $0x0
c0022240:	6a 5b                	push   $0x5b
c0022242:	e9 34 fc ff ff       	jmp    c0021e7b <intr_entry>

c0022247 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0022247:	55                   	push   %ebp
c0022248:	6a 00                	push   $0x0
c002224a:	6a 5c                	push   $0x5c
c002224c:	e9 2a fc ff ff       	jmp    c0021e7b <intr_entry>

c0022251 <intr5d_stub>:
c0022251:	55                   	push   %ebp
c0022252:	6a 00                	push   $0x0
c0022254:	6a 5d                	push   $0x5d
c0022256:	e9 20 fc ff ff       	jmp    c0021e7b <intr_entry>

c002225b <intr5e_stub>:
c002225b:	55                   	push   %ebp
c002225c:	6a 00                	push   $0x0
c002225e:	6a 5e                	push   $0x5e
c0022260:	e9 16 fc ff ff       	jmp    c0021e7b <intr_entry>

c0022265 <intr5f_stub>:
c0022265:	55                   	push   %ebp
c0022266:	6a 00                	push   $0x0
c0022268:	6a 5f                	push   $0x5f
c002226a:	e9 0c fc ff ff       	jmp    c0021e7b <intr_entry>

c002226f <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c002226f:	55                   	push   %ebp
c0022270:	6a 00                	push   $0x0
c0022272:	6a 60                	push   $0x60
c0022274:	e9 02 fc ff ff       	jmp    c0021e7b <intr_entry>

c0022279 <intr61_stub>:
c0022279:	55                   	push   %ebp
c002227a:	6a 00                	push   $0x0
c002227c:	6a 61                	push   $0x61
c002227e:	e9 f8 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022283 <intr62_stub>:
c0022283:	55                   	push   %ebp
c0022284:	6a 00                	push   $0x0
c0022286:	6a 62                	push   $0x62
c0022288:	e9 ee fb ff ff       	jmp    c0021e7b <intr_entry>

c002228d <intr63_stub>:
c002228d:	55                   	push   %ebp
c002228e:	6a 00                	push   $0x0
c0022290:	6a 63                	push   $0x63
c0022292:	e9 e4 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022297 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c0022297:	55                   	push   %ebp
c0022298:	6a 00                	push   $0x0
c002229a:	6a 64                	push   $0x64
c002229c:	e9 da fb ff ff       	jmp    c0021e7b <intr_entry>

c00222a1 <intr65_stub>:
c00222a1:	55                   	push   %ebp
c00222a2:	6a 00                	push   $0x0
c00222a4:	6a 65                	push   $0x65
c00222a6:	e9 d0 fb ff ff       	jmp    c0021e7b <intr_entry>

c00222ab <intr66_stub>:
c00222ab:	55                   	push   %ebp
c00222ac:	6a 00                	push   $0x0
c00222ae:	6a 66                	push   $0x66
c00222b0:	e9 c6 fb ff ff       	jmp    c0021e7b <intr_entry>

c00222b5 <intr67_stub>:
c00222b5:	55                   	push   %ebp
c00222b6:	6a 00                	push   $0x0
c00222b8:	6a 67                	push   $0x67
c00222ba:	e9 bc fb ff ff       	jmp    c0021e7b <intr_entry>

c00222bf <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c00222bf:	55                   	push   %ebp
c00222c0:	6a 00                	push   $0x0
c00222c2:	6a 68                	push   $0x68
c00222c4:	e9 b2 fb ff ff       	jmp    c0021e7b <intr_entry>

c00222c9 <intr69_stub>:
c00222c9:	55                   	push   %ebp
c00222ca:	6a 00                	push   $0x0
c00222cc:	6a 69                	push   $0x69
c00222ce:	e9 a8 fb ff ff       	jmp    c0021e7b <intr_entry>

c00222d3 <intr6a_stub>:
c00222d3:	55                   	push   %ebp
c00222d4:	6a 00                	push   $0x0
c00222d6:	6a 6a                	push   $0x6a
c00222d8:	e9 9e fb ff ff       	jmp    c0021e7b <intr_entry>

c00222dd <intr6b_stub>:
c00222dd:	55                   	push   %ebp
c00222de:	6a 00                	push   $0x0
c00222e0:	6a 6b                	push   $0x6b
c00222e2:	e9 94 fb ff ff       	jmp    c0021e7b <intr_entry>

c00222e7 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c00222e7:	55                   	push   %ebp
c00222e8:	6a 00                	push   $0x0
c00222ea:	6a 6c                	push   $0x6c
c00222ec:	e9 8a fb ff ff       	jmp    c0021e7b <intr_entry>

c00222f1 <intr6d_stub>:
c00222f1:	55                   	push   %ebp
c00222f2:	6a 00                	push   $0x0
c00222f4:	6a 6d                	push   $0x6d
c00222f6:	e9 80 fb ff ff       	jmp    c0021e7b <intr_entry>

c00222fb <intr6e_stub>:
c00222fb:	55                   	push   %ebp
c00222fc:	6a 00                	push   $0x0
c00222fe:	6a 6e                	push   $0x6e
c0022300:	e9 76 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022305 <intr6f_stub>:
c0022305:	55                   	push   %ebp
c0022306:	6a 00                	push   $0x0
c0022308:	6a 6f                	push   $0x6f
c002230a:	e9 6c fb ff ff       	jmp    c0021e7b <intr_entry>

c002230f <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c002230f:	55                   	push   %ebp
c0022310:	6a 00                	push   $0x0
c0022312:	6a 70                	push   $0x70
c0022314:	e9 62 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022319 <intr71_stub>:
c0022319:	55                   	push   %ebp
c002231a:	6a 00                	push   $0x0
c002231c:	6a 71                	push   $0x71
c002231e:	e9 58 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022323 <intr72_stub>:
c0022323:	55                   	push   %ebp
c0022324:	6a 00                	push   $0x0
c0022326:	6a 72                	push   $0x72
c0022328:	e9 4e fb ff ff       	jmp    c0021e7b <intr_entry>

c002232d <intr73_stub>:
c002232d:	55                   	push   %ebp
c002232e:	6a 00                	push   $0x0
c0022330:	6a 73                	push   $0x73
c0022332:	e9 44 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022337 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c0022337:	55                   	push   %ebp
c0022338:	6a 00                	push   $0x0
c002233a:	6a 74                	push   $0x74
c002233c:	e9 3a fb ff ff       	jmp    c0021e7b <intr_entry>

c0022341 <intr75_stub>:
c0022341:	55                   	push   %ebp
c0022342:	6a 00                	push   $0x0
c0022344:	6a 75                	push   $0x75
c0022346:	e9 30 fb ff ff       	jmp    c0021e7b <intr_entry>

c002234b <intr76_stub>:
c002234b:	55                   	push   %ebp
c002234c:	6a 00                	push   $0x0
c002234e:	6a 76                	push   $0x76
c0022350:	e9 26 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022355 <intr77_stub>:
c0022355:	55                   	push   %ebp
c0022356:	6a 00                	push   $0x0
c0022358:	6a 77                	push   $0x77
c002235a:	e9 1c fb ff ff       	jmp    c0021e7b <intr_entry>

c002235f <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c002235f:	55                   	push   %ebp
c0022360:	6a 00                	push   $0x0
c0022362:	6a 78                	push   $0x78
c0022364:	e9 12 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022369 <intr79_stub>:
c0022369:	55                   	push   %ebp
c002236a:	6a 00                	push   $0x0
c002236c:	6a 79                	push   $0x79
c002236e:	e9 08 fb ff ff       	jmp    c0021e7b <intr_entry>

c0022373 <intr7a_stub>:
c0022373:	55                   	push   %ebp
c0022374:	6a 00                	push   $0x0
c0022376:	6a 7a                	push   $0x7a
c0022378:	e9 fe fa ff ff       	jmp    c0021e7b <intr_entry>

c002237d <intr7b_stub>:
c002237d:	55                   	push   %ebp
c002237e:	6a 00                	push   $0x0
c0022380:	6a 7b                	push   $0x7b
c0022382:	e9 f4 fa ff ff       	jmp    c0021e7b <intr_entry>

c0022387 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c0022387:	55                   	push   %ebp
c0022388:	6a 00                	push   $0x0
c002238a:	6a 7c                	push   $0x7c
c002238c:	e9 ea fa ff ff       	jmp    c0021e7b <intr_entry>

c0022391 <intr7d_stub>:
c0022391:	55                   	push   %ebp
c0022392:	6a 00                	push   $0x0
c0022394:	6a 7d                	push   $0x7d
c0022396:	e9 e0 fa ff ff       	jmp    c0021e7b <intr_entry>

c002239b <intr7e_stub>:
c002239b:	55                   	push   %ebp
c002239c:	6a 00                	push   $0x0
c002239e:	6a 7e                	push   $0x7e
c00223a0:	e9 d6 fa ff ff       	jmp    c0021e7b <intr_entry>

c00223a5 <intr7f_stub>:
c00223a5:	55                   	push   %ebp
c00223a6:	6a 00                	push   $0x0
c00223a8:	6a 7f                	push   $0x7f
c00223aa:	e9 cc fa ff ff       	jmp    c0021e7b <intr_entry>

c00223af <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c00223af:	55                   	push   %ebp
c00223b0:	6a 00                	push   $0x0
c00223b2:	68 80 00 00 00       	push   $0x80
c00223b7:	e9 bf fa ff ff       	jmp    c0021e7b <intr_entry>

c00223bc <intr81_stub>:
c00223bc:	55                   	push   %ebp
c00223bd:	6a 00                	push   $0x0
c00223bf:	68 81 00 00 00       	push   $0x81
c00223c4:	e9 b2 fa ff ff       	jmp    c0021e7b <intr_entry>

c00223c9 <intr82_stub>:
c00223c9:	55                   	push   %ebp
c00223ca:	6a 00                	push   $0x0
c00223cc:	68 82 00 00 00       	push   $0x82
c00223d1:	e9 a5 fa ff ff       	jmp    c0021e7b <intr_entry>

c00223d6 <intr83_stub>:
c00223d6:	55                   	push   %ebp
c00223d7:	6a 00                	push   $0x0
c00223d9:	68 83 00 00 00       	push   $0x83
c00223de:	e9 98 fa ff ff       	jmp    c0021e7b <intr_entry>

c00223e3 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c00223e3:	55                   	push   %ebp
c00223e4:	6a 00                	push   $0x0
c00223e6:	68 84 00 00 00       	push   $0x84
c00223eb:	e9 8b fa ff ff       	jmp    c0021e7b <intr_entry>

c00223f0 <intr85_stub>:
c00223f0:	55                   	push   %ebp
c00223f1:	6a 00                	push   $0x0
c00223f3:	68 85 00 00 00       	push   $0x85
c00223f8:	e9 7e fa ff ff       	jmp    c0021e7b <intr_entry>

c00223fd <intr86_stub>:
c00223fd:	55                   	push   %ebp
c00223fe:	6a 00                	push   $0x0
c0022400:	68 86 00 00 00       	push   $0x86
c0022405:	e9 71 fa ff ff       	jmp    c0021e7b <intr_entry>

c002240a <intr87_stub>:
c002240a:	55                   	push   %ebp
c002240b:	6a 00                	push   $0x0
c002240d:	68 87 00 00 00       	push   $0x87
c0022412:	e9 64 fa ff ff       	jmp    c0021e7b <intr_entry>

c0022417 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022417:	55                   	push   %ebp
c0022418:	6a 00                	push   $0x0
c002241a:	68 88 00 00 00       	push   $0x88
c002241f:	e9 57 fa ff ff       	jmp    c0021e7b <intr_entry>

c0022424 <intr89_stub>:
c0022424:	55                   	push   %ebp
c0022425:	6a 00                	push   $0x0
c0022427:	68 89 00 00 00       	push   $0x89
c002242c:	e9 4a fa ff ff       	jmp    c0021e7b <intr_entry>

c0022431 <intr8a_stub>:
c0022431:	55                   	push   %ebp
c0022432:	6a 00                	push   $0x0
c0022434:	68 8a 00 00 00       	push   $0x8a
c0022439:	e9 3d fa ff ff       	jmp    c0021e7b <intr_entry>

c002243e <intr8b_stub>:
c002243e:	55                   	push   %ebp
c002243f:	6a 00                	push   $0x0
c0022441:	68 8b 00 00 00       	push   $0x8b
c0022446:	e9 30 fa ff ff       	jmp    c0021e7b <intr_entry>

c002244b <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c002244b:	55                   	push   %ebp
c002244c:	6a 00                	push   $0x0
c002244e:	68 8c 00 00 00       	push   $0x8c
c0022453:	e9 23 fa ff ff       	jmp    c0021e7b <intr_entry>

c0022458 <intr8d_stub>:
c0022458:	55                   	push   %ebp
c0022459:	6a 00                	push   $0x0
c002245b:	68 8d 00 00 00       	push   $0x8d
c0022460:	e9 16 fa ff ff       	jmp    c0021e7b <intr_entry>

c0022465 <intr8e_stub>:
c0022465:	55                   	push   %ebp
c0022466:	6a 00                	push   $0x0
c0022468:	68 8e 00 00 00       	push   $0x8e
c002246d:	e9 09 fa ff ff       	jmp    c0021e7b <intr_entry>

c0022472 <intr8f_stub>:
c0022472:	55                   	push   %ebp
c0022473:	6a 00                	push   $0x0
c0022475:	68 8f 00 00 00       	push   $0x8f
c002247a:	e9 fc f9 ff ff       	jmp    c0021e7b <intr_entry>

c002247f <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c002247f:	55                   	push   %ebp
c0022480:	6a 00                	push   $0x0
c0022482:	68 90 00 00 00       	push   $0x90
c0022487:	e9 ef f9 ff ff       	jmp    c0021e7b <intr_entry>

c002248c <intr91_stub>:
c002248c:	55                   	push   %ebp
c002248d:	6a 00                	push   $0x0
c002248f:	68 91 00 00 00       	push   $0x91
c0022494:	e9 e2 f9 ff ff       	jmp    c0021e7b <intr_entry>

c0022499 <intr92_stub>:
c0022499:	55                   	push   %ebp
c002249a:	6a 00                	push   $0x0
c002249c:	68 92 00 00 00       	push   $0x92
c00224a1:	e9 d5 f9 ff ff       	jmp    c0021e7b <intr_entry>

c00224a6 <intr93_stub>:
c00224a6:	55                   	push   %ebp
c00224a7:	6a 00                	push   $0x0
c00224a9:	68 93 00 00 00       	push   $0x93
c00224ae:	e9 c8 f9 ff ff       	jmp    c0021e7b <intr_entry>

c00224b3 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c00224b3:	55                   	push   %ebp
c00224b4:	6a 00                	push   $0x0
c00224b6:	68 94 00 00 00       	push   $0x94
c00224bb:	e9 bb f9 ff ff       	jmp    c0021e7b <intr_entry>

c00224c0 <intr95_stub>:
c00224c0:	55                   	push   %ebp
c00224c1:	6a 00                	push   $0x0
c00224c3:	68 95 00 00 00       	push   $0x95
c00224c8:	e9 ae f9 ff ff       	jmp    c0021e7b <intr_entry>

c00224cd <intr96_stub>:
c00224cd:	55                   	push   %ebp
c00224ce:	6a 00                	push   $0x0
c00224d0:	68 96 00 00 00       	push   $0x96
c00224d5:	e9 a1 f9 ff ff       	jmp    c0021e7b <intr_entry>

c00224da <intr97_stub>:
c00224da:	55                   	push   %ebp
c00224db:	6a 00                	push   $0x0
c00224dd:	68 97 00 00 00       	push   $0x97
c00224e2:	e9 94 f9 ff ff       	jmp    c0021e7b <intr_entry>

c00224e7 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c00224e7:	55                   	push   %ebp
c00224e8:	6a 00                	push   $0x0
c00224ea:	68 98 00 00 00       	push   $0x98
c00224ef:	e9 87 f9 ff ff       	jmp    c0021e7b <intr_entry>

c00224f4 <intr99_stub>:
c00224f4:	55                   	push   %ebp
c00224f5:	6a 00                	push   $0x0
c00224f7:	68 99 00 00 00       	push   $0x99
c00224fc:	e9 7a f9 ff ff       	jmp    c0021e7b <intr_entry>

c0022501 <intr9a_stub>:
c0022501:	55                   	push   %ebp
c0022502:	6a 00                	push   $0x0
c0022504:	68 9a 00 00 00       	push   $0x9a
c0022509:	e9 6d f9 ff ff       	jmp    c0021e7b <intr_entry>

c002250e <intr9b_stub>:
c002250e:	55                   	push   %ebp
c002250f:	6a 00                	push   $0x0
c0022511:	68 9b 00 00 00       	push   $0x9b
c0022516:	e9 60 f9 ff ff       	jmp    c0021e7b <intr_entry>

c002251b <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c002251b:	55                   	push   %ebp
c002251c:	6a 00                	push   $0x0
c002251e:	68 9c 00 00 00       	push   $0x9c
c0022523:	e9 53 f9 ff ff       	jmp    c0021e7b <intr_entry>

c0022528 <intr9d_stub>:
c0022528:	55                   	push   %ebp
c0022529:	6a 00                	push   $0x0
c002252b:	68 9d 00 00 00       	push   $0x9d
c0022530:	e9 46 f9 ff ff       	jmp    c0021e7b <intr_entry>

c0022535 <intr9e_stub>:
c0022535:	55                   	push   %ebp
c0022536:	6a 00                	push   $0x0
c0022538:	68 9e 00 00 00       	push   $0x9e
c002253d:	e9 39 f9 ff ff       	jmp    c0021e7b <intr_entry>

c0022542 <intr9f_stub>:
c0022542:	55                   	push   %ebp
c0022543:	6a 00                	push   $0x0
c0022545:	68 9f 00 00 00       	push   $0x9f
c002254a:	e9 2c f9 ff ff       	jmp    c0021e7b <intr_entry>

c002254f <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c002254f:	55                   	push   %ebp
c0022550:	6a 00                	push   $0x0
c0022552:	68 a0 00 00 00       	push   $0xa0
c0022557:	e9 1f f9 ff ff       	jmp    c0021e7b <intr_entry>

c002255c <intra1_stub>:
c002255c:	55                   	push   %ebp
c002255d:	6a 00                	push   $0x0
c002255f:	68 a1 00 00 00       	push   $0xa1
c0022564:	e9 12 f9 ff ff       	jmp    c0021e7b <intr_entry>

c0022569 <intra2_stub>:
c0022569:	55                   	push   %ebp
c002256a:	6a 00                	push   $0x0
c002256c:	68 a2 00 00 00       	push   $0xa2
c0022571:	e9 05 f9 ff ff       	jmp    c0021e7b <intr_entry>

c0022576 <intra3_stub>:
c0022576:	55                   	push   %ebp
c0022577:	6a 00                	push   $0x0
c0022579:	68 a3 00 00 00       	push   $0xa3
c002257e:	e9 f8 f8 ff ff       	jmp    c0021e7b <intr_entry>

c0022583 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c0022583:	55                   	push   %ebp
c0022584:	6a 00                	push   $0x0
c0022586:	68 a4 00 00 00       	push   $0xa4
c002258b:	e9 eb f8 ff ff       	jmp    c0021e7b <intr_entry>

c0022590 <intra5_stub>:
c0022590:	55                   	push   %ebp
c0022591:	6a 00                	push   $0x0
c0022593:	68 a5 00 00 00       	push   $0xa5
c0022598:	e9 de f8 ff ff       	jmp    c0021e7b <intr_entry>

c002259d <intra6_stub>:
c002259d:	55                   	push   %ebp
c002259e:	6a 00                	push   $0x0
c00225a0:	68 a6 00 00 00       	push   $0xa6
c00225a5:	e9 d1 f8 ff ff       	jmp    c0021e7b <intr_entry>

c00225aa <intra7_stub>:
c00225aa:	55                   	push   %ebp
c00225ab:	6a 00                	push   $0x0
c00225ad:	68 a7 00 00 00       	push   $0xa7
c00225b2:	e9 c4 f8 ff ff       	jmp    c0021e7b <intr_entry>

c00225b7 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c00225b7:	55                   	push   %ebp
c00225b8:	6a 00                	push   $0x0
c00225ba:	68 a8 00 00 00       	push   $0xa8
c00225bf:	e9 b7 f8 ff ff       	jmp    c0021e7b <intr_entry>

c00225c4 <intra9_stub>:
c00225c4:	55                   	push   %ebp
c00225c5:	6a 00                	push   $0x0
c00225c7:	68 a9 00 00 00       	push   $0xa9
c00225cc:	e9 aa f8 ff ff       	jmp    c0021e7b <intr_entry>

c00225d1 <intraa_stub>:
c00225d1:	55                   	push   %ebp
c00225d2:	6a 00                	push   $0x0
c00225d4:	68 aa 00 00 00       	push   $0xaa
c00225d9:	e9 9d f8 ff ff       	jmp    c0021e7b <intr_entry>

c00225de <intrab_stub>:
c00225de:	55                   	push   %ebp
c00225df:	6a 00                	push   $0x0
c00225e1:	68 ab 00 00 00       	push   $0xab
c00225e6:	e9 90 f8 ff ff       	jmp    c0021e7b <intr_entry>

c00225eb <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c00225eb:	55                   	push   %ebp
c00225ec:	6a 00                	push   $0x0
c00225ee:	68 ac 00 00 00       	push   $0xac
c00225f3:	e9 83 f8 ff ff       	jmp    c0021e7b <intr_entry>

c00225f8 <intrad_stub>:
c00225f8:	55                   	push   %ebp
c00225f9:	6a 00                	push   $0x0
c00225fb:	68 ad 00 00 00       	push   $0xad
c0022600:	e9 76 f8 ff ff       	jmp    c0021e7b <intr_entry>

c0022605 <intrae_stub>:
c0022605:	55                   	push   %ebp
c0022606:	6a 00                	push   $0x0
c0022608:	68 ae 00 00 00       	push   $0xae
c002260d:	e9 69 f8 ff ff       	jmp    c0021e7b <intr_entry>

c0022612 <intraf_stub>:
c0022612:	55                   	push   %ebp
c0022613:	6a 00                	push   $0x0
c0022615:	68 af 00 00 00       	push   $0xaf
c002261a:	e9 5c f8 ff ff       	jmp    c0021e7b <intr_entry>

c002261f <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c002261f:	55                   	push   %ebp
c0022620:	6a 00                	push   $0x0
c0022622:	68 b0 00 00 00       	push   $0xb0
c0022627:	e9 4f f8 ff ff       	jmp    c0021e7b <intr_entry>

c002262c <intrb1_stub>:
c002262c:	55                   	push   %ebp
c002262d:	6a 00                	push   $0x0
c002262f:	68 b1 00 00 00       	push   $0xb1
c0022634:	e9 42 f8 ff ff       	jmp    c0021e7b <intr_entry>

c0022639 <intrb2_stub>:
c0022639:	55                   	push   %ebp
c002263a:	6a 00                	push   $0x0
c002263c:	68 b2 00 00 00       	push   $0xb2
c0022641:	e9 35 f8 ff ff       	jmp    c0021e7b <intr_entry>

c0022646 <intrb3_stub>:
c0022646:	55                   	push   %ebp
c0022647:	6a 00                	push   $0x0
c0022649:	68 b3 00 00 00       	push   $0xb3
c002264e:	e9 28 f8 ff ff       	jmp    c0021e7b <intr_entry>

c0022653 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c0022653:	55                   	push   %ebp
c0022654:	6a 00                	push   $0x0
c0022656:	68 b4 00 00 00       	push   $0xb4
c002265b:	e9 1b f8 ff ff       	jmp    c0021e7b <intr_entry>

c0022660 <intrb5_stub>:
c0022660:	55                   	push   %ebp
c0022661:	6a 00                	push   $0x0
c0022663:	68 b5 00 00 00       	push   $0xb5
c0022668:	e9 0e f8 ff ff       	jmp    c0021e7b <intr_entry>

c002266d <intrb6_stub>:
c002266d:	55                   	push   %ebp
c002266e:	6a 00                	push   $0x0
c0022670:	68 b6 00 00 00       	push   $0xb6
c0022675:	e9 01 f8 ff ff       	jmp    c0021e7b <intr_entry>

c002267a <intrb7_stub>:
c002267a:	55                   	push   %ebp
c002267b:	6a 00                	push   $0x0
c002267d:	68 b7 00 00 00       	push   $0xb7
c0022682:	e9 f4 f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022687 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c0022687:	55                   	push   %ebp
c0022688:	6a 00                	push   $0x0
c002268a:	68 b8 00 00 00       	push   $0xb8
c002268f:	e9 e7 f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022694 <intrb9_stub>:
c0022694:	55                   	push   %ebp
c0022695:	6a 00                	push   $0x0
c0022697:	68 b9 00 00 00       	push   $0xb9
c002269c:	e9 da f7 ff ff       	jmp    c0021e7b <intr_entry>

c00226a1 <intrba_stub>:
c00226a1:	55                   	push   %ebp
c00226a2:	6a 00                	push   $0x0
c00226a4:	68 ba 00 00 00       	push   $0xba
c00226a9:	e9 cd f7 ff ff       	jmp    c0021e7b <intr_entry>

c00226ae <intrbb_stub>:
c00226ae:	55                   	push   %ebp
c00226af:	6a 00                	push   $0x0
c00226b1:	68 bb 00 00 00       	push   $0xbb
c00226b6:	e9 c0 f7 ff ff       	jmp    c0021e7b <intr_entry>

c00226bb <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c00226bb:	55                   	push   %ebp
c00226bc:	6a 00                	push   $0x0
c00226be:	68 bc 00 00 00       	push   $0xbc
c00226c3:	e9 b3 f7 ff ff       	jmp    c0021e7b <intr_entry>

c00226c8 <intrbd_stub>:
c00226c8:	55                   	push   %ebp
c00226c9:	6a 00                	push   $0x0
c00226cb:	68 bd 00 00 00       	push   $0xbd
c00226d0:	e9 a6 f7 ff ff       	jmp    c0021e7b <intr_entry>

c00226d5 <intrbe_stub>:
c00226d5:	55                   	push   %ebp
c00226d6:	6a 00                	push   $0x0
c00226d8:	68 be 00 00 00       	push   $0xbe
c00226dd:	e9 99 f7 ff ff       	jmp    c0021e7b <intr_entry>

c00226e2 <intrbf_stub>:
c00226e2:	55                   	push   %ebp
c00226e3:	6a 00                	push   $0x0
c00226e5:	68 bf 00 00 00       	push   $0xbf
c00226ea:	e9 8c f7 ff ff       	jmp    c0021e7b <intr_entry>

c00226ef <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c00226ef:	55                   	push   %ebp
c00226f0:	6a 00                	push   $0x0
c00226f2:	68 c0 00 00 00       	push   $0xc0
c00226f7:	e9 7f f7 ff ff       	jmp    c0021e7b <intr_entry>

c00226fc <intrc1_stub>:
c00226fc:	55                   	push   %ebp
c00226fd:	6a 00                	push   $0x0
c00226ff:	68 c1 00 00 00       	push   $0xc1
c0022704:	e9 72 f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022709 <intrc2_stub>:
c0022709:	55                   	push   %ebp
c002270a:	6a 00                	push   $0x0
c002270c:	68 c2 00 00 00       	push   $0xc2
c0022711:	e9 65 f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022716 <intrc3_stub>:
c0022716:	55                   	push   %ebp
c0022717:	6a 00                	push   $0x0
c0022719:	68 c3 00 00 00       	push   $0xc3
c002271e:	e9 58 f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022723 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022723:	55                   	push   %ebp
c0022724:	6a 00                	push   $0x0
c0022726:	68 c4 00 00 00       	push   $0xc4
c002272b:	e9 4b f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022730 <intrc5_stub>:
c0022730:	55                   	push   %ebp
c0022731:	6a 00                	push   $0x0
c0022733:	68 c5 00 00 00       	push   $0xc5
c0022738:	e9 3e f7 ff ff       	jmp    c0021e7b <intr_entry>

c002273d <intrc6_stub>:
c002273d:	55                   	push   %ebp
c002273e:	6a 00                	push   $0x0
c0022740:	68 c6 00 00 00       	push   $0xc6
c0022745:	e9 31 f7 ff ff       	jmp    c0021e7b <intr_entry>

c002274a <intrc7_stub>:
c002274a:	55                   	push   %ebp
c002274b:	6a 00                	push   $0x0
c002274d:	68 c7 00 00 00       	push   $0xc7
c0022752:	e9 24 f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022757 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022757:	55                   	push   %ebp
c0022758:	6a 00                	push   $0x0
c002275a:	68 c8 00 00 00       	push   $0xc8
c002275f:	e9 17 f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022764 <intrc9_stub>:
c0022764:	55                   	push   %ebp
c0022765:	6a 00                	push   $0x0
c0022767:	68 c9 00 00 00       	push   $0xc9
c002276c:	e9 0a f7 ff ff       	jmp    c0021e7b <intr_entry>

c0022771 <intrca_stub>:
c0022771:	55                   	push   %ebp
c0022772:	6a 00                	push   $0x0
c0022774:	68 ca 00 00 00       	push   $0xca
c0022779:	e9 fd f6 ff ff       	jmp    c0021e7b <intr_entry>

c002277e <intrcb_stub>:
c002277e:	55                   	push   %ebp
c002277f:	6a 00                	push   $0x0
c0022781:	68 cb 00 00 00       	push   $0xcb
c0022786:	e9 f0 f6 ff ff       	jmp    c0021e7b <intr_entry>

c002278b <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c002278b:	55                   	push   %ebp
c002278c:	6a 00                	push   $0x0
c002278e:	68 cc 00 00 00       	push   $0xcc
c0022793:	e9 e3 f6 ff ff       	jmp    c0021e7b <intr_entry>

c0022798 <intrcd_stub>:
c0022798:	55                   	push   %ebp
c0022799:	6a 00                	push   $0x0
c002279b:	68 cd 00 00 00       	push   $0xcd
c00227a0:	e9 d6 f6 ff ff       	jmp    c0021e7b <intr_entry>

c00227a5 <intrce_stub>:
c00227a5:	55                   	push   %ebp
c00227a6:	6a 00                	push   $0x0
c00227a8:	68 ce 00 00 00       	push   $0xce
c00227ad:	e9 c9 f6 ff ff       	jmp    c0021e7b <intr_entry>

c00227b2 <intrcf_stub>:
c00227b2:	55                   	push   %ebp
c00227b3:	6a 00                	push   $0x0
c00227b5:	68 cf 00 00 00       	push   $0xcf
c00227ba:	e9 bc f6 ff ff       	jmp    c0021e7b <intr_entry>

c00227bf <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c00227bf:	55                   	push   %ebp
c00227c0:	6a 00                	push   $0x0
c00227c2:	68 d0 00 00 00       	push   $0xd0
c00227c7:	e9 af f6 ff ff       	jmp    c0021e7b <intr_entry>

c00227cc <intrd1_stub>:
c00227cc:	55                   	push   %ebp
c00227cd:	6a 00                	push   $0x0
c00227cf:	68 d1 00 00 00       	push   $0xd1
c00227d4:	e9 a2 f6 ff ff       	jmp    c0021e7b <intr_entry>

c00227d9 <intrd2_stub>:
c00227d9:	55                   	push   %ebp
c00227da:	6a 00                	push   $0x0
c00227dc:	68 d2 00 00 00       	push   $0xd2
c00227e1:	e9 95 f6 ff ff       	jmp    c0021e7b <intr_entry>

c00227e6 <intrd3_stub>:
c00227e6:	55                   	push   %ebp
c00227e7:	6a 00                	push   $0x0
c00227e9:	68 d3 00 00 00       	push   $0xd3
c00227ee:	e9 88 f6 ff ff       	jmp    c0021e7b <intr_entry>

c00227f3 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c00227f3:	55                   	push   %ebp
c00227f4:	6a 00                	push   $0x0
c00227f6:	68 d4 00 00 00       	push   $0xd4
c00227fb:	e9 7b f6 ff ff       	jmp    c0021e7b <intr_entry>

c0022800 <intrd5_stub>:
c0022800:	55                   	push   %ebp
c0022801:	6a 00                	push   $0x0
c0022803:	68 d5 00 00 00       	push   $0xd5
c0022808:	e9 6e f6 ff ff       	jmp    c0021e7b <intr_entry>

c002280d <intrd6_stub>:
c002280d:	55                   	push   %ebp
c002280e:	6a 00                	push   $0x0
c0022810:	68 d6 00 00 00       	push   $0xd6
c0022815:	e9 61 f6 ff ff       	jmp    c0021e7b <intr_entry>

c002281a <intrd7_stub>:
c002281a:	55                   	push   %ebp
c002281b:	6a 00                	push   $0x0
c002281d:	68 d7 00 00 00       	push   $0xd7
c0022822:	e9 54 f6 ff ff       	jmp    c0021e7b <intr_entry>

c0022827 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022827:	55                   	push   %ebp
c0022828:	6a 00                	push   $0x0
c002282a:	68 d8 00 00 00       	push   $0xd8
c002282f:	e9 47 f6 ff ff       	jmp    c0021e7b <intr_entry>

c0022834 <intrd9_stub>:
c0022834:	55                   	push   %ebp
c0022835:	6a 00                	push   $0x0
c0022837:	68 d9 00 00 00       	push   $0xd9
c002283c:	e9 3a f6 ff ff       	jmp    c0021e7b <intr_entry>

c0022841 <intrda_stub>:
c0022841:	55                   	push   %ebp
c0022842:	6a 00                	push   $0x0
c0022844:	68 da 00 00 00       	push   $0xda
c0022849:	e9 2d f6 ff ff       	jmp    c0021e7b <intr_entry>

c002284e <intrdb_stub>:
c002284e:	55                   	push   %ebp
c002284f:	6a 00                	push   $0x0
c0022851:	68 db 00 00 00       	push   $0xdb
c0022856:	e9 20 f6 ff ff       	jmp    c0021e7b <intr_entry>

c002285b <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c002285b:	55                   	push   %ebp
c002285c:	6a 00                	push   $0x0
c002285e:	68 dc 00 00 00       	push   $0xdc
c0022863:	e9 13 f6 ff ff       	jmp    c0021e7b <intr_entry>

c0022868 <intrdd_stub>:
c0022868:	55                   	push   %ebp
c0022869:	6a 00                	push   $0x0
c002286b:	68 dd 00 00 00       	push   $0xdd
c0022870:	e9 06 f6 ff ff       	jmp    c0021e7b <intr_entry>

c0022875 <intrde_stub>:
c0022875:	55                   	push   %ebp
c0022876:	6a 00                	push   $0x0
c0022878:	68 de 00 00 00       	push   $0xde
c002287d:	e9 f9 f5 ff ff       	jmp    c0021e7b <intr_entry>

c0022882 <intrdf_stub>:
c0022882:	55                   	push   %ebp
c0022883:	6a 00                	push   $0x0
c0022885:	68 df 00 00 00       	push   $0xdf
c002288a:	e9 ec f5 ff ff       	jmp    c0021e7b <intr_entry>

c002288f <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c002288f:	55                   	push   %ebp
c0022890:	6a 00                	push   $0x0
c0022892:	68 e0 00 00 00       	push   $0xe0
c0022897:	e9 df f5 ff ff       	jmp    c0021e7b <intr_entry>

c002289c <intre1_stub>:
c002289c:	55                   	push   %ebp
c002289d:	6a 00                	push   $0x0
c002289f:	68 e1 00 00 00       	push   $0xe1
c00228a4:	e9 d2 f5 ff ff       	jmp    c0021e7b <intr_entry>

c00228a9 <intre2_stub>:
c00228a9:	55                   	push   %ebp
c00228aa:	6a 00                	push   $0x0
c00228ac:	68 e2 00 00 00       	push   $0xe2
c00228b1:	e9 c5 f5 ff ff       	jmp    c0021e7b <intr_entry>

c00228b6 <intre3_stub>:
c00228b6:	55                   	push   %ebp
c00228b7:	6a 00                	push   $0x0
c00228b9:	68 e3 00 00 00       	push   $0xe3
c00228be:	e9 b8 f5 ff ff       	jmp    c0021e7b <intr_entry>

c00228c3 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c00228c3:	55                   	push   %ebp
c00228c4:	6a 00                	push   $0x0
c00228c6:	68 e4 00 00 00       	push   $0xe4
c00228cb:	e9 ab f5 ff ff       	jmp    c0021e7b <intr_entry>

c00228d0 <intre5_stub>:
c00228d0:	55                   	push   %ebp
c00228d1:	6a 00                	push   $0x0
c00228d3:	68 e5 00 00 00       	push   $0xe5
c00228d8:	e9 9e f5 ff ff       	jmp    c0021e7b <intr_entry>

c00228dd <intre6_stub>:
c00228dd:	55                   	push   %ebp
c00228de:	6a 00                	push   $0x0
c00228e0:	68 e6 00 00 00       	push   $0xe6
c00228e5:	e9 91 f5 ff ff       	jmp    c0021e7b <intr_entry>

c00228ea <intre7_stub>:
c00228ea:	55                   	push   %ebp
c00228eb:	6a 00                	push   $0x0
c00228ed:	68 e7 00 00 00       	push   $0xe7
c00228f2:	e9 84 f5 ff ff       	jmp    c0021e7b <intr_entry>

c00228f7 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c00228f7:	55                   	push   %ebp
c00228f8:	6a 00                	push   $0x0
c00228fa:	68 e8 00 00 00       	push   $0xe8
c00228ff:	e9 77 f5 ff ff       	jmp    c0021e7b <intr_entry>

c0022904 <intre9_stub>:
c0022904:	55                   	push   %ebp
c0022905:	6a 00                	push   $0x0
c0022907:	68 e9 00 00 00       	push   $0xe9
c002290c:	e9 6a f5 ff ff       	jmp    c0021e7b <intr_entry>

c0022911 <intrea_stub>:
c0022911:	55                   	push   %ebp
c0022912:	6a 00                	push   $0x0
c0022914:	68 ea 00 00 00       	push   $0xea
c0022919:	e9 5d f5 ff ff       	jmp    c0021e7b <intr_entry>

c002291e <intreb_stub>:
c002291e:	55                   	push   %ebp
c002291f:	6a 00                	push   $0x0
c0022921:	68 eb 00 00 00       	push   $0xeb
c0022926:	e9 50 f5 ff ff       	jmp    c0021e7b <intr_entry>

c002292b <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c002292b:	55                   	push   %ebp
c002292c:	6a 00                	push   $0x0
c002292e:	68 ec 00 00 00       	push   $0xec
c0022933:	e9 43 f5 ff ff       	jmp    c0021e7b <intr_entry>

c0022938 <intred_stub>:
c0022938:	55                   	push   %ebp
c0022939:	6a 00                	push   $0x0
c002293b:	68 ed 00 00 00       	push   $0xed
c0022940:	e9 36 f5 ff ff       	jmp    c0021e7b <intr_entry>

c0022945 <intree_stub>:
c0022945:	55                   	push   %ebp
c0022946:	6a 00                	push   $0x0
c0022948:	68 ee 00 00 00       	push   $0xee
c002294d:	e9 29 f5 ff ff       	jmp    c0021e7b <intr_entry>

c0022952 <intref_stub>:
c0022952:	55                   	push   %ebp
c0022953:	6a 00                	push   $0x0
c0022955:	68 ef 00 00 00       	push   $0xef
c002295a:	e9 1c f5 ff ff       	jmp    c0021e7b <intr_entry>

c002295f <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c002295f:	55                   	push   %ebp
c0022960:	6a 00                	push   $0x0
c0022962:	68 f0 00 00 00       	push   $0xf0
c0022967:	e9 0f f5 ff ff       	jmp    c0021e7b <intr_entry>

c002296c <intrf1_stub>:
c002296c:	55                   	push   %ebp
c002296d:	6a 00                	push   $0x0
c002296f:	68 f1 00 00 00       	push   $0xf1
c0022974:	e9 02 f5 ff ff       	jmp    c0021e7b <intr_entry>

c0022979 <intrf2_stub>:
c0022979:	55                   	push   %ebp
c002297a:	6a 00                	push   $0x0
c002297c:	68 f2 00 00 00       	push   $0xf2
c0022981:	e9 f5 f4 ff ff       	jmp    c0021e7b <intr_entry>

c0022986 <intrf3_stub>:
c0022986:	55                   	push   %ebp
c0022987:	6a 00                	push   $0x0
c0022989:	68 f3 00 00 00       	push   $0xf3
c002298e:	e9 e8 f4 ff ff       	jmp    c0021e7b <intr_entry>

c0022993 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022993:	55                   	push   %ebp
c0022994:	6a 00                	push   $0x0
c0022996:	68 f4 00 00 00       	push   $0xf4
c002299b:	e9 db f4 ff ff       	jmp    c0021e7b <intr_entry>

c00229a0 <intrf5_stub>:
c00229a0:	55                   	push   %ebp
c00229a1:	6a 00                	push   $0x0
c00229a3:	68 f5 00 00 00       	push   $0xf5
c00229a8:	e9 ce f4 ff ff       	jmp    c0021e7b <intr_entry>

c00229ad <intrf6_stub>:
c00229ad:	55                   	push   %ebp
c00229ae:	6a 00                	push   $0x0
c00229b0:	68 f6 00 00 00       	push   $0xf6
c00229b5:	e9 c1 f4 ff ff       	jmp    c0021e7b <intr_entry>

c00229ba <intrf7_stub>:
c00229ba:	55                   	push   %ebp
c00229bb:	6a 00                	push   $0x0
c00229bd:	68 f7 00 00 00       	push   $0xf7
c00229c2:	e9 b4 f4 ff ff       	jmp    c0021e7b <intr_entry>

c00229c7 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c00229c7:	55                   	push   %ebp
c00229c8:	6a 00                	push   $0x0
c00229ca:	68 f8 00 00 00       	push   $0xf8
c00229cf:	e9 a7 f4 ff ff       	jmp    c0021e7b <intr_entry>

c00229d4 <intrf9_stub>:
c00229d4:	55                   	push   %ebp
c00229d5:	6a 00                	push   $0x0
c00229d7:	68 f9 00 00 00       	push   $0xf9
c00229dc:	e9 9a f4 ff ff       	jmp    c0021e7b <intr_entry>

c00229e1 <intrfa_stub>:
c00229e1:	55                   	push   %ebp
c00229e2:	6a 00                	push   $0x0
c00229e4:	68 fa 00 00 00       	push   $0xfa
c00229e9:	e9 8d f4 ff ff       	jmp    c0021e7b <intr_entry>

c00229ee <intrfb_stub>:
c00229ee:	55                   	push   %ebp
c00229ef:	6a 00                	push   $0x0
c00229f1:	68 fb 00 00 00       	push   $0xfb
c00229f6:	e9 80 f4 ff ff       	jmp    c0021e7b <intr_entry>

c00229fb <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c00229fb:	55                   	push   %ebp
c00229fc:	6a 00                	push   $0x0
c00229fe:	68 fc 00 00 00       	push   $0xfc
c0022a03:	e9 73 f4 ff ff       	jmp    c0021e7b <intr_entry>

c0022a08 <intrfd_stub>:
c0022a08:	55                   	push   %ebp
c0022a09:	6a 00                	push   $0x0
c0022a0b:	68 fd 00 00 00       	push   $0xfd
c0022a10:	e9 66 f4 ff ff       	jmp    c0021e7b <intr_entry>

c0022a15 <intrfe_stub>:
c0022a15:	55                   	push   %ebp
c0022a16:	6a 00                	push   $0x0
c0022a18:	68 fe 00 00 00       	push   $0xfe
c0022a1d:	e9 59 f4 ff ff       	jmp    c0021e7b <intr_entry>

c0022a22 <intrff_stub>:
c0022a22:	55                   	push   %ebp
c0022a23:	6a 00                	push   $0x0
c0022a25:	68 ff 00 00 00       	push   $0xff
c0022a2a:	e9 4c f4 ff ff       	jmp    c0021e7b <intr_entry>

c0022a2f <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c0022a2f:	53                   	push   %ebx
c0022a30:	83 ec 08             	sub    $0x8,%esp
c0022a33:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (sema != NULL);
c0022a37:	85 c0                	test   %eax,%eax
c0022a39:	74 26                	je     c0022a61 <sema_init+0x32>

  sema->value = value;
c0022a3b:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022a3f:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c0022a41:	8d 58 04             	lea    0x4(%eax),%ebx
c0022a44:	83 ec 0c             	sub    $0xc,%esp
c0022a47:	53                   	push   %ebx
c0022a48:	e8 81 5c 00 00       	call   c00286ce <list_init>
  ASSERT (list_empty(&sema->waiters));
c0022a4d:	89 1c 24             	mov    %ebx,(%esp)
c0022a50:	e8 6d 61 00 00       	call   c0028bc2 <list_empty>
c0022a55:	83 c4 10             	add    $0x10,%esp
c0022a58:	84 c0                	test   %al,%al
c0022a5a:	74 23                	je     c0022a7f <sema_init+0x50>
}
c0022a5c:	83 c4 08             	add    $0x8,%esp
c0022a5f:	5b                   	pop    %ebx
c0022a60:	c3                   	ret    
  ASSERT (sema != NULL);
c0022a61:	83 ec 0c             	sub    $0xc,%esp
c0022a64:	68 4e 0c 03 c0       	push   $0xc0030c4e
c0022a69:	68 21 01 03 c0       	push   $0xc0030121
c0022a6e:	68 2c ec 02 c0       	push   $0xc002ec2c
c0022a73:	6a 31                	push   $0x31
c0022a75:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022a7a:	e8 a8 5b 00 00       	call   c0028627 <debug_panic>
  ASSERT (list_empty(&sema->waiters));
c0022a7f:	83 ec 0c             	sub    $0xc,%esp
c0022a82:	68 71 0c 03 c0       	push   $0xc0030c71
c0022a87:	68 21 01 03 c0       	push   $0xc0030121
c0022a8c:	68 2c ec 02 c0       	push   $0xc002ec2c
c0022a91:	6a 35                	push   $0x35
c0022a93:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022a98:	e8 8a 5b 00 00       	call   c0028627 <debug_panic>

c0022a9d <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c0022a9d:	57                   	push   %edi
c0022a9e:	56                   	push   %esi
c0022a9f:	53                   	push   %ebx
c0022aa0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022aa4:	85 db                	test   %ebx,%ebx
c0022aa6:	74 4c                	je     c0022af4 <sema_down+0x57>
  ASSERT (!intr_context ());
c0022aa8:	e8 75 f1 ff ff       	call   c0021c22 <intr_context>
c0022aad:	84 c0                	test   %al,%al
c0022aaf:	75 61                	jne    c0022b12 <sema_down+0x75>

  old_level = intr_disable ();
c0022ab1:	e8 4b ef ff ff       	call   c0021a01 <intr_disable>
c0022ab6:	89 c7                	mov    %eax,%edi
  while (sema->value == 0) 
c0022ab8:	8b 03                	mov    (%ebx),%eax
c0022aba:	85 c0                	test   %eax,%eax
c0022abc:	75 23                	jne    c0022ae1 <sema_down+0x44>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c0022abe:	8d 73 04             	lea    0x4(%ebx),%esi
c0022ac1:	e8 f6 e1 ff ff       	call   c0020cbc <thread_current>
c0022ac6:	83 ec 08             	sub    $0x8,%esp
c0022ac9:	83 c0 5c             	add    $0x5c,%eax
c0022acc:	50                   	push   %eax
c0022acd:	56                   	push   %esi
c0022ace:	e8 47 60 00 00       	call   c0028b1a <list_push_back>
      thread_block ();
c0022ad3:	e8 25 e9 ff ff       	call   c00213fd <thread_block>
  while (sema->value == 0) 
c0022ad8:	8b 03                	mov    (%ebx),%eax
c0022ada:	83 c4 10             	add    $0x10,%esp
c0022add:	85 c0                	test   %eax,%eax
c0022adf:	74 e0                	je     c0022ac1 <sema_down+0x24>
    }
  sema->value--;
c0022ae1:	48                   	dec    %eax
c0022ae2:	89 03                	mov    %eax,(%ebx)
  intr_set_level (old_level);
c0022ae4:	83 ec 0c             	sub    $0xc,%esp
c0022ae7:	57                   	push   %edi
c0022ae8:	e8 1b ef ff ff       	call   c0021a08 <intr_set_level>
}
c0022aed:	83 c4 10             	add    $0x10,%esp
c0022af0:	5b                   	pop    %ebx
c0022af1:	5e                   	pop    %esi
c0022af2:	5f                   	pop    %edi
c0022af3:	c3                   	ret    
  ASSERT (sema != NULL);
c0022af4:	83 ec 0c             	sub    $0xc,%esp
c0022af7:	68 4e 0c 03 c0       	push   $0xc0030c4e
c0022afc:	68 21 01 03 c0       	push   $0xc0030121
c0022b01:	68 20 ec 02 c0       	push   $0xc002ec20
c0022b06:	6a 44                	push   $0x44
c0022b08:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022b0d:	e8 15 5b 00 00       	call   c0028627 <debug_panic>
  ASSERT (!intr_context ());
c0022b12:	83 ec 0c             	sub    $0xc,%esp
c0022b15:	68 f0 07 03 c0       	push   $0xc00307f0
c0022b1a:	68 21 01 03 c0       	push   $0xc0030121
c0022b1f:	68 20 ec 02 c0       	push   $0xc002ec20
c0022b24:	6a 45                	push   $0x45
c0022b26:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022b2b:	e8 f7 5a 00 00       	call   c0028627 <debug_panic>

c0022b30 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022b30:	53                   	push   %ebx
c0022b31:	83 ec 08             	sub    $0x8,%esp
c0022b34:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c0022b38:	85 db                	test   %ebx,%ebx
c0022b3a:	74 20                	je     c0022b5c <sema_try_down+0x2c>

  old_level = intr_disable ();
c0022b3c:	e8 c0 ee ff ff       	call   c0021a01 <intr_disable>
  if (sema->value > 0) 
c0022b41:	8b 13                	mov    (%ebx),%edx
c0022b43:	85 d2                	test   %edx,%edx
c0022b45:	74 33                	je     c0022b7a <sema_try_down+0x4a>
    {
      sema->value--;
c0022b47:	4a                   	dec    %edx
c0022b48:	89 13                	mov    %edx,(%ebx)
      success = true; 
c0022b4a:	b3 01                	mov    $0x1,%bl
    }
  else
    success = false;
  intr_set_level (old_level);
c0022b4c:	83 ec 0c             	sub    $0xc,%esp
c0022b4f:	50                   	push   %eax
c0022b50:	e8 b3 ee ff ff       	call   c0021a08 <intr_set_level>

  return success;
}
c0022b55:	88 d8                	mov    %bl,%al
c0022b57:	83 c4 18             	add    $0x18,%esp
c0022b5a:	5b                   	pop    %ebx
c0022b5b:	c3                   	ret    
  ASSERT (sema != NULL);
c0022b5c:	83 ec 0c             	sub    $0xc,%esp
c0022b5f:	68 4e 0c 03 c0       	push   $0xc0030c4e
c0022b64:	68 21 01 03 c0       	push   $0xc0030121
c0022b69:	68 10 ec 02 c0       	push   $0xc002ec10
c0022b6e:	6a 5c                	push   $0x5c
c0022b70:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022b75:	e8 ad 5a 00 00       	call   c0028627 <debug_panic>
    success = false;
c0022b7a:	b3 00                	mov    $0x0,%bl
c0022b7c:	eb ce                	jmp    c0022b4c <sema_try_down+0x1c>

c0022b7e <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0022b7e:	55                   	push   %ebp
c0022b7f:	57                   	push   %edi
c0022b80:	56                   	push   %esi
c0022b81:	53                   	push   %ebx
c0022b82:	83 ec 1c             	sub    $0x1c,%esp
c0022b85:	8b 74 24 30          	mov    0x30(%esp),%esi
  enum intr_level old_level = intr_disable ();
c0022b89:	e8 73 ee ff ff       	call   c0021a01 <intr_disable>
c0022b8e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  sema->value++;
c0022b92:	ff 06                	incl   (%esi)

  if (!list_empty (&sema->waiters)) {
c0022b94:	83 c6 04             	add    $0x4,%esi
c0022b97:	83 ec 0c             	sub    $0xc,%esp
c0022b9a:	56                   	push   %esi
c0022b9b:	e8 22 60 00 00       	call   c0028bc2 <list_empty>
c0022ba0:	83 c4 10             	add    $0x10,%esp
c0022ba3:	84 c0                	test   %al,%al
c0022ba5:	74 14                	je     c0022bbb <sema_up+0x3d>
      }
    }
  }
  //  thread_unblock (list_entry (list_pop_front (&sema->waiters), struct thread, elem));
  
  intr_set_level (old_level);
c0022ba7:	83 ec 0c             	sub    $0xc,%esp
c0022baa:	ff 74 24 18          	pushl  0x18(%esp)
c0022bae:	e8 55 ee ff ff       	call   c0021a08 <intr_set_level>
}
c0022bb3:	83 c4 2c             	add    $0x2c,%esp
c0022bb6:	5b                   	pop    %ebx
c0022bb7:	5e                   	pop    %esi
c0022bb8:	5f                   	pop    %edi
c0022bb9:	5d                   	pop    %ebp
c0022bba:	c3                   	ret    
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c0022bbb:	83 ec 0c             	sub    $0xc,%esp
c0022bbe:	56                   	push   %esi
c0022bbf:	e8 4d 5b 00 00       	call   c0028711 <list_begin>
c0022bc4:	89 c3                	mov    %eax,%ebx
c0022bc6:	83 c4 10             	add    $0x10,%esp
    int maxp = -1, tmpp;
c0022bc9:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c0022bce:	eb 0e                	jmp    c0022bde <sema_up+0x60>
              e = list_next (e)) {
c0022bd0:	83 ec 0c             	sub    $0xc,%esp
c0022bd3:	53                   	push   %ebx
c0022bd4:	e8 68 5b 00 00       	call   c0028741 <list_next>
c0022bd9:	89 c3                	mov    %eax,%ebx
c0022bdb:	83 c4 10             	add    $0x10,%esp
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c0022bde:	83 ec 0c             	sub    $0xc,%esp
c0022be1:	56                   	push   %esi
c0022be2:	e8 a2 5b 00 00       	call   c0028789 <list_end>
c0022be7:	83 c4 10             	add    $0x10,%esp
c0022bea:	39 c3                	cmp    %eax,%ebx
c0022bec:	74 17                	je     c0022c05 <sema_up+0x87>
      tmpp = thread_get_certain_priority(t);
c0022bee:	83 ec 0c             	sub    $0xc,%esp
      struct thread *t = list_entry (e, struct thread, elem);
c0022bf1:	8d 43 a4             	lea    -0x5c(%ebx),%eax
      tmpp = thread_get_certain_priority(t);
c0022bf4:	50                   	push   %eax
c0022bf5:	e8 99 e3 ff ff       	call   c0020f93 <thread_get_certain_priority>
c0022bfa:	83 c4 10             	add    $0x10,%esp
c0022bfd:	39 c7                	cmp    %eax,%edi
c0022bff:	7d cf                	jge    c0022bd0 <sema_up+0x52>
c0022c01:	89 c7                	mov    %eax,%edi
c0022c03:	eb cb                	jmp    c0022bd0 <sema_up+0x52>
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c0022c05:	83 ec 0c             	sub    $0xc,%esp
c0022c08:	56                   	push   %esi
c0022c09:	e8 03 5b 00 00       	call   c0028711 <list_begin>
c0022c0e:	89 c3                	mov    %eax,%ebx
c0022c10:	83 c4 10             	add    $0x10,%esp
c0022c13:	83 ec 0c             	sub    $0xc,%esp
c0022c16:	56                   	push   %esi
c0022c17:	e8 6d 5b 00 00       	call   c0028789 <list_end>
c0022c1c:	83 c4 10             	add    $0x10,%esp
c0022c1f:	39 c3                	cmp    %eax,%ebx
c0022c21:	74 84                	je     c0022ba7 <sema_up+0x29>
      struct thread *t = list_entry (e, struct thread, elem);
c0022c23:	8d 6b a4             	lea    -0x5c(%ebx),%ebp
      tmpp = thread_get_certain_priority(t);
c0022c26:	83 ec 0c             	sub    $0xc,%esp
c0022c29:	55                   	push   %ebp
c0022c2a:	e8 64 e3 ff ff       	call   c0020f93 <thread_get_certain_priority>
      if (tmpp == maxp) {
c0022c2f:	83 c4 10             	add    $0x10,%esp
c0022c32:	39 c7                	cmp    %eax,%edi
c0022c34:	74 10                	je     c0022c46 <sema_up+0xc8>
              e = list_next (e)) {
c0022c36:	83 ec 0c             	sub    $0xc,%esp
c0022c39:	53                   	push   %ebx
c0022c3a:	e8 02 5b 00 00       	call   c0028741 <list_next>
c0022c3f:	89 c3                	mov    %eax,%ebx
c0022c41:	83 c4 10             	add    $0x10,%esp
c0022c44:	eb cd                	jmp    c0022c13 <sema_up+0x95>
        list_remove(e);
c0022c46:	83 ec 0c             	sub    $0xc,%esp
c0022c49:	53                   	push   %ebx
c0022c4a:	e8 e8 5e 00 00       	call   c0028b37 <list_remove>
        thread_unblock (t);
c0022c4f:	89 2c 24             	mov    %ebp,(%esp)
c0022c52:	e8 22 e2 ff ff       	call   c0020e79 <thread_unblock>
        thread_check_switch ();
c0022c57:	e8 a6 e8 ff ff       	call   c0021502 <thread_check_switch>
        break;
c0022c5c:	83 c4 10             	add    $0x10,%esp
c0022c5f:	e9 43 ff ff ff       	jmp    c0022ba7 <sema_up+0x29>

c0022c64 <sema_test_helper>:
}

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022c64:	57                   	push   %edi
c0022c65:	56                   	push   %esi
c0022c66:	53                   	push   %ebx
c0022c67:	8b 74 24 10          	mov    0x10(%esp),%esi
c0022c6b:	bb 0a 00 00 00       	mov    $0xa,%ebx
  int i;

  for (i = 0; i < 10; i++) 
    {
      sema_down (&sema[0]);
      sema_up (&sema[1]);
c0022c70:	8d 7e 14             	lea    0x14(%esi),%edi
      sema_down (&sema[0]);
c0022c73:	83 ec 0c             	sub    $0xc,%esp
c0022c76:	56                   	push   %esi
c0022c77:	e8 21 fe ff ff       	call   c0022a9d <sema_down>
      sema_up (&sema[1]);
c0022c7c:	89 3c 24             	mov    %edi,(%esp)
c0022c7f:	e8 fa fe ff ff       	call   c0022b7e <sema_up>
  for (i = 0; i < 10; i++) 
c0022c84:	83 c4 10             	add    $0x10,%esp
c0022c87:	4b                   	dec    %ebx
c0022c88:	75 e9                	jne    c0022c73 <sema_test_helper+0xf>
    }
}
c0022c8a:	5b                   	pop    %ebx
c0022c8b:	5e                   	pop    %esi
c0022c8c:	5f                   	pop    %edi
c0022c8d:	c3                   	ret    

c0022c8e <sema_self_test>:
{
c0022c8e:	57                   	push   %edi
c0022c8f:	56                   	push   %esi
c0022c90:	53                   	push   %ebx
c0022c91:	83 ec 3c             	sub    $0x3c,%esp
  printf ("Testing semaphores...");
c0022c94:	68 8c 0c 03 c0       	push   $0xc0030c8c
c0022c99:	e8 db 3e 00 00       	call   c0026b79 <printf>
  sema_init (&sema[0], 0);
c0022c9e:	83 c4 08             	add    $0x8,%esp
c0022ca1:	6a 00                	push   $0x0
c0022ca3:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c0022ca7:	53                   	push   %ebx
c0022ca8:	e8 82 fd ff ff       	call   c0022a2f <sema_init>
  sema_init (&sema[1], 0);
c0022cad:	83 c4 08             	add    $0x8,%esp
c0022cb0:	6a 00                	push   $0x0
c0022cb2:	8d 44 24 28          	lea    0x28(%esp),%eax
c0022cb6:	50                   	push   %eax
c0022cb7:	e8 73 fd ff ff       	call   c0022a2f <sema_init>
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022cbc:	53                   	push   %ebx
c0022cbd:	68 64 2c 02 c0       	push   $0xc0022c64
c0022cc2:	6a 1f                	push   $0x1f
c0022cc4:	68 a2 0c 03 c0       	push   $0xc0030ca2
c0022cc9:	e8 a5 e8 ff ff       	call   c0021573 <thread_create>
c0022cce:	83 c4 20             	add    $0x20,%esp
c0022cd1:	bb 0a 00 00 00       	mov    $0xa,%ebx
      sema_up (&sema[0]);
c0022cd6:	8d 7c 24 08          	lea    0x8(%esp),%edi
      sema_down (&sema[1]);
c0022cda:	8d 74 24 1c          	lea    0x1c(%esp),%esi
      sema_up (&sema[0]);
c0022cde:	83 ec 0c             	sub    $0xc,%esp
c0022ce1:	57                   	push   %edi
c0022ce2:	e8 97 fe ff ff       	call   c0022b7e <sema_up>
      sema_down (&sema[1]);
c0022ce7:	89 34 24             	mov    %esi,(%esp)
c0022cea:	e8 ae fd ff ff       	call   c0022a9d <sema_down>
  for (i = 0; i < 10; i++) 
c0022cef:	83 c4 10             	add    $0x10,%esp
c0022cf2:	4b                   	dec    %ebx
c0022cf3:	75 e9                	jne    c0022cde <sema_self_test+0x50>
  printf ("done.\n");
c0022cf5:	83 ec 0c             	sub    $0xc,%esp
c0022cf8:	68 ac 0c 03 c0       	push   $0xc0030cac
c0022cfd:	e8 0c 74 00 00       	call   c002a10e <puts>
}
c0022d02:	83 c4 40             	add    $0x40,%esp
c0022d05:	5b                   	pop    %ebx
c0022d06:	5e                   	pop    %esi
c0022d07:	5f                   	pop    %edi
c0022d08:	c3                   	ret    

c0022d09 <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0022d09:	53                   	push   %ebx
c0022d0a:	83 ec 08             	sub    $0x8,%esp
c0022d0d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022d11:	85 db                	test   %ebx,%ebx
c0022d13:	74 2c                	je     c0022d41 <lock_init+0x38>

  lock->holder = NULL;
c0022d15:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  lock->max_donate_delta = 0;
c0022d1b:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
  list_init (&lock->donaters);
c0022d22:	83 ec 0c             	sub    $0xc,%esp
c0022d25:	8d 43 1c             	lea    0x1c(%ebx),%eax
c0022d28:	50                   	push   %eax
c0022d29:	e8 a0 59 00 00       	call   c00286ce <list_init>
  sema_init (&lock->semaphore, 1);
c0022d2e:	83 c4 08             	add    $0x8,%esp
c0022d31:	6a 01                	push   $0x1
c0022d33:	83 c3 04             	add    $0x4,%ebx
c0022d36:	53                   	push   %ebx
c0022d37:	e8 f3 fc ff ff       	call   c0022a2f <sema_init>
}
c0022d3c:	83 c4 18             	add    $0x18,%esp
c0022d3f:	5b                   	pop    %ebx
c0022d40:	c3                   	ret    
  ASSERT (lock != NULL);
c0022d41:	83 ec 0c             	sub    $0xc,%esp
c0022d44:	68 b2 0c 03 c0       	push   $0xc0030cb2
c0022d49:	68 21 01 03 c0       	push   $0xc0030121
c0022d4e:	68 04 ec 02 c0       	push   $0xc002ec04
c0022d53:	68 c8 00 00 00       	push   $0xc8
c0022d58:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022d5d:	e8 c5 58 00 00       	call   c0028627 <debug_panic>

c0022d62 <notify_donation>:

/* Update donation when lock status changes. */
void
notify_donation(struct thread *t) {
c0022d62:	55                   	push   %ebp
c0022d63:	57                   	push   %edi
c0022d64:	56                   	push   %esi
c0022d65:	53                   	push   %ebx
c0022d66:	83 ec 1c             	sub    $0x1c,%esp
c0022d69:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  if (t == NULL || t->father == NULL) {
c0022d6d:	85 ed                	test   %ebp,%ebp
c0022d6f:	0f 84 c2 00 00 00    	je     c0022e37 <notify_donation+0xd5>
c0022d75:	8b 45 48             	mov    0x48(%ebp),%eax
c0022d78:	85 c0                	test   %eax,%eax
c0022d7a:	0f 84 b7 00 00 00    	je     c0022e37 <notify_donation+0xd5>
    return;
  }
  int max_donate_delta = 0;

  struct list_elem *lock_elem, *donater_elem;
  for (lock_elem = list_begin (&t->father->lock_list);
c0022d80:	83 ec 0c             	sub    $0xc,%esp
c0022d83:	83 c0 30             	add    $0x30,%eax
c0022d86:	50                   	push   %eax
c0022d87:	e8 85 59 00 00       	call   c0028711 <list_begin>
c0022d8c:	89 c6                	mov    %eax,%esi
c0022d8e:	83 c4 10             	add    $0x10,%esp
  int max_donate_delta = 0;
c0022d91:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0022d98:	00 
  for (lock_elem = list_begin (&t->father->lock_list);
c0022d99:	eb 4f                	jmp    c0022dea <notify_donation+0x88>
      lock_elem = list_next (lock_elem)) {
    struct lock* l = list_entry (lock_elem, struct lock, elem);
    l->max_donate_delta = 0;
    for (donater_elem = list_begin (&l->donaters);
        donater_elem != list_end (&l->donaters);
        donater_elem = list_next (donater_elem)) {
c0022d9b:	83 ec 0c             	sub    $0xc,%esp
c0022d9e:	53                   	push   %ebx
c0022d9f:	e8 9d 59 00 00       	call   c0028741 <list_next>
c0022da4:	89 c3                	mov    %eax,%ebx
c0022da6:	83 c4 10             	add    $0x10,%esp
        donater_elem != list_end (&l->donaters);
c0022da9:	83 ec 0c             	sub    $0xc,%esp
c0022dac:	57                   	push   %edi
c0022dad:	e8 d7 59 00 00       	call   c0028789 <list_end>
    for (donater_elem = list_begin (&l->donaters);
c0022db2:	83 c4 10             	add    $0x10,%esp
c0022db5:	39 c3                	cmp    %eax,%ebx
c0022db7:	74 16                	je     c0022dcf <notify_donation+0x6d>
        struct thread *tmp = list_entry (donater_elem, struct thread, donate_elem);
        if (tmp->priority + tmp->max_donate_delta - t->father->priority > l->max_donate_delta) {
c0022db9:	8b 43 f4             	mov    -0xc(%ebx),%eax
c0022dbc:	03 43 d4             	add    -0x2c(%ebx),%eax
c0022dbf:	8b 55 48             	mov    0x48(%ebp),%edx
c0022dc2:	2b 42 20             	sub    0x20(%edx),%eax
c0022dc5:	3b 46 ec             	cmp    -0x14(%esi),%eax
c0022dc8:	7e d1                	jle    c0022d9b <notify_donation+0x39>
          l->max_donate_delta = tmp->priority + tmp->max_donate_delta - t->father->priority;
c0022dca:	89 46 ec             	mov    %eax,-0x14(%esi)
c0022dcd:	eb cc                	jmp    c0022d9b <notify_donation+0x39>
c0022dcf:	8b 46 ec             	mov    -0x14(%esi),%eax
c0022dd2:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c0022dd6:	7d 04                	jge    c0022ddc <notify_donation+0x7a>
c0022dd8:	89 44 24 0c          	mov    %eax,0xc(%esp)
      lock_elem = list_next (lock_elem)) {
c0022ddc:	83 ec 0c             	sub    $0xc,%esp
c0022ddf:	56                   	push   %esi
c0022de0:	e8 5c 59 00 00       	call   c0028741 <list_next>
c0022de5:	89 c6                	mov    %eax,%esi
c0022de7:	83 c4 10             	add    $0x10,%esp
      lock_elem != list_end (&t->father->lock_list);
c0022dea:	83 ec 0c             	sub    $0xc,%esp
c0022ded:	8b 45 48             	mov    0x48(%ebp),%eax
c0022df0:	83 c0 30             	add    $0x30,%eax
c0022df3:	50                   	push   %eax
c0022df4:	e8 90 59 00 00       	call   c0028789 <list_end>
  for (lock_elem = list_begin (&t->father->lock_list);
c0022df9:	83 c4 10             	add    $0x10,%esp
c0022dfc:	39 c6                	cmp    %eax,%esi
c0022dfe:	74 1a                	je     c0022e1a <notify_donation+0xb8>
    l->max_donate_delta = 0;
c0022e00:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
    for (donater_elem = list_begin (&l->donaters);
c0022e07:	8d 7e f0             	lea    -0x10(%esi),%edi
c0022e0a:	83 ec 0c             	sub    $0xc,%esp
c0022e0d:	57                   	push   %edi
c0022e0e:	e8 fe 58 00 00       	call   c0028711 <list_begin>
c0022e13:	89 c3                	mov    %eax,%ebx
c0022e15:	83 c4 10             	add    $0x10,%esp
c0022e18:	eb 8f                	jmp    c0022da9 <notify_donation+0x47>
      }
    if (l->max_donate_delta > max_donate_delta) {
      max_donate_delta = l->max_donate_delta;
    }
  }
  if (t->father->max_donate_delta != max_donate_delta) {
c0022e1a:	8b 45 48             	mov    0x48(%ebp),%eax
c0022e1d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0022e21:	3b 48 40             	cmp    0x40(%eax),%ecx
c0022e24:	74 11                	je     c0022e37 <notify_donation+0xd5>
    t->father->max_donate_delta = max_donate_delta;
c0022e26:	89 48 40             	mov    %ecx,0x40(%eax)
    notify_donation(t->father);
c0022e29:	83 ec 0c             	sub    $0xc,%esp
c0022e2c:	ff 75 48             	pushl  0x48(%ebp)
c0022e2f:	e8 2e ff ff ff       	call   c0022d62 <notify_donation>
c0022e34:	83 c4 10             	add    $0x10,%esp
  }
}
c0022e37:	83 c4 1c             	add    $0x1c,%esp
c0022e3a:	5b                   	pop    %ebx
c0022e3b:	5e                   	pop    %esi
c0022e3c:	5f                   	pop    %edi
c0022e3d:	5d                   	pop    %ebp
c0022e3e:	c3                   	ret    

c0022e3f <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022e3f:	53                   	push   %ebx
c0022e40:	83 ec 08             	sub    $0x8,%esp
c0022e43:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c0022e47:	85 c0                	test   %eax,%eax
c0022e49:	74 11                	je     c0022e5c <lock_held_by_current_thread+0x1d>

  return lock->holder == thread_current ();
c0022e4b:	8b 18                	mov    (%eax),%ebx
c0022e4d:	e8 6a de ff ff       	call   c0020cbc <thread_current>
c0022e52:	39 c3                	cmp    %eax,%ebx
c0022e54:	0f 94 c0             	sete   %al
}
c0022e57:	83 c4 08             	add    $0x8,%esp
c0022e5a:	5b                   	pop    %ebx
c0022e5b:	c3                   	ret    
  ASSERT (lock != NULL);
c0022e5c:	83 ec 0c             	sub    $0xc,%esp
c0022e5f:	68 b2 0c 03 c0       	push   $0xc0030cb2
c0022e64:	68 21 01 03 c0       	push   $0xc0030121
c0022e69:	68 b4 eb 02 c0       	push   $0xc002ebb4
c0022e6e:	68 5b 01 00 00       	push   $0x15b
c0022e73:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022e78:	e8 aa 57 00 00       	call   c0028627 <debug_panic>

c0022e7d <lock_acquire>:
{
c0022e7d:	56                   	push   %esi
c0022e7e:	53                   	push   %ebx
c0022e7f:	83 ec 04             	sub    $0x4,%esp
c0022e82:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022e86:	85 db                	test   %ebx,%ebx
c0022e88:	0f 84 8f 00 00 00    	je     c0022f1d <lock_acquire+0xa0>
  ASSERT (!intr_context ());
c0022e8e:	e8 8f ed ff ff       	call   c0021c22 <intr_context>
c0022e93:	84 c0                	test   %al,%al
c0022e95:	0f 85 a3 00 00 00    	jne    c0022f3e <lock_acquire+0xc1>
  ASSERT (!lock_held_by_current_thread (lock));
c0022e9b:	83 ec 0c             	sub    $0xc,%esp
c0022e9e:	53                   	push   %ebx
c0022e9f:	e8 9b ff ff ff       	call   c0022e3f <lock_held_by_current_thread>
c0022ea4:	83 c4 10             	add    $0x10,%esp
c0022ea7:	84 c0                	test   %al,%al
c0022ea9:	0f 85 b0 00 00 00    	jne    c0022f5f <lock_acquire+0xe2>
  if (lock->holder != NULL) {
c0022eaf:	83 3b 00             	cmpl   $0x0,(%ebx)
c0022eb2:	74 40                	je     c0022ef4 <lock_acquire+0x77>
    int delta = thread_get_priority () - lock->holder->priority;
c0022eb4:	e8 f2 e0 ff ff       	call   c0020fab <thread_get_priority>
c0022eb9:	8b 13                	mov    (%ebx),%edx
c0022ebb:	2b 42 20             	sub    0x20(%edx),%eax
c0022ebe:	89 c6                	mov    %eax,%esi
    if (delta > 0) {
c0022ec0:	85 c0                	test   %eax,%eax
c0022ec2:	7e 30                	jle    c0022ef4 <lock_acquire+0x77>
      struct thread *t = thread_current ();
c0022ec4:	e8 f3 dd ff ff       	call   c0020cbc <thread_current>
      t->father = lock->holder;
c0022ec9:	8b 13                	mov    (%ebx),%edx
c0022ecb:	89 50 48             	mov    %edx,0x48(%eax)
      list_push_back(&lock->donaters, &t->donate_elem);
c0022ece:	83 ec 08             	sub    $0x8,%esp
c0022ed1:	83 c0 4c             	add    $0x4c,%eax
c0022ed4:	50                   	push   %eax
c0022ed5:	8d 43 1c             	lea    0x1c(%ebx),%eax
c0022ed8:	50                   	push   %eax
c0022ed9:	e8 3c 5c 00 00       	call   c0028b1a <list_push_back>
      if (delta > lock->max_donate_delta) {
c0022ede:	83 c4 10             	add    $0x10,%esp
c0022ee1:	3b 73 18             	cmp    0x18(%ebx),%esi
c0022ee4:	7e 03                	jle    c0022ee9 <lock_acquire+0x6c>
        lock->max_donate_delta = delta;
c0022ee6:	89 73 18             	mov    %esi,0x18(%ebx)
      if (delta > lock->holder->max_donate_delta) {
c0022ee9:	8b 03                	mov    (%ebx),%eax
c0022eeb:	3b 70 40             	cmp    0x40(%eax),%esi
c0022eee:	0f 8f 8c 00 00 00    	jg     c0022f80 <lock_acquire+0x103>
  sema_down (&lock->semaphore);
c0022ef4:	83 ec 0c             	sub    $0xc,%esp
c0022ef7:	8d 43 04             	lea    0x4(%ebx),%eax
c0022efa:	50                   	push   %eax
c0022efb:	e8 9d fb ff ff       	call   c0022a9d <sema_down>
  lock->holder = thread_current ();
c0022f00:	e8 b7 dd ff ff       	call   c0020cbc <thread_current>
c0022f05:	89 03                	mov    %eax,(%ebx)
  list_push_back (&lock->holder->lock_list, &lock->elem);
c0022f07:	83 c4 08             	add    $0x8,%esp
c0022f0a:	83 c3 2c             	add    $0x2c,%ebx
c0022f0d:	53                   	push   %ebx
c0022f0e:	83 c0 30             	add    $0x30,%eax
c0022f11:	50                   	push   %eax
c0022f12:	e8 03 5c 00 00       	call   c0028b1a <list_push_back>
}
c0022f17:	83 c4 14             	add    $0x14,%esp
c0022f1a:	5b                   	pop    %ebx
c0022f1b:	5e                   	pop    %esi
c0022f1c:	c3                   	ret    
  ASSERT (lock != NULL);
c0022f1d:	83 ec 0c             	sub    $0xc,%esp
c0022f20:	68 b2 0c 03 c0       	push   $0xc0030cb2
c0022f25:	68 21 01 03 c0       	push   $0xc0030121
c0022f2a:	68 f4 eb 02 c0       	push   $0xc002ebf4
c0022f2f:	68 fc 00 00 00       	push   $0xfc
c0022f34:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022f39:	e8 e9 56 00 00       	call   c0028627 <debug_panic>
  ASSERT (!intr_context ());
c0022f3e:	83 ec 0c             	sub    $0xc,%esp
c0022f41:	68 f0 07 03 c0       	push   $0xc00307f0
c0022f46:	68 21 01 03 c0       	push   $0xc0030121
c0022f4b:	68 f4 eb 02 c0       	push   $0xc002ebf4
c0022f50:	68 fd 00 00 00       	push   $0xfd
c0022f55:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022f5a:	e8 c8 56 00 00       	call   c0028627 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022f5f:	83 ec 0c             	sub    $0xc,%esp
c0022f62:	68 cc 0c 03 c0       	push   $0xc0030ccc
c0022f67:	68 21 01 03 c0       	push   $0xc0030121
c0022f6c:	68 f4 eb 02 c0       	push   $0xc002ebf4
c0022f71:	68 fe 00 00 00       	push   $0xfe
c0022f76:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022f7b:	e8 a7 56 00 00       	call   c0028627 <debug_panic>
        lock->holder->max_donate_delta = delta;
c0022f80:	89 70 40             	mov    %esi,0x40(%eax)
        notify_donation (lock->holder);
c0022f83:	83 ec 0c             	sub    $0xc,%esp
c0022f86:	ff 33                	pushl  (%ebx)
c0022f88:	e8 d5 fd ff ff       	call   c0022d62 <notify_donation>
c0022f8d:	83 c4 10             	add    $0x10,%esp
c0022f90:	e9 5f ff ff ff       	jmp    c0022ef4 <lock_acquire+0x77>

c0022f95 <lock_try_acquire>:
{
c0022f95:	56                   	push   %esi
c0022f96:	53                   	push   %ebx
c0022f97:	83 ec 04             	sub    $0x4,%esp
c0022f9a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022f9e:	85 db                	test   %ebx,%ebx
c0022fa0:	74 2d                	je     c0022fcf <lock_try_acquire+0x3a>
  ASSERT (!lock_held_by_current_thread (lock));
c0022fa2:	83 ec 0c             	sub    $0xc,%esp
c0022fa5:	53                   	push   %ebx
c0022fa6:	e8 94 fe ff ff       	call   c0022e3f <lock_held_by_current_thread>
c0022fab:	83 c4 10             	add    $0x10,%esp
c0022fae:	84 c0                	test   %al,%al
c0022fb0:	75 3e                	jne    c0022ff0 <lock_try_acquire+0x5b>
  success = sema_try_down (&lock->semaphore);
c0022fb2:	83 ec 0c             	sub    $0xc,%esp
c0022fb5:	8d 43 04             	lea    0x4(%ebx),%eax
c0022fb8:	50                   	push   %eax
c0022fb9:	e8 72 fb ff ff       	call   c0022b30 <sema_try_down>
c0022fbe:	89 c6                	mov    %eax,%esi
  if (success)
c0022fc0:	83 c4 10             	add    $0x10,%esp
c0022fc3:	84 c0                	test   %al,%al
c0022fc5:	75 4a                	jne    c0023011 <lock_try_acquire+0x7c>
}
c0022fc7:	89 f0                	mov    %esi,%eax
c0022fc9:	83 c4 04             	add    $0x4,%esp
c0022fcc:	5b                   	pop    %ebx
c0022fcd:	5e                   	pop    %esi
c0022fce:	c3                   	ret    
  ASSERT (lock != NULL);
c0022fcf:	83 ec 0c             	sub    $0xc,%esp
c0022fd2:	68 b2 0c 03 c0       	push   $0xc0030cb2
c0022fd7:	68 21 01 03 c0       	push   $0xc0030121
c0022fdc:	68 e0 eb 02 c0       	push   $0xc002ebe0
c0022fe1:	68 20 01 00 00       	push   $0x120
c0022fe6:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0022feb:	e8 37 56 00 00       	call   c0028627 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022ff0:	83 ec 0c             	sub    $0xc,%esp
c0022ff3:	68 cc 0c 03 c0       	push   $0xc0030ccc
c0022ff8:	68 21 01 03 c0       	push   $0xc0030121
c0022ffd:	68 e0 eb 02 c0       	push   $0xc002ebe0
c0023002:	68 21 01 00 00       	push   $0x121
c0023007:	68 5b 0c 03 c0       	push   $0xc0030c5b
c002300c:	e8 16 56 00 00       	call   c0028627 <debug_panic>
    lock->holder = thread_current ();
c0023011:	e8 a6 dc ff ff       	call   c0020cbc <thread_current>
c0023016:	89 03                	mov    %eax,(%ebx)
  return success;
c0023018:	eb ad                	jmp    c0022fc7 <lock_try_acquire+0x32>

c002301a <lock_release>:
{
c002301a:	55                   	push   %ebp
c002301b:	57                   	push   %edi
c002301c:	56                   	push   %esi
c002301d:	53                   	push   %ebx
c002301e:	83 ec 0c             	sub    $0xc,%esp
c0023021:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  ASSERT (lock != NULL);
c0023025:	85 ed                	test   %ebp,%ebp
c0023027:	74 26                	je     c002304f <lock_release+0x35>
  ASSERT (lock_held_by_current_thread (lock));
c0023029:	83 ec 0c             	sub    $0xc,%esp
c002302c:	55                   	push   %ebp
c002302d:	e8 0d fe ff ff       	call   c0022e3f <lock_held_by_current_thread>
c0023032:	83 c4 10             	add    $0x10,%esp
c0023035:	84 c0                	test   %al,%al
c0023037:	74 37                	je     c0023070 <lock_release+0x56>
  struct thread *t = lock->holder;
c0023039:	8b 7d 00             	mov    0x0(%ebp),%edi
  for (e = list_begin (&lock->donaters); e != list_end (&lock->donaters); e = list_next (e)) {
c002303c:	8d 75 1c             	lea    0x1c(%ebp),%esi
c002303f:	83 ec 0c             	sub    $0xc,%esp
c0023042:	56                   	push   %esi
c0023043:	e8 c9 56 00 00       	call   c0028711 <list_begin>
c0023048:	89 c3                	mov    %eax,%ebx
c002304a:	83 c4 10             	add    $0x10,%esp
c002304d:	eb 57                	jmp    c00230a6 <lock_release+0x8c>
  ASSERT (lock != NULL);
c002304f:	83 ec 0c             	sub    $0xc,%esp
c0023052:	68 b2 0c 03 c0       	push   $0xc0030cb2
c0023057:	68 21 01 03 c0       	push   $0xc0030121
c002305c:	68 d0 eb 02 c0       	push   $0xc002ebd0
c0023061:	68 31 01 00 00       	push   $0x131
c0023066:	68 5b 0c 03 c0       	push   $0xc0030c5b
c002306b:	e8 b7 55 00 00       	call   c0028627 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023070:	83 ec 0c             	sub    $0xc,%esp
c0023073:	68 f0 0c 03 c0       	push   $0xc0030cf0
c0023078:	68 21 01 03 c0       	push   $0xc0030121
c002307d:	68 d0 eb 02 c0       	push   $0xc002ebd0
c0023082:	68 32 01 00 00       	push   $0x132
c0023087:	68 5b 0c 03 c0       	push   $0xc0030c5b
c002308c:	e8 96 55 00 00       	call   c0028627 <debug_panic>
    list_entry (e, struct thread, donate_elem)->father = NULL;
c0023091:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
  for (e = list_begin (&lock->donaters); e != list_end (&lock->donaters); e = list_next (e)) {
c0023098:	83 ec 0c             	sub    $0xc,%esp
c002309b:	53                   	push   %ebx
c002309c:	e8 a0 56 00 00       	call   c0028741 <list_next>
c00230a1:	89 c3                	mov    %eax,%ebx
c00230a3:	83 c4 10             	add    $0x10,%esp
c00230a6:	83 ec 0c             	sub    $0xc,%esp
c00230a9:	56                   	push   %esi
c00230aa:	e8 da 56 00 00       	call   c0028789 <list_end>
c00230af:	83 c4 10             	add    $0x10,%esp
c00230b2:	39 c3                	cmp    %eax,%ebx
c00230b4:	75 db                	jne    c0023091 <lock_release+0x77>
  list_remove (&lock->elem);
c00230b6:	83 ec 0c             	sub    $0xc,%esp
c00230b9:	8d 45 2c             	lea    0x2c(%ebp),%eax
c00230bc:	50                   	push   %eax
c00230bd:	e8 75 5a 00 00       	call   c0028b37 <list_remove>
  lock->max_donate_delta = 0;
c00230c2:	c7 45 18 00 00 00 00 	movl   $0x0,0x18(%ebp)
  lock->holder = NULL;
c00230c9:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
  while (!list_empty (&lock->donaters)) {
c00230d0:	83 c4 10             	add    $0x10,%esp
c00230d3:	eb 0c                	jmp    c00230e1 <lock_release+0xc7>
    list_pop_front (&lock->donaters);
c00230d5:	83 ec 0c             	sub    $0xc,%esp
c00230d8:	56                   	push   %esi
c00230d9:	e8 46 5b 00 00       	call   c0028c24 <list_pop_front>
c00230de:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&lock->donaters)) {
c00230e1:	83 ec 0c             	sub    $0xc,%esp
c00230e4:	56                   	push   %esi
c00230e5:	e8 d8 5a 00 00       	call   c0028bc2 <list_empty>
c00230ea:	83 c4 10             	add    $0x10,%esp
c00230ed:	84 c0                	test   %al,%al
c00230ef:	74 e4                	je     c00230d5 <lock_release+0xbb>
  sema_up (&lock->semaphore);
c00230f1:	83 ec 0c             	sub    $0xc,%esp
c00230f4:	83 c5 04             	add    $0x4,%ebp
c00230f7:	55                   	push   %ebp
c00230f8:	e8 81 fa ff ff       	call   c0022b7e <sema_up>
  for (e = list_begin (&t->lock_list); e != list_end (&t->lock_list); e = list_next (e)) {
c00230fd:	8d 6f 30             	lea    0x30(%edi),%ebp
c0023100:	89 2c 24             	mov    %ebp,(%esp)
c0023103:	e8 09 56 00 00       	call   c0028711 <list_begin>
c0023108:	89 c3                	mov    %eax,%ebx
c002310a:	83 c4 10             	add    $0x10,%esp
  int max_donate_delta = 0;
c002310d:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin (&t->lock_list); e != list_end (&t->lock_list); e = list_next (e)) {
c0023112:	eb 0e                	jmp    c0023122 <lock_release+0x108>
c0023114:	83 ec 0c             	sub    $0xc,%esp
c0023117:	53                   	push   %ebx
c0023118:	e8 24 56 00 00       	call   c0028741 <list_next>
c002311d:	89 c3                	mov    %eax,%ebx
c002311f:	83 c4 10             	add    $0x10,%esp
c0023122:	83 ec 0c             	sub    $0xc,%esp
c0023125:	55                   	push   %ebp
c0023126:	e8 5e 56 00 00       	call   c0028789 <list_end>
c002312b:	83 c4 10             	add    $0x10,%esp
c002312e:	39 c3                	cmp    %eax,%ebx
c0023130:	74 0b                	je     c002313d <lock_release+0x123>
c0023132:	8b 43 ec             	mov    -0x14(%ebx),%eax
c0023135:	39 c6                	cmp    %eax,%esi
c0023137:	7d db                	jge    c0023114 <lock_release+0xfa>
c0023139:	89 c6                	mov    %eax,%esi
c002313b:	eb d7                	jmp    c0023114 <lock_release+0xfa>
  if (t->max_donate_delta != max_donate_delta) {
c002313d:	3b 77 40             	cmp    0x40(%edi),%esi
c0023140:	74 0f                	je     c0023151 <lock_release+0x137>
    t->max_donate_delta = max_donate_delta;
c0023142:	89 77 40             	mov    %esi,0x40(%edi)
    notify_donation (t);
c0023145:	83 ec 0c             	sub    $0xc,%esp
c0023148:	57                   	push   %edi
c0023149:	e8 14 fc ff ff       	call   c0022d62 <notify_donation>
c002314e:	83 c4 10             	add    $0x10,%esp
  if (t->max_donate_delta == 0 && t->priority_to_set > -1) {
c0023151:	83 7f 40 00          	cmpl   $0x0,0x40(%edi)
c0023155:	75 11                	jne    c0023168 <lock_release+0x14e>
c0023157:	8b 47 44             	mov    0x44(%edi),%eax
c002315a:	85 c0                	test   %eax,%eax
c002315c:	78 0a                	js     c0023168 <lock_release+0x14e>
    t->priority = t->priority_to_set;
c002315e:	89 47 20             	mov    %eax,0x20(%edi)
    t->priority_to_set = -1;
c0023161:	c7 47 44 ff ff ff ff 	movl   $0xffffffff,0x44(%edi)
  thread_check_switch();
c0023168:	e8 95 e3 ff ff       	call   c0021502 <thread_check_switch>
}
c002316d:	83 c4 0c             	add    $0xc,%esp
c0023170:	5b                   	pop    %ebx
c0023171:	5e                   	pop    %esi
c0023172:	5f                   	pop    %edi
c0023173:	5d                   	pop    %ebp
c0023174:	c3                   	ret    

c0023175 <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0023175:	83 ec 0c             	sub    $0xc,%esp
c0023178:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (cond != NULL);
c002317c:	85 c0                	test   %eax,%eax
c002317e:	74 0d                	je     c002318d <cond_init+0x18>

  list_init (&cond->waiters);
c0023180:	83 ec 0c             	sub    $0xc,%esp
c0023183:	50                   	push   %eax
c0023184:	e8 45 55 00 00       	call   c00286ce <list_init>
}
c0023189:	83 c4 1c             	add    $0x1c,%esp
c002318c:	c3                   	ret    
  ASSERT (cond != NULL);
c002318d:	83 ec 0c             	sub    $0xc,%esp
c0023190:	68 bf 0c 03 c0       	push   $0xc0030cbf
c0023195:	68 21 01 03 c0       	push   $0xc0030121
c002319a:	68 a8 eb 02 c0       	push   $0xc002eba8
c002319f:	68 6e 01 00 00       	push   $0x16e
c00231a4:	68 5b 0c 03 c0       	push   $0xc0030c5b
c00231a9:	e8 79 54 00 00       	call   c0028627 <debug_panic>

c00231ae <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c00231ae:	55                   	push   %ebp
c00231af:	57                   	push   %edi
c00231b0:	56                   	push   %esi
c00231b1:	53                   	push   %ebx
c00231b2:	83 ec 2c             	sub    $0x2c,%esp
c00231b5:	8b 74 24 40          	mov    0x40(%esp),%esi
c00231b9:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c00231bd:	85 f6                	test   %esi,%esi
c00231bf:	74 6f                	je     c0023230 <cond_wait+0x82>
  ASSERT (lock != NULL);
c00231c1:	85 db                	test   %ebx,%ebx
c00231c3:	0f 84 88 00 00 00    	je     c0023251 <cond_wait+0xa3>
  ASSERT (!intr_context ());
c00231c9:	e8 54 ea ff ff       	call   c0021c22 <intr_context>
c00231ce:	84 c0                	test   %al,%al
c00231d0:	0f 85 9c 00 00 00    	jne    c0023272 <cond_wait+0xc4>
  ASSERT (lock_held_by_current_thread (lock));
c00231d6:	83 ec 0c             	sub    $0xc,%esp
c00231d9:	53                   	push   %ebx
c00231da:	e8 60 fc ff ff       	call   c0022e3f <lock_held_by_current_thread>
c00231df:	83 c4 10             	add    $0x10,%esp
c00231e2:	84 c0                	test   %al,%al
c00231e4:	0f 84 a9 00 00 00    	je     c0023293 <cond_wait+0xe5>
  
  sema_init (&waiter.semaphore, 0);
c00231ea:	83 ec 08             	sub    $0x8,%esp
c00231ed:	6a 00                	push   $0x0
c00231ef:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c00231f3:	8d 7c 24 14          	lea    0x14(%esp),%edi
c00231f7:	57                   	push   %edi
c00231f8:	e8 32 f8 ff ff       	call   c0022a2f <sema_init>
  list_push_back (&cond->waiters, &waiter.elem);
c00231fd:	83 c4 08             	add    $0x8,%esp
c0023200:	55                   	push   %ebp
c0023201:	56                   	push   %esi
c0023202:	e8 13 59 00 00       	call   c0028b1a <list_push_back>
  lock_release (lock);
c0023207:	89 1c 24             	mov    %ebx,(%esp)
c002320a:	e8 0b fe ff ff       	call   c002301a <lock_release>
  waiter.pthread = thread_current();
c002320f:	e8 a8 da ff ff       	call   c0020cbc <thread_current>
c0023214:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  sema_down (&waiter.semaphore);
c0023218:	89 3c 24             	mov    %edi,(%esp)
c002321b:	e8 7d f8 ff ff       	call   c0022a9d <sema_down>
  lock_acquire (lock);
c0023220:	89 1c 24             	mov    %ebx,(%esp)
c0023223:	e8 55 fc ff ff       	call   c0022e7d <lock_acquire>
}
c0023228:	83 c4 3c             	add    $0x3c,%esp
c002322b:	5b                   	pop    %ebx
c002322c:	5e                   	pop    %esi
c002322d:	5f                   	pop    %edi
c002322e:	5d                   	pop    %ebp
c002322f:	c3                   	ret    
  ASSERT (cond != NULL);
c0023230:	83 ec 0c             	sub    $0xc,%esp
c0023233:	68 bf 0c 03 c0       	push   $0xc0030cbf
c0023238:	68 21 01 03 c0       	push   $0xc0030121
c002323d:	68 9c eb 02 c0       	push   $0xc002eb9c
c0023242:	68 8c 01 00 00       	push   $0x18c
c0023247:	68 5b 0c 03 c0       	push   $0xc0030c5b
c002324c:	e8 d6 53 00 00       	call   c0028627 <debug_panic>
  ASSERT (lock != NULL);
c0023251:	83 ec 0c             	sub    $0xc,%esp
c0023254:	68 b2 0c 03 c0       	push   $0xc0030cb2
c0023259:	68 21 01 03 c0       	push   $0xc0030121
c002325e:	68 9c eb 02 c0       	push   $0xc002eb9c
c0023263:	68 8d 01 00 00       	push   $0x18d
c0023268:	68 5b 0c 03 c0       	push   $0xc0030c5b
c002326d:	e8 b5 53 00 00       	call   c0028627 <debug_panic>
  ASSERT (!intr_context ());
c0023272:	83 ec 0c             	sub    $0xc,%esp
c0023275:	68 f0 07 03 c0       	push   $0xc00307f0
c002327a:	68 21 01 03 c0       	push   $0xc0030121
c002327f:	68 9c eb 02 c0       	push   $0xc002eb9c
c0023284:	68 8e 01 00 00       	push   $0x18e
c0023289:	68 5b 0c 03 c0       	push   $0xc0030c5b
c002328e:	e8 94 53 00 00       	call   c0028627 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023293:	83 ec 0c             	sub    $0xc,%esp
c0023296:	68 f0 0c 03 c0       	push   $0xc0030cf0
c002329b:	68 21 01 03 c0       	push   $0xc0030121
c00232a0:	68 9c eb 02 c0       	push   $0xc002eb9c
c00232a5:	68 8f 01 00 00       	push   $0x18f
c00232aa:	68 5b 0c 03 c0       	push   $0xc0030c5b
c00232af:	e8 73 53 00 00       	call   c0028627 <debug_panic>

c00232b4 <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c00232b4:	55                   	push   %ebp
c00232b5:	57                   	push   %edi
c00232b6:	56                   	push   %esi
c00232b7:	53                   	push   %ebx
c00232b8:	83 ec 0c             	sub    $0xc,%esp
c00232bb:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c00232bf:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  ASSERT (cond != NULL);
c00232c3:	85 ed                	test   %ebp,%ebp
c00232c5:	74 3f                	je     c0023306 <cond_signal+0x52>
  ASSERT (lock != NULL);
c00232c7:	85 db                	test   %ebx,%ebx
c00232c9:	74 5c                	je     c0023327 <cond_signal+0x73>
  ASSERT (!intr_context ());
c00232cb:	e8 52 e9 ff ff       	call   c0021c22 <intr_context>
c00232d0:	84 c0                	test   %al,%al
c00232d2:	75 74                	jne    c0023348 <cond_signal+0x94>
  ASSERT (lock_held_by_current_thread (lock));
c00232d4:	83 ec 0c             	sub    $0xc,%esp
c00232d7:	53                   	push   %ebx
c00232d8:	e8 62 fb ff ff       	call   c0022e3f <lock_held_by_current_thread>
c00232dd:	83 c4 10             	add    $0x10,%esp
c00232e0:	84 c0                	test   %al,%al
c00232e2:	0f 84 81 00 00 00    	je     c0023369 <cond_signal+0xb5>

  if (!list_empty (&cond->waiters)) {
c00232e8:	89 ef                	mov    %ebp,%edi
c00232ea:	83 ec 0c             	sub    $0xc,%esp
c00232ed:	55                   	push   %ebp
c00232ee:	e8 cf 58 00 00       	call   c0028bc2 <list_empty>
c00232f3:	83 c4 10             	add    $0x10,%esp
c00232f6:	84 c0                	test   %al,%al
c00232f8:	0f 84 8c 00 00 00    	je     c002338a <cond_signal+0xd6>
        sema_up (&t->semaphore);
        break;
      }
    }
  }
}
c00232fe:	83 c4 0c             	add    $0xc,%esp
c0023301:	5b                   	pop    %ebx
c0023302:	5e                   	pop    %esi
c0023303:	5f                   	pop    %edi
c0023304:	5d                   	pop    %ebp
c0023305:	c3                   	ret    
  ASSERT (cond != NULL);
c0023306:	83 ec 0c             	sub    $0xc,%esp
c0023309:	68 bf 0c 03 c0       	push   $0xc0030cbf
c002330e:	68 21 01 03 c0       	push   $0xc0030121
c0023313:	68 90 eb 02 c0       	push   $0xc002eb90
c0023318:	68 a3 01 00 00       	push   $0x1a3
c002331d:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0023322:	e8 00 53 00 00       	call   c0028627 <debug_panic>
  ASSERT (lock != NULL);
c0023327:	83 ec 0c             	sub    $0xc,%esp
c002332a:	68 b2 0c 03 c0       	push   $0xc0030cb2
c002332f:	68 21 01 03 c0       	push   $0xc0030121
c0023334:	68 90 eb 02 c0       	push   $0xc002eb90
c0023339:	68 a4 01 00 00       	push   $0x1a4
c002333e:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0023343:	e8 df 52 00 00       	call   c0028627 <debug_panic>
  ASSERT (!intr_context ());
c0023348:	83 ec 0c             	sub    $0xc,%esp
c002334b:	68 f0 07 03 c0       	push   $0xc00307f0
c0023350:	68 21 01 03 c0       	push   $0xc0030121
c0023355:	68 90 eb 02 c0       	push   $0xc002eb90
c002335a:	68 a5 01 00 00       	push   $0x1a5
c002335f:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0023364:	e8 be 52 00 00       	call   c0028627 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023369:	83 ec 0c             	sub    $0xc,%esp
c002336c:	68 f0 0c 03 c0       	push   $0xc0030cf0
c0023371:	68 21 01 03 c0       	push   $0xc0030121
c0023376:	68 90 eb 02 c0       	push   $0xc002eb90
c002337b:	68 a6 01 00 00       	push   $0x1a6
c0023380:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0023385:	e8 9d 52 00 00       	call   c0028627 <debug_panic>
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c002338a:	83 ec 0c             	sub    $0xc,%esp
c002338d:	55                   	push   %ebp
c002338e:	e8 7e 53 00 00       	call   c0028711 <list_begin>
c0023393:	89 c3                	mov    %eax,%ebx
c0023395:	83 c4 10             	add    $0x10,%esp
    int maxp = -1, tmpp;
c0023398:	be ff ff ff ff       	mov    $0xffffffff,%esi
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c002339d:	eb 0e                	jmp    c00233ad <cond_signal+0xf9>
              e = list_next (e)) {
c002339f:	83 ec 0c             	sub    $0xc,%esp
c00233a2:	53                   	push   %ebx
c00233a3:	e8 99 53 00 00       	call   c0028741 <list_next>
c00233a8:	89 c3                	mov    %eax,%ebx
c00233aa:	83 c4 10             	add    $0x10,%esp
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c00233ad:	83 ec 0c             	sub    $0xc,%esp
c00233b0:	57                   	push   %edi
c00233b1:	e8 d3 53 00 00       	call   c0028789 <list_end>
c00233b6:	83 c4 10             	add    $0x10,%esp
c00233b9:	39 c3                	cmp    %eax,%ebx
c00233bb:	74 16                	je     c00233d3 <cond_signal+0x11f>
      tmpp = thread_get_certain_priority(t->pthread);
c00233bd:	83 ec 0c             	sub    $0xc,%esp
c00233c0:	ff 73 1c             	pushl  0x1c(%ebx)
c00233c3:	e8 cb db ff ff       	call   c0020f93 <thread_get_certain_priority>
c00233c8:	83 c4 10             	add    $0x10,%esp
c00233cb:	39 c6                	cmp    %eax,%esi
c00233cd:	7d d0                	jge    c002339f <cond_signal+0xeb>
c00233cf:	89 c6                	mov    %eax,%esi
c00233d1:	eb cc                	jmp    c002339f <cond_signal+0xeb>
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c00233d3:	83 ec 0c             	sub    $0xc,%esp
c00233d6:	55                   	push   %ebp
c00233d7:	e8 35 53 00 00       	call   c0028711 <list_begin>
c00233dc:	89 c3                	mov    %eax,%ebx
c00233de:	83 c4 10             	add    $0x10,%esp
c00233e1:	83 ec 0c             	sub    $0xc,%esp
c00233e4:	57                   	push   %edi
c00233e5:	e8 9f 53 00 00       	call   c0028789 <list_end>
c00233ea:	83 c4 10             	add    $0x10,%esp
c00233ed:	39 c3                	cmp    %eax,%ebx
c00233ef:	0f 84 09 ff ff ff    	je     c00232fe <cond_signal+0x4a>
      tmpp = thread_get_certain_priority(t->pthread);
c00233f5:	83 ec 0c             	sub    $0xc,%esp
c00233f8:	ff 73 1c             	pushl  0x1c(%ebx)
c00233fb:	e8 93 db ff ff       	call   c0020f93 <thread_get_certain_priority>
      if (tmpp == maxp) {
c0023400:	83 c4 10             	add    $0x10,%esp
c0023403:	39 c6                	cmp    %eax,%esi
c0023405:	74 10                	je     c0023417 <cond_signal+0x163>
              e = list_next (e)) {
c0023407:	83 ec 0c             	sub    $0xc,%esp
c002340a:	53                   	push   %ebx
c002340b:	e8 31 53 00 00       	call   c0028741 <list_next>
c0023410:	89 c3                	mov    %eax,%ebx
c0023412:	83 c4 10             	add    $0x10,%esp
c0023415:	eb ca                	jmp    c00233e1 <cond_signal+0x12d>
        list_remove (e);
c0023417:	83 ec 0c             	sub    $0xc,%esp
c002341a:	53                   	push   %ebx
c002341b:	e8 17 57 00 00       	call   c0028b37 <list_remove>
        sema_up (&t->semaphore);
c0023420:	83 c3 08             	add    $0x8,%ebx
c0023423:	89 1c 24             	mov    %ebx,(%esp)
c0023426:	e8 53 f7 ff ff       	call   c0022b7e <sema_up>
        break;
c002342b:	83 c4 10             	add    $0x10,%esp
c002342e:	e9 cb fe ff ff       	jmp    c00232fe <cond_signal+0x4a>

c0023433 <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0023433:	56                   	push   %esi
c0023434:	53                   	push   %ebx
c0023435:	83 ec 04             	sub    $0x4,%esp
c0023438:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002343c:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (cond != NULL);
c0023440:	85 db                	test   %ebx,%ebx
c0023442:	74 25                	je     c0023469 <cond_broadcast+0x36>
  ASSERT (lock != NULL);
c0023444:	85 f6                	test   %esi,%esi
c0023446:	75 4f                	jne    c0023497 <cond_broadcast+0x64>
c0023448:	83 ec 0c             	sub    $0xc,%esp
c002344b:	68 b2 0c 03 c0       	push   $0xc0030cb2
c0023450:	68 21 01 03 c0       	push   $0xc0030121
c0023455:	68 80 eb 02 c0       	push   $0xc002eb80
c002345a:	68 ca 01 00 00       	push   $0x1ca
c002345f:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0023464:	e8 be 51 00 00       	call   c0028627 <debug_panic>
  ASSERT (cond != NULL);
c0023469:	83 ec 0c             	sub    $0xc,%esp
c002346c:	68 bf 0c 03 c0       	push   $0xc0030cbf
c0023471:	68 21 01 03 c0       	push   $0xc0030121
c0023476:	68 80 eb 02 c0       	push   $0xc002eb80
c002347b:	68 c9 01 00 00       	push   $0x1c9
c0023480:	68 5b 0c 03 c0       	push   $0xc0030c5b
c0023485:	e8 9d 51 00 00       	call   c0028627 <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c002348a:	83 ec 08             	sub    $0x8,%esp
c002348d:	56                   	push   %esi
c002348e:	53                   	push   %ebx
c002348f:	e8 20 fe ff ff       	call   c00232b4 <cond_signal>
c0023494:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c0023497:	83 ec 0c             	sub    $0xc,%esp
c002349a:	53                   	push   %ebx
c002349b:	e8 22 57 00 00       	call   c0028bc2 <list_empty>
c00234a0:	83 c4 10             	add    $0x10,%esp
c00234a3:	84 c0                	test   %al,%al
c00234a5:	74 e3                	je     c002348a <cond_broadcast+0x57>
}
c00234a7:	83 c4 04             	add    $0x4,%esp
c00234aa:	5b                   	pop    %ebx
c00234ab:	5e                   	pop    %esi
c00234ac:	c3                   	ret    

c00234ad <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c00234ad:	55                   	push   %ebp
c00234ae:	57                   	push   %edi
c00234af:	56                   	push   %esi
c00234b0:	53                   	push   %ebx
c00234b1:	83 ec 18             	sub    $0x18,%esp
c00234b4:	89 c5                	mov    %eax,%ebp
c00234b6:	89 d7                	mov    %edx,%edi
c00234b8:	89 ce                	mov    %ecx,%esi
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c00234ba:	51                   	push   %ecx
c00234bb:	e8 c3 5d 00 00       	call   c0029283 <bitmap_buf_size>
c00234c0:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
c00234c6:	89 d8                	mov    %ebx,%eax
c00234c8:	c1 e8 0c             	shr    $0xc,%eax
  if (bm_pages > page_cnt)
c00234cb:	83 c4 10             	add    $0x10,%esp
c00234ce:	39 c6                	cmp    %eax,%esi
c00234d0:	72 3d                	jb     c002350f <init_pool+0x62>
    PANIC ("Not enough memory in %s for bitmap.", name);
  page_cnt -= bm_pages;
c00234d2:	29 c6                	sub    %eax,%esi

  printf ("%zu pages available in %s.\n", page_cnt, name);
c00234d4:	83 ec 04             	sub    $0x4,%esp
c00234d7:	ff 74 24 24          	pushl  0x24(%esp)
c00234db:	56                   	push   %esi
c00234dc:	68 7f 0d 03 c0       	push   $0xc0030d7f
c00234e1:	e8 93 36 00 00       	call   c0026b79 <printf>

  /* Initialize the pool. */
  lock_init (&p->lock);
c00234e6:	89 2c 24             	mov    %ebp,(%esp)
c00234e9:	e8 1b f8 ff ff       	call   c0022d09 <lock_init>
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c00234ee:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c00234f4:	83 c4 0c             	add    $0xc,%esp
c00234f7:	53                   	push   %ebx
c00234f8:	57                   	push   %edi
c00234f9:	56                   	push   %esi
c00234fa:	e8 5d 60 00 00       	call   c002955c <bitmap_create_in_buf>
c00234ff:	89 45 34             	mov    %eax,0x34(%ebp)
  p->base = base + bm_pages * PGSIZE;
c0023502:	01 df                	add    %ebx,%edi
c0023504:	89 7d 38             	mov    %edi,0x38(%ebp)
}
c0023507:	83 c4 1c             	add    $0x1c,%esp
c002350a:	5b                   	pop    %ebx
c002350b:	5e                   	pop    %esi
c002350c:	5f                   	pop    %edi
c002350d:	5d                   	pop    %ebp
c002350e:	c3                   	ret    
    PANIC ("Not enough memory in %s for bitmap.", name);
c002350f:	83 ec 0c             	sub    $0xc,%esp
c0023512:	ff 74 24 2c          	pushl  0x2c(%esp)
c0023516:	68 14 0d 03 c0       	push   $0xc0030d14
c002351b:	68 64 ec 02 c0       	push   $0xc002ec64
c0023520:	68 a1 00 00 00       	push   $0xa1
c0023525:	68 68 0d 03 c0       	push   $0xc0030d68
c002352a:	e8 f8 50 00 00       	call   c0028627 <debug_panic>

c002352f <palloc_init>:
{
c002352f:	56                   	push   %esi
c0023530:	53                   	push   %ebx
c0023531:	83 ec 04             	sub    $0x4,%esp
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c0023534:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c0023539:	c1 e0 0c             	shl    $0xc,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c002353c:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0023541:	77 5b                	ja     c002359e <palloc_init+0x6f>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0023543:	2d 00 00 10 00       	sub    $0x100000,%eax
c0023548:	89 c3                	mov    %eax,%ebx
c002354a:	85 c0                	test   %eax,%eax
c002354c:	78 6e                	js     c00235bc <palloc_init+0x8d>
c002354e:	c1 fb 0c             	sar    $0xc,%ebx
  size_t user_pages = free_pages / 2;
c0023551:	89 d8                	mov    %ebx,%eax
c0023553:	d1 e8                	shr    %eax
c0023555:	89 c6                	mov    %eax,%esi
c0023557:	3b 44 24 10          	cmp    0x10(%esp),%eax
c002355b:	76 04                	jbe    c0023561 <palloc_init+0x32>
c002355d:	8b 74 24 10          	mov    0x10(%esp),%esi
  kernel_pages = free_pages - user_pages;
c0023561:	29 f3                	sub    %esi,%ebx
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023563:	83 ec 0c             	sub    $0xc,%esp
c0023566:	68 b6 0d 03 c0       	push   $0xc0030db6
c002356b:	89 d9                	mov    %ebx,%ecx
c002356d:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c0023572:	b8 00 c7 03 c0       	mov    $0xc003c700,%eax
c0023577:	e8 31 ff ff ff       	call   c00234ad <init_pool>
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c002357c:	c1 e3 0c             	shl    $0xc,%ebx
c002357f:	8d 93 00 00 10 c0    	lea    -0x3ff00000(%ebx),%edx
c0023585:	c7 04 24 c2 0d 03 c0 	movl   $0xc0030dc2,(%esp)
c002358c:	89 f1                	mov    %esi,%ecx
c002358e:	b8 c0 c6 03 c0       	mov    $0xc003c6c0,%eax
c0023593:	e8 15 ff ff ff       	call   c00234ad <init_pool>
}
c0023598:	83 c4 14             	add    $0x14,%esp
c002359b:	5b                   	pop    %ebx
c002359c:	5e                   	pop    %esi
c002359d:	c3                   	ret    
c002359e:	83 ec 0c             	sub    $0xc,%esp
c00235a1:	68 9b 0d 03 c0       	push   $0xc0030d9b
c00235a6:	68 21 01 03 c0       	push   $0xc0030121
c00235ab:	68 70 ec 02 c0       	push   $0xc002ec70
c00235b0:	6a 4a                	push   $0x4a
c00235b2:	68 64 01 03 c0       	push   $0xc0030164
c00235b7:	e8 6b 50 00 00       	call   c0028627 <debug_panic>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c00235bc:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
c00235c2:	eb 8a                	jmp    c002354e <palloc_init+0x1f>

c00235c4 <palloc_get_multiple>:
{
c00235c4:	57                   	push   %edi
c00235c5:	56                   	push   %esi
c00235c6:	53                   	push   %ebx
c00235c7:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c00235cb:	f6 44 24 10 04       	testb  $0x4,0x10(%esp)
c00235d0:	75 47                	jne    c0023619 <palloc_get_multiple+0x55>
c00235d2:	bb 00 c7 03 c0       	mov    $0xc003c700,%ebx
  if (page_cnt == 0)
c00235d7:	85 ff                	test   %edi,%edi
c00235d9:	74 76                	je     c0023651 <palloc_get_multiple+0x8d>
  lock_acquire (&pool->lock);
c00235db:	83 ec 0c             	sub    $0xc,%esp
c00235de:	53                   	push   %ebx
c00235df:	e8 99 f8 ff ff       	call   c0022e7d <lock_acquire>
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c00235e4:	6a 00                	push   $0x0
c00235e6:	57                   	push   %edi
c00235e7:	6a 00                	push   $0x0
c00235e9:	ff 73 34             	pushl  0x34(%ebx)
c00235ec:	e8 3a 62 00 00       	call   c002982b <bitmap_scan_and_flip>
c00235f1:	89 c6                	mov    %eax,%esi
  lock_release (&pool->lock);
c00235f3:	83 c4 14             	add    $0x14,%esp
c00235f6:	53                   	push   %ebx
c00235f7:	e8 1e fa ff ff       	call   c002301a <lock_release>
  if (page_idx != BITMAP_ERROR)
c00235fc:	83 c4 10             	add    $0x10,%esp
c00235ff:	83 fe ff             	cmp    $0xffffffff,%esi
c0023602:	74 29                	je     c002362d <palloc_get_multiple+0x69>
    pages = pool->base + PGSIZE * page_idx;
c0023604:	c1 e6 0c             	shl    $0xc,%esi
  if (pages != NULL) 
c0023607:	03 73 38             	add    0x38(%ebx),%esi
c002360a:	74 21                	je     c002362d <palloc_get_multiple+0x69>
      if (flags & PAL_ZERO)
c002360c:	f6 44 24 10 02       	testb  $0x2,0x10(%esp)
c0023611:	75 0d                	jne    c0023620 <palloc_get_multiple+0x5c>
}
c0023613:	89 f0                	mov    %esi,%eax
c0023615:	5b                   	pop    %ebx
c0023616:	5e                   	pop    %esi
c0023617:	5f                   	pop    %edi
c0023618:	c3                   	ret    
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0023619:	bb c0 c6 03 c0       	mov    $0xc003c6c0,%ebx
c002361e:	eb b7                	jmp    c00235d7 <palloc_get_multiple+0x13>
        memset (pages, 0, PGSIZE * page_cnt);
c0023620:	89 f9                	mov    %edi,%ecx
c0023622:	c1 e1 0c             	shl    $0xc,%ecx
c0023625:	b0 00                	mov    $0x0,%al
c0023627:	89 f7                	mov    %esi,%edi
c0023629:	f3 aa                	rep stos %al,%es:(%edi)
c002362b:	eb e6                	jmp    c0023613 <palloc_get_multiple+0x4f>
      if (flags & PAL_ASSERT)
c002362d:	f6 44 24 10 01       	testb  $0x1,0x10(%esp)
c0023632:	75 07                	jne    c002363b <palloc_get_multiple+0x77>
  return pages;
c0023634:	be 00 00 00 00       	mov    $0x0,%esi
c0023639:	eb d8                	jmp    c0023613 <palloc_get_multiple+0x4f>
        PANIC ("palloc_get: out of pages");
c002363b:	68 cc 0d 03 c0       	push   $0xc0030dcc
c0023640:	68 50 ec 02 c0       	push   $0xc002ec50
c0023645:	6a 61                	push   $0x61
c0023647:	68 68 0d 03 c0       	push   $0xc0030d68
c002364c:	e8 d6 4f 00 00       	call   c0028627 <debug_panic>
    return NULL;
c0023651:	be 00 00 00 00       	mov    $0x0,%esi
c0023656:	eb bb                	jmp    c0023613 <palloc_get_multiple+0x4f>

c0023658 <palloc_get_page>:
{
c0023658:	83 ec 14             	sub    $0x14,%esp
  return palloc_get_multiple (flags, 1);
c002365b:	6a 01                	push   $0x1
c002365d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023661:	e8 5e ff ff ff       	call   c00235c4 <palloc_get_multiple>
}
c0023666:	83 c4 1c             	add    $0x1c,%esp
c0023669:	c3                   	ret    

c002366a <palloc_free_multiple>:
{
c002366a:	55                   	push   %ebp
c002366b:	57                   	push   %edi
c002366c:	56                   	push   %esi
c002366d:	53                   	push   %ebx
c002366e:	83 ec 0c             	sub    $0xc,%esp
c0023671:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  ASSERT (pg_ofs (pages) == 0);
c0023675:	f7 44 24 20 ff 0f 00 	testl  $0xfff,0x20(%esp)
c002367c:	00 
c002367d:	75 13                	jne    c0023692 <palloc_free_multiple+0x28>
  if (pages == NULL || page_cnt == 0)
c002367f:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0023684:	74 04                	je     c002368a <palloc_free_multiple+0x20>
c0023686:	85 db                	test   %ebx,%ebx
c0023688:	75 26                	jne    c00236b0 <palloc_free_multiple+0x46>
}
c002368a:	83 c4 0c             	add    $0xc,%esp
c002368d:	5b                   	pop    %ebx
c002368e:	5e                   	pop    %esi
c002368f:	5f                   	pop    %edi
c0023690:	5d                   	pop    %ebp
c0023691:	c3                   	ret    
  ASSERT (pg_ofs (pages) == 0);
c0023692:	83 ec 0c             	sub    $0xc,%esp
c0023695:	68 e5 0d 03 c0       	push   $0xc0030de5
c002369a:	68 21 01 03 c0       	push   $0xc0030121
c002369f:	68 38 ec 02 c0       	push   $0xc002ec38
c00236a4:	6a 7b                	push   $0x7b
c00236a6:	68 68 0d 03 c0       	push   $0xc0030d68
c00236ab:	e8 77 4f 00 00       	call   c0028627 <debug_panic>
  return (uintptr_t) va >> PGBITS;
c00236b0:	8b 74 24 20          	mov    0x20(%esp),%esi
c00236b4:	c1 ee 0c             	shr    $0xc,%esi
c00236b7:	8b 2d 38 c7 03 c0    	mov    0xc003c738,%ebp
c00236bd:	c1 ed 0c             	shr    $0xc,%ebp
static bool
page_from_pool (const struct pool *pool, void *page) 
{
  size_t page_no = pg_no (page);
  size_t start_page = pg_no (pool->base);
  size_t end_page = start_page + bitmap_size (pool->used_map);
c00236c0:	83 ec 0c             	sub    $0xc,%esp
c00236c3:	ff 35 34 c7 03 c0    	pushl  0xc003c734
c00236c9:	e8 ee 5b 00 00       	call   c00292bc <bitmap_size>

  return page_no >= start_page && page_no < end_page;
c00236ce:	83 c4 10             	add    $0x10,%esp
c00236d1:	39 ee                	cmp    %ebp,%esi
c00236d3:	72 06                	jb     c00236db <palloc_free_multiple+0x71>
  size_t end_page = start_page + bitmap_size (pool->used_map);
c00236d5:	01 c5                	add    %eax,%ebp
  return page_no >= start_page && page_no < end_page;
c00236d7:	39 ee                	cmp    %ebp,%esi
c00236d9:	72 44                	jb     c002371f <palloc_free_multiple+0xb5>
c00236db:	8b 2d f8 c6 03 c0    	mov    0xc003c6f8,%ebp
c00236e1:	c1 ed 0c             	shr    $0xc,%ebp
  size_t end_page = start_page + bitmap_size (pool->used_map);
c00236e4:	83 ec 0c             	sub    $0xc,%esp
c00236e7:	ff 35 f4 c6 03 c0    	pushl  0xc003c6f4
c00236ed:	e8 ca 5b 00 00       	call   c00292bc <bitmap_size>
  return page_no >= start_page && page_no < end_page;
c00236f2:	83 c4 10             	add    $0x10,%esp
c00236f5:	39 ee                	cmp    %ebp,%esi
c00236f7:	73 19                	jae    c0023712 <palloc_free_multiple+0xa8>
    NOT_REACHED ();
c00236f9:	68 84 08 03 c0       	push   $0xc0030884
c00236fe:	68 38 ec 02 c0       	push   $0xc002ec38
c0023703:	68 84 00 00 00       	push   $0x84
c0023708:	68 68 0d 03 c0       	push   $0xc0030d68
c002370d:	e8 15 4f 00 00       	call   c0028627 <debug_panic>
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023712:	01 e8                	add    %ebp,%eax
  return page_no >= start_page && page_no < end_page;
c0023714:	39 c6                	cmp    %eax,%esi
c0023716:	73 e1                	jae    c00236f9 <palloc_free_multiple+0x8f>
    pool = &user_pool;
c0023718:	bd c0 c6 03 c0       	mov    $0xc003c6c0,%ebp
c002371d:	eb 05                	jmp    c0023724 <palloc_free_multiple+0xba>
    pool = &kernel_pool;
c002371f:	bd 00 c7 03 c0       	mov    $0xc003c700,%ebp
c0023724:	8b 45 38             	mov    0x38(%ebp),%eax
c0023727:	c1 e8 0c             	shr    $0xc,%eax
  page_idx = pg_no (pages) - pg_no (pool->base);
c002372a:	29 c6                	sub    %eax,%esi
  memset (pages, 0xcc, PGSIZE * page_cnt);
c002372c:	89 d9                	mov    %ebx,%ecx
c002372e:	c1 e1 0c             	shl    $0xc,%ecx
c0023731:	b0 cc                	mov    $0xcc,%al
c0023733:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0023737:	f3 aa                	rep stos %al,%es:(%edi)
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023739:	83 ec 04             	sub    $0x4,%esp
c002373c:	53                   	push   %ebx
c002373d:	56                   	push   %esi
c002373e:	ff 75 34             	pushl  0x34(%ebp)
c0023741:	e8 18 60 00 00       	call   c002975e <bitmap_all>
c0023746:	83 c4 10             	add    $0x10,%esp
c0023749:	84 c0                	test   %al,%al
c002374b:	74 14                	je     c0023761 <palloc_free_multiple+0xf7>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c002374d:	6a 00                	push   $0x0
c002374f:	53                   	push   %ebx
c0023750:	56                   	push   %esi
c0023751:	ff 75 34             	pushl  0x34(%ebp)
c0023754:	e8 b0 5c 00 00       	call   c0029409 <bitmap_set_multiple>
c0023759:	83 c4 10             	add    $0x10,%esp
c002375c:	e9 29 ff ff ff       	jmp    c002368a <palloc_free_multiple+0x20>
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023761:	83 ec 0c             	sub    $0xc,%esp
c0023764:	68 38 0d 03 c0       	push   $0xc0030d38
c0023769:	68 21 01 03 c0       	push   $0xc0030121
c002376e:	68 38 ec 02 c0       	push   $0xc002ec38
c0023773:	68 8c 00 00 00       	push   $0x8c
c0023778:	68 68 0d 03 c0       	push   $0xc0030d68
c002377d:	e8 a5 4e 00 00       	call   c0028627 <debug_panic>

c0023782 <palloc_free_page>:
{
c0023782:	83 ec 14             	sub    $0x14,%esp
  palloc_free_multiple (page, 1);
c0023785:	6a 01                	push   $0x1
c0023787:	ff 74 24 1c          	pushl  0x1c(%esp)
c002378b:	e8 da fe ff ff       	call   c002366a <palloc_free_multiple>
}
c0023790:	83 c4 1c             	add    $0x1c,%esp
c0023793:	c3                   	ret    

c0023794 <arena_to_block>:
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c0023794:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (a != NULL);
c0023797:	85 c0                	test   %eax,%eax
c0023799:	74 1b                	je     c00237b6 <arena_to_block+0x22>
  ASSERT (a->magic == ARENA_MAGIC);
c002379b:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c00237a1:	75 34                	jne    c00237d7 <arena_to_block+0x43>
  ASSERT (idx < a->desc->blocks_per_arena);
c00237a3:	8b 48 04             	mov    0x4(%eax),%ecx
c00237a6:	39 51 04             	cmp    %edx,0x4(%ecx)
c00237a9:	76 4d                	jbe    c00237f8 <arena_to_block+0x64>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c00237ab:	0f af 11             	imul   (%ecx),%edx
  return (struct block *) ((uint8_t *) a
c00237ae:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c00237b2:	83 c4 0c             	add    $0xc,%esp
c00237b5:	c3                   	ret    
  ASSERT (a != NULL);
c00237b6:	83 ec 0c             	sub    $0xc,%esp
c00237b9:	68 51 0c 03 c0       	push   $0xc0030c51
c00237be:	68 21 01 03 c0       	push   $0xc0030121
c00237c3:	68 90 ec 02 c0       	push   $0xc002ec90
c00237c8:	68 20 01 00 00       	push   $0x120
c00237cd:	68 f9 0d 03 c0       	push   $0xc0030df9
c00237d2:	e8 50 4e 00 00       	call   c0028627 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00237d7:	83 ec 0c             	sub    $0xc,%esp
c00237da:	68 10 0e 03 c0       	push   $0xc0030e10
c00237df:	68 21 01 03 c0       	push   $0xc0030121
c00237e4:	68 90 ec 02 c0       	push   $0xc002ec90
c00237e9:	68 21 01 00 00       	push   $0x121
c00237ee:	68 f9 0d 03 c0       	push   $0xc0030df9
c00237f3:	e8 2f 4e 00 00       	call   c0028627 <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c00237f8:	83 ec 0c             	sub    $0xc,%esp
c00237fb:	68 28 0e 03 c0       	push   $0xc0030e28
c0023800:	68 21 01 03 c0       	push   $0xc0030121
c0023805:	68 90 ec 02 c0       	push   $0xc002ec90
c002380a:	68 22 01 00 00       	push   $0x122
c002380f:	68 f9 0d 03 c0       	push   $0xc0030df9
c0023814:	e8 0e 4e 00 00       	call   c0028627 <debug_panic>

c0023819 <block_to_arena>:
{
c0023819:	53                   	push   %ebx
c002381a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c002381d:	89 c1                	mov    %eax,%ecx
c002381f:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0023825:	74 29                	je     c0023850 <block_to_arena+0x37>
  ASSERT (a->magic == ARENA_MAGIC);
c0023827:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c002382d:	75 42                	jne    c0023871 <block_to_arena+0x58>
  ASSERT (a->desc == NULL
c002382f:	8b 59 04             	mov    0x4(%ecx),%ebx
c0023832:	85 db                	test   %ebx,%ebx
c0023834:	74 7d                	je     c00238b3 <block_to_arena+0x9a>
  return (uintptr_t) va & PGMASK;
c0023836:	25 ff 0f 00 00       	and    $0xfff,%eax
c002383b:	83 e8 0c             	sub    $0xc,%eax
c002383e:	ba 00 00 00 00       	mov    $0x0,%edx
c0023843:	f7 33                	divl   (%ebx)
c0023845:	85 d2                	test   %edx,%edx
c0023847:	75 49                	jne    c0023892 <block_to_arena+0x79>
}
c0023849:	89 c8                	mov    %ecx,%eax
c002384b:	83 c4 08             	add    $0x8,%esp
c002384e:	5b                   	pop    %ebx
c002384f:	c3                   	ret    
  ASSERT (a != NULL);
c0023850:	83 ec 0c             	sub    $0xc,%esp
c0023853:	68 51 0c 03 c0       	push   $0xc0030c51
c0023858:	68 21 01 03 c0       	push   $0xc0030121
c002385d:	68 80 ec 02 c0       	push   $0xc002ec80
c0023862:	68 11 01 00 00       	push   $0x111
c0023867:	68 f9 0d 03 c0       	push   $0xc0030df9
c002386c:	e8 b6 4d 00 00       	call   c0028627 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023871:	83 ec 0c             	sub    $0xc,%esp
c0023874:	68 10 0e 03 c0       	push   $0xc0030e10
c0023879:	68 21 01 03 c0       	push   $0xc0030121
c002387e:	68 80 ec 02 c0       	push   $0xc002ec80
c0023883:	68 12 01 00 00       	push   $0x112
c0023888:	68 f9 0d 03 c0       	push   $0xc0030df9
c002388d:	e8 95 4d 00 00       	call   c0028627 <debug_panic>
  ASSERT (a->desc == NULL
c0023892:	83 ec 0c             	sub    $0xc,%esp
c0023895:	68 48 0e 03 c0       	push   $0xc0030e48
c002389a:	68 21 01 03 c0       	push   $0xc0030121
c002389f:	68 80 ec 02 c0       	push   $0xc002ec80
c00238a4:	68 16 01 00 00       	push   $0x116
c00238a9:	68 f9 0d 03 c0       	push   $0xc0030df9
c00238ae:	e8 74 4d 00 00       	call   c0028627 <debug_panic>
c00238b3:	25 ff 0f 00 00       	and    $0xfff,%eax
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c00238b8:	83 f8 0c             	cmp    $0xc,%eax
c00238bb:	74 8c                	je     c0023849 <block_to_arena+0x30>
c00238bd:	83 ec 0c             	sub    $0xc,%esp
c00238c0:	68 90 0e 03 c0       	push   $0xc0030e90
c00238c5:	68 21 01 03 c0       	push   $0xc0030121
c00238ca:	68 80 ec 02 c0       	push   $0xc002ec80
c00238cf:	68 17 01 00 00       	push   $0x117
c00238d4:	68 f9 0d 03 c0       	push   $0xc0030df9
c00238d9:	e8 49 4d 00 00       	call   c0028627 <debug_panic>

c00238de <malloc_init>:
{
c00238de:	55                   	push   %ebp
c00238df:	57                   	push   %edi
c00238e0:	56                   	push   %esi
c00238e1:	53                   	push   %ebx
c00238e2:	83 ec 0c             	sub    $0xc,%esp
      struct desc *d = &descs[desc_cnt++];
c00238e5:	a1 40 c7 03 c0       	mov    0xc003c740,%eax
c00238ea:	8d 50 01             	lea    0x1(%eax),%edx
c00238ed:	89 15 40 c7 03 c0    	mov    %edx,0xc003c740
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00238f3:	83 fa 0a             	cmp    $0xa,%edx
c00238f6:	0f 87 b4 00 00 00    	ja     c00239b0 <malloc_init+0xd2>
      d->block_size = block_size;
c00238fc:	8d 1c c0             	lea    (%eax,%eax,8),%ebx
c00238ff:	01 db                	add    %ebx,%ebx
c0023901:	8d 14 03             	lea    (%ebx,%eax,1),%edx
c0023904:	c1 e2 02             	shl    $0x2,%edx
c0023907:	c7 82 60 c7 03 c0 10 	movl   $0x10,-0x3ffc38a0(%edx)
c002390e:	00 00 00 
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023911:	c7 82 64 c7 03 c0 ff 	movl   $0xff,-0x3ffc389c(%edx)
c0023918:	00 00 00 
c002391b:	89 d3                	mov    %edx,%ebx
      list_init (&d->free_list);
c002391d:	83 ec 0c             	sub    $0xc,%esp
c0023920:	8d 82 68 c7 03 c0    	lea    -0x3ffc3898(%edx),%eax
c0023926:	50                   	push   %eax
c0023927:	e8 a2 4d 00 00       	call   c00286ce <list_init>
      lock_init (&d->lock);
c002392c:	81 c3 78 c7 03 c0    	add    $0xc003c778,%ebx
c0023932:	89 1c 24             	mov    %ebx,(%esp)
c0023935:	e8 cf f3 ff ff       	call   c0022d09 <lock_init>
c002393a:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c002393d:	be 20 00 00 00       	mov    $0x20,%esi
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023942:	bf f4 0f 00 00       	mov    $0xff4,%edi
      struct desc *d = &descs[desc_cnt++];
c0023947:	8b 0d 40 c7 03 c0    	mov    0xc003c740,%ecx
c002394d:	8d 41 01             	lea    0x1(%ecx),%eax
c0023950:	a3 40 c7 03 c0       	mov    %eax,0xc003c740
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023955:	83 f8 0a             	cmp    $0xa,%eax
c0023958:	77 56                	ja     c00239b0 <malloc_init+0xd2>
      d->block_size = block_size;
c002395a:	8d 1c c9             	lea    (%ecx,%ecx,8),%ebx
c002395d:	01 db                	add    %ebx,%ebx
c002395f:	8d 2c 0b             	lea    (%ebx,%ecx,1),%ebp
c0023962:	c1 e5 02             	shl    $0x2,%ebp
c0023965:	89 b5 60 c7 03 c0    	mov    %esi,-0x3ffc38a0(%ebp)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c002396b:	89 f8                	mov    %edi,%eax
c002396d:	ba 00 00 00 00       	mov    $0x0,%edx
c0023972:	f7 f6                	div    %esi
c0023974:	89 85 64 c7 03 c0    	mov    %eax,-0x3ffc389c(%ebp)
c002397a:	89 eb                	mov    %ebp,%ebx
      list_init (&d->free_list);
c002397c:	83 ec 0c             	sub    $0xc,%esp
c002397f:	8d 85 68 c7 03 c0    	lea    -0x3ffc3898(%ebp),%eax
c0023985:	50                   	push   %eax
c0023986:	e8 43 4d 00 00       	call   c00286ce <list_init>
      lock_init (&d->lock);
c002398b:	81 c3 78 c7 03 c0    	add    $0xc003c778,%ebx
c0023991:	89 1c 24             	mov    %ebx,(%esp)
c0023994:	e8 70 f3 ff ff       	call   c0022d09 <lock_init>
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023999:	8d 04 36             	lea    (%esi,%esi,1),%eax
c002399c:	89 c6                	mov    %eax,%esi
c002399e:	83 c4 10             	add    $0x10,%esp
c00239a1:	3d ff 07 00 00       	cmp    $0x7ff,%eax
c00239a6:	76 9f                	jbe    c0023947 <malloc_init+0x69>
}
c00239a8:	83 c4 0c             	add    $0xc,%esp
c00239ab:	5b                   	pop    %ebx
c00239ac:	5e                   	pop    %esi
c00239ad:	5f                   	pop    %edi
c00239ae:	5d                   	pop    %ebp
c00239af:	c3                   	ret    
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00239b0:	83 ec 0c             	sub    $0xc,%esp
c00239b3:	68 bc 0e 03 c0       	push   $0xc0030ebc
c00239b8:	68 21 01 03 c0       	push   $0xc0030121
c00239bd:	68 a0 ec 02 c0       	push   $0xc002eca0
c00239c2:	6a 4f                	push   $0x4f
c00239c4:	68 f9 0d 03 c0       	push   $0xc0030df9
c00239c9:	e8 59 4c 00 00       	call   c0028627 <debug_panic>

c00239ce <malloc>:
{
c00239ce:	55                   	push   %ebp
c00239cf:	57                   	push   %edi
c00239d0:	56                   	push   %esi
c00239d1:	53                   	push   %ebx
c00239d2:	83 ec 1c             	sub    $0x1c,%esp
c00239d5:	8b 44 24 30          	mov    0x30(%esp),%eax
  if (size == 0)
c00239d9:	85 c0                	test   %eax,%eax
c00239db:	0f 84 2e 01 00 00    	je     c0023b0f <malloc+0x141>
  for (d = descs; d < descs + desc_cnt; d++)
c00239e1:	8b 0d 40 c7 03 c0    	mov    0xc003c740,%ecx
c00239e7:	8d 14 c9             	lea    (%ecx,%ecx,8),%edx
c00239ea:	01 d2                	add    %edx,%edx
c00239ec:	01 ca                	add    %ecx,%edx
c00239ee:	8d 14 95 60 c7 03 c0 	lea    -0x3ffc38a0(,%edx,4),%edx
c00239f5:	81 fa 60 c7 03 c0    	cmp    $0xc003c760,%edx
c00239fb:	0f 86 bb 00 00 00    	jbe    c0023abc <malloc+0xee>
    if (d->block_size >= size)
c0023a01:	3b 05 60 c7 03 c0    	cmp    0xc003c760,%eax
c0023a07:	0f 86 10 01 00 00    	jbe    c0023b1d <malloc+0x14f>
c0023a0d:	bb 60 c7 03 c0       	mov    $0xc003c760,%ebx
  for (d = descs; d < descs + desc_cnt; d++)
c0023a12:	83 c3 4c             	add    $0x4c,%ebx
c0023a15:	39 d3                	cmp    %edx,%ebx
c0023a17:	0f 83 a4 00 00 00    	jae    c0023ac1 <malloc+0xf3>
    if (d->block_size >= size)
c0023a1d:	3b 03                	cmp    (%ebx),%eax
c0023a1f:	77 f1                	ja     c0023a12 <malloc+0x44>
  lock_acquire (&d->lock);
c0023a21:	8d 43 18             	lea    0x18(%ebx),%eax
c0023a24:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0023a28:	83 ec 0c             	sub    $0xc,%esp
c0023a2b:	50                   	push   %eax
c0023a2c:	e8 4c f4 ff ff       	call   c0022e7d <lock_acquire>
  if (list_empty (&d->free_list))
c0023a31:	8d 7b 08             	lea    0x8(%ebx),%edi
c0023a34:	89 3c 24             	mov    %edi,(%esp)
c0023a37:	e8 86 51 00 00       	call   c0028bc2 <list_empty>
c0023a3c:	83 c4 10             	add    $0x10,%esp
c0023a3f:	84 c0                	test   %al,%al
c0023a41:	74 4d                	je     c0023a90 <malloc+0xc2>
      a = palloc_get_page (0);
c0023a43:	83 ec 0c             	sub    $0xc,%esp
c0023a46:	6a 00                	push   $0x0
c0023a48:	e8 0b fc ff ff       	call   c0023658 <palloc_get_page>
c0023a4d:	89 c5                	mov    %eax,%ebp
      if (a == NULL) 
c0023a4f:	83 c4 10             	add    $0x10,%esp
c0023a52:	85 c0                	test   %eax,%eax
c0023a54:	0f 84 9f 00 00 00    	je     c0023af9 <malloc+0x12b>
      a->magic = ARENA_MAGIC;
c0023a5a:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c0023a60:	89 58 04             	mov    %ebx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c0023a63:	8b 43 04             	mov    0x4(%ebx),%eax
c0023a66:	89 45 08             	mov    %eax,0x8(%ebp)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023a69:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0023a6d:	74 21                	je     c0023a90 <malloc+0xc2>
c0023a6f:	be 00 00 00 00       	mov    $0x0,%esi
          struct block *b = arena_to_block (a, i);
c0023a74:	89 f2                	mov    %esi,%edx
c0023a76:	89 e8                	mov    %ebp,%eax
c0023a78:	e8 17 fd ff ff       	call   c0023794 <arena_to_block>
          list_push_back (&d->free_list, &b->free_elem);
c0023a7d:	83 ec 08             	sub    $0x8,%esp
c0023a80:	50                   	push   %eax
c0023a81:	57                   	push   %edi
c0023a82:	e8 93 50 00 00       	call   c0028b1a <list_push_back>
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023a87:	46                   	inc    %esi
c0023a88:	83 c4 10             	add    $0x10,%esp
c0023a8b:	39 73 04             	cmp    %esi,0x4(%ebx)
c0023a8e:	77 e4                	ja     c0023a74 <malloc+0xa6>
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023a90:	83 ec 0c             	sub    $0xc,%esp
c0023a93:	57                   	push   %edi
c0023a94:	e8 8b 51 00 00       	call   c0028c24 <list_pop_front>
c0023a99:	89 c3                	mov    %eax,%ebx
  a = block_to_arena (b);
c0023a9b:	e8 79 fd ff ff       	call   c0023819 <block_to_arena>
  a->free_cnt--;
c0023aa0:	ff 48 08             	decl   0x8(%eax)
  lock_release (&d->lock);
c0023aa3:	83 c4 04             	add    $0x4,%esp
c0023aa6:	ff 74 24 18          	pushl  0x18(%esp)
c0023aaa:	e8 6b f5 ff ff       	call   c002301a <lock_release>
  return b;
c0023aaf:	83 c4 10             	add    $0x10,%esp
c0023ab2:	89 d8                	mov    %ebx,%eax
}
c0023ab4:	83 c4 1c             	add    $0x1c,%esp
c0023ab7:	5b                   	pop    %ebx
c0023ab8:	5e                   	pop    %esi
c0023ab9:	5f                   	pop    %edi
c0023aba:	5d                   	pop    %ebp
c0023abb:	c3                   	ret    
  for (d = descs; d < descs + desc_cnt; d++)
c0023abc:	bb 60 c7 03 c0       	mov    $0xc003c760,%ebx
  if (d == descs + desc_cnt) 
c0023ac1:	39 da                	cmp    %ebx,%edx
c0023ac3:	0f 85 58 ff ff ff    	jne    c0023a21 <malloc+0x53>
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c0023ac9:	8d 98 0b 10 00 00    	lea    0x100b(%eax),%ebx
c0023acf:	c1 eb 0c             	shr    $0xc,%ebx
      a = palloc_get_multiple (0, page_cnt);
c0023ad2:	83 ec 08             	sub    $0x8,%esp
c0023ad5:	53                   	push   %ebx
c0023ad6:	6a 00                	push   $0x0
c0023ad8:	e8 e7 fa ff ff       	call   c00235c4 <palloc_get_multiple>
      if (a == NULL)
c0023add:	83 c4 10             	add    $0x10,%esp
c0023ae0:	85 c0                	test   %eax,%eax
c0023ae2:	74 32                	je     c0023b16 <malloc+0x148>
      a->magic = ARENA_MAGIC;
c0023ae4:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c0023aea:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023af1:	89 58 08             	mov    %ebx,0x8(%eax)
      return a + 1;
c0023af4:	83 c0 0c             	add    $0xc,%eax
c0023af7:	eb bb                	jmp    c0023ab4 <malloc+0xe6>
          lock_release (&d->lock);
c0023af9:	83 ec 0c             	sub    $0xc,%esp
c0023afc:	ff 74 24 18          	pushl  0x18(%esp)
c0023b00:	e8 15 f5 ff ff       	call   c002301a <lock_release>
          return NULL; 
c0023b05:	83 c4 10             	add    $0x10,%esp
c0023b08:	b8 00 00 00 00       	mov    $0x0,%eax
c0023b0d:	eb a5                	jmp    c0023ab4 <malloc+0xe6>
    return NULL;
c0023b0f:	b8 00 00 00 00       	mov    $0x0,%eax
c0023b14:	eb 9e                	jmp    c0023ab4 <malloc+0xe6>
        return NULL;
c0023b16:	b8 00 00 00 00       	mov    $0x0,%eax
c0023b1b:	eb 97                	jmp    c0023ab4 <malloc+0xe6>
    if (d->block_size >= size)
c0023b1d:	bb 60 c7 03 c0       	mov    $0xc003c760,%ebx
c0023b22:	e9 fa fe ff ff       	jmp    c0023a21 <malloc+0x53>

c0023b27 <calloc>:
{
c0023b27:	57                   	push   %edi
c0023b28:	53                   	push   %ebx
c0023b29:	83 ec 04             	sub    $0x4,%esp
c0023b2c:	8b 44 24 10          	mov    0x10(%esp),%eax
  size = a * b;
c0023b30:	89 c3                	mov    %eax,%ebx
c0023b32:	0f af 5c 24 14       	imul   0x14(%esp),%ebx
  if (size < a || size < b)
c0023b37:	39 d8                	cmp    %ebx,%eax
c0023b39:	77 28                	ja     c0023b63 <calloc+0x3c>
c0023b3b:	39 5c 24 14          	cmp    %ebx,0x14(%esp)
c0023b3f:	77 29                	ja     c0023b6a <calloc+0x43>
  p = malloc (size);
c0023b41:	83 ec 0c             	sub    $0xc,%esp
c0023b44:	53                   	push   %ebx
c0023b45:	e8 84 fe ff ff       	call   c00239ce <malloc>
c0023b4a:	89 c2                	mov    %eax,%edx
  if (p != NULL)
c0023b4c:	83 c4 10             	add    $0x10,%esp
c0023b4f:	85 c0                	test   %eax,%eax
c0023b51:	74 08                	je     c0023b5b <calloc+0x34>
    memset (p, 0, size);
c0023b53:	b0 00                	mov    $0x0,%al
c0023b55:	89 d7                	mov    %edx,%edi
c0023b57:	89 d9                	mov    %ebx,%ecx
c0023b59:	f3 aa                	rep stos %al,%es:(%edi)
}
c0023b5b:	89 d0                	mov    %edx,%eax
c0023b5d:	83 c4 04             	add    $0x4,%esp
c0023b60:	5b                   	pop    %ebx
c0023b61:	5f                   	pop    %edi
c0023b62:	c3                   	ret    
    return NULL;
c0023b63:	ba 00 00 00 00       	mov    $0x0,%edx
c0023b68:	eb f1                	jmp    c0023b5b <calloc+0x34>
c0023b6a:	ba 00 00 00 00       	mov    $0x0,%edx
c0023b6f:	eb ea                	jmp    c0023b5b <calloc+0x34>

c0023b71 <free>:
{
c0023b71:	55                   	push   %ebp
c0023b72:	57                   	push   %edi
c0023b73:	56                   	push   %esi
c0023b74:	53                   	push   %ebx
c0023b75:	83 ec 0c             	sub    $0xc,%esp
c0023b78:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  if (p != NULL)
c0023b7c:	85 ed                	test   %ebp,%ebp
c0023b7e:	0f 84 86 00 00 00    	je     c0023c0a <free+0x99>
      struct arena *a = block_to_arena (b);
c0023b84:	89 e8                	mov    %ebp,%eax
c0023b86:	e8 8e fc ff ff       	call   c0023819 <block_to_arena>
c0023b8b:	89 c6                	mov    %eax,%esi
      struct desc *d = a->desc;
c0023b8d:	8b 58 04             	mov    0x4(%eax),%ebx
      if (d != NULL) 
c0023b90:	85 db                	test   %ebx,%ebx
c0023b92:	0f 84 9b 00 00 00    	je     c0023c33 <free+0xc2>
          memset (b, 0xcc, d->block_size);
c0023b98:	8b 0b                	mov    (%ebx),%ecx
c0023b9a:	b0 cc                	mov    $0xcc,%al
c0023b9c:	89 ef                	mov    %ebp,%edi
c0023b9e:	f3 aa                	rep stos %al,%es:(%edi)
          lock_acquire (&d->lock);
c0023ba0:	8d 7b 18             	lea    0x18(%ebx),%edi
c0023ba3:	83 ec 0c             	sub    $0xc,%esp
c0023ba6:	57                   	push   %edi
c0023ba7:	e8 d1 f2 ff ff       	call   c0022e7d <lock_acquire>
          list_push_front (&d->free_list, &b->free_elem);
c0023bac:	83 c4 08             	add    $0x8,%esp
c0023baf:	55                   	push   %ebp
c0023bb0:	8d 43 08             	lea    0x8(%ebx),%eax
c0023bb3:	50                   	push   %eax
c0023bb4:	e8 44 4f 00 00       	call   c0028afd <list_push_front>
          if (++a->free_cnt >= d->blocks_per_arena) 
c0023bb9:	8b 46 08             	mov    0x8(%esi),%eax
c0023bbc:	40                   	inc    %eax
c0023bbd:	89 46 08             	mov    %eax,0x8(%esi)
c0023bc0:	8b 53 04             	mov    0x4(%ebx),%edx
c0023bc3:	83 c4 10             	add    $0x10,%esp
c0023bc6:	39 d0                	cmp    %edx,%eax
c0023bc8:	72 34                	jb     c0023bfe <free+0x8d>
              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023bca:	39 d0                	cmp    %edx,%eax
c0023bcc:	75 44                	jne    c0023c12 <free+0xa1>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023bce:	bd 00 00 00 00       	mov    $0x0,%ebp
c0023bd3:	85 c0                	test   %eax,%eax
c0023bd5:	74 1b                	je     c0023bf2 <free+0x81>
                  struct block *b = arena_to_block (a, i);
c0023bd7:	89 ea                	mov    %ebp,%edx
c0023bd9:	89 f0                	mov    %esi,%eax
c0023bdb:	e8 b4 fb ff ff       	call   c0023794 <arena_to_block>
                  list_remove (&b->free_elem);
c0023be0:	83 ec 0c             	sub    $0xc,%esp
c0023be3:	50                   	push   %eax
c0023be4:	e8 4e 4f 00 00       	call   c0028b37 <list_remove>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023be9:	45                   	inc    %ebp
c0023bea:	83 c4 10             	add    $0x10,%esp
c0023bed:	39 6b 04             	cmp    %ebp,0x4(%ebx)
c0023bf0:	77 e5                	ja     c0023bd7 <free+0x66>
              palloc_free_page (a);
c0023bf2:	83 ec 0c             	sub    $0xc,%esp
c0023bf5:	56                   	push   %esi
c0023bf6:	e8 87 fb ff ff       	call   c0023782 <palloc_free_page>
c0023bfb:	83 c4 10             	add    $0x10,%esp
          lock_release (&d->lock);
c0023bfe:	83 ec 0c             	sub    $0xc,%esp
c0023c01:	57                   	push   %edi
c0023c02:	e8 13 f4 ff ff       	call   c002301a <lock_release>
c0023c07:	83 c4 10             	add    $0x10,%esp
}
c0023c0a:	83 c4 0c             	add    $0xc,%esp
c0023c0d:	5b                   	pop    %ebx
c0023c0e:	5e                   	pop    %esi
c0023c0f:	5f                   	pop    %edi
c0023c10:	5d                   	pop    %ebp
c0023c11:	c3                   	ret    
              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023c12:	83 ec 0c             	sub    $0xc,%esp
c0023c15:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0023c1a:	68 21 01 03 c0       	push   $0xc0030121
c0023c1f:	68 78 ec 02 c0       	push   $0xc002ec78
c0023c24:	68 f6 00 00 00       	push   $0xf6
c0023c29:	68 f9 0d 03 c0       	push   $0xc0030df9
c0023c2e:	e8 f4 49 00 00       	call   c0028627 <debug_panic>
          palloc_free_multiple (a, a->free_cnt);
c0023c33:	83 ec 08             	sub    $0x8,%esp
c0023c36:	ff 70 08             	pushl  0x8(%eax)
c0023c39:	50                   	push   %eax
c0023c3a:	e8 2b fa ff ff       	call   c002366a <palloc_free_multiple>
          return;
c0023c3f:	83 c4 10             	add    $0x10,%esp
c0023c42:	eb c6                	jmp    c0023c0a <free+0x99>

c0023c44 <realloc>:
{
c0023c44:	55                   	push   %ebp
c0023c45:	57                   	push   %edi
c0023c46:	56                   	push   %esi
c0023c47:	53                   	push   %ebx
c0023c48:	83 ec 0c             	sub    $0xc,%esp
c0023c4b:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0023c4f:	8b 74 24 24          	mov    0x24(%esp),%esi
  if (new_size == 0) 
c0023c53:	85 f6                	test   %esi,%esi
c0023c55:	74 4a                	je     c0023ca1 <realloc+0x5d>
      void *new_block = malloc (new_size);
c0023c57:	83 ec 0c             	sub    $0xc,%esp
c0023c5a:	56                   	push   %esi
c0023c5b:	e8 6e fd ff ff       	call   c00239ce <malloc>
c0023c60:	89 c5                	mov    %eax,%ebp
      if (old_block != NULL && new_block != NULL)
c0023c62:	83 c4 10             	add    $0x10,%esp
c0023c65:	85 db                	test   %ebx,%ebx
c0023c67:	74 2e                	je     c0023c97 <realloc+0x53>
c0023c69:	85 c0                	test   %eax,%eax
c0023c6b:	74 2a                	je     c0023c97 <realloc+0x53>
  struct arena *a = block_to_arena (b);
c0023c6d:	89 d8                	mov    %ebx,%eax
c0023c6f:	e8 a5 fb ff ff       	call   c0023819 <block_to_arena>
  struct desc *d = a->desc;
c0023c74:	8b 50 04             	mov    0x4(%eax),%edx
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023c77:	85 d2                	test   %edx,%edx
c0023c79:	74 39                	je     c0023cb4 <realloc+0x70>
c0023c7b:	8b 02                	mov    (%edx),%eax
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023c7d:	89 f1                	mov    %esi,%ecx
c0023c7f:	39 c6                	cmp    %eax,%esi
c0023c81:	76 02                	jbe    c0023c85 <realloc+0x41>
c0023c83:	89 c1                	mov    %eax,%ecx
          memcpy (new_block, old_block, min_size);
c0023c85:	89 ef                	mov    %ebp,%edi
c0023c87:	89 de                	mov    %ebx,%esi
c0023c89:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
          free (old_block);
c0023c8b:	83 ec 0c             	sub    $0xc,%esp
c0023c8e:	53                   	push   %ebx
c0023c8f:	e8 dd fe ff ff       	call   c0023b71 <free>
c0023c94:	83 c4 10             	add    $0x10,%esp
}
c0023c97:	89 e8                	mov    %ebp,%eax
c0023c99:	83 c4 0c             	add    $0xc,%esp
c0023c9c:	5b                   	pop    %ebx
c0023c9d:	5e                   	pop    %esi
c0023c9e:	5f                   	pop    %edi
c0023c9f:	5d                   	pop    %ebp
c0023ca0:	c3                   	ret    
      free (old_block);
c0023ca1:	83 ec 0c             	sub    $0xc,%esp
c0023ca4:	53                   	push   %ebx
c0023ca5:	e8 c7 fe ff ff       	call   c0023b71 <free>
      return NULL;
c0023caa:	83 c4 10             	add    $0x10,%esp
c0023cad:	bd 00 00 00 00       	mov    $0x0,%ebp
c0023cb2:	eb e3                	jmp    c0023c97 <realloc+0x53>
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023cb4:	8b 40 08             	mov    0x8(%eax),%eax
c0023cb7:	c1 e0 0c             	shl    $0xc,%eax
c0023cba:	89 da                	mov    %ebx,%edx
c0023cbc:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0023cc2:	29 d0                	sub    %edx,%eax
c0023cc4:	eb b7                	jmp    c0023c7d <realloc+0x39>

c0023cc6 <fixed32_init>:

#include "fixed_point.h"
const int FLOAT_POINT = 1 << 14;

struct fixed32 fixed32_init(int32_t x) {
c0023cc6:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {x * FLOAT_POINT};
c0023cca:	8b 54 24 08          	mov    0x8(%esp),%edx
c0023cce:	c1 e2 0e             	shl    $0xe,%edx
c0023cd1:	89 10                	mov    %edx,(%eax)
  return res;
}
c0023cd3:	c2 04 00             	ret    $0x4

c0023cd6 <fixed32_trunc>:
  } else {
    printf("-%d.%03d", -num / 1000, -num % 1000);
  }
}

int32_t fixed32_trunc(struct fixed32 a) {
c0023cd6:	8b 54 24 04          	mov    0x4(%esp),%edx
  return a.num / FLOAT_POINT;
c0023cda:	89 d0                	mov    %edx,%eax
c0023cdc:	85 d2                	test   %edx,%edx
c0023cde:	78 04                	js     c0023ce4 <fixed32_trunc+0xe>
c0023ce0:	c1 f8 0e             	sar    $0xe,%eax
}
c0023ce3:	c3                   	ret    
  return a.num / FLOAT_POINT;
c0023ce4:	8d 82 ff 3f 00 00    	lea    0x3fff(%edx),%eax
c0023cea:	eb f4                	jmp    c0023ce0 <fixed32_trunc+0xa>

c0023cec <fixed32_round>:

int32_t fixed32_round(struct fixed32 a) {
c0023cec:	8b 54 24 04          	mov    0x4(%esp),%edx
  /* int div round to zero */
  return (a.num + ((a.num >= 0) ? 1 : -1) * (FLOAT_POINT >> 1)) / FLOAT_POINT;
c0023cf0:	89 d0                	mov    %edx,%eax
c0023cf2:	c1 f8 1f             	sar    $0x1f,%eax
c0023cf5:	25 00 c0 ff ff       	and    $0xffffc000,%eax
c0023cfa:	8d 94 10 00 20 00 00 	lea    0x2000(%eax,%edx,1),%edx
c0023d01:	89 d0                	mov    %edx,%eax
c0023d03:	85 d2                	test   %edx,%edx
c0023d05:	78 04                	js     c0023d0b <fixed32_round+0x1f>
c0023d07:	c1 f8 0e             	sar    $0xe,%eax
}
c0023d0a:	c3                   	ret    
  return (a.num + ((a.num >= 0) ? 1 : -1) * (FLOAT_POINT >> 1)) / FLOAT_POINT;
c0023d0b:	8d 82 ff 3f 00 00    	lea    0x3fff(%edx),%eax
c0023d11:	eb f4                	jmp    c0023d07 <fixed32_round+0x1b>

c0023d13 <fixed32_print>:
void fixed32_print(struct fixed32 a) {
c0023d13:	53                   	push   %ebx
c0023d14:	83 ec 08             	sub    $0x8,%esp
c0023d17:	8b 44 24 10          	mov    0x10(%esp),%eax
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
  return res;
}

struct fixed32 fixed32_mul_int(struct fixed32 a, int32_t b) {
  struct fixed32 res = {a.num * b};
c0023d1b:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023d1e:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023d21:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023d24:	c1 e0 03             	shl    $0x3,%eax
  int num = fixed32_round(fixed32_mul_int(a, 1000));
c0023d27:	50                   	push   %eax
c0023d28:	e8 bf ff ff ff       	call   c0023cec <fixed32_round>
c0023d2d:	83 c4 04             	add    $0x4,%esp
c0023d30:	89 c1                	mov    %eax,%ecx
  if (num >= 0) {
c0023d32:	85 c0                	test   %eax,%eax
c0023d34:	78 30                	js     c0023d66 <fixed32_print+0x53>
    printf("%d.%03d", num / 1000, num % 1000);
c0023d36:	83 ec 04             	sub    $0x4,%esp
c0023d39:	bb e8 03 00 00       	mov    $0x3e8,%ebx
c0023d3e:	99                   	cltd   
c0023d3f:	f7 fb                	idiv   %ebx
c0023d41:	52                   	push   %edx
c0023d42:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c0023d47:	f7 e9                	imul   %ecx
c0023d49:	89 d0                	mov    %edx,%eax
c0023d4b:	c1 f8 06             	sar    $0x6,%eax
c0023d4e:	c1 f9 1f             	sar    $0x1f,%ecx
c0023d51:	29 c8                	sub    %ecx,%eax
c0023d53:	50                   	push   %eax
c0023d54:	68 0c 0f 03 c0       	push   $0xc0030f0c
c0023d59:	e8 1b 2e 00 00       	call   c0026b79 <printf>
c0023d5e:	83 c4 10             	add    $0x10,%esp
}
c0023d61:	83 c4 08             	add    $0x8,%esp
c0023d64:	5b                   	pop    %ebx
c0023d65:	c3                   	ret    
    printf("-%d.%03d", -num / 1000, -num % 1000);
c0023d66:	f7 d9                	neg    %ecx
c0023d68:	83 ec 04             	sub    $0x4,%esp
c0023d6b:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c0023d70:	f7 e9                	imul   %ecx
c0023d72:	89 d0                	mov    %edx,%eax
c0023d74:	c1 f8 06             	sar    $0x6,%eax
c0023d77:	89 ca                	mov    %ecx,%edx
c0023d79:	c1 fa 1f             	sar    $0x1f,%edx
c0023d7c:	29 d0                	sub    %edx,%eax
c0023d7e:	8d 14 80             	lea    (%eax,%eax,4),%edx
c0023d81:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0023d84:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0023d87:	c1 e2 03             	shl    $0x3,%edx
c0023d8a:	29 d1                	sub    %edx,%ecx
c0023d8c:	51                   	push   %ecx
c0023d8d:	50                   	push   %eax
c0023d8e:	68 0b 0f 03 c0       	push   $0xc0030f0b
c0023d93:	e8 e1 2d 00 00       	call   c0026b79 <printf>
c0023d98:	83 c4 10             	add    $0x10,%esp
}
c0023d9b:	eb c4                	jmp    c0023d61 <fixed32_print+0x4e>

c0023d9d <fixed32_add>:
struct fixed32 fixed32_add(struct fixed32 a, struct fixed32 b) {
c0023d9d:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num + b.num};
c0023da1:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023da5:	03 54 24 08          	add    0x8(%esp),%edx
c0023da9:	89 10                	mov    %edx,(%eax)
}
c0023dab:	c2 04 00             	ret    $0x4

c0023dae <fixed32_add_int>:
struct fixed32 fixed32_add_int(struct fixed32 a, int32_t b) {
c0023dae:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num + b * FLOAT_POINT};
c0023db2:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023db6:	c1 e2 0e             	shl    $0xe,%edx
c0023db9:	03 54 24 08          	add    0x8(%esp),%edx
c0023dbd:	89 10                	mov    %edx,(%eax)
}
c0023dbf:	c2 04 00             	ret    $0x4

c0023dc2 <fixed32_sub>:
struct fixed32 fixed32_sub(struct fixed32 a, struct fixed32 b) {
c0023dc2:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num - b.num};
c0023dc6:	8b 54 24 08          	mov    0x8(%esp),%edx
c0023dca:	2b 54 24 0c          	sub    0xc(%esp),%edx
c0023dce:	89 10                	mov    %edx,(%eax)
}
c0023dd0:	c2 04 00             	ret    $0x4

c0023dd3 <fixed32_sub_int>:
struct fixed32 fixed32_sub_int(struct fixed32 a, int32_t b) {
c0023dd3:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num - b * FLOAT_POINT};
c0023dd7:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023ddb:	c1 e2 0e             	shl    $0xe,%edx
c0023dde:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0023de2:	29 d1                	sub    %edx,%ecx
c0023de4:	89 08                	mov    %ecx,(%eax)
}
c0023de6:	c2 04 00             	ret    $0x4

c0023de9 <fixed32_mul>:
struct fixed32 fixed32_mul(struct fixed32 a, struct fixed32 b) {
c0023de9:	55                   	push   %ebp
c0023dea:	57                   	push   %edi
c0023deb:	56                   	push   %esi
c0023dec:	53                   	push   %ebx
c0023ded:	8b 54 24 18          	mov    0x18(%esp),%edx
c0023df1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
c0023df5:	89 d3                	mov    %edx,%ebx
c0023df7:	c1 fb 1f             	sar    $0x1f,%ebx
c0023dfa:	89 c7                	mov    %eax,%edi
c0023dfc:	c1 ff 1f             	sar    $0x1f,%edi
c0023dff:	89 dd                	mov    %ebx,%ebp
c0023e01:	0f af e8             	imul   %eax,%ebp
c0023e04:	89 fe                	mov    %edi,%esi
c0023e06:	0f af f2             	imul   %edx,%esi
c0023e09:	01 ee                	add    %ebp,%esi
c0023e0b:	f7 e2                	mul    %edx
c0023e0d:	01 f2                	add    %esi,%edx
c0023e0f:	89 c6                	mov    %eax,%esi
c0023e11:	89 d7                	mov    %edx,%edi
c0023e13:	85 d2                	test   %edx,%edx
c0023e15:	78 11                	js     c0023e28 <fixed32_mul+0x3f>
c0023e17:	0f ac fe 0e          	shrd   $0xe,%edi,%esi
c0023e1b:	8b 44 24 14          	mov    0x14(%esp),%eax
c0023e1f:	89 30                	mov    %esi,(%eax)
}
c0023e21:	5b                   	pop    %ebx
c0023e22:	5e                   	pop    %esi
c0023e23:	5f                   	pop    %edi
c0023e24:	5d                   	pop    %ebp
c0023e25:	c2 04 00             	ret    $0x4
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
c0023e28:	05 ff 3f 00 00       	add    $0x3fff,%eax
c0023e2d:	83 d2 00             	adc    $0x0,%edx
c0023e30:	89 c6                	mov    %eax,%esi
c0023e32:	89 d7                	mov    %edx,%edi
c0023e34:	eb e1                	jmp    c0023e17 <fixed32_mul+0x2e>

c0023e36 <fixed32_mul_int>:
struct fixed32 fixed32_mul_int(struct fixed32 a, int32_t b) {
c0023e36:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num * b};
c0023e3a:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023e3e:	0f af 54 24 08       	imul   0x8(%esp),%edx
  return res;
c0023e43:	89 10                	mov    %edx,(%eax)
}
c0023e45:	c2 04 00             	ret    $0x4

c0023e48 <fixed32_div>:

struct fixed32 fixed32_div(struct fixed32 a, struct fixed32 b) {
c0023e48:	57                   	push   %edi
c0023e49:	56                   	push   %esi
c0023e4a:	53                   	push   %ebx
c0023e4b:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  struct fixed32 res = {(int64_t)a.num * FLOAT_POINT / b.num};
c0023e4f:	8b 44 24 14          	mov    0x14(%esp),%eax
c0023e53:	99                   	cltd   
c0023e54:	0f a4 c2 0e          	shld   $0xe,%eax,%edx
c0023e58:	c1 e0 0e             	shl    $0xe,%eax
c0023e5b:	8b 74 24 18          	mov    0x18(%esp),%esi
c0023e5f:	89 f7                	mov    %esi,%edi
c0023e61:	c1 ff 1f             	sar    $0x1f,%edi
c0023e64:	57                   	push   %edi
c0023e65:	56                   	push   %esi
c0023e66:	52                   	push   %edx
c0023e67:	50                   	push   %eax
c0023e68:	e8 d4 41 00 00       	call   c0028041 <__divdi3>
c0023e6d:	83 c4 10             	add    $0x10,%esp
c0023e70:	89 03                	mov    %eax,(%ebx)
  return res;
}
c0023e72:	89 d8                	mov    %ebx,%eax
c0023e74:	5b                   	pop    %ebx
c0023e75:	5e                   	pop    %esi
c0023e76:	5f                   	pop    %edi
c0023e77:	c2 04 00             	ret    $0x4

c0023e7a <fixed32_div_int>:

struct fixed32 fixed32_div_int(struct fixed32 a, int32_t b) {
c0023e7a:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0023e7e:	8b 44 24 08          	mov    0x8(%esp),%eax
  struct fixed32 res = {a.num / b};
c0023e82:	99                   	cltd   
c0023e83:	f7 7c 24 0c          	idivl  0xc(%esp)
  return res;
c0023e87:	89 01                	mov    %eax,(%ecx)
}
c0023e89:	89 c8                	mov    %ecx,%eax
c0023e8b:	c2 04 00             	ret    $0x4

c0023e8e <fixed32_div_int_int>:

struct fixed32 fixed32_div_int_int(int32_t a, int32_t b) {
c0023e8e:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  struct fixed32 res = {a * FLOAT_POINT / b};
c0023e92:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023e96:	c1 e0 0e             	shl    $0xe,%eax
c0023e99:	99                   	cltd   
c0023e9a:	f7 7c 24 0c          	idivl  0xc(%esp)
  return res;
c0023e9e:	89 01                	mov    %eax,(%ecx)
}
c0023ea0:	89 c8                	mov    %ecx,%eax
c0023ea2:	c2 04 00             	ret    $0x4

c0023ea5 <fixed32_less_than>:

bool fixed32_less_than(struct fixed32 a, struct fixed32 b) {
  return a.num < b.num;
c0023ea5:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023ea9:	39 44 24 04          	cmp    %eax,0x4(%esp)
c0023ead:	0f 9c c0             	setl   %al
c0023eb0:	c3                   	ret    

c0023eb1 <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023eb1:	57                   	push   %edi
c0023eb2:	56                   	push   %esi
c0023eb3:	53                   	push   %ebx
c0023eb4:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023eb8:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0023ebc:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023ec0:	f7 c6 fd ff ff ff    	test   $0xfffffffd,%esi
c0023ec6:	74 1e                	je     c0023ee6 <pit_configure_channel+0x35>
c0023ec8:	83 ec 0c             	sub    $0xc,%esp
c0023ecb:	68 14 0f 03 c0       	push   $0xc0030f14
c0023ed0:	68 21 01 03 c0       	push   $0xc0030121
c0023ed5:	68 b0 ec 02 c0       	push   $0xc002ecb0
c0023eda:	6a 33                	push   $0x33
c0023edc:	68 31 0f 03 c0       	push   $0xc0030f31
c0023ee1:	e8 41 47 00 00       	call   c0028627 <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023ee6:	8d 43 fe             	lea    -0x2(%ebx),%eax
c0023ee9:	83 f8 01             	cmp    $0x1,%eax
c0023eec:	77 22                	ja     c0023f10 <pit_configure_channel+0x5f>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023eee:	83 f9 12             	cmp    $0x12,%ecx
c0023ef1:	7e 3b                	jle    c0023f2e <pit_configure_channel+0x7d>
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
    }
  else if (frequency > PIT_HZ)
c0023ef3:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c0023ef9:	7f 6b                	jg     c0023f66 <pit_configure_channel+0xb5>
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023efb:	89 c8                	mov    %ecx,%eax
c0023efd:	c1 e8 1f             	shr    $0x1f,%eax
c0023f00:	01 c8                	add    %ecx,%eax
c0023f02:	d1 f8                	sar    %eax
c0023f04:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023f09:	99                   	cltd   
c0023f0a:	f7 f9                	idiv   %ecx
c0023f0c:	89 c7                	mov    %eax,%edi
c0023f0e:	eb 23                	jmp    c0023f33 <pit_configure_channel+0x82>
  ASSERT (mode == 2 || mode == 3);
c0023f10:	83 ec 0c             	sub    $0xc,%esp
c0023f13:	68 45 0f 03 c0       	push   $0xc0030f45
c0023f18:	68 21 01 03 c0       	push   $0xc0030121
c0023f1d:	68 b0 ec 02 c0       	push   $0xc002ecb0
c0023f22:	6a 34                	push   $0x34
c0023f24:	68 31 0f 03 c0       	push   $0xc0030f31
c0023f29:	e8 f9 46 00 00       	call   c0028627 <debug_panic>
      count = 0;
c0023f2e:	bf 00 00 00 00       	mov    $0x0,%edi

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023f33:	e8 c9 da ff ff       	call   c0021a01 <intr_disable>
c0023f38:	89 c1                	mov    %eax,%ecx
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023f3a:	8d 04 1b             	lea    (%ebx,%ebx,1),%eax
c0023f3d:	83 c8 30             	or     $0x30,%eax
c0023f40:	89 f3                	mov    %esi,%ebx
c0023f42:	c1 e3 06             	shl    $0x6,%ebx
c0023f45:	09 d8                	or     %ebx,%eax
c0023f47:	e6 43                	out    %al,$0x43
  outb (PIT_PORT_COUNTER (channel), count);
c0023f49:	8d 56 40             	lea    0x40(%esi),%edx
c0023f4c:	89 f8                	mov    %edi,%eax
c0023f4e:	ee                   	out    %al,(%dx)
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023f4f:	89 f8                	mov    %edi,%eax
c0023f51:	66 c1 e8 08          	shr    $0x8,%ax
c0023f55:	ee                   	out    %al,(%dx)
  intr_set_level (old_level);
c0023f56:	83 ec 0c             	sub    $0xc,%esp
c0023f59:	51                   	push   %ecx
c0023f5a:	e8 a9 da ff ff       	call   c0021a08 <intr_set_level>
}
c0023f5f:	83 c4 10             	add    $0x10,%esp
c0023f62:	5b                   	pop    %ebx
c0023f63:	5e                   	pop    %esi
c0023f64:	5f                   	pop    %edi
c0023f65:	c3                   	ret    
      count = 2;
c0023f66:	bf 02 00 00 00       	mov    $0x2,%edi
c0023f6b:	eb c6                	jmp    c0023f33 <pit_configure_channel+0x82>

c0023f6d <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0023f6d:	53                   	push   %ebx
  while (loops-- > 0)
c0023f6e:	89 c1                	mov    %eax,%ecx
c0023f70:	89 d3                	mov    %edx,%ebx
c0023f72:	83 c1 ff             	add    $0xffffffff,%ecx
c0023f75:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023f78:	85 d2                	test   %edx,%edx
c0023f7a:	78 13                	js     c0023f8f <busy_wait+0x22>
c0023f7c:	85 d2                	test   %edx,%edx
c0023f7e:	7e 11                	jle    c0023f91 <busy_wait+0x24>
c0023f80:	83 c1 ff             	add    $0xffffffff,%ecx
c0023f83:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023f86:	89 d8                	mov    %ebx,%eax
c0023f88:	21 c8                	and    %ecx,%eax
c0023f8a:	83 f8 ff             	cmp    $0xffffffff,%eax
c0023f8d:	75 f1                	jne    c0023f80 <busy_wait+0x13>
    barrier ();
}
c0023f8f:	5b                   	pop    %ebx
c0023f90:	c3                   	ret    
  while (loops-- > 0)
c0023f91:	83 f8 00             	cmp    $0x0,%eax
c0023f94:	76 f9                	jbe    c0023f8f <busy_wait+0x22>
c0023f96:	eb e8                	jmp    c0023f80 <busy_wait+0x13>

c0023f98 <too_many_loops>:
{
c0023f98:	55                   	push   %ebp
c0023f99:	57                   	push   %edi
c0023f9a:	56                   	push   %esi
c0023f9b:	53                   	push   %ebx
c0023f9c:	83 ec 04             	sub    $0x4,%esp
  int64_t start = ticks;
c0023f9f:	8b 2d 60 ca 03 c0    	mov    0xc003ca60,%ebp
c0023fa5:	8b 3d 64 ca 03 c0    	mov    0xc003ca64,%edi
  while (ticks == start)
c0023fab:	8b 35 60 ca 03 c0    	mov    0xc003ca60,%esi
c0023fb1:	8b 1d 64 ca 03 c0    	mov    0xc003ca64,%ebx
c0023fb7:	89 ea                	mov    %ebp,%edx
c0023fb9:	31 f2                	xor    %esi,%edx
c0023fbb:	89 f9                	mov    %edi,%ecx
c0023fbd:	31 d9                	xor    %ebx,%ecx
c0023fbf:	09 d1                	or     %edx,%ecx
c0023fc1:	74 e8                	je     c0023fab <too_many_loops+0x13>
  busy_wait (loops);
c0023fc3:	ba 00 00 00 00       	mov    $0x0,%edx
c0023fc8:	e8 a0 ff ff ff       	call   c0023f6d <busy_wait>
  return start != ticks;
c0023fcd:	33 35 60 ca 03 c0    	xor    0xc003ca60,%esi
c0023fd3:	33 1d 64 ca 03 c0    	xor    0xc003ca64,%ebx
c0023fd9:	09 de                	or     %ebx,%esi
c0023fdb:	0f 95 c0             	setne  %al
}
c0023fde:	83 c4 04             	add    $0x4,%esp
c0023fe1:	5b                   	pop    %ebx
c0023fe2:	5e                   	pop    %esi
c0023fe3:	5f                   	pop    %edi
c0023fe4:	5d                   	pop    %ebp
c0023fe5:	c3                   	ret    

c0023fe6 <timer_interrupt>:
{
c0023fe6:	83 ec 0c             	sub    $0xc,%esp
  ticks++;
c0023fe9:	83 05 60 ca 03 c0 01 	addl   $0x1,0xc003ca60
c0023ff0:	83 15 64 ca 03 c0 00 	adcl   $0x0,0xc003ca64
  thread_tick ();
c0023ff7:	e8 26 cd ff ff       	call   c0020d22 <thread_tick>
  thread_tick_events(ticks % TIMER_FREQ == 0);
c0023ffc:	83 ec 10             	sub    $0x10,%esp
c0023fff:	6a 00                	push   $0x0
c0024001:	6a 64                	push   $0x64
c0024003:	ff 35 64 ca 03 c0    	pushl  0xc003ca64
c0024009:	ff 35 60 ca 03 c0    	pushl  0xc003ca60
c002400f:	e8 49 40 00 00       	call   c002805d <__moddi3>
c0024014:	83 c4 14             	add    $0x14,%esp
c0024017:	09 d0                	or     %edx,%eax
c0024019:	0f 94 c0             	sete   %al
c002401c:	0f b6 c0             	movzbl %al,%eax
c002401f:	50                   	push   %eax
c0024020:	e8 49 d1 ff ff       	call   c002116e <thread_tick_events>
}
c0024025:	83 c4 1c             	add    $0x1c,%esp
c0024028:	c3                   	ret    

c0024029 <real_time_delay>:
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0024029:	57                   	push   %edi
c002402a:	56                   	push   %esi
c002402b:	53                   	push   %ebx
c002402c:	89 c6                	mov    %eax,%esi
c002402e:	89 d7                	mov    %edx,%edi
c0024030:	89 cb                	mov    %ecx,%ebx
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c0024032:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024037:	89 d8                	mov    %ebx,%eax
c0024039:	99                   	cltd   
c002403a:	f7 f9                	idiv   %ecx
c002403c:	85 d2                	test   %edx,%edx
c002403e:	75 5c                	jne    c002409c <real_time_delay+0x73>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c0024040:	a1 58 ca 03 c0       	mov    0xc003ca58,%eax
c0024045:	0f af f8             	imul   %eax,%edi
c0024048:	f7 e6                	mul    %esi
c002404a:	01 fa                	add    %edi,%edx
c002404c:	6a 00                	push   $0x0
c002404e:	68 e8 03 00 00       	push   $0x3e8
c0024053:	52                   	push   %edx
c0024054:	50                   	push   %eax
c0024055:	e8 e7 3f 00 00       	call   c0028041 <__divdi3>
c002405a:	83 c4 10             	add    $0x10,%esp
c002405d:	89 c6                	mov    %eax,%esi
c002405f:	6b ca 64             	imul   $0x64,%edx,%ecx
c0024062:	bf 64 00 00 00       	mov    $0x64,%edi
c0024067:	89 f8                	mov    %edi,%eax
c0024069:	f7 e6                	mul    %esi
c002406b:	89 c6                	mov    %eax,%esi
c002406d:	89 d7                	mov    %edx,%edi
c002406f:	01 cf                	add    %ecx,%edi
c0024071:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
c0024076:	89 c8                	mov    %ecx,%eax
c0024078:	f7 eb                	imul   %ebx
c002407a:	89 d1                	mov    %edx,%ecx
c002407c:	89 c8                	mov    %ecx,%eax
c002407e:	c1 f8 06             	sar    $0x6,%eax
c0024081:	c1 fb 1f             	sar    $0x1f,%ebx
c0024084:	29 d8                	sub    %ebx,%eax
c0024086:	99                   	cltd   
c0024087:	52                   	push   %edx
c0024088:	50                   	push   %eax
c0024089:	57                   	push   %edi
c002408a:	56                   	push   %esi
c002408b:	e8 b1 3f 00 00       	call   c0028041 <__divdi3>
c0024090:	83 c4 10             	add    $0x10,%esp
c0024093:	e8 d5 fe ff ff       	call   c0023f6d <busy_wait>
}
c0024098:	5b                   	pop    %ebx
c0024099:	5e                   	pop    %esi
c002409a:	5f                   	pop    %edi
c002409b:	c3                   	ret    
  ASSERT (denom % 1000 == 0);
c002409c:	83 ec 0c             	sub    $0xc,%esp
c002409f:	68 5c 0f 03 c0       	push   $0xc0030f5c
c00240a4:	68 21 01 03 c0       	push   $0xc0030121
c00240a9:	68 c8 ec 02 c0       	push   $0xc002ecc8
c00240ae:	68 f9 00 00 00       	push   $0xf9
c00240b3:	68 6e 0f 03 c0       	push   $0xc0030f6e
c00240b8:	e8 6a 45 00 00       	call   c0028627 <debug_panic>

c00240bd <timer_init>:
{
c00240bd:	83 ec 10             	sub    $0x10,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c00240c0:	6a 64                	push   $0x64
c00240c2:	6a 02                	push   $0x2
c00240c4:	6a 00                	push   $0x0
c00240c6:	e8 e6 fd ff ff       	call   c0023eb1 <pit_configure_channel>
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c00240cb:	83 c4 0c             	add    $0xc,%esp
c00240ce:	68 84 0f 03 c0       	push   $0xc0030f84
c00240d3:	68 e6 3f 02 c0       	push   $0xc0023fe6
c00240d8:	6a 20                	push   $0x20
c00240da:	e8 a3 da ff ff       	call   c0021b82 <intr_register_ext>
}
c00240df:	83 c4 1c             	add    $0x1c,%esp
c00240e2:	c3                   	ret    

c00240e3 <timer_calibrate>:
{
c00240e3:	57                   	push   %edi
c00240e4:	56                   	push   %esi
c00240e5:	53                   	push   %ebx
  ASSERT (intr_get_level () == INTR_ON);
c00240e6:	e8 d9 d8 ff ff       	call   c00219c4 <intr_get_level>
c00240eb:	83 f8 01             	cmp    $0x1,%eax
c00240ee:	75 56                	jne    c0024146 <timer_calibrate+0x63>
  printf ("Calibrating timer...  ");
c00240f0:	83 ec 0c             	sub    $0xc,%esp
c00240f3:	68 ac 0f 03 c0       	push   $0xc0030fac
c00240f8:	e8 7c 2a 00 00       	call   c0026b79 <printf>
  loops_per_tick = 1u << 10;
c00240fd:	c7 05 58 ca 03 c0 00 	movl   $0x400,0xc003ca58
c0024104:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0024107:	83 c4 10             	add    $0x10,%esp
c002410a:	8b 35 58 ca 03 c0    	mov    0xc003ca58,%esi
c0024110:	8d 1c 36             	lea    (%esi,%esi,1),%ebx
c0024113:	89 d8                	mov    %ebx,%eax
c0024115:	e8 7e fe ff ff       	call   c0023f98 <too_many_loops>
c002411a:	84 c0                	test   %al,%al
c002411c:	75 46                	jne    c0024164 <timer_calibrate+0x81>
      loops_per_tick <<= 1;
c002411e:	89 1d 58 ca 03 c0    	mov    %ebx,0xc003ca58
      ASSERT (loops_per_tick != 0);
c0024124:	85 db                	test   %ebx,%ebx
c0024126:	75 e2                	jne    c002410a <timer_calibrate+0x27>
c0024128:	83 ec 0c             	sub    $0xc,%esp
c002412b:	68 c3 0f 03 c0       	push   $0xc0030fc3
c0024130:	68 21 01 03 c0       	push   $0xc0030121
c0024135:	68 f4 ec 02 c0       	push   $0xc002ecf4
c002413a:	6a 39                	push   $0x39
c002413c:	68 6e 0f 03 c0       	push   $0xc0030f6e
c0024141:	e8 e1 44 00 00       	call   c0028627 <debug_panic>
  ASSERT (intr_get_level () == INTR_ON);
c0024146:	83 ec 0c             	sub    $0xc,%esp
c0024149:	68 8f 0f 03 c0       	push   $0xc0030f8f
c002414e:	68 21 01 03 c0       	push   $0xc0030121
c0024153:	68 f4 ec 02 c0       	push   $0xc002ecf4
c0024158:	6a 30                	push   $0x30
c002415a:	68 6e 0f 03 c0       	push   $0xc0030f6e
c002415f:	e8 c3 44 00 00       	call   c0028627 <debug_panic>
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024164:	89 f3                	mov    %esi,%ebx
c0024166:	d1 eb                	shr    %ebx
c0024168:	89 f7                	mov    %esi,%edi
c002416a:	c1 ef 0a             	shr    $0xa,%edi
c002416d:	39 df                	cmp    %ebx,%edi
c002416f:	75 27                	jne    c0024198 <timer_calibrate+0xb5>
  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0024171:	83 ec 04             	sub    $0x4,%esp
c0024174:	b8 64 00 00 00       	mov    $0x64,%eax
c0024179:	f7 25 58 ca 03 c0    	mull   0xc003ca58
c002417f:	52                   	push   %edx
c0024180:	50                   	push   %eax
c0024181:	68 d7 0f 03 c0       	push   $0xc0030fd7
c0024186:	e8 ee 29 00 00       	call   c0026b79 <printf>
}
c002418b:	83 c4 10             	add    $0x10,%esp
c002418e:	5b                   	pop    %ebx
c002418f:	5e                   	pop    %esi
c0024190:	5f                   	pop    %edi
c0024191:	c3                   	ret    
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024192:	d1 eb                	shr    %ebx
c0024194:	39 df                	cmp    %ebx,%edi
c0024196:	74 d9                	je     c0024171 <timer_calibrate+0x8e>
    if (!too_many_loops (high_bit | test_bit))
c0024198:	89 f0                	mov    %esi,%eax
c002419a:	09 d8                	or     %ebx,%eax
c002419c:	e8 f7 fd ff ff       	call   c0023f98 <too_many_loops>
c00241a1:	84 c0                	test   %al,%al
c00241a3:	75 ed                	jne    c0024192 <timer_calibrate+0xaf>
      loops_per_tick |= test_bit;
c00241a5:	09 1d 58 ca 03 c0    	or     %ebx,0xc003ca58
c00241ab:	eb e5                	jmp    c0024192 <timer_calibrate+0xaf>

c00241ad <timer_ticks>:
{
c00241ad:	57                   	push   %edi
c00241ae:	56                   	push   %esi
c00241af:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level = intr_disable ();
c00241b2:	e8 4a d8 ff ff       	call   c0021a01 <intr_disable>
  int64_t t = ticks;
c00241b7:	8b 35 60 ca 03 c0    	mov    0xc003ca60,%esi
c00241bd:	8b 3d 64 ca 03 c0    	mov    0xc003ca64,%edi
  intr_set_level (old_level);
c00241c3:	83 ec 0c             	sub    $0xc,%esp
c00241c6:	50                   	push   %eax
c00241c7:	e8 3c d8 ff ff       	call   c0021a08 <intr_set_level>
}
c00241cc:	89 f0                	mov    %esi,%eax
c00241ce:	89 fa                	mov    %edi,%edx
c00241d0:	83 c4 14             	add    $0x14,%esp
c00241d3:	5e                   	pop    %esi
c00241d4:	5f                   	pop    %edi
c00241d5:	c3                   	ret    

c00241d6 <timer_elapsed>:
{
c00241d6:	57                   	push   %edi
c00241d7:	56                   	push   %esi
c00241d8:	83 ec 04             	sub    $0x4,%esp
c00241db:	8b 74 24 10          	mov    0x10(%esp),%esi
c00241df:	8b 7c 24 14          	mov    0x14(%esp),%edi
  return timer_ticks () - then;
c00241e3:	e8 c5 ff ff ff       	call   c00241ad <timer_ticks>
c00241e8:	29 f0                	sub    %esi,%eax
c00241ea:	19 fa                	sbb    %edi,%edx
}
c00241ec:	83 c4 04             	add    $0x4,%esp
c00241ef:	5e                   	pop    %esi
c00241f0:	5f                   	pop    %edi
c00241f1:	c3                   	ret    

c00241f2 <timer_sleep>:
{
c00241f2:	56                   	push   %esi
c00241f3:	53                   	push   %ebx
c00241f4:	83 ec 04             	sub    $0x4,%esp
c00241f7:	8b 74 24 10          	mov    0x10(%esp),%esi
c00241fb:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (intr_get_level () == INTR_ON);  
c00241ff:	e8 c0 d7 ff ff       	call   c00219c4 <intr_get_level>
c0024204:	83 f8 01             	cmp    $0x1,%eax
c0024207:	75 2e                	jne    c0024237 <timer_sleep+0x45>
  if (ticks <= 0) return;
c0024209:	85 db                	test   %ebx,%ebx
c002420b:	78 24                	js     c0024231 <timer_sleep+0x3f>
c002420d:	85 db                	test   %ebx,%ebx
c002420f:	7e 44                	jle    c0024255 <timer_sleep+0x63>
  struct thread *t = thread_current();
c0024211:	e8 a6 ca ff ff       	call   c0020cbc <thread_current>
  t->sleep_remain = ticks;
c0024216:	89 70 24             	mov    %esi,0x24(%eax)
  enum intr_level old_level = intr_disable();
c0024219:	e8 e3 d7 ff ff       	call   c0021a01 <intr_disable>
c002421e:	89 c3                	mov    %eax,%ebx
  thread_block();
c0024220:	e8 d8 d1 ff ff       	call   c00213fd <thread_block>
  intr_set_level(old_level);
c0024225:	83 ec 0c             	sub    $0xc,%esp
c0024228:	53                   	push   %ebx
c0024229:	e8 da d7 ff ff       	call   c0021a08 <intr_set_level>
c002422e:	83 c4 10             	add    $0x10,%esp
}
c0024231:	83 c4 04             	add    $0x4,%esp
c0024234:	5b                   	pop    %ebx
c0024235:	5e                   	pop    %esi
c0024236:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);  
c0024237:	83 ec 0c             	sub    $0xc,%esp
c002423a:	68 8f 0f 03 c0       	push   $0xc0030f8f
c002423f:	68 21 01 03 c0       	push   $0xc0030121
c0024244:	68 e8 ec 02 c0       	push   $0xc002ece8
c0024249:	6a 5c                	push   $0x5c
c002424b:	68 6e 0f 03 c0       	push   $0xc0030f6e
c0024250:	e8 d2 43 00 00       	call   c0028627 <debug_panic>
  if (ticks <= 0) return;
c0024255:	83 fe 00             	cmp    $0x0,%esi
c0024258:	76 d7                	jbe    c0024231 <timer_sleep+0x3f>
c002425a:	eb b5                	jmp    c0024211 <timer_sleep+0x1f>

c002425c <real_time_sleep>:
{
c002425c:	55                   	push   %ebp
c002425d:	57                   	push   %edi
c002425e:	56                   	push   %esi
c002425f:	53                   	push   %ebx
c0024260:	83 ec 1c             	sub    $0x1c,%esp
c0024263:	89 c6                	mov    %eax,%esi
c0024265:	89 44 24 08          	mov    %eax,0x8(%esp)
c0024269:	89 54 24 0c          	mov    %edx,0xc(%esp)
c002426d:	89 cd                	mov    %ecx,%ebp
  int64_t ticks = num * TIMER_FREQ / denom;
c002426f:	6b fa 64             	imul   $0x64,%edx,%edi
c0024272:	b9 64 00 00 00       	mov    $0x64,%ecx
c0024277:	89 c8                	mov    %ecx,%eax
c0024279:	f7 e6                	mul    %esi
c002427b:	89 c1                	mov    %eax,%ecx
c002427d:	89 d3                	mov    %edx,%ebx
c002427f:	01 fb                	add    %edi,%ebx
c0024281:	89 e8                	mov    %ebp,%eax
c0024283:	99                   	cltd   
c0024284:	52                   	push   %edx
c0024285:	55                   	push   %ebp
c0024286:	53                   	push   %ebx
c0024287:	51                   	push   %ecx
c0024288:	e8 b4 3d 00 00       	call   c0028041 <__divdi3>
c002428d:	83 c4 10             	add    $0x10,%esp
c0024290:	89 c6                	mov    %eax,%esi
c0024292:	89 d7                	mov    %edx,%edi
  ASSERT (intr_get_level () == INTR_ON);
c0024294:	e8 2b d7 ff ff       	call   c00219c4 <intr_get_level>
c0024299:	83 f8 01             	cmp    $0x1,%eax
c002429c:	75 1d                	jne    c00242bb <real_time_sleep+0x5f>
  if (ticks > 0)
c002429e:	85 ff                	test   %edi,%edi
c00242a0:	78 3f                	js     c00242e1 <real_time_sleep+0x85>
c00242a2:	85 ff                	test   %edi,%edi
c00242a4:	7e 36                	jle    c00242dc <real_time_sleep+0x80>
      timer_sleep (ticks); 
c00242a6:	83 ec 08             	sub    $0x8,%esp
c00242a9:	57                   	push   %edi
c00242aa:	56                   	push   %esi
c00242ab:	e8 42 ff ff ff       	call   c00241f2 <timer_sleep>
c00242b0:	83 c4 10             	add    $0x10,%esp
}
c00242b3:	83 c4 1c             	add    $0x1c,%esp
c00242b6:	5b                   	pop    %ebx
c00242b7:	5e                   	pop    %esi
c00242b8:	5f                   	pop    %edi
c00242b9:	5d                   	pop    %ebp
c00242ba:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c00242bb:	83 ec 0c             	sub    $0xc,%esp
c00242be:	68 8f 0f 03 c0       	push   $0xc0030f8f
c00242c3:	68 21 01 03 c0       	push   $0xc0030121
c00242c8:	68 d8 ec 02 c0       	push   $0xc002ecd8
c00242cd:	68 e3 00 00 00       	push   $0xe3
c00242d2:	68 6e 0f 03 c0       	push   $0xc0030f6e
c00242d7:	e8 4b 43 00 00       	call   c0028627 <debug_panic>
  if (ticks > 0)
c00242dc:	83 fe 00             	cmp    $0x0,%esi
c00242df:	77 c5                	ja     c00242a6 <real_time_sleep+0x4a>
      real_time_delay (num, denom); 
c00242e1:	89 e9                	mov    %ebp,%ecx
c00242e3:	8b 44 24 08          	mov    0x8(%esp),%eax
c00242e7:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00242eb:	e8 39 fd ff ff       	call   c0024029 <real_time_delay>
}
c00242f0:	eb c1                	jmp    c00242b3 <real_time_sleep+0x57>

c00242f2 <timer_msleep>:
{
c00242f2:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ms, 1000);
c00242f5:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c00242fa:	8b 44 24 10          	mov    0x10(%esp),%eax
c00242fe:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024302:	e8 55 ff ff ff       	call   c002425c <real_time_sleep>
}
c0024307:	83 c4 0c             	add    $0xc,%esp
c002430a:	c3                   	ret    

c002430b <timer_usleep>:
{
c002430b:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (us, 1000 * 1000);
c002430e:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024313:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024317:	8b 54 24 14          	mov    0x14(%esp),%edx
c002431b:	e8 3c ff ff ff       	call   c002425c <real_time_sleep>
}
c0024320:	83 c4 0c             	add    $0xc,%esp
c0024323:	c3                   	ret    

c0024324 <timer_nsleep>:
{
c0024324:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0024327:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c002432c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024330:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024334:	e8 23 ff ff ff       	call   c002425c <real_time_sleep>
}
c0024339:	83 c4 0c             	add    $0xc,%esp
c002433c:	c3                   	ret    

c002433d <timer_mdelay>:
{
c002433d:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ms, 1000);
c0024340:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024345:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024349:	8b 54 24 14          	mov    0x14(%esp),%edx
c002434d:	e8 d7 fc ff ff       	call   c0024029 <real_time_delay>
}
c0024352:	83 c4 0c             	add    $0xc,%esp
c0024355:	c3                   	ret    

c0024356 <timer_udelay>:
{
c0024356:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (us, 1000 * 1000);
c0024359:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c002435e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024362:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024366:	e8 be fc ff ff       	call   c0024029 <real_time_delay>
}
c002436b:	83 c4 0c             	add    $0xc,%esp
c002436e:	c3                   	ret    

c002436f <timer_ndelay>:
{
c002436f:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ns, 1000 * 1000 * 1000);
c0024372:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024377:	8b 44 24 10          	mov    0x10(%esp),%eax
c002437b:	8b 54 24 14          	mov    0x14(%esp),%edx
c002437f:	e8 a5 fc ff ff       	call   c0024029 <real_time_delay>
}
c0024384:	83 c4 0c             	add    $0xc,%esp
c0024387:	c3                   	ret    

c0024388 <timer_print_stats>:
{
c0024388:	83 ec 0c             	sub    $0xc,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c002438b:	e8 1d fe ff ff       	call   c00241ad <timer_ticks>
c0024390:	83 ec 04             	sub    $0x4,%esp
c0024393:	52                   	push   %edx
c0024394:	50                   	push   %eax
c0024395:	68 e7 0f 03 c0       	push   $0xc0030fe7
c002439a:	e8 da 27 00 00       	call   c0026b79 <printf>
}
c002439f:	83 c4 1c             	add    $0x1c,%esp
c00243a2:	c3                   	ret    

c00243a3 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c00243a3:	55                   	push   %ebp
c00243a4:	57                   	push   %edi
c00243a5:	56                   	push   %esi
c00243a6:	53                   	push   %ebx
c00243a7:	83 ec 08             	sub    $0x8,%esp
c00243aa:	89 0c 24             	mov    %ecx,(%esp)
  for (; k->first_scancode != 0; k++)
c00243ad:	8a 18                	mov    (%eax),%bl
c00243af:	84 db                	test   %bl,%bl
c00243b1:	74 49                	je     c00243fc <map_key+0x59>
c00243b3:	89 c6                	mov    %eax,%esi
    if (scancode >= k->first_scancode
        && scancode < k->first_scancode + strlen (k->chars)) 
c00243b5:	b0 00                	mov    $0x0,%al
c00243b7:	eb 09                	jmp    c00243c2 <map_key+0x1f>
  for (; k->first_scancode != 0; k++)
c00243b9:	83 c6 08             	add    $0x8,%esi
c00243bc:	8a 1e                	mov    (%esi),%bl
c00243be:	84 db                	test   %bl,%bl
c00243c0:	74 30                	je     c00243f2 <map_key+0x4f>
    if (scancode >= k->first_scancode
c00243c2:	0f b6 db             	movzbl %bl,%ebx
c00243c5:	39 d3                	cmp    %edx,%ebx
c00243c7:	77 f0                	ja     c00243b9 <map_key+0x16>
        && scancode < k->first_scancode + strlen (k->chars)) 
c00243c9:	8b 6e 04             	mov    0x4(%esi),%ebp
c00243cc:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00243d1:	89 ef                	mov    %ebp,%edi
c00243d3:	f2 ae                	repnz scas %es:(%edi),%al
c00243d5:	f7 d1                	not    %ecx
c00243d7:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c00243db:	39 ca                	cmp    %ecx,%edx
c00243dd:	73 da                	jae    c00243b9 <map_key+0x16>
      {
        *c = k->chars[scancode - k->first_scancode];
c00243df:	29 da                	sub    %ebx,%edx
c00243e1:	8a 44 15 00          	mov    0x0(%ebp,%edx,1),%al
c00243e5:	88 44 24 07          	mov    %al,0x7(%esp)
c00243e9:	8b 3c 24             	mov    (%esp),%edi
c00243ec:	88 07                	mov    %al,(%edi)
        return true; 
c00243ee:	b0 01                	mov    $0x1,%al
c00243f0:	eb 02                	jmp    c00243f4 <map_key+0x51>
      }

  return false;
c00243f2:	b0 00                	mov    $0x0,%al
}
c00243f4:	83 c4 08             	add    $0x8,%esp
c00243f7:	5b                   	pop    %ebx
c00243f8:	5e                   	pop    %esi
c00243f9:	5f                   	pop    %edi
c00243fa:	5d                   	pop    %ebp
c00243fb:	c3                   	ret    
  return false;
c00243fc:	b0 00                	mov    $0x0,%al
c00243fe:	eb f4                	jmp    c00243f4 <map_key+0x51>

c0024400 <keyboard_interrupt>:
{
c0024400:	55                   	push   %ebp
c0024401:	57                   	push   %edi
c0024402:	56                   	push   %esi
c0024403:	53                   	push   %ebx
c0024404:	83 ec 2c             	sub    $0x2c,%esp
  bool shift = left_shift || right_shift;
c0024407:	a0 76 ca 03 c0       	mov    0xc003ca76,%al
c002440c:	89 c7                	mov    %eax,%edi
c002440e:	84 c0                	test   %al,%al
c0024410:	75 07                	jne    c0024419 <keyboard_interrupt+0x19>
c0024412:	a0 75 ca 03 c0       	mov    0xc003ca75,%al
c0024417:	89 c7                	mov    %eax,%edi
  bool alt = left_alt || right_alt;
c0024419:	a0 74 ca 03 c0       	mov    0xc003ca74,%al
c002441e:	89 c5                	mov    %eax,%ebp
c0024420:	84 c0                	test   %al,%al
c0024422:	75 07                	jne    c002442b <keyboard_interrupt+0x2b>
c0024424:	a0 73 ca 03 c0       	mov    0xc003ca73,%al
c0024429:	89 c5                	mov    %eax,%ebp
  bool ctrl = left_ctrl || right_ctrl;
c002442b:	a0 72 ca 03 c0       	mov    0xc003ca72,%al
c0024430:	88 44 24 0f          	mov    %al,0xf(%esp)
c0024434:	84 c0                	test   %al,%al
c0024436:	75 09                	jne    c0024441 <keyboard_interrupt+0x41>
c0024438:	a0 71 ca 03 c0       	mov    0xc003ca71,%al
c002443d:	88 44 24 0f          	mov    %al,0xf(%esp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024441:	e4 60                	in     $0x60,%al
  code = inb (DATA_REG);
c0024443:	0f b6 d8             	movzbl %al,%ebx
  if (code == 0xe0)
c0024446:	81 fb e0 00 00 00    	cmp    $0xe0,%ebx
c002444c:	74 63                	je     c00244b1 <keyboard_interrupt+0xb1>
  release = (code & 0x80) != 0;
c002444e:	89 de                	mov    %ebx,%esi
c0024450:	81 e6 80 00 00 00    	and    $0x80,%esi
  code &= ~0x80u;
c0024456:	80 e3 7f             	and    $0x7f,%bl
  if (code == 0x3a) 
c0024459:	83 fb 3a             	cmp    $0x3a,%ebx
c002445c:	74 5d                	je     c00244bb <keyboard_interrupt+0xbb>
  else if (map_key (invariant_keymap, code, &c)
c002445e:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024462:	89 da                	mov    %ebx,%edx
c0024464:	b8 e0 ed 02 c0       	mov    $0xc002ede0,%eax
c0024469:	e8 35 ff ff ff       	call   c00243a3 <map_key>
c002446e:	84 c0                	test   %al,%al
c0024470:	75 70                	jne    c00244e2 <keyboard_interrupt+0xe2>
           || (!shift && map_key (unshifted_keymap, code, &c))
c0024472:	89 f8                	mov    %edi,%eax
c0024474:	84 c0                	test   %al,%al
c0024476:	74 56                	je     c00244ce <keyboard_interrupt+0xce>
           || (shift && map_key (shifted_keymap, code, &c)))
c0024478:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c002447c:	89 da                	mov    %ebx,%edx
c002447e:	b8 60 ed 02 c0       	mov    $0xc002ed60,%eax
c0024483:	e8 1b ff ff ff       	call   c00243a3 <map_key>
c0024488:	84 c0                	test   %al,%al
c002448a:	75 56                	jne    c00244e2 <keyboard_interrupt+0xe2>
        if (key->scancode == code)
c002448c:	83 fb 2a             	cmp    $0x2a,%ebx
c002448f:	0f 84 e2 00 00 00    	je     c0024577 <keyboard_interrupt+0x177>
c0024495:	b8 20 ed 02 c0       	mov    $0xc002ed20,%eax
      for (key = shift_keys; key->scancode != 0; key++) 
c002449a:	83 c0 08             	add    $0x8,%eax
c002449d:	8b 10                	mov    (%eax),%edx
c002449f:	85 d2                	test   %edx,%edx
c00244a1:	74 23                	je     c00244c6 <keyboard_interrupt+0xc6>
        if (key->scancode == code)
c00244a3:	39 d3                	cmp    %edx,%ebx
c00244a5:	75 f3                	jne    c002449a <keyboard_interrupt+0x9a>
            *key->state_var = !release;
c00244a7:	8b 40 04             	mov    0x4(%eax),%eax
c00244aa:	85 f6                	test   %esi,%esi
c00244ac:	0f 94 00             	sete   (%eax)
            break;
c00244af:	eb 15                	jmp    c00244c6 <keyboard_interrupt+0xc6>
c00244b1:	e4 60                	in     $0x60,%al
    code = (code << 8) | inb (DATA_REG);
c00244b3:	0f b6 d8             	movzbl %al,%ebx
c00244b6:	80 cf e0             	or     $0xe0,%bh
c00244b9:	eb 93                	jmp    c002444e <keyboard_interrupt+0x4e>
      if (!release)
c00244bb:	85 f6                	test   %esi,%esi
c00244bd:	75 07                	jne    c00244c6 <keyboard_interrupt+0xc6>
        caps_lock = !caps_lock;
c00244bf:	80 35 70 ca 03 c0 01 	xorb   $0x1,0xc003ca70
}
c00244c6:	83 c4 2c             	add    $0x2c,%esp
c00244c9:	5b                   	pop    %ebx
c00244ca:	5e                   	pop    %esi
c00244cb:	5f                   	pop    %edi
c00244cc:	5d                   	pop    %ebp
c00244cd:	c3                   	ret    
           || (!shift && map_key (unshifted_keymap, code, &c))
c00244ce:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00244d2:	89 da                	mov    %ebx,%edx
c00244d4:	b8 a0 ed 02 c0       	mov    $0xc002eda0,%eax
c00244d9:	e8 c5 fe ff ff       	call   c00243a3 <map_key>
c00244de:	84 c0                	test   %al,%al
c00244e0:	74 aa                	je     c002448c <keyboard_interrupt+0x8c>
      if (!release) 
c00244e2:	85 f6                	test   %esi,%esi
c00244e4:	75 e0                	jne    c00244c6 <keyboard_interrupt+0xc6>
          if (c == 0177 && ctrl && alt)
c00244e6:	8a 44 24 1f          	mov    0x1f(%esp),%al
c00244ea:	3c 7f                	cmp    $0x7f,%al
c00244ec:	74 4e                	je     c002453c <keyboard_interrupt+0x13c>
          if (ctrl && c >= 0x40 && c < 0x60) 
c00244ee:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00244f3:	74 08                	je     c00244fd <keyboard_interrupt+0xfd>
c00244f5:	8d 50 c0             	lea    -0x40(%eax),%edx
c00244f8:	80 fa 1f             	cmp    $0x1f,%dl
c00244fb:	76 60                	jbe    c002455d <keyboard_interrupt+0x15d>
          else if (shift == caps_lock)
c00244fd:	89 f9                	mov    %edi,%ecx
c00244ff:	38 0d 70 ca 03 c0    	cmp    %cl,0xc003ca70
c0024505:	74 5c                	je     c0024563 <keyboard_interrupt+0x163>
          if (alt)
c0024507:	89 e8                	mov    %ebp,%eax
c0024509:	84 c0                	test   %al,%al
c002450b:	74 05                	je     c0024512 <keyboard_interrupt+0x112>
            c += 0x80;
c002450d:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
          if (!input_full ())
c0024512:	e8 c3 18 00 00       	call   c0025dda <input_full>
c0024517:	84 c0                	test   %al,%al
c0024519:	75 ab                	jne    c00244c6 <keyboard_interrupt+0xc6>
              key_cnt++;
c002451b:	83 05 68 ca 03 c0 01 	addl   $0x1,0xc003ca68
c0024522:	83 15 6c ca 03 c0 00 	adcl   $0x0,0xc003ca6c
              input_putc (c);
c0024529:	83 ec 0c             	sub    $0xc,%esp
c002452c:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c0024531:	50                   	push   %eax
c0024532:	e8 f7 17 00 00       	call   c0025d2e <input_putc>
c0024537:	83 c4 10             	add    $0x10,%esp
c002453a:	eb 8a                	jmp    c00244c6 <keyboard_interrupt+0xc6>
          if (c == 0177 && ctrl && alt)
c002453c:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0024541:	74 06                	je     c0024549 <keyboard_interrupt+0x149>
c0024543:	89 e9                	mov    %ebp,%ecx
c0024545:	84 c9                	test   %cl,%cl
c0024547:	75 0f                	jne    c0024558 <keyboard_interrupt+0x158>
          else if (shift == caps_lock)
c0024549:	89 f9                	mov    %edi,%ecx
c002454b:	38 0d 70 ca 03 c0    	cmp    %cl,0xc003ca70
c0024551:	75 b4                	jne    c0024507 <keyboard_interrupt+0x107>
            c = tolower (c);
c0024553:	0f b6 c0             	movzbl %al,%eax
c0024556:	eb 19                	jmp    c0024571 <keyboard_interrupt+0x171>
            shutdown_reboot ();
c0024558:	e8 64 1e 00 00       	call   c00263c1 <shutdown_reboot>
              c -= 0x40; 
c002455d:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c0024561:	eb a4                	jmp    c0024507 <keyboard_interrupt+0x107>
            c = tolower (c);
c0024563:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c0024566:	8d 50 bf             	lea    -0x41(%eax),%edx
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c0024569:	83 fa 19             	cmp    $0x19,%edx
c002456c:	77 03                	ja     c0024571 <keyboard_interrupt+0x171>
c002456e:	83 c0 20             	add    $0x20,%eax
c0024571:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0024575:	eb 90                	jmp    c0024507 <keyboard_interrupt+0x107>
      for (key = shift_keys; key->scancode != 0; key++) 
c0024577:	b8 20 ed 02 c0       	mov    $0xc002ed20,%eax
c002457c:	e9 26 ff ff ff       	jmp    c00244a7 <keyboard_interrupt+0xa7>

c0024581 <kbd_init>:
{
c0024581:	83 ec 10             	sub    $0x10,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c0024584:	68 fa 0f 03 c0       	push   $0xc0030ffa
c0024589:	68 00 44 02 c0       	push   $0xc0024400
c002458e:	6a 21                	push   $0x21
c0024590:	e8 ed d5 ff ff       	call   c0021b82 <intr_register_ext>
}
c0024595:	83 c4 1c             	add    $0x1c,%esp
c0024598:	c3                   	ret    

c0024599 <kbd_print_stats>:
{
c0024599:	83 ec 10             	sub    $0x10,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c002459c:	ff 35 6c ca 03 c0    	pushl  0xc003ca6c
c00245a2:	ff 35 68 ca 03 c0    	pushl  0xc003ca68
c00245a8:	68 08 10 03 c0       	push   $0xc0031008
c00245ad:	e8 c7 25 00 00       	call   c0026b79 <printf>
}
c00245b2:	83 c4 1c             	add    $0x1c,%esp
c00245b5:	c3                   	ret    

c00245b6 <move_cursor>:
/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c00245b6:	a1 80 ca 03 c0       	mov    0xc003ca80,%eax
c00245bb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c00245c2:	01 c1                	add    %eax,%ecx
c00245c4:	c1 e1 04             	shl    $0x4,%ecx
c00245c7:	03 0d 84 ca 03 c0    	add    0xc003ca84,%ecx
  outw (0x3d4, 0x0e | (cp & 0xff00));
c00245cd:	89 c8                	mov    %ecx,%eax
c00245cf:	b0 00                	mov    $0x0,%al
c00245d1:	83 c8 0e             	or     $0xe,%eax
/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00245d4:	ba d4 03 00 00       	mov    $0x3d4,%edx
c00245d9:	66 ef                	out    %ax,(%dx)
  outw (0x3d4, 0x0f | (cp << 8));
c00245db:	89 c8                	mov    %ecx,%eax
c00245dd:	c1 e0 08             	shl    $0x8,%eax
c00245e0:	83 c8 0f             	or     $0xf,%eax
c00245e3:	66 ef                	out    %ax,(%dx)
c00245e5:	c3                   	ret    

c00245e6 <newline>:
  cx = 0;
c00245e6:	c7 05 84 ca 03 c0 00 	movl   $0x0,0xc003ca84
c00245ed:	00 00 00 
  cy++;
c00245f0:	a1 80 ca 03 c0       	mov    0xc003ca80,%eax
c00245f5:	40                   	inc    %eax
  if (cy >= ROW_CNT)
c00245f6:	83 f8 18             	cmp    $0x18,%eax
c00245f9:	77 06                	ja     c0024601 <newline+0x1b>
  cy++;
c00245fb:	a3 80 ca 03 c0       	mov    %eax,0xc003ca80
c0024600:	c3                   	ret    
{
c0024601:	53                   	push   %ebx
c0024602:	83 ec 0c             	sub    $0xc,%esp
      cy = ROW_CNT - 1;
c0024605:	c7 05 80 ca 03 c0 18 	movl   $0x18,0xc003ca80
c002460c:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c002460f:	8b 1d 7c ca 03 c0    	mov    0xc003ca7c,%ebx
c0024615:	68 00 0f 00 00       	push   $0xf00
c002461a:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0024620:	50                   	push   %eax
c0024621:	53                   	push   %ebx
c0024622:	e8 1b 33 00 00       	call   c0027942 <memmove>
c0024627:	8d 83 00 0f 00 00    	lea    0xf00(%ebx),%eax
c002462d:	8d 93 a0 0f 00 00    	lea    0xfa0(%ebx),%edx
c0024633:	83 c4 10             	add    $0x10,%esp
      fb[y][x][0] = ' ';
c0024636:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c0024639:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c002463d:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0024640:	39 d0                	cmp    %edx,%eax
c0024642:	75 f2                	jne    c0024636 <newline+0x50>
}
c0024644:	83 c4 08             	add    $0x8,%esp
c0024647:	5b                   	pop    %ebx
c0024648:	c3                   	ret    

c0024649 <vga_putc>:
{
c0024649:	56                   	push   %esi
c002464a:	53                   	push   %ebx
c002464b:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level = intr_disable ();
c002464e:	e8 ae d3 ff ff       	call   c0021a01 <intr_disable>
c0024653:	89 c3                	mov    %eax,%ebx
  if (!inited)
c0024655:	80 3d 78 ca 03 c0 00 	cmpb   $0x0,0xc003ca78
c002465c:	74 17                	je     c0024675 <vga_putc+0x2c>
  switch (c) 
c002465e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024662:	83 e8 07             	sub    $0x7,%eax
c0024665:	83 f8 06             	cmp    $0x6,%eax
c0024668:	0f 87 23 01 00 00    	ja     c0024791 <vga_putc+0x148>
c002466e:	ff 24 85 30 ee 02 c0 	jmp    *-0x3ffd11d0(,%eax,4)
      fb = ptov (0xb8000);
c0024675:	c7 05 7c ca 03 c0 00 	movl   $0xc00b8000,0xc003ca7c
c002467c:	80 0b c0 
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002467f:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0024684:	b0 0e                	mov    $0xe,%al
c0024686:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024687:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c002468c:	89 ca                	mov    %ecx,%edx
c002468e:	ec                   	in     (%dx),%al
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
  cp = inb (0x3d5) << 8;
c002468f:	89 c6                	mov    %eax,%esi
c0024691:	c1 e6 08             	shl    $0x8,%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024694:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0024699:	b0 0f                	mov    $0xf,%al
c002469b:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002469c:	89 ca                	mov    %ecx,%edx
c002469e:	ec                   	in     (%dx),%al

  outb (0x3d4, 0x0f);
  cp |= inb (0x3d5);
c002469f:	0f b6 c0             	movzbl %al,%eax
c00246a2:	09 f0                	or     %esi,%eax
c00246a4:	89 c1                	mov    %eax,%ecx

  *x = cp % COL_CNT;
c00246a6:	be 50 00 00 00       	mov    $0x50,%esi
c00246ab:	ba 00 00 00 00       	mov    $0x0,%edx
c00246b0:	66 f7 f6             	div    %si
c00246b3:	0f b7 d2             	movzwl %dx,%edx
c00246b6:	89 15 84 ca 03 c0    	mov    %edx,0xc003ca84
  *y = cp / COL_CNT;
c00246bc:	0f b7 c1             	movzwl %cx,%eax
c00246bf:	8d 14 80             	lea    (%eax,%eax,4),%edx
c00246c2:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00246c5:	01 d2                	add    %edx,%edx
c00246c7:	01 c2                	add    %eax,%edx
c00246c9:	89 d1                	mov    %edx,%ecx
c00246cb:	c1 e1 08             	shl    $0x8,%ecx
c00246ce:	01 ca                	add    %ecx,%edx
c00246d0:	8d 04 90             	lea    (%eax,%edx,4),%eax
c00246d3:	c1 e8 16             	shr    $0x16,%eax
c00246d6:	a3 80 ca 03 c0       	mov    %eax,0xc003ca80
      inited = true; 
c00246db:	c6 05 78 ca 03 c0 01 	movb   $0x1,0xc003ca78
c00246e2:	e9 77 ff ff ff       	jmp    c002465e <vga_putc+0x15>
      fb[y][x][0] = ' ';
c00246e7:	a1 7c ca 03 c0       	mov    0xc003ca7c,%eax
c00246ec:	8d 88 a0 0f 00 00    	lea    0xfa0(%eax),%ecx
c00246f2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00246f8:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c00246fb:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c00246ff:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0024702:	39 d0                	cmp    %edx,%eax
c0024704:	75 f2                	jne    c00246f8 <vga_putc+0xaf>
c0024706:	89 d0                	mov    %edx,%eax
  for (y = 0; y < ROW_CNT; y++)
c0024708:	39 d1                	cmp    %edx,%ecx
c002470a:	75 e6                	jne    c00246f2 <vga_putc+0xa9>
  cx = cy = 0;
c002470c:	c7 05 80 ca 03 c0 00 	movl   $0x0,0xc003ca80
c0024713:	00 00 00 
c0024716:	c7 05 84 ca 03 c0 00 	movl   $0x0,0xc003ca84
c002471d:	00 00 00 
  move_cursor ();
c0024720:	e8 91 fe ff ff       	call   c00245b6 <move_cursor>
c0024725:	eb 05                	jmp    c002472c <vga_putc+0xe3>
      newline ();
c0024727:	e8 ba fe ff ff       	call   c00245e6 <newline>
  move_cursor ();
c002472c:	e8 85 fe ff ff       	call   c00245b6 <move_cursor>
  intr_set_level (old_level);
c0024731:	83 ec 0c             	sub    $0xc,%esp
c0024734:	53                   	push   %ebx
c0024735:	e8 ce d2 ff ff       	call   c0021a08 <intr_set_level>
}
c002473a:	83 c4 14             	add    $0x14,%esp
c002473d:	5b                   	pop    %ebx
c002473e:	5e                   	pop    %esi
c002473f:	c3                   	ret    
      if (cx > 0)
c0024740:	a1 84 ca 03 c0       	mov    0xc003ca84,%eax
c0024745:	85 c0                	test   %eax,%eax
c0024747:	74 e3                	je     c002472c <vga_putc+0xe3>
        cx--;
c0024749:	48                   	dec    %eax
c002474a:	a3 84 ca 03 c0       	mov    %eax,0xc003ca84
c002474f:	eb db                	jmp    c002472c <vga_putc+0xe3>
      cx = 0;
c0024751:	c7 05 84 ca 03 c0 00 	movl   $0x0,0xc003ca84
c0024758:	00 00 00 
      break;
c002475b:	eb cf                	jmp    c002472c <vga_putc+0xe3>
      cx = ROUND_UP (cx + 1, 8);
c002475d:	a1 84 ca 03 c0       	mov    0xc003ca84,%eax
c0024762:	83 c0 08             	add    $0x8,%eax
c0024765:	83 e0 f8             	and    $0xfffffff8,%eax
c0024768:	a3 84 ca 03 c0       	mov    %eax,0xc003ca84
      if (cx >= COL_CNT)
c002476d:	83 f8 4f             	cmp    $0x4f,%eax
c0024770:	76 ba                	jbe    c002472c <vga_putc+0xe3>
        newline ();
c0024772:	e8 6f fe ff ff       	call   c00245e6 <newline>
c0024777:	eb b3                	jmp    c002472c <vga_putc+0xe3>
      intr_set_level (old_level);
c0024779:	83 ec 0c             	sub    $0xc,%esp
c002477c:	53                   	push   %ebx
c002477d:	e8 86 d2 ff ff       	call   c0021a08 <intr_set_level>
      speaker_beep ();
c0024782:	e8 b8 1d 00 00       	call   c002653f <speaker_beep>
      intr_disable ();
c0024787:	e8 75 d2 ff ff       	call   c0021a01 <intr_disable>
      break;
c002478c:	83 c4 10             	add    $0x10,%esp
c002478f:	eb 9b                	jmp    c002472c <vga_putc+0xe3>
      fb[cy][cx][0] = c;
c0024791:	8b 35 7c ca 03 c0    	mov    0xc003ca7c,%esi
c0024797:	a1 80 ca 03 c0       	mov    0xc003ca80,%eax
c002479c:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002479f:	c1 e0 05             	shl    $0x5,%eax
c00247a2:	01 f0                	add    %esi,%eax
c00247a4:	8b 0d 84 ca 03 c0    	mov    0xc003ca84,%ecx
c00247aa:	8a 54 24 10          	mov    0x10(%esp),%dl
c00247ae:	88 14 48             	mov    %dl,(%eax,%ecx,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c00247b1:	a1 80 ca 03 c0       	mov    0xc003ca80,%eax
c00247b6:	8d 04 80             	lea    (%eax,%eax,4),%eax
c00247b9:	c1 e0 05             	shl    $0x5,%eax
c00247bc:	8d 14 06             	lea    (%esi,%eax,1),%edx
c00247bf:	a1 84 ca 03 c0       	mov    0xc003ca84,%eax
c00247c4:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c00247c9:	a1 84 ca 03 c0       	mov    0xc003ca84,%eax
c00247ce:	40                   	inc    %eax
c00247cf:	a3 84 ca 03 c0       	mov    %eax,0xc003ca84
c00247d4:	83 f8 4f             	cmp    $0x4f,%eax
c00247d7:	0f 86 4f ff ff ff    	jbe    c002472c <vga_putc+0xe3>
        newline ();
c00247dd:	e8 04 fe ff ff       	call   c00245e6 <newline>
c00247e2:	e9 45 ff ff ff       	jmp    c002472c <vga_putc+0xe3>

c00247e7 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c00247e7:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (mode == UNINIT);
c00247ea:	83 3d 24 cb 03 c0 00 	cmpl   $0x0,0xc003cb24
c00247f1:	75 51                	jne    c0024844 <init_poll+0x5d>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00247f3:	ba f9 03 00 00       	mov    $0x3f9,%edx
c00247f8:	b0 00                	mov    $0x0,%al
c00247fa:	ee                   	out    %al,(%dx)
c00247fb:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024800:	ee                   	out    %al,(%dx)
c0024801:	ba fb 03 00 00       	mov    $0x3fb,%edx
c0024806:	b0 83                	mov    $0x83,%al
c0024808:	ee                   	out    %al,(%dx)
c0024809:	ba f8 03 00 00       	mov    $0x3f8,%edx
c002480e:	b0 0c                	mov    $0xc,%al
c0024810:	ee                   	out    %al,(%dx)
c0024811:	ba f9 03 00 00       	mov    $0x3f9,%edx
c0024816:	b0 00                	mov    $0x0,%al
c0024818:	ee                   	out    %al,(%dx)
c0024819:	ba fb 03 00 00       	mov    $0x3fb,%edx
c002481e:	b0 03                	mov    $0x3,%al
c0024820:	ee                   	out    %al,(%dx)
c0024821:	ba fc 03 00 00       	mov    $0x3fc,%edx
c0024826:	b0 08                	mov    $0x8,%al
c0024828:	ee                   	out    %al,(%dx)
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
  outb (FCR_REG, 0);                    /* Disable FIFO. */
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
  intq_init (&txq);
c0024829:	83 ec 0c             	sub    $0xc,%esp
c002482c:	68 a0 ca 03 c0       	push   $0xc003caa0
c0024831:	e8 6b 16 00 00       	call   c0025ea1 <intq_init>
  mode = POLL;
c0024836:	c7 05 24 cb 03 c0 01 	movl   $0x1,0xc003cb24
c002483d:	00 00 00 
} 
c0024840:	83 c4 1c             	add    $0x1c,%esp
c0024843:	c3                   	ret    
  ASSERT (mode == UNINIT);
c0024844:	83 ec 0c             	sub    $0xc,%esp
c0024847:	68 7f 10 03 c0       	push   $0xc003107f
c002484c:	68 21 01 03 c0       	push   $0xc0030121
c0024851:	68 74 ee 02 c0       	push   $0xc002ee74
c0024856:	6a 45                	push   $0x45
c0024858:	68 8e 10 03 c0       	push   $0xc003108e
c002485d:	e8 c5 3d 00 00       	call   c0028627 <debug_panic>

c0024862 <write_ier>:
}

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024862:	53                   	push   %ebx
c0024863:	83 ec 08             	sub    $0x8,%esp
  uint8_t ier = 0;

  ASSERT (intr_get_level () == INTR_OFF);
c0024866:	e8 59 d1 ff ff       	call   c00219c4 <intr_get_level>
c002486b:	85 c0                	test   %eax,%eax
c002486d:	75 30                	jne    c002489f <write_ier+0x3d>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c002486f:	83 ec 0c             	sub    $0xc,%esp
c0024872:	68 a0 ca 03 c0       	push   $0xc003caa0
c0024877:	e8 57 16 00 00       	call   c0025ed3 <intq_empty>
c002487c:	83 c4 10             	add    $0x10,%esp
c002487f:	84 c0                	test   %al,%al
    ier |= IER_XMIT;
c0024881:	0f 94 c3             	sete   %bl
c0024884:	d1 e3                	shl    %ebx

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024886:	e8 4f 15 00 00       	call   c0025dda <input_full>
c002488b:	84 c0                	test   %al,%al
c002488d:	75 03                	jne    c0024892 <write_ier+0x30>
    ier |= IER_RECV;
c002488f:	83 cb 01             	or     $0x1,%ebx
c0024892:	ba f9 03 00 00       	mov    $0x3f9,%edx
c0024897:	88 d8                	mov    %bl,%al
c0024899:	ee                   	out    %al,(%dx)
  
  outb (IER_REG, ier);
}
c002489a:	83 c4 08             	add    $0x8,%esp
c002489d:	5b                   	pop    %ebx
c002489e:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c002489f:	83 ec 0c             	sub    $0xc,%esp
c00248a2:	68 26 07 03 c0       	push   $0xc0030726
c00248a7:	68 21 01 03 c0       	push   $0xc0030121
c00248ac:	68 68 ee 02 c0       	push   $0xc002ee68
c00248b1:	68 b5 00 00 00       	push   $0xb5
c00248b6:	68 8e 10 03 c0       	push   $0xc003108e
c00248bb:	e8 67 3d 00 00       	call   c0028627 <debug_panic>

c00248c0 <serial_interrupt>:
}

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c00248c0:	56                   	push   %esi
c00248c1:	53                   	push   %ebx
c00248c2:	83 ec 04             	sub    $0x4,%esp
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00248c5:	ba fa 03 00 00       	mov    $0x3fa,%edx
c00248ca:	ec                   	in     (%dx),%al
c00248cb:	bb fd 03 00 00       	mov    $0x3fd,%ebx
c00248d0:	be f8 03 00 00       	mov    $0x3f8,%esi
c00248d5:	eb 12                	jmp    c00248e9 <serial_interrupt+0x29>
c00248d7:	89 f2                	mov    %esi,%edx
c00248d9:	ec                   	in     (%dx),%al
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));
c00248da:	83 ec 0c             	sub    $0xc,%esp
c00248dd:	0f b6 c0             	movzbl %al,%eax
c00248e0:	50                   	push   %eax
c00248e1:	e8 48 14 00 00       	call   c0025d2e <input_putc>
c00248e6:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c00248e9:	e8 ec 14 00 00       	call   c0025dda <input_full>
c00248ee:	84 c0                	test   %al,%al
c00248f0:	75 07                	jne    c00248f9 <serial_interrupt+0x39>
c00248f2:	89 da                	mov    %ebx,%edx
c00248f4:	ec                   	in     (%dx),%al
c00248f5:	a8 01                	test   $0x1,%al
c00248f7:	75 de                	jne    c00248d7 <serial_interrupt+0x17>
c00248f9:	bb fd 03 00 00       	mov    $0x3fd,%ebx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00248fe:	be f8 03 00 00       	mov    $0x3f8,%esi
c0024903:	eb 13                	jmp    c0024918 <serial_interrupt+0x58>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
    outb (THR_REG, intq_getc (&txq));
c0024905:	83 ec 0c             	sub    $0xc,%esp
c0024908:	68 a0 ca 03 c0       	push   $0xc003caa0
c002490d:	e8 a3 17 00 00       	call   c00260b5 <intq_getc>
c0024912:	89 f2                	mov    %esi,%edx
c0024914:	ee                   	out    %al,(%dx)
c0024915:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024918:	83 ec 0c             	sub    $0xc,%esp
c002491b:	68 a0 ca 03 c0       	push   $0xc003caa0
c0024920:	e8 ae 15 00 00       	call   c0025ed3 <intq_empty>
c0024925:	83 c4 10             	add    $0x10,%esp
c0024928:	84 c0                	test   %al,%al
c002492a:	75 07                	jne    c0024933 <serial_interrupt+0x73>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002492c:	89 da                	mov    %ebx,%edx
c002492e:	ec                   	in     (%dx),%al
c002492f:	a8 20                	test   $0x20,%al
c0024931:	75 d2                	jne    c0024905 <serial_interrupt+0x45>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024933:	e8 2a ff ff ff       	call   c0024862 <write_ier>
}
c0024938:	83 c4 04             	add    $0x4,%esp
c002493b:	5b                   	pop    %ebx
c002493c:	5e                   	pop    %esi
c002493d:	c3                   	ret    

c002493e <putc_poll>:
{
c002493e:	53                   	push   %ebx
c002493f:	83 ec 08             	sub    $0x8,%esp
c0024942:	89 c3                	mov    %eax,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0024944:	e8 7b d0 ff ff       	call   c00219c4 <intr_get_level>
c0024949:	85 c0                	test   %eax,%eax
c002494b:	75 17                	jne    c0024964 <putc_poll+0x26>
c002494d:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0024952:	ec                   	in     (%dx),%al
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024953:	a8 20                	test   $0x20,%al
c0024955:	74 fb                	je     c0024952 <putc_poll+0x14>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024957:	ba f8 03 00 00       	mov    $0x3f8,%edx
c002495c:	88 d8                	mov    %bl,%al
c002495e:	ee                   	out    %al,(%dx)
}
c002495f:	83 c4 08             	add    $0x8,%esp
c0024962:	5b                   	pop    %ebx
c0024963:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024964:	83 ec 0c             	sub    $0xc,%esp
c0024967:	68 26 07 03 c0       	push   $0xc0030726
c002496c:	68 21 01 03 c0       	push   $0xc0030121
c0024971:	68 5c ee 02 c0       	push   $0xc002ee5c
c0024976:	68 c9 00 00 00       	push   $0xc9
c002497b:	68 8e 10 03 c0       	push   $0xc003108e
c0024980:	e8 a2 3c 00 00       	call   c0028627 <debug_panic>

c0024985 <serial_init_queue>:
{
c0024985:	53                   	push   %ebx
c0024986:	83 ec 08             	sub    $0x8,%esp
  if (mode == UNINIT)
c0024989:	83 3d 24 cb 03 c0 00 	cmpl   $0x0,0xc003cb24
c0024990:	74 40                	je     c00249d2 <serial_init_queue+0x4d>
  ASSERT (mode == POLL);
c0024992:	83 3d 24 cb 03 c0 01 	cmpl   $0x1,0xc003cb24
c0024999:	75 3e                	jne    c00249d9 <serial_init_queue+0x54>
  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c002499b:	83 ec 04             	sub    $0x4,%esp
c002499e:	68 b2 10 03 c0       	push   $0xc00310b2
c00249a3:	68 c0 48 02 c0       	push   $0xc00248c0
c00249a8:	6a 24                	push   $0x24
c00249aa:	e8 d3 d1 ff ff       	call   c0021b82 <intr_register_ext>
  mode = QUEUE;
c00249af:	c7 05 24 cb 03 c0 02 	movl   $0x2,0xc003cb24
c00249b6:	00 00 00 
  old_level = intr_disable ();
c00249b9:	e8 43 d0 ff ff       	call   c0021a01 <intr_disable>
c00249be:	89 c3                	mov    %eax,%ebx
  write_ier ();
c00249c0:	e8 9d fe ff ff       	call   c0024862 <write_ier>
  intr_set_level (old_level);
c00249c5:	89 1c 24             	mov    %ebx,(%esp)
c00249c8:	e8 3b d0 ff ff       	call   c0021a08 <intr_set_level>
}
c00249cd:	83 c4 18             	add    $0x18,%esp
c00249d0:	5b                   	pop    %ebx
c00249d1:	c3                   	ret    
    init_poll ();
c00249d2:	e8 10 fe ff ff       	call   c00247e7 <init_poll>
c00249d7:	eb b9                	jmp    c0024992 <serial_init_queue+0xd>
  ASSERT (mode == POLL);
c00249d9:	83 ec 0c             	sub    $0xc,%esp
c00249dc:	68 a5 10 03 c0       	push   $0xc00310a5
c00249e1:	68 21 01 03 c0       	push   $0xc0030121
c00249e6:	68 80 ee 02 c0       	push   $0xc002ee80
c00249eb:	6a 58                	push   $0x58
c00249ed:	68 8e 10 03 c0       	push   $0xc003108e
c00249f2:	e8 30 3c 00 00       	call   c0028627 <debug_panic>

c00249f7 <serial_putc>:
{
c00249f7:	56                   	push   %esi
c00249f8:	53                   	push   %ebx
c00249f9:	83 ec 04             	sub    $0x4,%esp
c00249fc:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level = intr_disable ();
c0024a00:	e8 fc cf ff ff       	call   c0021a01 <intr_disable>
c0024a05:	89 c6                	mov    %eax,%esi
  if (mode != QUEUE)
c0024a07:	a1 24 cb 03 c0       	mov    0xc003cb24,%eax
c0024a0c:	83 f8 02             	cmp    $0x2,%eax
c0024a0f:	74 22                	je     c0024a33 <serial_putc+0x3c>
      if (mode == UNINIT)
c0024a11:	85 c0                	test   %eax,%eax
c0024a13:	74 17                	je     c0024a2c <serial_putc+0x35>
      putc_poll (byte); 
c0024a15:	0f b6 c3             	movzbl %bl,%eax
c0024a18:	e8 21 ff ff ff       	call   c002493e <putc_poll>
  intr_set_level (old_level);
c0024a1d:	83 ec 0c             	sub    $0xc,%esp
c0024a20:	56                   	push   %esi
c0024a21:	e8 e2 cf ff ff       	call   c0021a08 <intr_set_level>
}
c0024a26:	83 c4 14             	add    $0x14,%esp
c0024a29:	5b                   	pop    %ebx
c0024a2a:	5e                   	pop    %esi
c0024a2b:	c3                   	ret    
        init_poll ();
c0024a2c:	e8 b6 fd ff ff       	call   c00247e7 <init_poll>
c0024a31:	eb e2                	jmp    c0024a15 <serial_putc+0x1e>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024a33:	85 f6                	test   %esi,%esi
c0024a35:	74 1b                	je     c0024a52 <serial_putc+0x5b>
      intq_putc (&txq, byte); 
c0024a37:	83 ec 08             	sub    $0x8,%esp
c0024a3a:	0f b6 db             	movzbl %bl,%ebx
c0024a3d:	53                   	push   %ebx
c0024a3e:	68 a0 ca 03 c0       	push   $0xc003caa0
c0024a43:	e8 28 17 00 00       	call   c0026170 <intq_putc>
      write_ier ();
c0024a48:	e8 15 fe ff ff       	call   c0024862 <write_ier>
c0024a4d:	83 c4 10             	add    $0x10,%esp
c0024a50:	eb cb                	jmp    c0024a1d <serial_putc+0x26>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024a52:	83 ec 0c             	sub    $0xc,%esp
c0024a55:	68 a0 ca 03 c0       	push   $0xc003caa0
c0024a5a:	e8 b4 14 00 00       	call   c0025f13 <intq_full>
c0024a5f:	83 c4 10             	add    $0x10,%esp
c0024a62:	84 c0                	test   %al,%al
c0024a64:	74 d1                	je     c0024a37 <serial_putc+0x40>
          putc_poll (intq_getc (&txq)); 
c0024a66:	83 ec 0c             	sub    $0xc,%esp
c0024a69:	68 a0 ca 03 c0       	push   $0xc003caa0
c0024a6e:	e8 42 16 00 00       	call   c00260b5 <intq_getc>
c0024a73:	0f b6 c0             	movzbl %al,%eax
c0024a76:	e8 c3 fe ff ff       	call   c002493e <putc_poll>
c0024a7b:	83 c4 10             	add    $0x10,%esp
c0024a7e:	eb b7                	jmp    c0024a37 <serial_putc+0x40>

c0024a80 <serial_flush>:
{
c0024a80:	53                   	push   %ebx
c0024a81:	83 ec 08             	sub    $0x8,%esp
  enum intr_level old_level = intr_disable ();
c0024a84:	e8 78 cf ff ff       	call   c0021a01 <intr_disable>
c0024a89:	89 c3                	mov    %eax,%ebx
  while (!intq_empty (&txq))
c0024a8b:	eb 18                	jmp    c0024aa5 <serial_flush+0x25>
    putc_poll (intq_getc (&txq));
c0024a8d:	83 ec 0c             	sub    $0xc,%esp
c0024a90:	68 a0 ca 03 c0       	push   $0xc003caa0
c0024a95:	e8 1b 16 00 00       	call   c00260b5 <intq_getc>
c0024a9a:	0f b6 c0             	movzbl %al,%eax
c0024a9d:	e8 9c fe ff ff       	call   c002493e <putc_poll>
c0024aa2:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c0024aa5:	83 ec 0c             	sub    $0xc,%esp
c0024aa8:	68 a0 ca 03 c0       	push   $0xc003caa0
c0024aad:	e8 21 14 00 00       	call   c0025ed3 <intq_empty>
c0024ab2:	83 c4 10             	add    $0x10,%esp
c0024ab5:	84 c0                	test   %al,%al
c0024ab7:	74 d4                	je     c0024a8d <serial_flush+0xd>
  intr_set_level (old_level);
c0024ab9:	83 ec 0c             	sub    $0xc,%esp
c0024abc:	53                   	push   %ebx
c0024abd:	e8 46 cf ff ff       	call   c0021a08 <intr_set_level>
}
c0024ac2:	83 c4 18             	add    $0x18,%esp
c0024ac5:	5b                   	pop    %ebx
c0024ac6:	c3                   	ret    

c0024ac7 <serial_notify>:
{
c0024ac7:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0024aca:	e8 f5 ce ff ff       	call   c00219c4 <intr_get_level>
c0024acf:	85 c0                	test   %eax,%eax
c0024ad1:	75 0d                	jne    c0024ae0 <serial_notify+0x19>
  if (mode == QUEUE)
c0024ad3:	83 3d 24 cb 03 c0 02 	cmpl   $0x2,0xc003cb24
c0024ada:	74 25                	je     c0024b01 <serial_notify+0x3a>
}
c0024adc:	83 c4 0c             	add    $0xc,%esp
c0024adf:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024ae0:	83 ec 0c             	sub    $0xc,%esp
c0024ae3:	68 26 07 03 c0       	push   $0xc0030726
c0024ae8:	68 21 01 03 c0       	push   $0xc0030121
c0024aed:	68 4c ee 02 c0       	push   $0xc002ee4c
c0024af2:	68 96 00 00 00       	push   $0x96
c0024af7:	68 8e 10 03 c0       	push   $0xc003108e
c0024afc:	e8 26 3b 00 00       	call   c0028627 <debug_panic>
    write_ier ();
c0024b01:	e8 5c fd ff ff       	call   c0024862 <write_ier>
}
c0024b06:	eb d4                	jmp    c0024adc <serial_notify+0x15>

c0024b08 <check_sector>:
/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
  if (sector >= block->size)
c0024b08:	8b 48 1c             	mov    0x1c(%eax),%ecx
c0024b0b:	39 d1                	cmp    %edx,%ecx
c0024b0d:	76 01                	jbe    c0024b10 <check_sector+0x8>
c0024b0f:	c3                   	ret    
{
c0024b10:	83 ec 10             	sub    $0x10,%esp
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024b13:	51                   	push   %ecx
c0024b14:	52                   	push   %edx

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
  return block->name;
c0024b15:	83 c0 08             	add    $0x8,%eax
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024b18:	50                   	push   %eax
c0024b19:	68 bc 10 03 c0       	push   $0xc00310bc
c0024b1e:	68 b0 ee 02 c0       	push   $0xc002eeb0
c0024b23:	6a 70                	push   $0x70
c0024b25:	68 4a 11 03 c0       	push   $0xc003114a
c0024b2a:	e8 f8 3a 00 00       	call   c0028627 <debug_panic>

c0024b2f <block_type_name>:
{
c0024b2f:	83 ec 0c             	sub    $0xc,%esp
c0024b32:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (type < BLOCK_CNT);
c0024b36:	83 f8 05             	cmp    $0x5,%eax
c0024b39:	77 0b                	ja     c0024b46 <block_type_name+0x17>
  return block_type_names[type];
c0024b3b:	8b 04 85 e0 ee 02 c0 	mov    -0x3ffd1120(,%eax,4),%eax
}
c0024b42:	83 c4 0c             	add    $0xc,%esp
c0024b45:	c3                   	ret    
  ASSERT (type < BLOCK_CNT);
c0024b46:	83 ec 0c             	sub    $0xc,%esp
c0024b49:	68 60 11 03 c0       	push   $0xc0031160
c0024b4e:	68 21 01 03 c0       	push   $0xc0030121
c0024b53:	68 f8 ee 02 c0       	push   $0xc002eef8
c0024b58:	6a 2f                	push   $0x2f
c0024b5a:	68 4a 11 03 c0       	push   $0xc003114a
c0024b5f:	e8 c3 3a 00 00       	call   c0028627 <debug_panic>

c0024b64 <block_get_role>:
{
c0024b64:	83 ec 0c             	sub    $0xc,%esp
c0024b67:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0024b6b:	83 f8 03             	cmp    $0x3,%eax
c0024b6e:	77 0b                	ja     c0024b7b <block_get_role+0x17>
  return block_by_role[role];
c0024b70:	8b 04 85 28 cb 03 c0 	mov    -0x3ffc34d8(,%eax,4),%eax
}
c0024b77:	83 c4 0c             	add    $0xc,%esp
c0024b7a:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c0024b7b:	83 ec 0c             	sub    $0xc,%esp
c0024b7e:	68 71 11 03 c0       	push   $0xc0031171
c0024b83:	68 21 01 03 c0       	push   $0xc0030121
c0024b88:	68 d0 ee 02 c0       	push   $0xc002eed0
c0024b8d:	6a 38                	push   $0x38
c0024b8f:	68 4a 11 03 c0       	push   $0xc003114a
c0024b94:	e8 8e 3a 00 00       	call   c0028627 <debug_panic>

c0024b99 <block_set_role>:
{
c0024b99:	83 ec 0c             	sub    $0xc,%esp
c0024b9c:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0024ba0:	83 f8 03             	cmp    $0x3,%eax
c0024ba3:	77 0f                	ja     c0024bb4 <block_set_role+0x1b>
  block_by_role[role] = block;
c0024ba5:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024ba9:	89 14 85 28 cb 03 c0 	mov    %edx,-0x3ffc34d8(,%eax,4)
}
c0024bb0:	83 c4 0c             	add    $0xc,%esp
c0024bb3:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c0024bb4:	83 ec 0c             	sub    $0xc,%esp
c0024bb7:	68 71 11 03 c0       	push   $0xc0031171
c0024bbc:	68 21 01 03 c0       	push   $0xc0030121
c0024bc1:	68 c0 ee 02 c0       	push   $0xc002eec0
c0024bc6:	6a 40                	push   $0x40
c0024bc8:	68 4a 11 03 c0       	push   $0xc003114a
c0024bcd:	e8 55 3a 00 00       	call   c0028627 <debug_panic>

c0024bd2 <block_first>:
{
c0024bd2:	53                   	push   %ebx
c0024bd3:	83 ec 14             	sub    $0x14,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c0024bd6:	68 14 b0 03 c0       	push   $0xc003b014
c0024bdb:	e8 31 3b 00 00       	call   c0028711 <list_begin>
c0024be0:	89 c3                	mov    %eax,%ebx
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c0024be2:	c7 04 24 14 b0 03 c0 	movl   $0xc003b014,(%esp)
c0024be9:	e8 9b 3b 00 00       	call   c0028789 <list_end>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0024bee:	83 c4 10             	add    $0x10,%esp
c0024bf1:	39 c3                	cmp    %eax,%ebx
c0024bf3:	74 07                	je     c0024bfc <block_first+0x2a>
c0024bf5:	89 d8                	mov    %ebx,%eax
}
c0024bf7:	83 c4 08             	add    $0x8,%esp
c0024bfa:	5b                   	pop    %ebx
c0024bfb:	c3                   	ret    
          : NULL);
c0024bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  return list_elem_to_block (list_begin (&all_blocks));
c0024c01:	eb f4                	jmp    c0024bf7 <block_first+0x25>

c0024c03 <block_next>:
{
c0024c03:	53                   	push   %ebx
c0024c04:	83 ec 14             	sub    $0x14,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0024c07:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024c0b:	e8 31 3b 00 00       	call   c0028741 <list_next>
c0024c10:	89 c3                	mov    %eax,%ebx
  return (list_elem != list_end (&all_blocks)
c0024c12:	c7 04 24 14 b0 03 c0 	movl   $0xc003b014,(%esp)
c0024c19:	e8 6b 3b 00 00       	call   c0028789 <list_end>
          : NULL);
c0024c1e:	83 c4 10             	add    $0x10,%esp
c0024c21:	39 c3                	cmp    %eax,%ebx
c0024c23:	74 07                	je     c0024c2c <block_next+0x29>
c0024c25:	89 d8                	mov    %ebx,%eax
}
c0024c27:	83 c4 08             	add    $0x8,%esp
c0024c2a:	5b                   	pop    %ebx
c0024c2b:	c3                   	ret    
          : NULL);
c0024c2c:	b8 00 00 00 00       	mov    $0x0,%eax
  return list_elem_to_block (list_next (&block->list_elem));
c0024c31:	eb f4                	jmp    c0024c27 <block_next+0x24>

c0024c33 <block_get_by_name>:
{
c0024c33:	56                   	push   %esi
c0024c34:	53                   	push   %ebx
c0024c35:	83 ec 10             	sub    $0x10,%esp
c0024c38:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024c3c:	68 14 b0 03 c0       	push   $0xc003b014
c0024c41:	e8 cb 3a 00 00       	call   c0028711 <list_begin>
c0024c46:	89 c3                	mov    %eax,%ebx
c0024c48:	83 c4 10             	add    $0x10,%esp
c0024c4b:	83 ec 0c             	sub    $0xc,%esp
c0024c4e:	68 14 b0 03 c0       	push   $0xc003b014
c0024c53:	e8 31 3b 00 00       	call   c0028789 <list_end>
c0024c58:	83 c4 10             	add    $0x10,%esp
c0024c5b:	39 c3                	cmp    %eax,%ebx
c0024c5d:	74 24                	je     c0024c83 <block_get_by_name+0x50>
      if (!strcmp (name, block->name))
c0024c5f:	8d 43 08             	lea    0x8(%ebx),%eax
c0024c62:	83 ec 08             	sub    $0x8,%esp
c0024c65:	50                   	push   %eax
c0024c66:	56                   	push   %esi
c0024c67:	e8 70 2d 00 00       	call   c00279dc <strcmp>
c0024c6c:	83 c4 10             	add    $0x10,%esp
c0024c6f:	85 c0                	test   %eax,%eax
c0024c71:	74 1b                	je     c0024c8e <block_get_by_name+0x5b>
       e = list_next (e))
c0024c73:	83 ec 0c             	sub    $0xc,%esp
c0024c76:	53                   	push   %ebx
c0024c77:	e8 c5 3a 00 00       	call   c0028741 <list_next>
c0024c7c:	89 c3                	mov    %eax,%ebx
c0024c7e:	83 c4 10             	add    $0x10,%esp
c0024c81:	eb c8                	jmp    c0024c4b <block_get_by_name+0x18>
  return NULL;
c0024c83:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024c88:	83 c4 04             	add    $0x4,%esp
c0024c8b:	5b                   	pop    %ebx
c0024c8c:	5e                   	pop    %esi
c0024c8d:	c3                   	ret    
c0024c8e:	89 d8                	mov    %ebx,%eax
c0024c90:	eb f6                	jmp    c0024c88 <block_get_by_name+0x55>

c0024c92 <block_read>:
{
c0024c92:	56                   	push   %esi
c0024c93:	53                   	push   %ebx
c0024c94:	83 ec 04             	sub    $0x4,%esp
c0024c97:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0024c9b:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c0024c9f:	89 f2                	mov    %esi,%edx
c0024ca1:	89 d8                	mov    %ebx,%eax
c0024ca3:	e8 60 fe ff ff       	call   c0024b08 <check_sector>
  block->ops->read (block->aux, sector, buffer);
c0024ca8:	83 ec 04             	sub    $0x4,%esp
c0024cab:	8b 43 20             	mov    0x20(%ebx),%eax
c0024cae:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024cb2:	56                   	push   %esi
c0024cb3:	ff 73 24             	pushl  0x24(%ebx)
c0024cb6:	ff 10                	call   *(%eax)
  block->read_cnt++;
c0024cb8:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c0024cbc:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c0024cc0:	83 c4 14             	add    $0x14,%esp
c0024cc3:	5b                   	pop    %ebx
c0024cc4:	5e                   	pop    %esi
c0024cc5:	c3                   	ret    

c0024cc6 <block_write>:
{
c0024cc6:	56                   	push   %esi
c0024cc7:	53                   	push   %ebx
c0024cc8:	83 ec 04             	sub    $0x4,%esp
c0024ccb:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0024ccf:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c0024cd3:	89 f2                	mov    %esi,%edx
c0024cd5:	89 d8                	mov    %ebx,%eax
c0024cd7:	e8 2c fe ff ff       	call   c0024b08 <check_sector>
  ASSERT (block->type != BLOCK_FOREIGN);
c0024cdc:	83 7b 18 05          	cmpl   $0x5,0x18(%ebx)
c0024ce0:	74 1f                	je     c0024d01 <block_write+0x3b>
  block->ops->write (block->aux, sector, buffer);
c0024ce2:	83 ec 04             	sub    $0x4,%esp
c0024ce5:	8b 43 20             	mov    0x20(%ebx),%eax
c0024ce8:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024cec:	56                   	push   %esi
c0024ced:	ff 73 24             	pushl  0x24(%ebx)
c0024cf0:	ff 50 04             	call   *0x4(%eax)
  block->write_cnt++;
c0024cf3:	83 43 30 01          	addl   $0x1,0x30(%ebx)
c0024cf7:	83 53 34 00          	adcl   $0x0,0x34(%ebx)
}
c0024cfb:	83 c4 14             	add    $0x14,%esp
c0024cfe:	5b                   	pop    %ebx
c0024cff:	5e                   	pop    %esi
c0024d00:	c3                   	ret    
  ASSERT (block->type != BLOCK_FOREIGN);
c0024d01:	83 ec 0c             	sub    $0xc,%esp
c0024d04:	68 87 11 03 c0       	push   $0xc0031187
c0024d09:	68 21 01 03 c0       	push   $0xc0030121
c0024d0e:	68 a4 ee 02 c0       	push   $0xc002eea4
c0024d13:	68 89 00 00 00       	push   $0x89
c0024d18:	68 4a 11 03 c0       	push   $0xc003114a
c0024d1d:	e8 05 39 00 00       	call   c0028627 <debug_panic>

c0024d22 <block_size>:
  return block->size;
c0024d22:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024d26:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0024d29:	c3                   	ret    

c0024d2a <block_name>:
  return block->name;
c0024d2a:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024d2e:	83 c0 08             	add    $0x8,%eax
}
c0024d31:	c3                   	ret    

c0024d32 <block_type>:
  return block->type;
c0024d32:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024d36:	8b 40 18             	mov    0x18(%eax),%eax
}
c0024d39:	c3                   	ret    

c0024d3a <block_print_stats>:
{
c0024d3a:	57                   	push   %edi
c0024d3b:	56                   	push   %esi
c0024d3c:	53                   	push   %ebx
c0024d3d:	be 28 cb 03 c0       	mov    $0xc003cb28,%esi
c0024d42:	bf 38 cb 03 c0       	mov    $0xc003cb38,%edi
c0024d47:	eb 07                	jmp    c0024d50 <block_print_stats+0x16>
c0024d49:	83 c6 04             	add    $0x4,%esi
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0024d4c:	39 fe                	cmp    %edi,%esi
c0024d4e:	74 34                	je     c0024d84 <block_print_stats+0x4a>
      struct block *block = block_by_role[i];
c0024d50:	8b 1e                	mov    (%esi),%ebx
      if (block != NULL)
c0024d52:	85 db                	test   %ebx,%ebx
c0024d54:	74 f3                	je     c0024d49 <block_print_stats+0xf>
          printf ("%s (%s): %llu reads, %llu writes\n",
c0024d56:	83 ec 0c             	sub    $0xc,%esp
c0024d59:	ff 73 18             	pushl  0x18(%ebx)
c0024d5c:	e8 ce fd ff ff       	call   c0024b2f <block_type_name>
c0024d61:	83 c4 0c             	add    $0xc,%esp
c0024d64:	ff 73 34             	pushl  0x34(%ebx)
c0024d67:	ff 73 30             	pushl  0x30(%ebx)
c0024d6a:	ff 73 2c             	pushl  0x2c(%ebx)
c0024d6d:	ff 73 28             	pushl  0x28(%ebx)
c0024d70:	50                   	push   %eax
c0024d71:	83 c3 08             	add    $0x8,%ebx
c0024d74:	53                   	push   %ebx
c0024d75:	68 f0 10 03 c0       	push   $0xc00310f0
c0024d7a:	e8 fa 1d 00 00       	call   c0026b79 <printf>
c0024d7f:	83 c4 20             	add    $0x20,%esp
c0024d82:	eb c5                	jmp    c0024d49 <block_print_stats+0xf>
}
c0024d84:	5b                   	pop    %ebx
c0024d85:	5e                   	pop    %esi
c0024d86:	5f                   	pop    %edi
c0024d87:	c3                   	ret    

c0024d88 <block_register>:
{
c0024d88:	55                   	push   %ebp
c0024d89:	57                   	push   %edi
c0024d8a:	56                   	push   %esi
c0024d8b:	53                   	push   %ebx
c0024d8c:	83 ec 18             	sub    $0x18,%esp
c0024d8f:	8b 74 24 34          	mov    0x34(%esp),%esi
c0024d93:	8b 7c 24 38          	mov    0x38(%esp),%edi
  struct block *block = malloc (sizeof *block);
c0024d97:	6a 38                	push   $0x38
c0024d99:	e8 30 ec ff ff       	call   c00239ce <malloc>
  if (block == NULL)
c0024d9e:	83 c4 10             	add    $0x10,%esp
c0024da1:	85 c0                	test   %eax,%eax
c0024da3:	0f 84 b6 00 00 00    	je     c0024e5f <block_register+0xd7>
c0024da9:	89 c3                	mov    %eax,%ebx
  list_push_back (&all_blocks, &block->list_elem);
c0024dab:	83 ec 08             	sub    $0x8,%esp
c0024dae:	50                   	push   %eax
c0024daf:	68 14 b0 03 c0       	push   $0xc003b014
c0024db4:	e8 61 3d 00 00       	call   c0028b1a <list_push_back>
  strlcpy (block->name, name, sizeof block->name);
c0024db9:	8d 6b 08             	lea    0x8(%ebx),%ebp
c0024dbc:	83 c4 0c             	add    $0xc,%esp
c0024dbf:	6a 10                	push   $0x10
c0024dc1:	ff 74 24 28          	pushl  0x28(%esp)
c0024dc5:	55                   	push   %ebp
c0024dc6:	e8 56 2f 00 00       	call   c0027d21 <strlcpy>
  block->type = type;
c0024dcb:	8b 44 24 34          	mov    0x34(%esp),%eax
c0024dcf:	89 43 18             	mov    %eax,0x18(%ebx)
  block->size = size;
c0024dd2:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  block->ops = ops;
c0024dd5:	8b 44 24 40          	mov    0x40(%esp),%eax
c0024dd9:	89 43 20             	mov    %eax,0x20(%ebx)
  block->aux = aux;
c0024ddc:	8b 44 24 44          	mov    0x44(%esp),%eax
c0024de0:	89 43 24             	mov    %eax,0x24(%ebx)
  block->read_cnt = 0;
c0024de3:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
c0024dea:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  block->write_cnt = 0;
c0024df1:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
c0024df8:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c0024dff:	83 c4 0c             	add    $0xc,%esp
c0024e02:	57                   	push   %edi
c0024e03:	55                   	push   %ebp
c0024e04:	68 a4 11 03 c0       	push   $0xc00311a4
c0024e09:	e8 6b 1d 00 00       	call   c0026b79 <printf>
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c0024e0e:	83 c4 08             	add    $0x8,%esp
c0024e11:	8b 43 1c             	mov    0x1c(%ebx),%eax
c0024e14:	ba 00 00 00 00       	mov    $0x0,%edx
c0024e19:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c0024e1d:	c1 e0 09             	shl    $0x9,%eax
c0024e20:	52                   	push   %edx
c0024e21:	50                   	push   %eax
c0024e22:	e8 f6 26 00 00       	call   c002751d <print_human_readable_size>
  printf (")");
c0024e27:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0024e2e:	e8 47 53 00 00       	call   c002a17a <putchar>
  if (extra_info != NULL)
c0024e33:	83 c4 10             	add    $0x10,%esp
c0024e36:	85 f6                	test   %esi,%esi
c0024e38:	74 11                	je     c0024e4b <block_register+0xc3>
    printf (", %s", extra_info);
c0024e3a:	83 ec 08             	sub    $0x8,%esp
c0024e3d:	56                   	push   %esi
c0024e3e:	68 b6 11 03 c0       	push   $0xc00311b6
c0024e43:	e8 31 1d 00 00       	call   c0026b79 <printf>
c0024e48:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0024e4b:	83 ec 0c             	sub    $0xc,%esp
c0024e4e:	6a 0a                	push   $0xa
c0024e50:	e8 25 53 00 00       	call   c002a17a <putchar>
}
c0024e55:	89 d8                	mov    %ebx,%eax
c0024e57:	83 c4 1c             	add    $0x1c,%esp
c0024e5a:	5b                   	pop    %ebx
c0024e5b:	5e                   	pop    %esi
c0024e5c:	5f                   	pop    %edi
c0024e5d:	5d                   	pop    %ebp
c0024e5e:	c3                   	ret    
    PANIC ("Failed to allocate memory for block device descriptor");
c0024e5f:	68 14 11 03 c0       	push   $0xc0031114
c0024e64:	68 94 ee 02 c0       	push   $0xc002ee94
c0024e69:	68 c1 00 00 00       	push   $0xc1
c0024e6e:	68 4a 11 03 c0       	push   $0xc003114a
c0024e73:	e8 af 37 00 00       	call   c0028627 <debug_panic>

c0024e78 <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0024e78:	83 ec 10             	sub    $0x10,%esp
c0024e7b:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_read (p->block, p->start + sector, buffer);
c0024e7f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024e83:	8b 42 04             	mov    0x4(%edx),%eax
c0024e86:	03 44 24 1c          	add    0x1c(%esp),%eax
c0024e8a:	50                   	push   %eax
c0024e8b:	ff 32                	pushl  (%edx)
c0024e8d:	e8 00 fe ff ff       	call   c0024c92 <block_read>
}
c0024e92:	83 c4 1c             	add    $0x1c,%esp
c0024e95:	c3                   	ret    

c0024e96 <read_partition_table>:
{
c0024e96:	55                   	push   %ebp
c0024e97:	57                   	push   %edi
c0024e98:	56                   	push   %esi
c0024e99:	53                   	push   %ebx
c0024e9a:	81 ec c8 00 00 00    	sub    $0xc8,%esp
c0024ea0:	89 c3                	mov    %eax,%ebx
c0024ea2:	89 d6                	mov    %edx,%esi
c0024ea4:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  if (sector >= block_size (block))
c0024ea8:	50                   	push   %eax
c0024ea9:	e8 74 fe ff ff       	call   c0024d22 <block_size>
c0024eae:	83 c4 10             	add    $0x10,%esp
c0024eb1:	39 f0                	cmp    %esi,%eax
c0024eb3:	76 6b                	jbe    c0024f20 <read_partition_table+0x8a>
  pt = malloc (sizeof *pt);
c0024eb5:	83 ec 0c             	sub    $0xc,%esp
c0024eb8:	68 00 02 00 00       	push   $0x200
c0024ebd:	e8 0c eb ff ff       	call   c00239ce <malloc>
c0024ec2:	89 c7                	mov    %eax,%edi
  if (pt == NULL)
c0024ec4:	83 c4 10             	add    $0x10,%esp
c0024ec7:	85 c0                	test   %eax,%eax
c0024ec9:	74 72                	je     c0024f3d <read_partition_table+0xa7>
  block_read (block, 0, pt);
c0024ecb:	83 ec 04             	sub    $0x4,%esp
c0024ece:	50                   	push   %eax
c0024ecf:	6a 00                	push   $0x0
c0024ed1:	53                   	push   %ebx
c0024ed2:	e8 bb fd ff ff       	call   c0024c92 <block_read>
  if (pt->signature != 0xaa55)
c0024ed7:	83 c4 10             	add    $0x10,%esp
c0024eda:	66 81 bf fe 01 00 00 	cmpw   $0xaa55,0x1fe(%edi)
c0024ee1:	55 aa 
c0024ee3:	0f 84 87 00 00 00    	je     c0024f70 <read_partition_table+0xda>
      if (primary_extended_sector == 0)
c0024ee9:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0024eed:	75 64                	jne    c0024f53 <read_partition_table+0xbd>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c0024eef:	83 ec 0c             	sub    $0xc,%esp
c0024ef2:	53                   	push   %ebx
c0024ef3:	e8 32 fe ff ff       	call   c0024d2a <block_name>
c0024ef8:	83 c4 08             	add    $0x8,%esp
c0024efb:	50                   	push   %eax
c0024efc:	68 c8 16 03 c0       	push   $0xc00316c8
c0024f01:	e8 73 1c 00 00       	call   c0026b79 <printf>
c0024f06:	83 c4 10             	add    $0x10,%esp
      free (pt);
c0024f09:	83 ec 0c             	sub    $0xc,%esp
c0024f0c:	57                   	push   %edi
c0024f0d:	e8 5f ec ff ff       	call   c0023b71 <free>
      return;
c0024f12:	83 c4 10             	add    $0x10,%esp
}
c0024f15:	81 c4 bc 00 00 00    	add    $0xbc,%esp
c0024f1b:	5b                   	pop    %ebx
c0024f1c:	5e                   	pop    %esi
c0024f1d:	5f                   	pop    %edi
c0024f1e:	5d                   	pop    %ebp
c0024f1f:	c3                   	ret    
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0024f20:	83 ec 0c             	sub    $0xc,%esp
c0024f23:	53                   	push   %ebx
c0024f24:	e8 01 fe ff ff       	call   c0024d2a <block_name>
c0024f29:	83 c4 0c             	add    $0xc,%esp
c0024f2c:	56                   	push   %esi
c0024f2d:	50                   	push   %eax
c0024f2e:	68 60 16 03 c0       	push   $0xc0031660
c0024f33:	e8 41 1c 00 00       	call   c0026b79 <printf>
      return;
c0024f38:	83 c4 10             	add    $0x10,%esp
c0024f3b:	eb d8                	jmp    c0024f15 <read_partition_table+0x7f>
    PANIC ("Failed to allocate memory for partition table.");
c0024f3d:	68 98 16 03 c0       	push   $0xc0031698
c0024f42:	68 30 f3 02 c0       	push   $0xc002f330
c0024f47:	6a 5a                	push   $0x5a
c0024f49:	68 cf 11 03 c0       	push   $0xc00311cf
c0024f4e:	e8 d4 36 00 00       	call   c0028627 <debug_panic>
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c0024f53:	83 ec 0c             	sub    $0xc,%esp
c0024f56:	53                   	push   %ebx
c0024f57:	e8 ce fd ff ff       	call   c0024d2a <block_name>
c0024f5c:	83 c4 0c             	add    $0xc,%esp
c0024f5f:	56                   	push   %esi
c0024f60:	50                   	push   %eax
c0024f61:	68 f0 16 03 c0       	push   $0xc00316f0
c0024f66:	e8 0e 1c 00 00       	call   c0026b79 <printf>
c0024f6b:	83 c4 10             	add    $0x10,%esp
c0024f6e:	eb 99                	jmp    c0024f09 <read_partition_table+0x73>
c0024f70:	8d af c2 01 00 00    	lea    0x1c2(%edi),%ebp
c0024f76:	8d 87 02 02 00 00    	lea    0x202(%edi),%eax
c0024f7c:	89 44 24 04          	mov    %eax,0x4(%esp)
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0024f80:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0024f84:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0024f88:	89 74 24 10          	mov    %esi,0x10(%esp)
c0024f8c:	eb 51                	jmp    c0024fdf <read_partition_table+0x149>
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0024f8e:	83 ec 0c             	sub    $0xc,%esp
c0024f91:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0024f95:	53                   	push   %ebx
c0024f96:	e8 8f fd ff ff       	call   c0024d2a <block_name>
c0024f9b:	83 c4 0c             	add    $0xc,%esp
c0024f9e:	8b 74 24 14          	mov    0x14(%esp),%esi
c0024fa2:	56                   	push   %esi
c0024fa3:	50                   	push   %eax
c0024fa4:	68 24 17 03 c0       	push   $0xc0031724
c0024fa9:	e8 cb 1b 00 00       	call   c0026b79 <printf>
          if (sector == 0)
c0024fae:	83 c4 10             	add    $0x10,%esp
c0024fb1:	85 f6                	test   %esi,%esi
c0024fb3:	0f 85 33 01 00 00    	jne    c00250ec <read_partition_table+0x256>
            read_partition_table (block, e->offset, e->offset, part_nr);
c0024fb9:	8b 57 04             	mov    0x4(%edi),%edx
c0024fbc:	83 ec 0c             	sub    $0xc,%esp
c0024fbf:	ff b4 24 dc 00 00 00 	pushl  0xdc(%esp)
c0024fc6:	89 d1                	mov    %edx,%ecx
c0024fc8:	89 d8                	mov    %ebx,%eax
c0024fca:	e8 c7 fe ff ff       	call   c0024e96 <read_partition_table>
c0024fcf:	83 c4 10             	add    $0x10,%esp
c0024fd2:	83 c5 10             	add    $0x10,%ebp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0024fd5:	3b 6c 24 04          	cmp    0x4(%esp),%ebp
c0024fd9:	0f 84 b1 01 00 00    	je     c0025190 <read_partition_table+0x2fa>
c0024fdf:	89 ef                	mov    %ebp,%edi
      if (e->size == 0 || e->type == 0)
c0024fe1:	8b 75 08             	mov    0x8(%ebp),%esi
c0024fe4:	85 f6                	test   %esi,%esi
c0024fe6:	74 ea                	je     c0024fd2 <read_partition_table+0x13c>
c0024fe8:	8a 5d 00             	mov    0x0(%ebp),%bl
c0024feb:	84 db                	test   %bl,%bl
c0024fed:	74 e3                	je     c0024fd2 <read_partition_table+0x13c>
      else if (e->type == 0x05       /* Extended partition. */
c0024fef:	88 d8                	mov    %bl,%al
c0024ff1:	83 e0 7f             	and    $0x7f,%eax
c0024ff4:	3c 05                	cmp    $0x5,%al
c0024ff6:	74 96                	je     c0024f8e <read_partition_table+0xf8>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c0024ff8:	80 fb 0f             	cmp    $0xf,%bl
c0024ffb:	74 91                	je     c0024f8e <read_partition_table+0xf8>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0024ffd:	80 fb c5             	cmp    $0xc5,%bl
c0025000:	74 8c                	je     c0024f8e <read_partition_table+0xf8>
          ++*part_nr;
c0025002:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
c0025009:	8b 00                	mov    (%eax),%eax
c002500b:	40                   	inc    %eax
c002500c:	89 44 24 18          	mov    %eax,0x18(%esp)
c0025010:	8b 94 24 d0 00 00 00 	mov    0xd0(%esp),%edx
c0025017:	89 02                	mov    %eax,(%edx)
          found_partition (block, e->type, e->offset + sector,
c0025019:	8b 44 24 10          	mov    0x10(%esp),%eax
c002501d:	03 45 04             	add    0x4(%ebp),%eax
c0025020:	89 c7                	mov    %eax,%edi
c0025022:	89 44 24 14          	mov    %eax,0x14(%esp)
  if (start >= block_size (block))
c0025026:	83 ec 0c             	sub    $0xc,%esp
c0025029:	ff 74 24 14          	pushl  0x14(%esp)
c002502d:	e8 f0 fc ff ff       	call   c0024d22 <block_size>
c0025032:	83 c4 10             	add    $0x10,%esp
c0025035:	39 c7                	cmp    %eax,%edi
c0025037:	0f 83 d2 00 00 00    	jae    c002510f <read_partition_table+0x279>
  else if (start + size < start || start + size > block_size (block))
c002503d:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0025041:	01 f7                	add    %esi,%edi
c0025043:	0f 82 ed 00 00 00    	jb     c0025136 <read_partition_table+0x2a0>
c0025049:	83 ec 0c             	sub    $0xc,%esp
c002504c:	ff 74 24 14          	pushl  0x14(%esp)
c0025050:	e8 cd fc ff ff       	call   c0024d22 <block_size>
c0025055:	83 c4 10             	add    $0x10,%esp
c0025058:	39 c7                	cmp    %eax,%edi
c002505a:	0f 87 d6 00 00 00    	ja     c0025136 <read_partition_table+0x2a0>
          found_partition (block, e->type, e->offset + sector,
c0025060:	0f b6 fb             	movzbl %bl,%edi
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025063:	80 fb 20             	cmp    $0x20,%bl
c0025066:	0f 84 39 01 00 00    	je     c00251a5 <read_partition_table+0x30f>
c002506c:	80 fb 21             	cmp    $0x21,%bl
c002506f:	0f 84 c2 01 00 00    	je     c0025237 <read_partition_table+0x3a1>
c0025075:	80 fb 22             	cmp    $0x22,%bl
c0025078:	0f 84 c6 01 00 00    	je     c0025244 <read_partition_table+0x3ae>
c002507e:	80 fb 23             	cmp    $0x23,%bl
c0025081:	0f 84 ca 01 00 00    	je     c0025251 <read_partition_table+0x3bb>
      p = malloc (sizeof *p);
c0025087:	83 ec 0c             	sub    $0xc,%esp
c002508a:	6a 08                	push   $0x8
c002508c:	e8 3d e9 ff ff       	call   c00239ce <malloc>
c0025091:	89 c3                	mov    %eax,%ebx
      if (p == NULL)
c0025093:	83 c4 10             	add    $0x10,%esp
c0025096:	85 c0                	test   %eax,%eax
c0025098:	0f 84 ca 00 00 00    	je     c0025168 <read_partition_table+0x2d2>
      p->block = block;
c002509e:	8b 44 24 08          	mov    0x8(%esp),%eax
c00250a2:	89 03                	mov    %eax,(%ebx)
      p->start = start;
c00250a4:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00250a8:	89 4b 04             	mov    %ecx,0x4(%ebx)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c00250ab:	83 ec 0c             	sub    $0xc,%esp
c00250ae:	50                   	push   %eax
c00250af:	e8 76 fc ff ff       	call   c0024d2a <block_name>
c00250b4:	83 c4 04             	add    $0x4,%esp
c00250b7:	ff 74 24 24          	pushl  0x24(%esp)
c00250bb:	50                   	push   %eax
c00250bc:	68 e9 11 03 c0       	push   $0xc00311e9
c00250c1:	6a 10                	push   $0x10
c00250c3:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c00250c7:	50                   	push   %eax
c00250c8:	e8 38 22 00 00       	call   c0027305 <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c00250cd:	8b 04 bd 20 ef 02 c0 	mov    -0x3ffd10e0(,%edi,4),%eax
c00250d4:	83 c4 20             	add    $0x20,%esp
c00250d7:	85 c0                	test   %eax,%eax
c00250d9:	0f 84 a2 00 00 00    	je     c0025181 <read_partition_table+0x2eb>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00250df:	c7 44 24 1c 05 00 00 	movl   $0x5,0x1c(%esp)
c00250e6:	00 
c00250e7:	e9 0d 01 00 00       	jmp    c00251f9 <read_partition_table+0x363>
            read_partition_table (block, e->offset + primary_extended_sector,
c00250ec:	8b 0c 24             	mov    (%esp),%ecx
c00250ef:	89 ca                	mov    %ecx,%edx
c00250f1:	03 57 04             	add    0x4(%edi),%edx
c00250f4:	83 ec 0c             	sub    $0xc,%esp
c00250f7:	ff b4 24 dc 00 00 00 	pushl  0xdc(%esp)
c00250fe:	8b 44 24 18          	mov    0x18(%esp),%eax
c0025102:	e8 8f fd ff ff       	call   c0024e96 <read_partition_table>
c0025107:	83 c4 10             	add    $0x10,%esp
c002510a:	e9 c3 fe ff ff       	jmp    c0024fd2 <read_partition_table+0x13c>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c002510f:	83 ec 0c             	sub    $0xc,%esp
c0025112:	ff 74 24 14          	pushl  0x14(%esp)
c0025116:	e8 0f fc ff ff       	call   c0024d2a <block_name>
c002511b:	ff 74 24 24          	pushl  0x24(%esp)
c002511f:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025123:	50                   	push   %eax
c0025124:	68 4c 17 03 c0       	push   $0xc003174c
c0025129:	e8 4b 1a 00 00       	call   c0026b79 <printf>
c002512e:	83 c4 20             	add    $0x20,%esp
c0025131:	e9 9c fe ff ff       	jmp    c0024fd2 <read_partition_table+0x13c>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0025136:	83 ec 0c             	sub    $0xc,%esp
c0025139:	8b 74 24 14          	mov    0x14(%esp),%esi
c002513d:	56                   	push   %esi
c002513e:	e8 df fb ff ff       	call   c0024d22 <block_size>
c0025143:	89 c3                	mov    %eax,%ebx
c0025145:	89 34 24             	mov    %esi,(%esp)
c0025148:	e8 dd fb ff ff       	call   c0024d2a <block_name>
c002514d:	89 1c 24             	mov    %ebx,(%esp)
c0025150:	57                   	push   %edi
c0025151:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025155:	50                   	push   %eax
c0025156:	68 84 17 03 c0       	push   $0xc0031784
c002515b:	e8 19 1a 00 00       	call   c0026b79 <printf>
c0025160:	83 c4 20             	add    $0x20,%esp
c0025163:	e9 6a fe ff ff       	jmp    c0024fd2 <read_partition_table+0x13c>
        PANIC ("Failed to allocate memory for partition descriptor");
c0025168:	68 b8 17 03 c0       	push   $0xc00317b8
c002516d:	68 20 f3 02 c0       	push   $0xc002f320
c0025172:	68 b1 00 00 00       	push   $0xb1
c0025177:	68 cf 11 03 c0       	push   $0xc00311cf
c002517c:	e8 a6 34 00 00       	call   c0028627 <debug_panic>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025181:	c7 44 24 1c 05 00 00 	movl   $0x5,0x1c(%esp)
c0025188:	00 
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025189:	b8 c7 11 03 c0       	mov    $0xc00311c7,%eax
c002518e:	eb 69                	jmp    c00251f9 <read_partition_table+0x363>
c0025190:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  free (pt);
c0025194:	83 ec 0c             	sub    $0xc,%esp
c0025197:	57                   	push   %edi
c0025198:	e8 d4 e9 ff ff       	call   c0023b71 <free>
c002519d:	83 c4 10             	add    $0x10,%esp
c00251a0:	e9 70 fd ff ff       	jmp    c0024f15 <read_partition_table+0x7f>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00251a5:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c00251ac:	00 
      p = malloc (sizeof *p);
c00251ad:	83 ec 0c             	sub    $0xc,%esp
c00251b0:	6a 08                	push   $0x8
c00251b2:	e8 17 e8 ff ff       	call   c00239ce <malloc>
c00251b7:	89 c3                	mov    %eax,%ebx
      if (p == NULL)
c00251b9:	83 c4 10             	add    $0x10,%esp
c00251bc:	85 c0                	test   %eax,%eax
c00251be:	74 a8                	je     c0025168 <read_partition_table+0x2d2>
      p->block = block;
c00251c0:	8b 44 24 08          	mov    0x8(%esp),%eax
c00251c4:	89 03                	mov    %eax,(%ebx)
      p->start = start;
c00251c6:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00251ca:	89 4b 04             	mov    %ecx,0x4(%ebx)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c00251cd:	83 ec 0c             	sub    $0xc,%esp
c00251d0:	50                   	push   %eax
c00251d1:	e8 54 fb ff ff       	call   c0024d2a <block_name>
c00251d6:	83 c4 04             	add    $0x4,%esp
c00251d9:	ff 74 24 24          	pushl  0x24(%esp)
c00251dd:	50                   	push   %eax
c00251de:	68 e9 11 03 c0       	push   $0xc00311e9
c00251e3:	6a 10                	push   $0x10
c00251e5:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c00251e9:	50                   	push   %eax
c00251ea:	e8 16 21 00 00       	call   c0027305 <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c00251ef:	8b 04 bd 20 ef 02 c0 	mov    -0x3ffd10e0(,%edi,4),%eax
c00251f6:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c00251f9:	83 ec 0c             	sub    $0xc,%esp
c00251fc:	57                   	push   %edi
c00251fd:	50                   	push   %eax
c00251fe:	68 ee 11 03 c0       	push   $0xc00311ee
c0025203:	68 80 00 00 00       	push   $0x80
c0025208:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c002520c:	50                   	push   %eax
c002520d:	e8 f3 20 00 00       	call   c0027305 <snprintf>
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025212:	83 c4 18             	add    $0x18,%esp
c0025215:	53                   	push   %ebx
c0025216:	68 24 b0 03 c0       	push   $0xc003b024
c002521b:	56                   	push   %esi
c002521c:	8d 44 24 44          	lea    0x44(%esp),%eax
c0025220:	50                   	push   %eax
c0025221:	ff 74 24 34          	pushl  0x34(%esp)
c0025225:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c0025229:	50                   	push   %eax
c002522a:	e8 59 fb ff ff       	call   c0024d88 <block_register>
c002522f:	83 c4 20             	add    $0x20,%esp
c0025232:	e9 9b fd ff ff       	jmp    c0024fd2 <read_partition_table+0x13c>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025237:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
c002523e:	00 
c002523f:	e9 69 ff ff ff       	jmp    c00251ad <read_partition_table+0x317>
c0025244:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
c002524b:	00 
c002524c:	e9 5c ff ff ff       	jmp    c00251ad <read_partition_table+0x317>
c0025251:	c7 44 24 1c 03 00 00 	movl   $0x3,0x1c(%esp)
c0025258:	00 
c0025259:	e9 4f ff ff ff       	jmp    c00251ad <read_partition_table+0x317>

c002525e <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c002525e:	83 ec 10             	sub    $0x10,%esp
c0025261:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_write (p->block, p->start + sector, buffer);
c0025265:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025269:	8b 42 04             	mov    0x4(%edx),%eax
c002526c:	03 44 24 1c          	add    0x1c(%esp),%eax
c0025270:	50                   	push   %eax
c0025271:	ff 32                	pushl  (%edx)
c0025273:	e8 4e fa ff ff       	call   c0024cc6 <block_write>
}
c0025278:	83 c4 1c             	add    $0x1c,%esp
c002527b:	c3                   	ret    

c002527c <partition_scan>:
{
c002527c:	83 ec 28             	sub    $0x28,%esp
  int part_nr = 0;
c002527f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0025286:	00 
  read_partition_table (block, 0, 0, &part_nr);
c0025287:	8d 44 24 18          	lea    0x18(%esp),%eax
c002528b:	50                   	push   %eax
c002528c:	b9 00 00 00 00       	mov    $0x0,%ecx
c0025291:	ba 00 00 00 00       	mov    $0x0,%edx
c0025296:	8b 44 24 30          	mov    0x30(%esp),%eax
c002529a:	e8 f7 fb ff ff       	call   c0024e96 <read_partition_table>
  if (part_nr == 0)
c002529f:	83 c4 10             	add    $0x10,%esp
c00252a2:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c00252a7:	74 04                	je     c00252ad <partition_scan+0x31>
}
c00252a9:	83 c4 1c             	add    $0x1c,%esp
c00252ac:	c3                   	ret    
    printf ("%s: Device contains no partitions\n", block_name (block));
c00252ad:	83 ec 0c             	sub    $0xc,%esp
c00252b0:	ff 74 24 2c          	pushl  0x2c(%esp)
c00252b4:	e8 71 fa ff ff       	call   c0024d2a <block_name>
c00252b9:	83 c4 08             	add    $0x8,%esp
c00252bc:	50                   	push   %eax
c00252bd:	68 ec 17 03 c0       	push   $0xc00317ec
c00252c2:	e8 b2 18 00 00       	call   c0026b79 <printf>
c00252c7:	83 c4 10             	add    $0x10,%esp
}
c00252ca:	eb dd                	jmp    c00252a9 <partition_scan+0x2d>

c00252cc <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c00252cc:	57                   	push   %edi
c00252cd:	56                   	push   %esi
c00252ce:	53                   	push   %ebx
c00252cf:	89 d7                	mov    %edx,%edi
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c00252d1:	83 fa 01             	cmp    $0x1,%edx
c00252d4:	7e 1d                	jle    c00252f3 <descramble_ata_string+0x27>
c00252d6:	89 c1                	mov    %eax,%ecx
c00252d8:	8d 5a fe             	lea    -0x2(%edx),%ebx
c00252db:	83 e3 fe             	and    $0xfffffffe,%ebx
c00252de:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
    {
      char tmp = string[i];
c00252e2:	8a 19                	mov    (%ecx),%bl
      string[i] = string[i + 1];
c00252e4:	8a 51 01             	mov    0x1(%ecx),%dl
c00252e7:	88 11                	mov    %dl,(%ecx)
      string[i + 1] = tmp;
c00252e9:	88 59 01             	mov    %bl,0x1(%ecx)
c00252ec:	83 c1 02             	add    $0x2,%ecx
  for (i = 0; i + 1 < size; i += 2)
c00252ef:	39 f1                	cmp    %esi,%ecx
c00252f1:	75 ef                	jne    c00252e2 <descramble_ata_string+0x16>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c00252f3:	8d 57 ff             	lea    -0x1(%edi),%edx
c00252f6:	85 d2                	test   %edx,%edx
c00252f8:	7f 05                	jg     c00252ff <descramble_ata_string+0x33>
c00252fa:	eb 14                	jmp    c0025310 <descramble_ata_string+0x44>
c00252fc:	4a                   	dec    %edx
c00252fd:	74 11                	je     c0025310 <descramble_ata_string+0x44>
    {
      int c = string[size - 1];
c00252ff:	8a 4c 10 ff          	mov    -0x1(%eax,%edx,1),%cl
      if (c != '\0' && !isspace (c))
c0025303:	f6 c1 df             	test   $0xdf,%cl
c0025306:	74 f4                	je     c00252fc <descramble_ata_string+0x30>
          || c == '\r' || c == '\t' || c == '\v');
c0025308:	83 e9 09             	sub    $0x9,%ecx
c002530b:	80 f9 04             	cmp    $0x4,%cl
c002530e:	76 ec                	jbe    c00252fc <descramble_ata_string+0x30>
        break; 
    }
  string[size] = '\0';
c0025310:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

  return string;
}
c0025314:	5b                   	pop    %ebx
c0025315:	5e                   	pop    %esi
c0025316:	5f                   	pop    %edi
c0025317:	c3                   	ret    

c0025318 <interrupt_handler>:
}

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c0025318:	83 ec 0c             	sub    $0xc,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
    if (f->vec_no == c->irq)
c002531b:	8b 44 24 10          	mov    0x10(%esp),%eax
c002531f:	8b 40 30             	mov    0x30(%eax),%eax
c0025322:	0f b6 15 4a cb 03 c0 	movzbl 0xc003cb4a,%edx
c0025329:	39 d0                	cmp    %edx,%eax
c002532b:	74 29                	je     c0025356 <interrupt_handler+0x3e>
c002532d:	0f b6 15 ca cb 03 c0 	movzbl 0xc003cbca,%edx
c0025334:	b9 c0 cb 03 c0       	mov    $0xc003cbc0,%ecx
c0025339:	39 c2                	cmp    %eax,%edx
c002533b:	74 1e                	je     c002535b <interrupt_handler+0x43>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c002533d:	68 84 08 03 c0       	push   $0xc0030884
c0025342:	68 98 f3 02 c0       	push   $0xc002f398
c0025347:	68 0c 02 00 00       	push   $0x20c
c002534c:	68 29 18 03 c0       	push   $0xc0031829
c0025351:	e8 d1 32 00 00       	call   c0028627 <debug_panic>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0025356:	b9 40 cb 03 c0       	mov    $0xc003cb40,%ecx
        if (c->expecting_interrupt) 
c002535b:	80 79 40 00          	cmpb   $0x0,0x40(%ecx)
c002535f:	74 1a                	je     c002537b <interrupt_handler+0x63>
            inb (reg_status (c));               /* Acknowledge interrupt. */
c0025361:	8b 41 08             	mov    0x8(%ecx),%eax
c0025364:	8d 50 07             	lea    0x7(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025367:	ec                   	in     (%dx),%al
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c0025368:	83 ec 0c             	sub    $0xc,%esp
c002536b:	83 c1 44             	add    $0x44,%ecx
c002536e:	51                   	push   %ecx
c002536f:	e8 0a d8 ff ff       	call   c0022b7e <sema_up>
c0025374:	83 c4 10             	add    $0x10,%esp
}
c0025377:	83 c4 0c             	add    $0xc,%esp
c002537a:	c3                   	ret    
          printf ("%s: unexpected interrupt\n", c->name);
c002537b:	83 ec 08             	sub    $0x8,%esp
c002537e:	51                   	push   %ecx
c002537f:	68 0f 18 03 c0       	push   $0xc003180f
c0025384:	e8 f0 17 00 00       	call   c0026b79 <printf>
c0025389:	83 c4 10             	add    $0x10,%esp
c002538c:	eb e9                	jmp    c0025377 <interrupt_handler+0x5f>

c002538e <wait_until_idle>:
{
c002538e:	56                   	push   %esi
c002538f:	53                   	push   %ebx
c0025390:	83 ec 04             	sub    $0x4,%esp
c0025393:	89 c6                	mov    %eax,%esi
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025395:	8b 40 08             	mov    0x8(%eax),%eax
c0025398:	8b 40 08             	mov    0x8(%eax),%eax
c002539b:	8d 50 07             	lea    0x7(%eax),%edx
c002539e:	ec                   	in     (%dx),%al
c002539f:	a8 88                	test   $0x88,%al
c00253a1:	74 45                	je     c00253e8 <wait_until_idle+0x5a>
      timer_usleep (10);
c00253a3:	83 ec 08             	sub    $0x8,%esp
c00253a6:	6a 00                	push   $0x0
c00253a8:	6a 0a                	push   $0xa
c00253aa:	e8 5c ef ff ff       	call   c002430b <timer_usleep>
c00253af:	83 c4 10             	add    $0x10,%esp
c00253b2:	bb e7 03 00 00       	mov    $0x3e7,%ebx
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c00253b7:	8b 46 08             	mov    0x8(%esi),%eax
c00253ba:	8b 40 08             	mov    0x8(%eax),%eax
c00253bd:	8d 50 07             	lea    0x7(%eax),%edx
c00253c0:	ec                   	in     (%dx),%al
c00253c1:	a8 88                	test   $0x88,%al
c00253c3:	74 23                	je     c00253e8 <wait_until_idle+0x5a>
      timer_usleep (10);
c00253c5:	83 ec 08             	sub    $0x8,%esp
c00253c8:	6a 00                	push   $0x0
c00253ca:	6a 0a                	push   $0xa
c00253cc:	e8 3a ef ff ff       	call   c002430b <timer_usleep>
  for (i = 0; i < 1000; i++) 
c00253d1:	83 c4 10             	add    $0x10,%esp
c00253d4:	4b                   	dec    %ebx
c00253d5:	75 e0                	jne    c00253b7 <wait_until_idle+0x29>
  printf ("%s: idle timeout\n", d->name);
c00253d7:	83 ec 08             	sub    $0x8,%esp
c00253da:	56                   	push   %esi
c00253db:	68 3d 18 03 c0       	push   $0xc003183d
c00253e0:	e8 94 17 00 00       	call   c0026b79 <printf>
c00253e5:	83 c4 10             	add    $0x10,%esp
}
c00253e8:	83 c4 04             	add    $0x4,%esp
c00253eb:	5b                   	pop    %ebx
c00253ec:	5e                   	pop    %esi
c00253ed:	c3                   	ret    

c00253ee <select_device>:
{
c00253ee:	83 ec 0c             	sub    $0xc,%esp
  struct channel *c = d->channel;
c00253f1:	8b 50 08             	mov    0x8(%eax),%edx
  if (d->dev_no == 1)
c00253f4:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
c00253f8:	74 23                	je     c002541d <select_device+0x2f>
  uint8_t dev = DEV_MBS;
c00253fa:	b0 a0                	mov    $0xa0,%al
  outb (reg_device (c), dev);
c00253fc:	8b 4a 08             	mov    0x8(%edx),%ecx
c00253ff:	8d 51 06             	lea    0x6(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025402:	ee                   	out    %al,(%dx)
  inb (reg_alt_status (c));
c0025403:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025409:	ec                   	in     (%dx),%al
  timer_nsleep (400);
c002540a:	83 ec 08             	sub    $0x8,%esp
c002540d:	6a 00                	push   $0x0
c002540f:	68 90 01 00 00       	push   $0x190
c0025414:	e8 0b ef ff ff       	call   c0024324 <timer_nsleep>
}
c0025419:	83 c4 1c             	add    $0x1c,%esp
c002541c:	c3                   	ret    
    dev |= DEV_DEV;
c002541d:	b0 b0                	mov    $0xb0,%al
c002541f:	eb db                	jmp    c00253fc <select_device+0xe>

c0025421 <check_device_type>:
{
c0025421:	56                   	push   %esi
c0025422:	53                   	push   %ebx
c0025423:	83 ec 14             	sub    $0x14,%esp
c0025426:	89 c6                	mov    %eax,%esi
  struct channel *c = d->channel;
c0025428:	8b 58 08             	mov    0x8(%eax),%ebx
  select_device (d);
c002542b:	e8 be ff ff ff       	call   c00253ee <select_device>
  error = inb (reg_error (c));
c0025430:	8b 5b 08             	mov    0x8(%ebx),%ebx
c0025433:	8d 53 01             	lea    0x1(%ebx),%edx
c0025436:	ec                   	in     (%dx),%al
c0025437:	88 c1                	mov    %al,%cl
  lbam = inb (reg_lbam (c));
c0025439:	8d 53 04             	lea    0x4(%ebx),%edx
c002543c:	ec                   	in     (%dx),%al
c002543d:	88 44 24 0e          	mov    %al,0xe(%esp)
  lbah = inb (reg_lbah (c));
c0025441:	8d 53 05             	lea    0x5(%ebx),%edx
c0025444:	ec                   	in     (%dx),%al
c0025445:	88 44 24 0f          	mov    %al,0xf(%esp)
  status = inb (reg_status (c));
c0025449:	8d 53 07             	lea    0x7(%ebx),%edx
c002544c:	ec                   	in     (%dx),%al
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c002544d:	80 f9 01             	cmp    $0x1,%cl
c0025450:	74 1b                	je     c002546d <check_device_type+0x4c>
c0025452:	80 f9 81             	cmp    $0x81,%cl
c0025455:	74 10                	je     c0025467 <check_device_type+0x46>
      d->is_ata = false;
c0025457:	c6 46 10 00          	movb   $0x0,0x10(%esi)
      return error != 0x81;      
c002545b:	80 f9 81             	cmp    $0x81,%cl
c002545e:	0f 95 c0             	setne  %al
}
c0025461:	83 c4 14             	add    $0x14,%esp
c0025464:	5b                   	pop    %ebx
c0025465:	5e                   	pop    %esi
c0025466:	c3                   	ret    
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025467:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c002546b:	74 ea                	je     c0025457 <check_device_type+0x36>
      || (status & STA_DRDY) == 0
c002546d:	a8 40                	test   $0x40,%al
c002546f:	74 e6                	je     c0025457 <check_device_type+0x36>
      || (status & STA_BSY) != 0)
c0025471:	84 c0                	test   %al,%al
c0025473:	78 e2                	js     c0025457 <check_device_type+0x36>
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025475:	80 7c 24 0e 00       	cmpb   $0x0,0xe(%esp)
c002547a:	75 16                	jne    c0025492 <check_device_type+0x71>
c002547c:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0025481:	0f 94 c0             	sete   %al
c0025484:	0f b6 c0             	movzbl %al,%eax
c0025487:	88 46 10             	mov    %al,0x10(%esi)
c002548a:	80 66 10 01          	andb   $0x1,0x10(%esi)
      return true; 
c002548e:	b0 01                	mov    $0x1,%al
c0025490:	eb cf                	jmp    c0025461 <check_device_type+0x40>
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025492:	80 7c 24 0e 3c       	cmpb   $0x3c,0xe(%esp)
c0025497:	74 07                	je     c00254a0 <check_device_type+0x7f>
c0025499:	b8 00 00 00 00       	mov    $0x0,%eax
c002549e:	eb e7                	jmp    c0025487 <check_device_type+0x66>
c00254a0:	80 7c 24 0f c3       	cmpb   $0xc3,0xf(%esp)
c00254a5:	0f 94 c0             	sete   %al
c00254a8:	0f b6 c0             	movzbl %al,%eax
c00254ab:	eb da                	jmp    c0025487 <check_device_type+0x66>

c00254ad <select_sector>:
{
c00254ad:	57                   	push   %edi
c00254ae:	56                   	push   %esi
c00254af:	53                   	push   %ebx
  struct channel *c = d->channel;
c00254b0:	8b 78 08             	mov    0x8(%eax),%edi
  ASSERT (sec_no < (1UL << 28));
c00254b3:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c00254b9:	77 4d                	ja     c0025508 <select_sector+0x5b>
c00254bb:	89 c6                	mov    %eax,%esi
c00254bd:	89 d3                	mov    %edx,%ebx
  wait_until_idle (d);
c00254bf:	e8 ca fe ff ff       	call   c002538e <wait_until_idle>
  select_device (d);
c00254c4:	89 f0                	mov    %esi,%eax
c00254c6:	e8 23 ff ff ff       	call   c00253ee <select_device>
  wait_until_idle (d);
c00254cb:	89 f0                	mov    %esi,%eax
c00254cd:	e8 bc fe ff ff       	call   c002538e <wait_until_idle>
  outb (reg_nsect (c), 1);
c00254d2:	8b 4f 08             	mov    0x8(%edi),%ecx
c00254d5:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00254d8:	b0 01                	mov    $0x1,%al
c00254da:	ee                   	out    %al,(%dx)
  outb (reg_lbal (c), sec_no);
c00254db:	8d 51 03             	lea    0x3(%ecx),%edx
c00254de:	88 d8                	mov    %bl,%al
c00254e0:	ee                   	out    %al,(%dx)
  outb (reg_lbam (c), sec_no >> 8);
c00254e1:	89 d8                	mov    %ebx,%eax
c00254e3:	c1 e8 08             	shr    $0x8,%eax
c00254e6:	8d 51 04             	lea    0x4(%ecx),%edx
c00254e9:	ee                   	out    %al,(%dx)
  outb (reg_lbah (c), (sec_no >> 16));
c00254ea:	89 d8                	mov    %ebx,%eax
c00254ec:	c1 e8 10             	shr    $0x10,%eax
c00254ef:	8d 51 05             	lea    0x5(%ecx),%edx
c00254f2:	ee                   	out    %al,(%dx)
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c00254f3:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c00254f7:	74 30                	je     c0025529 <select_sector+0x7c>
c00254f9:	b0 e0                	mov    $0xe0,%al
c00254fb:	c1 eb 18             	shr    $0x18,%ebx
c00254fe:	09 d8                	or     %ebx,%eax
  outb (reg_device (c),
c0025500:	8d 51 06             	lea    0x6(%ecx),%edx
c0025503:	ee                   	out    %al,(%dx)
}
c0025504:	5b                   	pop    %ebx
c0025505:	5e                   	pop    %esi
c0025506:	5f                   	pop    %edi
c0025507:	c3                   	ret    
  ASSERT (sec_no < (1UL << 28));
c0025508:	83 ec 0c             	sub    $0xc,%esp
c002550b:	68 4f 18 03 c0       	push   $0xc003184f
c0025510:	68 21 01 03 c0       	push   $0xc0030121
c0025515:	68 68 f3 02 c0       	push   $0xc002f368
c002551a:	68 89 01 00 00       	push   $0x189
c002551f:	68 29 18 03 c0       	push   $0xc0031829
c0025524:	e8 fe 30 00 00       	call   c0028627 <debug_panic>
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0025529:	b0 f0                	mov    $0xf0,%al
c002552b:	eb ce                	jmp    c00254fb <select_sector+0x4e>

c002552d <wait_while_busy>:
{
c002552d:	57                   	push   %edi
c002552e:	56                   	push   %esi
c002552f:	53                   	push   %ebx
c0025530:	89 c7                	mov    %eax,%edi
  struct channel *c = d->channel;
c0025532:	8b 70 08             	mov    0x8(%eax),%esi
  for (i = 0; i < 3000; i++)
c0025535:	bb 00 00 00 00       	mov    $0x0,%ebx
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c002553a:	8b 46 08             	mov    0x8(%esi),%eax
c002553d:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025543:	ec                   	in     (%dx),%al
c0025544:	84 c0                	test   %al,%al
c0025546:	79 33                	jns    c002557b <wait_while_busy+0x4e>
      timer_msleep (10);
c0025548:	83 ec 08             	sub    $0x8,%esp
c002554b:	6a 00                	push   $0x0
c002554d:	6a 0a                	push   $0xa
c002554f:	e8 9e ed ff ff       	call   c00242f2 <timer_msleep>
  for (i = 0; i < 3000; i++)
c0025554:	43                   	inc    %ebx
c0025555:	83 c4 10             	add    $0x10,%esp
c0025558:	81 fb b8 0b 00 00    	cmp    $0xbb8,%ebx
c002555e:	74 49                	je     c00255a9 <wait_while_busy+0x7c>
      if (i == 700)
c0025560:	81 fb bc 02 00 00    	cmp    $0x2bc,%ebx
c0025566:	75 d2                	jne    c002553a <wait_while_busy+0xd>
        printf ("%s: busy, waiting...", d->name);
c0025568:	83 ec 08             	sub    $0x8,%esp
c002556b:	57                   	push   %edi
c002556c:	68 64 18 03 c0       	push   $0xc0031864
c0025571:	e8 03 16 00 00       	call   c0026b79 <printf>
c0025576:	83 c4 10             	add    $0x10,%esp
c0025579:	eb bf                	jmp    c002553a <wait_while_busy+0xd>
          if (i >= 700)
c002557b:	81 fb bb 02 00 00    	cmp    $0x2bb,%ebx
c0025581:	7f 14                	jg     c0025597 <wait_while_busy+0x6a>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0025583:	8b 46 08             	mov    0x8(%esi),%eax
c0025586:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c002558c:	ec                   	in     (%dx),%al
c002558d:	c0 e8 03             	shr    $0x3,%al
c0025590:	83 e0 01             	and    $0x1,%eax
}
c0025593:	5b                   	pop    %ebx
c0025594:	5e                   	pop    %esi
c0025595:	5f                   	pop    %edi
c0025596:	c3                   	ret    
            printf ("ok\n");
c0025597:	83 ec 0c             	sub    $0xc,%esp
c002559a:	68 79 18 03 c0       	push   $0xc0031879
c002559f:	e8 6a 4b 00 00       	call   c002a10e <puts>
c00255a4:	83 c4 10             	add    $0x10,%esp
c00255a7:	eb da                	jmp    c0025583 <wait_while_busy+0x56>
  printf ("failed\n");
c00255a9:	83 ec 0c             	sub    $0xc,%esp
c00255ac:	68 08 27 03 c0       	push   $0xc0032708
c00255b1:	e8 58 4b 00 00       	call   c002a10e <puts>
  return false;
c00255b6:	83 c4 10             	add    $0x10,%esp
c00255b9:	b0 00                	mov    $0x0,%al
c00255bb:	eb d6                	jmp    c0025593 <wait_while_busy+0x66>

c00255bd <issue_pio_command>:
{
c00255bd:	56                   	push   %esi
c00255be:	53                   	push   %ebx
c00255bf:	83 ec 04             	sub    $0x4,%esp
c00255c2:	89 c3                	mov    %eax,%ebx
c00255c4:	89 d6                	mov    %edx,%esi
  ASSERT (intr_get_level () == INTR_ON);
c00255c6:	e8 f9 c3 ff ff       	call   c00219c4 <intr_get_level>
c00255cb:	83 f8 01             	cmp    $0x1,%eax
c00255ce:	75 13                	jne    c00255e3 <issue_pio_command+0x26>
  c->expecting_interrupt = true;
c00255d0:	c6 43 40 01          	movb   $0x1,0x40(%ebx)
  outb (reg_command (c), command);
c00255d4:	8b 53 08             	mov    0x8(%ebx),%edx
c00255d7:	83 c2 07             	add    $0x7,%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00255da:	89 f0                	mov    %esi,%eax
c00255dc:	ee                   	out    %al,(%dx)
}
c00255dd:	83 c4 04             	add    $0x4,%esp
c00255e0:	5b                   	pop    %ebx
c00255e1:	5e                   	pop    %esi
c00255e2:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c00255e3:	83 ec 0c             	sub    $0xc,%esp
c00255e6:	68 8f 0f 03 c0       	push   $0xc0030f8f
c00255eb:	68 21 01 03 c0       	push   $0xc0030121
c00255f0:	68 48 f3 02 c0       	push   $0xc002f348
c00255f5:	68 9b 01 00 00       	push   $0x19b
c00255fa:	68 29 18 03 c0       	push   $0xc0031829
c00255ff:	e8 23 30 00 00       	call   c0028627 <debug_panic>

c0025604 <ide_write>:
{
c0025604:	57                   	push   %edi
c0025605:	56                   	push   %esi
c0025606:	53                   	push   %ebx
c0025607:	8b 74 24 10          	mov    0x10(%esp),%esi
  struct channel *c = d->channel;
c002560b:	8b 5e 08             	mov    0x8(%esi),%ebx
  lock_acquire (&c->lock);
c002560e:	8d 7b 0c             	lea    0xc(%ebx),%edi
c0025611:	83 ec 0c             	sub    $0xc,%esp
c0025614:	57                   	push   %edi
c0025615:	e8 63 d8 ff ff       	call   c0022e7d <lock_acquire>
  select_sector (d, sec_no);
c002561a:	8b 54 24 24          	mov    0x24(%esp),%edx
c002561e:	89 f0                	mov    %esi,%eax
c0025620:	e8 88 fe ff ff       	call   c00254ad <select_sector>
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c0025625:	ba 30 00 00 00       	mov    $0x30,%edx
c002562a:	89 d8                	mov    %ebx,%eax
c002562c:	e8 8c ff ff ff       	call   c00255bd <issue_pio_command>
  if (!wait_while_busy (d))
c0025631:	89 f0                	mov    %esi,%eax
c0025633:	e8 f5 fe ff ff       	call   c002552d <wait_while_busy>
c0025638:	83 c4 10             	add    $0x10,%esp
c002563b:	84 c0                	test   %al,%al
c002563d:	74 2a                	je     c0025669 <ide_write+0x65>
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c002563f:	8b 53 08             	mov    0x8(%ebx),%edx
c0025642:	8b 74 24 18          	mov    0x18(%esp),%esi
c0025646:	b9 00 01 00 00       	mov    $0x100,%ecx
c002564b:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
  sema_down (&c->completion_wait);
c002564e:	83 ec 0c             	sub    $0xc,%esp
c0025651:	83 c3 44             	add    $0x44,%ebx
c0025654:	53                   	push   %ebx
c0025655:	e8 43 d4 ff ff       	call   c0022a9d <sema_down>
  lock_release (&c->lock);
c002565a:	89 3c 24             	mov    %edi,(%esp)
c002565d:	e8 b8 d9 ff ff       	call   c002301a <lock_release>
}
c0025662:	83 c4 10             	add    $0x10,%esp
c0025665:	5b                   	pop    %ebx
c0025666:	5e                   	pop    %esi
c0025667:	5f                   	pop    %edi
c0025668:	c3                   	ret    
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c0025669:	83 ec 08             	sub    $0x8,%esp
c002566c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025670:	56                   	push   %esi
c0025671:	68 c8 18 03 c0       	push   $0xc00318c8
c0025676:	68 78 f3 02 c0       	push   $0xc002f378
c002567b:	68 75 01 00 00       	push   $0x175
c0025680:	68 29 18 03 c0       	push   $0xc0031829
c0025685:	e8 9d 2f 00 00       	call   c0028627 <debug_panic>

c002568a <identify_ata_device>:
{
c002568a:	57                   	push   %edi
c002568b:	56                   	push   %esi
c002568c:	53                   	push   %ebx
c002568d:	81 ec 80 02 00 00    	sub    $0x280,%esp
  struct channel *c = d->channel;
c0025693:	8b 70 08             	mov    0x8(%eax),%esi
  ASSERT (d->is_ata);
c0025696:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c002569a:	74 49                	je     c00256e5 <identify_ata_device+0x5b>
c002569c:	89 c3                	mov    %eax,%ebx
  wait_until_idle (d);
c002569e:	e8 eb fc ff ff       	call   c002538e <wait_until_idle>
  select_device (d);
c00256a3:	89 d8                	mov    %ebx,%eax
c00256a5:	e8 44 fd ff ff       	call   c00253ee <select_device>
  wait_until_idle (d);
c00256aa:	89 d8                	mov    %ebx,%eax
c00256ac:	e8 dd fc ff ff       	call   c002538e <wait_until_idle>
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c00256b1:	ba ec 00 00 00       	mov    $0xec,%edx
c00256b6:	89 f0                	mov    %esi,%eax
c00256b8:	e8 00 ff ff ff       	call   c00255bd <issue_pio_command>
  sema_down (&c->completion_wait);
c00256bd:	83 ec 0c             	sub    $0xc,%esp
c00256c0:	8d 46 44             	lea    0x44(%esi),%eax
c00256c3:	50                   	push   %eax
c00256c4:	e8 d4 d3 ff ff       	call   c0022a9d <sema_down>
  if (!wait_while_busy (d))
c00256c9:	89 d8                	mov    %ebx,%eax
c00256cb:	e8 5d fe ff ff       	call   c002552d <wait_while_busy>
c00256d0:	83 c4 10             	add    $0x10,%esp
c00256d3:	84 c0                	test   %al,%al
c00256d5:	75 2f                	jne    c0025706 <identify_ata_device+0x7c>
      d->is_ata = false;
c00256d7:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
}
c00256db:	81 c4 80 02 00 00    	add    $0x280,%esp
c00256e1:	5b                   	pop    %ebx
c00256e2:	5e                   	pop    %esi
c00256e3:	5f                   	pop    %edi
c00256e4:	c3                   	ret    
  ASSERT (d->is_ata);
c00256e5:	83 ec 0c             	sub    $0xc,%esp
c00256e8:	68 7c 18 03 c0       	push   $0xc003187c
c00256ed:	68 21 01 03 c0       	push   $0xc0030121
c00256f2:	68 84 f3 02 c0       	push   $0xc002f384
c00256f7:	68 0d 01 00 00       	push   $0x10d
c00256fc:	68 29 18 03 c0       	push   $0xc0031829
c0025701:	e8 21 2f 00 00       	call   c0028627 <debug_panic>
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025706:	8b 56 08             	mov    0x8(%esi),%edx
c0025709:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0025710:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025715:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  capacity = *(uint32_t *) &id[60 * 2];
c0025718:	8b b4 24 f8 00 00 00 	mov    0xf8(%esp),%esi
  model = descramble_ata_string (&id[10 * 2], 20);
c002571f:	ba 14 00 00 00       	mov    $0x14,%edx
c0025724:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c002572b:	e8 9c fb ff ff       	call   c00252cc <descramble_ata_string>
c0025730:	89 c7                	mov    %eax,%edi
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025732:	ba 28 00 00 00       	mov    $0x28,%edx
c0025737:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c002573e:	e8 89 fb ff ff       	call   c00252cc <descramble_ata_string>
  snprintf (extra_info, sizeof extra_info,
c0025743:	83 ec 0c             	sub    $0xc,%esp
c0025746:	50                   	push   %eax
c0025747:	57                   	push   %edi
c0025748:	68 86 18 03 c0       	push   $0xc0031886
c002574d:	68 80 00 00 00       	push   $0x80
c0025752:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0025756:	50                   	push   %eax
c0025757:	e8 a9 1b 00 00       	call   c0027305 <snprintf>
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c002575c:	83 c4 20             	add    $0x20,%esp
c002575f:	81 fe ff ff 1f 00    	cmp    $0x1fffff,%esi
c0025765:	76 3a                	jbe    c00257a1 <identify_ata_device+0x117>
      printf ("%s: ignoring ", d->name);
c0025767:	83 ec 08             	sub    $0x8,%esp
c002576a:	53                   	push   %ebx
c002576b:	68 9e 18 03 c0       	push   $0xc003189e
c0025770:	e8 04 14 00 00       	call   c0026b79 <printf>
      print_human_readable_size (capacity * 512);
c0025775:	83 c4 08             	add    $0x8,%esp
c0025778:	89 f0                	mov    %esi,%eax
c002577a:	c1 e0 09             	shl    $0x9,%eax
c002577d:	ba 00 00 00 00       	mov    $0x0,%edx
c0025782:	52                   	push   %edx
c0025783:	50                   	push   %eax
c0025784:	e8 94 1d 00 00       	call   c002751d <print_human_readable_size>
      printf ("disk for safety\n");
c0025789:	c7 04 24 ac 18 03 c0 	movl   $0xc00318ac,(%esp)
c0025790:	e8 79 49 00 00       	call   c002a10e <puts>
      d->is_ata = false;
c0025795:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
      return;
c0025799:	83 c4 10             	add    $0x10,%esp
c002579c:	e9 3a ff ff ff       	jmp    c00256db <identify_ata_device+0x51>
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c00257a1:	83 ec 08             	sub    $0x8,%esp
c00257a4:	53                   	push   %ebx
c00257a5:	68 2c b0 03 c0       	push   $0xc003b02c
c00257aa:	56                   	push   %esi
c00257ab:	8d 44 24 14          	lea    0x14(%esp),%eax
c00257af:	50                   	push   %eax
c00257b0:	6a 04                	push   $0x4
c00257b2:	53                   	push   %ebx
c00257b3:	e8 d0 f5 ff ff       	call   c0024d88 <block_register>
  partition_scan (block);
c00257b8:	83 c4 14             	add    $0x14,%esp
c00257bb:	50                   	push   %eax
c00257bc:	e8 bb fa ff ff       	call   c002527c <partition_scan>
c00257c1:	83 c4 10             	add    $0x10,%esp
c00257c4:	e9 12 ff ff ff       	jmp    c00256db <identify_ata_device+0x51>

c00257c9 <ide_read>:
{
c00257c9:	55                   	push   %ebp
c00257ca:	57                   	push   %edi
c00257cb:	56                   	push   %esi
c00257cc:	53                   	push   %ebx
c00257cd:	83 ec 18             	sub    $0x18,%esp
c00257d0:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  struct channel *c = d->channel;
c00257d4:	8b 5e 08             	mov    0x8(%esi),%ebx
  lock_acquire (&c->lock);
c00257d7:	8d 6b 0c             	lea    0xc(%ebx),%ebp
c00257da:	55                   	push   %ebp
c00257db:	e8 9d d6 ff ff       	call   c0022e7d <lock_acquire>
  select_sector (d, sec_no);
c00257e0:	8b 54 24 34          	mov    0x34(%esp),%edx
c00257e4:	89 f0                	mov    %esi,%eax
c00257e6:	e8 c2 fc ff ff       	call   c00254ad <select_sector>
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c00257eb:	ba 20 00 00 00       	mov    $0x20,%edx
c00257f0:	89 d8                	mov    %ebx,%eax
c00257f2:	e8 c6 fd ff ff       	call   c00255bd <issue_pio_command>
  sema_down (&c->completion_wait);
c00257f7:	8d 43 44             	lea    0x44(%ebx),%eax
c00257fa:	89 04 24             	mov    %eax,(%esp)
c00257fd:	e8 9b d2 ff ff       	call   c0022a9d <sema_down>
  if (!wait_while_busy (d))
c0025802:	89 f0                	mov    %esi,%eax
c0025804:	e8 24 fd ff ff       	call   c002552d <wait_while_busy>
c0025809:	83 c4 10             	add    $0x10,%esp
c002580c:	84 c0                	test   %al,%al
c002580e:	74 20                	je     c0025830 <ide_read+0x67>
c0025810:	8b 53 08             	mov    0x8(%ebx),%edx
c0025813:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0025817:	b9 00 01 00 00       	mov    $0x100,%ecx
c002581c:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  lock_release (&c->lock);
c002581f:	83 ec 0c             	sub    $0xc,%esp
c0025822:	55                   	push   %ebp
c0025823:	e8 f2 d7 ff ff       	call   c002301a <lock_release>
}
c0025828:	83 c4 1c             	add    $0x1c,%esp
c002582b:	5b                   	pop    %ebx
c002582c:	5e                   	pop    %esi
c002582d:	5f                   	pop    %edi
c002582e:	5d                   	pop    %ebp
c002582f:	c3                   	ret    
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0025830:	83 ec 08             	sub    $0x8,%esp
c0025833:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025837:	56                   	push   %esi
c0025838:	68 ec 18 03 c0       	push   $0xc00318ec
c002583d:	68 5c f3 02 c0       	push   $0xc002f35c
c0025842:	68 62 01 00 00       	push   $0x162
c0025847:	68 29 18 03 c0       	push   $0xc0031829
c002584c:	e8 d6 2d 00 00       	call   c0028627 <debug_panic>

c0025851 <ide_init>:
{
c0025851:	55                   	push   %ebp
c0025852:	57                   	push   %edi
c0025853:	56                   	push   %esi
c0025854:	53                   	push   %ebx
c0025855:	83 ec 1c             	sub    $0x1c,%esp
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025858:	6a 00                	push   $0x0
c002585a:	68 bc 18 03 c0       	push   $0xc00318bc
c002585f:	6a 08                	push   $0x8
c0025861:	68 40 cb 03 c0       	push   $0xc003cb40
c0025866:	e8 9a 1a 00 00       	call   c0027305 <snprintf>
          c->reg_base = 0x1f0;
c002586b:	66 c7 05 48 cb 03 c0 	movw   $0x1f0,0xc003cb48
c0025872:	f0 01 
          c->irq = 14 + 0x20;
c0025874:	c6 05 4a cb 03 c0 2e 	movb   $0x2e,0xc003cb4a
      lock_init (&c->lock);
c002587b:	c7 04 24 4c cb 03 c0 	movl   $0xc003cb4c,(%esp)
c0025882:	e8 82 d4 ff ff       	call   c0022d09 <lock_init>
      c->expecting_interrupt = false;
c0025887:	c6 05 80 cb 03 c0 00 	movb   $0x0,0xc003cb80
      sema_init (&c->completion_wait, 0);
c002588e:	83 c4 08             	add    $0x8,%esp
c0025891:	6a 00                	push   $0x0
c0025893:	68 84 cb 03 c0       	push   $0xc003cb84
c0025898:	e8 92 d1 ff ff       	call   c0022a2f <sema_init>
          snprintf (d->name, sizeof d->name,
c002589d:	6a 61                	push   $0x61
c002589f:	68 c3 18 03 c0       	push   $0xc00318c3
c00258a4:	6a 08                	push   $0x8
c00258a6:	68 98 cb 03 c0       	push   $0xc003cb98
c00258ab:	e8 55 1a 00 00       	call   c0027305 <snprintf>
          d->channel = c;
c00258b0:	c7 05 a0 cb 03 c0 40 	movl   $0xc003cb40,0xc003cba0
c00258b7:	cb 03 c0 
          d->dev_no = dev_no;
c00258ba:	c7 05 a4 cb 03 c0 00 	movl   $0x0,0xc003cba4
c00258c1:	00 00 00 
          d->is_ata = false;
c00258c4:	c6 05 a8 cb 03 c0 00 	movb   $0x0,0xc003cba8
          snprintf (d->name, sizeof d->name,
c00258cb:	83 c4 20             	add    $0x20,%esp
c00258ce:	6a 62                	push   $0x62
c00258d0:	68 c3 18 03 c0       	push   $0xc00318c3
c00258d5:	6a 08                	push   $0x8
c00258d7:	68 ac cb 03 c0       	push   $0xc003cbac
c00258dc:	e8 24 1a 00 00       	call   c0027305 <snprintf>
          d->channel = c;
c00258e1:	c7 05 b4 cb 03 c0 40 	movl   $0xc003cb40,0xc003cbb4
c00258e8:	cb 03 c0 
          d->dev_no = dev_no;
c00258eb:	c7 05 b8 cb 03 c0 01 	movl   $0x1,0xc003cbb8
c00258f2:	00 00 00 
          d->is_ata = false;
c00258f5:	c6 05 bc cb 03 c0 00 	movb   $0x0,0xc003cbbc
      intr_register_ext (c->irq, interrupt_handler, c->name);
c00258fc:	83 c4 0c             	add    $0xc,%esp
c00258ff:	68 40 cb 03 c0       	push   $0xc003cb40
c0025904:	68 18 53 02 c0       	push   $0xc0025318
c0025909:	0f b6 05 4a cb 03 c0 	movzbl 0xc003cb4a,%eax
c0025910:	50                   	push   %eax
c0025911:	e8 6c c2 ff ff       	call   c0021b82 <intr_register_ext>
      select_device (d);
c0025916:	b8 98 cb 03 c0       	mov    $0xc003cb98,%eax
c002591b:	e8 ce fa ff ff       	call   c00253ee <select_device>
      outb (reg_nsect (c), 0x55);
c0025920:	8b 0d 48 cb 03 c0    	mov    0xc003cb48,%ecx
c0025926:	8d 59 02             	lea    0x2(%ecx),%ebx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025929:	b0 55                	mov    $0x55,%al
c002592b:	89 da                	mov    %ebx,%edx
c002592d:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c002592e:	83 c1 03             	add    $0x3,%ecx
c0025931:	b0 aa                	mov    $0xaa,%al
c0025933:	89 ca                	mov    %ecx,%edx
c0025935:	ee                   	out    %al,(%dx)
c0025936:	89 da                	mov    %ebx,%edx
c0025938:	ee                   	out    %al,(%dx)
c0025939:	b0 55                	mov    $0x55,%al
c002593b:	89 ca                	mov    %ecx,%edx
c002593d:	ee                   	out    %al,(%dx)
c002593e:	89 da                	mov    %ebx,%edx
c0025940:	ee                   	out    %al,(%dx)
c0025941:	b0 aa                	mov    $0xaa,%al
c0025943:	89 ca                	mov    %ecx,%edx
c0025945:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025946:	89 da                	mov    %ebx,%edx
c0025948:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025949:	83 c4 10             	add    $0x10,%esp
c002594c:	3c 55                	cmp    $0x55,%al
c002594e:	0f 84 84 02 00 00    	je     c0025bd8 <ide_init+0x387>
c0025954:	b3 00                	mov    $0x0,%bl
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025956:	88 5c 24 0e          	mov    %bl,0xe(%esp)
      select_device (d);
c002595a:	b8 ac cb 03 c0       	mov    $0xc003cbac,%eax
c002595f:	e8 8a fa ff ff       	call   c00253ee <select_device>
      outb (reg_nsect (c), 0x55);
c0025964:	8b 0d 48 cb 03 c0    	mov    0xc003cb48,%ecx
c002596a:	8d 71 02             	lea    0x2(%ecx),%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002596d:	b0 55                	mov    $0x55,%al
c002596f:	89 f2                	mov    %esi,%edx
c0025971:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025972:	8d 79 03             	lea    0x3(%ecx),%edi
c0025975:	b0 aa                	mov    $0xaa,%al
c0025977:	89 fa                	mov    %edi,%edx
c0025979:	ee                   	out    %al,(%dx)
c002597a:	89 f2                	mov    %esi,%edx
c002597c:	ee                   	out    %al,(%dx)
c002597d:	b0 55                	mov    $0x55,%al
c002597f:	89 fa                	mov    %edi,%edx
c0025981:	ee                   	out    %al,(%dx)
c0025982:	89 f2                	mov    %esi,%edx
c0025984:	ee                   	out    %al,(%dx)
c0025985:	b0 aa                	mov    $0xaa,%al
c0025987:	89 fa                	mov    %edi,%edx
c0025989:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002598a:	89 f2                	mov    %esi,%edx
c002598c:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c002598d:	3c 55                	cmp    $0x55,%al
c002598f:	0f 84 50 02 00 00    	je     c0025be5 <ide_init+0x394>
c0025995:	be 00 00 00 00       	mov    $0x0,%esi
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c002599a:	89 f0                	mov    %esi,%eax
c002599c:	88 44 24 0f          	mov    %al,0xf(%esp)
  outb (reg_ctl (c), 0);
c00259a0:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00259a6:	b0 00                	mov    $0x0,%al
c00259a8:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c00259a9:	83 ec 08             	sub    $0x8,%esp
c00259ac:	6a 00                	push   $0x0
c00259ae:	6a 0a                	push   $0xa
c00259b0:	e8 56 e9 ff ff       	call   c002430b <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c00259b5:	a1 48 cb 03 c0       	mov    0xc003cb48,%eax
c00259ba:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c00259c0:	b0 04                	mov    $0x4,%al
c00259c2:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c00259c3:	83 c4 08             	add    $0x8,%esp
c00259c6:	6a 00                	push   $0x0
c00259c8:	6a 0a                	push   $0xa
c00259ca:	e8 3c e9 ff ff       	call   c002430b <timer_usleep>
  outb (reg_ctl (c), 0);
c00259cf:	a1 48 cb 03 c0       	mov    0xc003cb48,%eax
c00259d4:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c00259da:	b0 00                	mov    $0x0,%al
c00259dc:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c00259dd:	83 c4 08             	add    $0x8,%esp
c00259e0:	6a 00                	push   $0x0
c00259e2:	68 96 00 00 00       	push   $0x96
c00259e7:	e8 06 e9 ff ff       	call   c00242f2 <timer_msleep>
  if (present[0]) 
c00259ec:	83 c4 10             	add    $0x10,%esp
c00259ef:	84 db                	test   %bl,%bl
c00259f1:	0f 85 fd 01 00 00    	jne    c0025bf4 <ide_init+0x3a3>
  if (present[1])
c00259f7:	89 f0                	mov    %esi,%eax
c00259f9:	84 c0                	test   %al,%al
c00259fb:	0f 85 0c 02 00 00    	jne    c0025c0d <ide_init+0x3bc>
      if (check_device_type (&c->devices[0]))
c0025a01:	b8 98 cb 03 c0       	mov    $0xc003cb98,%eax
c0025a06:	e8 16 fa ff ff       	call   c0025421 <check_device_type>
c0025a0b:	84 c0                	test   %al,%al
c0025a0d:	0f 85 42 02 00 00    	jne    c0025c55 <ide_init+0x404>
        if (c->devices[dev_no].is_ata)
c0025a13:	80 3d a8 cb 03 c0 00 	cmpb   $0x0,0xc003cba8
c0025a1a:	0f 85 44 02 00 00    	jne    c0025c64 <ide_init+0x413>
c0025a20:	80 3d bc cb 03 c0 00 	cmpb   $0x0,0xc003cbbc
c0025a27:	0f 85 46 02 00 00    	jne    c0025c73 <ide_init+0x422>
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025a2d:	6a 01                	push   $0x1
c0025a2f:	68 bc 18 03 c0       	push   $0xc00318bc
c0025a34:	6a 08                	push   $0x8
c0025a36:	68 c0 cb 03 c0       	push   $0xc003cbc0
c0025a3b:	e8 c5 18 00 00       	call   c0027305 <snprintf>
          c->reg_base = 0x170;
c0025a40:	66 c7 05 c8 cb 03 c0 	movw   $0x170,0xc003cbc8
c0025a47:	70 01 
          c->irq = 15 + 0x20;
c0025a49:	c6 05 ca cb 03 c0 2f 	movb   $0x2f,0xc003cbca
      lock_init (&c->lock);
c0025a50:	c7 04 24 cc cb 03 c0 	movl   $0xc003cbcc,(%esp)
c0025a57:	e8 ad d2 ff ff       	call   c0022d09 <lock_init>
      c->expecting_interrupt = false;
c0025a5c:	c6 05 00 cc 03 c0 00 	movb   $0x0,0xc003cc00
      sema_init (&c->completion_wait, 0);
c0025a63:	83 c4 08             	add    $0x8,%esp
c0025a66:	6a 00                	push   $0x0
c0025a68:	68 04 cc 03 c0       	push   $0xc003cc04
c0025a6d:	e8 bd cf ff ff       	call   c0022a2f <sema_init>
          snprintf (d->name, sizeof d->name,
c0025a72:	6a 63                	push   $0x63
c0025a74:	68 c3 18 03 c0       	push   $0xc00318c3
c0025a79:	6a 08                	push   $0x8
c0025a7b:	68 18 cc 03 c0       	push   $0xc003cc18
c0025a80:	e8 80 18 00 00       	call   c0027305 <snprintf>
          d->channel = c;
c0025a85:	c7 05 20 cc 03 c0 c0 	movl   $0xc003cbc0,0xc003cc20
c0025a8c:	cb 03 c0 
          d->dev_no = dev_no;
c0025a8f:	c7 05 24 cc 03 c0 00 	movl   $0x0,0xc003cc24
c0025a96:	00 00 00 
          d->is_ata = false;
c0025a99:	c6 05 28 cc 03 c0 00 	movb   $0x0,0xc003cc28
          snprintf (d->name, sizeof d->name,
c0025aa0:	83 c4 20             	add    $0x20,%esp
c0025aa3:	6a 64                	push   $0x64
c0025aa5:	68 c3 18 03 c0       	push   $0xc00318c3
c0025aaa:	6a 08                	push   $0x8
c0025aac:	68 2c cc 03 c0       	push   $0xc003cc2c
c0025ab1:	e8 4f 18 00 00       	call   c0027305 <snprintf>
          d->channel = c;
c0025ab6:	c7 05 34 cc 03 c0 c0 	movl   $0xc003cbc0,0xc003cc34
c0025abd:	cb 03 c0 
          d->dev_no = dev_no;
c0025ac0:	c7 05 38 cc 03 c0 01 	movl   $0x1,0xc003cc38
c0025ac7:	00 00 00 
          d->is_ata = false;
c0025aca:	c6 05 3c cc 03 c0 00 	movb   $0x0,0xc003cc3c
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025ad1:	83 c4 0c             	add    $0xc,%esp
c0025ad4:	68 c0 cb 03 c0       	push   $0xc003cbc0
c0025ad9:	68 18 53 02 c0       	push   $0xc0025318
c0025ade:	0f b6 05 ca cb 03 c0 	movzbl 0xc003cbca,%eax
c0025ae5:	50                   	push   %eax
c0025ae6:	e8 97 c0 ff ff       	call   c0021b82 <intr_register_ext>
c0025aeb:	bf 18 cc 03 c0       	mov    $0xc003cc18,%edi
c0025af0:	8d 74 24 1e          	lea    0x1e(%esp),%esi
c0025af4:	83 c4 10             	add    $0x10,%esp
      select_device (d);
c0025af7:	89 f8                	mov    %edi,%eax
c0025af9:	e8 f0 f8 ff ff       	call   c00253ee <select_device>
      outb (reg_nsect (c), 0x55);
c0025afe:	8b 2d c8 cb 03 c0    	mov    0xc003cbc8,%ebp
c0025b04:	8d 4d 02             	lea    0x2(%ebp),%ecx
c0025b07:	b0 55                	mov    $0x55,%al
c0025b09:	89 ca                	mov    %ecx,%edx
c0025b0b:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025b0c:	8d 5d 03             	lea    0x3(%ebp),%ebx
c0025b0f:	b0 aa                	mov    $0xaa,%al
c0025b11:	89 da                	mov    %ebx,%edx
c0025b13:	ee                   	out    %al,(%dx)
c0025b14:	89 ca                	mov    %ecx,%edx
c0025b16:	ee                   	out    %al,(%dx)
c0025b17:	b0 55                	mov    $0x55,%al
c0025b19:	89 da                	mov    %ebx,%edx
c0025b1b:	ee                   	out    %al,(%dx)
c0025b1c:	89 ca                	mov    %ecx,%edx
c0025b1e:	ee                   	out    %al,(%dx)
c0025b1f:	b0 aa                	mov    $0xaa,%al
c0025b21:	89 da                	mov    %ebx,%edx
c0025b23:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025b24:	89 ca                	mov    %ecx,%edx
c0025b26:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025b27:	3c 55                	cmp    $0x55,%al
c0025b29:	0f 84 53 01 00 00    	je     c0025c82 <ide_init+0x431>
c0025b2f:	b0 00                	mov    $0x0,%al
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025b31:	88 06                	mov    %al,(%esi)
c0025b33:	83 c7 14             	add    $0x14,%edi
c0025b36:	46                   	inc    %esi
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025b37:	8d 44 24 10          	lea    0x10(%esp),%eax
c0025b3b:	39 f0                	cmp    %esi,%eax
c0025b3d:	75 b8                	jne    c0025af7 <ide_init+0x2a6>
  outb (reg_ctl (c), 0);
c0025b3f:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025b45:	b0 00                	mov    $0x0,%al
c0025b47:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0025b48:	83 ec 08             	sub    $0x8,%esp
c0025b4b:	6a 00                	push   $0x0
c0025b4d:	6a 0a                	push   $0xa
c0025b4f:	e8 b7 e7 ff ff       	call   c002430b <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c0025b54:	a1 c8 cb 03 c0       	mov    0xc003cbc8,%eax
c0025b59:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025b5f:	b0 04                	mov    $0x4,%al
c0025b61:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0025b62:	83 c4 08             	add    $0x8,%esp
c0025b65:	6a 00                	push   $0x0
c0025b67:	6a 0a                	push   $0xa
c0025b69:	e8 9d e7 ff ff       	call   c002430b <timer_usleep>
  outb (reg_ctl (c), 0);
c0025b6e:	a1 c8 cb 03 c0       	mov    0xc003cbc8,%eax
c0025b73:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025b79:	b0 00                	mov    $0x0,%al
c0025b7b:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c0025b7c:	83 c4 08             	add    $0x8,%esp
c0025b7f:	6a 00                	push   $0x0
c0025b81:	68 96 00 00 00       	push   $0x96
c0025b86:	e8 67 e7 ff ff       	call   c00242f2 <timer_msleep>
  if (present[0]) 
c0025b8b:	83 c4 10             	add    $0x10,%esp
c0025b8e:	80 7c 24 0e 00       	cmpb   $0x0,0xe(%esp)
c0025b93:	0f 85 f6 00 00 00    	jne    c0025c8f <ide_init+0x43e>
  if (present[1])
c0025b99:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0025b9e:	0f 85 04 01 00 00    	jne    c0025ca8 <ide_init+0x457>
      if (check_device_type (&c->devices[0]))
c0025ba4:	b8 18 cc 03 c0       	mov    $0xc003cc18,%eax
c0025ba9:	e8 73 f8 ff ff       	call   c0025421 <check_device_type>
c0025bae:	84 c0                	test   %al,%al
c0025bb0:	0f 85 3a 01 00 00    	jne    c0025cf0 <ide_init+0x49f>
        if (c->devices[dev_no].is_ata)
c0025bb6:	80 3d 28 cc 03 c0 00 	cmpb   $0x0,0xc003cc28
c0025bbd:	0f 85 3c 01 00 00    	jne    c0025cff <ide_init+0x4ae>
c0025bc3:	80 3d 3c cc 03 c0 00 	cmpb   $0x0,0xc003cc3c
c0025bca:	0f 85 3e 01 00 00    	jne    c0025d0e <ide_init+0x4bd>
}
c0025bd0:	83 c4 1c             	add    $0x1c,%esp
c0025bd3:	5b                   	pop    %ebx
c0025bd4:	5e                   	pop    %esi
c0025bd5:	5f                   	pop    %edi
c0025bd6:	5d                   	pop    %ebp
c0025bd7:	c3                   	ret    
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025bd8:	89 ca                	mov    %ecx,%edx
c0025bda:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025bdb:	3c aa                	cmp    $0xaa,%al
c0025bdd:	0f 94 c3             	sete   %bl
c0025be0:	e9 71 fd ff ff       	jmp    c0025956 <ide_init+0x105>
c0025be5:	89 fa                	mov    %edi,%edx
c0025be7:	ec                   	in     (%dx),%al
c0025be8:	3c aa                	cmp    $0xaa,%al
c0025bea:	0f 94 c0             	sete   %al
c0025bed:	89 c6                	mov    %eax,%esi
c0025bef:	e9 a6 fd ff ff       	jmp    c002599a <ide_init+0x149>
      select_device (&c->devices[0]);
c0025bf4:	b8 98 cb 03 c0       	mov    $0xc003cb98,%eax
c0025bf9:	e8 f0 f7 ff ff       	call   c00253ee <select_device>
      wait_while_busy (&c->devices[0]); 
c0025bfe:	b8 98 cb 03 c0       	mov    $0xc003cb98,%eax
c0025c03:	e8 25 f9 ff ff       	call   c002552d <wait_while_busy>
c0025c08:	e9 ea fd ff ff       	jmp    c00259f7 <ide_init+0x1a6>
      select_device (&c->devices[1]);
c0025c0d:	b8 ac cb 03 c0       	mov    $0xc003cbac,%eax
c0025c12:	e8 d7 f7 ff ff       	call   c00253ee <select_device>
c0025c17:	bb b8 0b 00 00       	mov    $0xbb8,%ebx
c0025c1c:	eb 12                	jmp    c0025c30 <ide_init+0x3df>
          timer_msleep (10);
c0025c1e:	83 ec 08             	sub    $0x8,%esp
c0025c21:	6a 00                	push   $0x0
c0025c23:	6a 0a                	push   $0xa
c0025c25:	e8 c8 e6 ff ff       	call   c00242f2 <timer_msleep>
      for (i = 0; i < 3000; i++) 
c0025c2a:	83 c4 10             	add    $0x10,%esp
c0025c2d:	4b                   	dec    %ebx
c0025c2e:	74 16                	je     c0025c46 <ide_init+0x3f5>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025c30:	8b 0d 48 cb 03 c0    	mov    0xc003cb48,%ecx
c0025c36:	8d 51 02             	lea    0x2(%ecx),%edx
c0025c39:	ec                   	in     (%dx),%al
c0025c3a:	3c 01                	cmp    $0x1,%al
c0025c3c:	75 e0                	jne    c0025c1e <ide_init+0x3cd>
c0025c3e:	8d 51 03             	lea    0x3(%ecx),%edx
c0025c41:	ec                   	in     (%dx),%al
c0025c42:	3c 01                	cmp    $0x1,%al
c0025c44:	75 d8                	jne    c0025c1e <ide_init+0x3cd>
      wait_while_busy (&c->devices[1]);
c0025c46:	b8 ac cb 03 c0       	mov    $0xc003cbac,%eax
c0025c4b:	e8 dd f8 ff ff       	call   c002552d <wait_while_busy>
c0025c50:	e9 ac fd ff ff       	jmp    c0025a01 <ide_init+0x1b0>
        check_device_type (&c->devices[1]);
c0025c55:	b8 ac cb 03 c0       	mov    $0xc003cbac,%eax
c0025c5a:	e8 c2 f7 ff ff       	call   c0025421 <check_device_type>
c0025c5f:	e9 af fd ff ff       	jmp    c0025a13 <ide_init+0x1c2>
          identify_ata_device (&c->devices[dev_no]);
c0025c64:	b8 98 cb 03 c0       	mov    $0xc003cb98,%eax
c0025c69:	e8 1c fa ff ff       	call   c002568a <identify_ata_device>
c0025c6e:	e9 ad fd ff ff       	jmp    c0025a20 <ide_init+0x1cf>
c0025c73:	b8 ac cb 03 c0       	mov    $0xc003cbac,%eax
c0025c78:	e8 0d fa ff ff       	call   c002568a <identify_ata_device>
c0025c7d:	e9 ab fd ff ff       	jmp    c0025a2d <ide_init+0x1dc>
c0025c82:	89 da                	mov    %ebx,%edx
c0025c84:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025c85:	3c aa                	cmp    $0xaa,%al
c0025c87:	0f 94 c0             	sete   %al
c0025c8a:	e9 a2 fe ff ff       	jmp    c0025b31 <ide_init+0x2e0>
      select_device (&c->devices[0]);
c0025c8f:	b8 18 cc 03 c0       	mov    $0xc003cc18,%eax
c0025c94:	e8 55 f7 ff ff       	call   c00253ee <select_device>
      wait_while_busy (&c->devices[0]); 
c0025c99:	b8 18 cc 03 c0       	mov    $0xc003cc18,%eax
c0025c9e:	e8 8a f8 ff ff       	call   c002552d <wait_while_busy>
c0025ca3:	e9 f1 fe ff ff       	jmp    c0025b99 <ide_init+0x348>
      select_device (&c->devices[1]);
c0025ca8:	b8 2c cc 03 c0       	mov    $0xc003cc2c,%eax
c0025cad:	e8 3c f7 ff ff       	call   c00253ee <select_device>
c0025cb2:	bb b8 0b 00 00       	mov    $0xbb8,%ebx
c0025cb7:	eb 12                	jmp    c0025ccb <ide_init+0x47a>
          timer_msleep (10);
c0025cb9:	83 ec 08             	sub    $0x8,%esp
c0025cbc:	6a 00                	push   $0x0
c0025cbe:	6a 0a                	push   $0xa
c0025cc0:	e8 2d e6 ff ff       	call   c00242f2 <timer_msleep>
      for (i = 0; i < 3000; i++) 
c0025cc5:	83 c4 10             	add    $0x10,%esp
c0025cc8:	4b                   	dec    %ebx
c0025cc9:	74 16                	je     c0025ce1 <ide_init+0x490>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025ccb:	8b 0d c8 cb 03 c0    	mov    0xc003cbc8,%ecx
c0025cd1:	8d 51 02             	lea    0x2(%ecx),%edx
c0025cd4:	ec                   	in     (%dx),%al
c0025cd5:	3c 01                	cmp    $0x1,%al
c0025cd7:	75 e0                	jne    c0025cb9 <ide_init+0x468>
c0025cd9:	8d 51 03             	lea    0x3(%ecx),%edx
c0025cdc:	ec                   	in     (%dx),%al
c0025cdd:	3c 01                	cmp    $0x1,%al
c0025cdf:	75 d8                	jne    c0025cb9 <ide_init+0x468>
      wait_while_busy (&c->devices[1]);
c0025ce1:	b8 2c cc 03 c0       	mov    $0xc003cc2c,%eax
c0025ce6:	e8 42 f8 ff ff       	call   c002552d <wait_while_busy>
c0025ceb:	e9 b4 fe ff ff       	jmp    c0025ba4 <ide_init+0x353>
        check_device_type (&c->devices[1]);
c0025cf0:	b8 2c cc 03 c0       	mov    $0xc003cc2c,%eax
c0025cf5:	e8 27 f7 ff ff       	call   c0025421 <check_device_type>
c0025cfa:	e9 b7 fe ff ff       	jmp    c0025bb6 <ide_init+0x365>
          identify_ata_device (&c->devices[dev_no]);
c0025cff:	b8 18 cc 03 c0       	mov    $0xc003cc18,%eax
c0025d04:	e8 81 f9 ff ff       	call   c002568a <identify_ata_device>
c0025d09:	e9 b5 fe ff ff       	jmp    c0025bc3 <ide_init+0x372>
c0025d0e:	b8 2c cc 03 c0       	mov    $0xc003cc2c,%eax
c0025d13:	e8 72 f9 ff ff       	call   c002568a <identify_ata_device>
}
c0025d18:	e9 b3 fe ff ff       	jmp    c0025bd0 <ide_init+0x37f>

c0025d1d <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0025d1d:	83 ec 18             	sub    $0x18,%esp
  intq_init (&buffer);
c0025d20:	68 40 cc 03 c0       	push   $0xc003cc40
c0025d25:	e8 77 01 00 00       	call   c0025ea1 <intq_init>
}
c0025d2a:	83 c4 1c             	add    $0x1c,%esp
c0025d2d:	c3                   	ret    

c0025d2e <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0025d2e:	53                   	push   %ebx
c0025d2f:	83 ec 08             	sub    $0x8,%esp
c0025d32:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025d36:	e8 89 bc ff ff       	call   c00219c4 <intr_get_level>
c0025d3b:	85 c0                	test   %eax,%eax
c0025d3d:	75 2f                	jne    c0025d6e <input_putc+0x40>
  ASSERT (!intq_full (&buffer));
c0025d3f:	83 ec 0c             	sub    $0xc,%esp
c0025d42:	68 40 cc 03 c0       	push   $0xc003cc40
c0025d47:	e8 c7 01 00 00       	call   c0025f13 <intq_full>
c0025d4c:	83 c4 10             	add    $0x10,%esp
c0025d4f:	84 c0                	test   %al,%al
c0025d51:	75 39                	jne    c0025d8c <input_putc+0x5e>

  intq_putc (&buffer, key);
c0025d53:	83 ec 08             	sub    $0x8,%esp
c0025d56:	0f b6 db             	movzbl %bl,%ebx
c0025d59:	53                   	push   %ebx
c0025d5a:	68 40 cc 03 c0       	push   $0xc003cc40
c0025d5f:	e8 0c 04 00 00       	call   c0026170 <intq_putc>
  serial_notify ();
c0025d64:	e8 5e ed ff ff       	call   c0024ac7 <serial_notify>
}
c0025d69:	83 c4 18             	add    $0x18,%esp
c0025d6c:	5b                   	pop    %ebx
c0025d6d:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025d6e:	83 ec 0c             	sub    $0xc,%esp
c0025d71:	68 26 07 03 c0       	push   $0xc0030726
c0025d76:	68 21 01 03 c0       	push   $0xc0030121
c0025d7b:	68 b8 f3 02 c0       	push   $0xc002f3b8
c0025d80:	6a 15                	push   $0x15
c0025d82:	68 0c 19 03 c0       	push   $0xc003190c
c0025d87:	e8 9b 28 00 00       	call   c0028627 <debug_panic>
  ASSERT (!intq_full (&buffer));
c0025d8c:	83 ec 0c             	sub    $0xc,%esp
c0025d8f:	68 22 19 03 c0       	push   $0xc0031922
c0025d94:	68 21 01 03 c0       	push   $0xc0030121
c0025d99:	68 b8 f3 02 c0       	push   $0xc002f3b8
c0025d9e:	6a 16                	push   $0x16
c0025da0:	68 0c 19 03 c0       	push   $0xc003190c
c0025da5:	e8 7d 28 00 00       	call   c0028627 <debug_panic>

c0025daa <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0025daa:	56                   	push   %esi
c0025dab:	53                   	push   %ebx
c0025dac:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0025daf:	e8 4d bc ff ff       	call   c0021a01 <intr_disable>
c0025db4:	89 c6                	mov    %eax,%esi
  key = intq_getc (&buffer);
c0025db6:	83 ec 0c             	sub    $0xc,%esp
c0025db9:	68 40 cc 03 c0       	push   $0xc003cc40
c0025dbe:	e8 f2 02 00 00       	call   c00260b5 <intq_getc>
c0025dc3:	88 c3                	mov    %al,%bl
  serial_notify ();
c0025dc5:	e8 fd ec ff ff       	call   c0024ac7 <serial_notify>
  intr_set_level (old_level);
c0025dca:	89 34 24             	mov    %esi,(%esp)
c0025dcd:	e8 36 bc ff ff       	call   c0021a08 <intr_set_level>
  
  return key;
}
c0025dd2:	88 d8                	mov    %bl,%al
c0025dd4:	83 c4 14             	add    $0x14,%esp
c0025dd7:	5b                   	pop    %ebx
c0025dd8:	5e                   	pop    %esi
c0025dd9:	c3                   	ret    

c0025dda <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0025dda:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0025ddd:	e8 e2 bb ff ff       	call   c00219c4 <intr_get_level>
c0025de2:	85 c0                	test   %eax,%eax
c0025de4:	75 11                	jne    c0025df7 <input_full+0x1d>
  return intq_full (&buffer);
c0025de6:	83 ec 0c             	sub    $0xc,%esp
c0025de9:	68 40 cc 03 c0       	push   $0xc003cc40
c0025dee:	e8 20 01 00 00       	call   c0025f13 <intq_full>
}
c0025df3:	83 c4 1c             	add    $0x1c,%esp
c0025df6:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025df7:	83 ec 0c             	sub    $0xc,%esp
c0025dfa:	68 26 07 03 c0       	push   $0xc0030726
c0025dff:	68 21 01 03 c0       	push   $0xc0030121
c0025e04:	68 ac f3 02 c0       	push   $0xc002f3ac
c0025e09:	6a 32                	push   $0x32
c0025e0b:	68 0c 19 03 c0       	push   $0xc003190c
c0025e10:	e8 12 28 00 00       	call   c0028627 <debug_panic>

c0025e15 <input_getline>:

/*
 * read a line from input
 */
void
input_getline(char *str, int max_len) {
c0025e15:	55                   	push   %ebp
c0025e16:	57                   	push   %edi
c0025e17:	56                   	push   %esi
c0025e18:	53                   	push   %ebx
c0025e19:	83 ec 0c             	sub    $0xc,%esp
c0025e1c:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025e20:	8b 7c 24 24          	mov    0x24(%esp),%edi
  int len = 0;
c0025e24:	be 00 00 00 00       	mov    $0x0,%esi
c0025e29:	eb 2d                	jmp    c0025e58 <input_getline+0x43>
  do {
    char ch = input_getc();
    bool done = false;
    switch (ch) {
c0025e2b:	3c 0d                	cmp    $0xd,%al
c0025e2d:	74 3f                	je     c0025e6e <input_getline+0x59>
          putbuf("\b \b", 3);
          len--;
        }
        break;
      default:
        if (ch == 0x09 || (ch >= 0x20 && ch <= 0x7E)) {
c0025e2f:	80 fb 09             	cmp    $0x9,%bl
c0025e32:	74 07                	je     c0025e3b <input_getline+0x26>
c0025e34:	8d 43 e0             	lea    -0x20(%ebx),%eax
c0025e37:	3c 5e                	cmp    $0x5e,%al
c0025e39:	77 16                	ja     c0025e51 <input_getline+0x3c>
          putchar(ch);
c0025e3b:	83 ec 0c             	sub    $0xc,%esp
    switch (ch) {
c0025e3e:	0f be c3             	movsbl %bl,%eax
          putchar(ch);
c0025e41:	50                   	push   %eax
c0025e42:	e8 33 43 00 00       	call   c002a17a <putchar>
          str[len++] = ch;
c0025e47:	88 5c 35 00          	mov    %bl,0x0(%ebp,%esi,1)
c0025e4b:	83 c4 10             	add    $0x10,%esp
c0025e4e:	8d 76 01             	lea    0x1(%esi),%esi
        }
        break;
    }
    if (done || len + 1 >= max_len) {
c0025e51:	8d 46 01             	lea    0x1(%esi),%eax
c0025e54:	39 f8                	cmp    %edi,%eax
c0025e56:	7d 16                	jge    c0025e6e <input_getline+0x59>
    char ch = input_getc();
c0025e58:	e8 4d ff ff ff       	call   c0025daa <input_getc>
c0025e5d:	88 c3                	mov    %al,%bl
    switch (ch) {
c0025e5f:	3c 08                	cmp    $0x8,%al
c0025e61:	74 25                	je     c0025e88 <input_getline+0x73>
c0025e63:	3c 08                	cmp    $0x8,%al
c0025e65:	77 c4                	ja     c0025e2b <input_getline+0x16>
c0025e67:	8d 43 fd             	lea    -0x3(%ebx),%eax
c0025e6a:	3c 01                	cmp    $0x1,%al
c0025e6c:	77 c1                	ja     c0025e2f <input_getline+0x1a>
      putchar('\n');
c0025e6e:	83 ec 0c             	sub    $0xc,%esp
c0025e71:	6a 0a                	push   $0xa
c0025e73:	e8 02 43 00 00       	call   c002a17a <putchar>
      break;
    }
  } while (true);
  str[len] = '\0';
c0025e78:	c6 44 35 00 00       	movb   $0x0,0x0(%ebp,%esi,1)
c0025e7d:	83 c4 10             	add    $0x10,%esp
c0025e80:	83 c4 0c             	add    $0xc,%esp
c0025e83:	5b                   	pop    %ebx
c0025e84:	5e                   	pop    %esi
c0025e85:	5f                   	pop    %edi
c0025e86:	5d                   	pop    %ebp
c0025e87:	c3                   	ret    
        if (len > 0) {
c0025e88:	85 f6                	test   %esi,%esi
c0025e8a:	7e c5                	jle    c0025e51 <input_getline+0x3c>
          putbuf("\b \b", 3);
c0025e8c:	83 ec 08             	sub    $0x8,%esp
c0025e8f:	6a 03                	push   $0x3
c0025e91:	68 37 19 03 c0       	push   $0xc0031937
c0025e96:	e8 ae 42 00 00       	call   c002a149 <putbuf>
          len--;
c0025e9b:	4e                   	dec    %esi
c0025e9c:	83 c4 10             	add    $0x10,%esp
c0025e9f:	eb b0                	jmp    c0025e51 <input_getline+0x3c>

c0025ea1 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c0025ea1:	53                   	push   %ebx
c0025ea2:	83 ec 14             	sub    $0x14,%esp
c0025ea5:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_init (&q->lock);
c0025ea9:	53                   	push   %ebx
c0025eaa:	e8 5a ce ff ff       	call   c0022d09 <lock_init>
  q->not_full = q->not_empty = NULL;
c0025eaf:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
c0025eb6:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  q->head = q->tail = 0;
c0025ebd:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
c0025ec4:	00 00 00 
c0025ec7:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
}
c0025ece:	83 c4 18             	add    $0x18,%esp
c0025ed1:	5b                   	pop    %ebx
c0025ed2:	c3                   	ret    

c0025ed3 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0025ed3:	53                   	push   %ebx
c0025ed4:	83 ec 08             	sub    $0x8,%esp
c0025ed7:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025edb:	e8 e4 ba ff ff       	call   c00219c4 <intr_get_level>
c0025ee0:	85 c0                	test   %eax,%eax
c0025ee2:	75 11                	jne    c0025ef5 <intq_empty+0x22>
  return q->head == q->tail;
c0025ee4:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
c0025eea:	39 43 7c             	cmp    %eax,0x7c(%ebx)
c0025eed:	0f 94 c0             	sete   %al
}
c0025ef0:	83 c4 08             	add    $0x8,%esp
c0025ef3:	5b                   	pop    %ebx
c0025ef4:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025ef5:	83 ec 0c             	sub    $0xc,%esp
c0025ef8:	68 26 07 03 c0       	push   $0xc0030726
c0025efd:	68 21 01 03 c0       	push   $0xc0030121
c0025f02:	68 f8 f3 02 c0       	push   $0xc002f3f8
c0025f07:	6a 16                	push   $0x16
c0025f09:	68 3b 19 03 c0       	push   $0xc003193b
c0025f0e:	e8 14 27 00 00       	call   c0028627 <debug_panic>

c0025f13 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c0025f13:	53                   	push   %ebx
c0025f14:	83 ec 08             	sub    $0x8,%esp
c0025f17:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025f1b:	e8 a4 ba ff ff       	call   c00219c4 <intr_get_level>
c0025f20:	85 c0                	test   %eax,%eax
c0025f22:	75 19                	jne    c0025f3d <intq_full+0x2a>

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
  return (pos + 1) % INTQ_BUFSIZE;
c0025f24:	8b 43 7c             	mov    0x7c(%ebx),%eax
c0025f27:	40                   	inc    %eax
c0025f28:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0025f2d:	78 2c                	js     c0025f5b <intq_full+0x48>
  return next (q->head) == q->tail;
c0025f2f:	3b 83 80 00 00 00    	cmp    0x80(%ebx),%eax
c0025f35:	0f 94 c0             	sete   %al
}
c0025f38:	83 c4 08             	add    $0x8,%esp
c0025f3b:	5b                   	pop    %ebx
c0025f3c:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025f3d:	83 ec 0c             	sub    $0xc,%esp
c0025f40:	68 26 07 03 c0       	push   $0xc0030726
c0025f45:	68 21 01 03 c0       	push   $0xc0030121
c0025f4a:	68 ec f3 02 c0       	push   $0xc002f3ec
c0025f4f:	6a 1e                	push   $0x1e
c0025f51:	68 3b 19 03 c0       	push   $0xc003193b
c0025f56:	e8 cc 26 00 00       	call   c0028627 <debug_panic>
  return (pos + 1) % INTQ_BUFSIZE;
c0025f5b:	48                   	dec    %eax
c0025f5c:	83 c8 c0             	or     $0xffffffc0,%eax
c0025f5f:	40                   	inc    %eax
c0025f60:	eb cd                	jmp    c0025f2f <intq_full+0x1c>

c0025f62 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0025f62:	56                   	push   %esi
c0025f63:	53                   	push   %ebx
c0025f64:	83 ec 04             	sub    $0x4,%esp
c0025f67:	89 c3                	mov    %eax,%ebx
c0025f69:	89 d6                	mov    %edx,%esi
  ASSERT (!intr_context ());
c0025f6b:	e8 b2 bc ff ff       	call   c0021c22 <intr_context>
c0025f70:	84 c0                	test   %al,%al
c0025f72:	75 39                	jne    c0025fad <wait+0x4b>
  ASSERT (intr_get_level () == INTR_OFF);
c0025f74:	e8 4b ba ff ff       	call   c00219c4 <intr_get_level>
c0025f79:	85 c0                	test   %eax,%eax
c0025f7b:	75 4e                	jne    c0025fcb <wait+0x69>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0025f7d:	8d 43 38             	lea    0x38(%ebx),%eax
c0025f80:	39 c6                	cmp    %eax,%esi
c0025f82:	74 65                	je     c0025fe9 <wait+0x87>
c0025f84:	8d 43 34             	lea    0x34(%ebx),%eax
c0025f87:	39 c6                	cmp    %eax,%esi
c0025f89:	75 70                	jne    c0025ffb <wait+0x99>
c0025f8b:	83 ec 0c             	sub    $0xc,%esp
c0025f8e:	53                   	push   %ebx
c0025f8f:	e8 7f ff ff ff       	call   c0025f13 <intq_full>
c0025f94:	83 c4 10             	add    $0x10,%esp
c0025f97:	84 c0                	test   %al,%al
c0025f99:	74 60                	je     c0025ffb <wait+0x99>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0025f9b:	e8 1c ad ff ff       	call   c0020cbc <thread_current>
c0025fa0:	89 06                	mov    %eax,(%esi)
  thread_block ();
c0025fa2:	e8 56 b4 ff ff       	call   c00213fd <thread_block>
}
c0025fa7:	83 c4 04             	add    $0x4,%esp
c0025faa:	5b                   	pop    %ebx
c0025fab:	5e                   	pop    %esi
c0025fac:	c3                   	ret    
  ASSERT (!intr_context ());
c0025fad:	83 ec 0c             	sub    $0xc,%esp
c0025fb0:	68 f0 07 03 c0       	push   $0xc00307f0
c0025fb5:	68 21 01 03 c0       	push   $0xc0030121
c0025fba:	68 d8 f3 02 c0       	push   $0xc002f3d8
c0025fbf:	6a 59                	push   $0x59
c0025fc1:	68 3b 19 03 c0       	push   $0xc003193b
c0025fc6:	e8 5c 26 00 00       	call   c0028627 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0025fcb:	83 ec 0c             	sub    $0xc,%esp
c0025fce:	68 26 07 03 c0       	push   $0xc0030726
c0025fd3:	68 21 01 03 c0       	push   $0xc0030121
c0025fd8:	68 d8 f3 02 c0       	push   $0xc002f3d8
c0025fdd:	6a 5a                	push   $0x5a
c0025fdf:	68 3b 19 03 c0       	push   $0xc003193b
c0025fe4:	e8 3e 26 00 00       	call   c0028627 <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0025fe9:	83 ec 0c             	sub    $0xc,%esp
c0025fec:	53                   	push   %ebx
c0025fed:	e8 e1 fe ff ff       	call   c0025ed3 <intq_empty>
c0025ff2:	83 c4 10             	add    $0x10,%esp
c0025ff5:	84 c0                	test   %al,%al
c0025ff7:	74 8b                	je     c0025f84 <wait+0x22>
c0025ff9:	eb a0                	jmp    c0025f9b <wait+0x39>
c0025ffb:	83 ec 0c             	sub    $0xc,%esp
c0025ffe:	68 50 19 03 c0       	push   $0xc0031950
c0026003:	68 21 01 03 c0       	push   $0xc0030121
c0026008:	68 d8 f3 02 c0       	push   $0xc002f3d8
c002600d:	6a 5c                	push   $0x5c
c002600f:	68 3b 19 03 c0       	push   $0xc003193b
c0026014:	e8 0e 26 00 00       	call   c0028627 <debug_panic>

c0026019 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0026019:	56                   	push   %esi
c002601a:	53                   	push   %ebx
c002601b:	83 ec 04             	sub    $0x4,%esp
c002601e:	89 c6                	mov    %eax,%esi
c0026020:	89 d3                	mov    %edx,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0026022:	e8 9d b9 ff ff       	call   c00219c4 <intr_get_level>
c0026027:	85 c0                	test   %eax,%eax
c0026029:	75 3c                	jne    c0026067 <signal+0x4e>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c002602b:	8d 46 38             	lea    0x38(%esi),%eax
c002602e:	39 c3                	cmp    %eax,%ebx
c0026030:	74 53                	je     c0026085 <signal+0x6c>
c0026032:	8d 46 34             	lea    0x34(%esi),%eax
c0026035:	39 c3                	cmp    %eax,%ebx
c0026037:	75 5e                	jne    c0026097 <signal+0x7e>
c0026039:	83 ec 0c             	sub    $0xc,%esp
c002603c:	56                   	push   %esi
c002603d:	e8 d1 fe ff ff       	call   c0025f13 <intq_full>
c0026042:	83 c4 10             	add    $0x10,%esp
c0026045:	84 c0                	test   %al,%al
c0026047:	75 4e                	jne    c0026097 <signal+0x7e>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c0026049:	8b 03                	mov    (%ebx),%eax
c002604b:	85 c0                	test   %eax,%eax
c002604d:	74 12                	je     c0026061 <signal+0x48>
    {
      thread_unblock (*waiter);
c002604f:	83 ec 0c             	sub    $0xc,%esp
c0026052:	50                   	push   %eax
c0026053:	e8 21 ae ff ff       	call   c0020e79 <thread_unblock>
      *waiter = NULL;
c0026058:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
c002605e:	83 c4 10             	add    $0x10,%esp
    }
}
c0026061:	83 c4 04             	add    $0x4,%esp
c0026064:	5b                   	pop    %ebx
c0026065:	5e                   	pop    %esi
c0026066:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0026067:	83 ec 0c             	sub    $0xc,%esp
c002606a:	68 26 07 03 c0       	push   $0xc0030726
c002606f:	68 21 01 03 c0       	push   $0xc0030121
c0026074:	68 d0 f3 02 c0       	push   $0xc002f3d0
c0026079:	6a 69                	push   $0x69
c002607b:	68 3b 19 03 c0       	push   $0xc003193b
c0026080:	e8 a2 25 00 00       	call   c0028627 <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026085:	83 ec 0c             	sub    $0xc,%esp
c0026088:	56                   	push   %esi
c0026089:	e8 45 fe ff ff       	call   c0025ed3 <intq_empty>
c002608e:	83 c4 10             	add    $0x10,%esp
c0026091:	84 c0                	test   %al,%al
c0026093:	74 b4                	je     c0026049 <signal+0x30>
c0026095:	eb 9b                	jmp    c0026032 <signal+0x19>
c0026097:	83 ec 0c             	sub    $0xc,%esp
c002609a:	68 ac 19 03 c0       	push   $0xc00319ac
c002609f:	68 21 01 03 c0       	push   $0xc0030121
c00260a4:	68 d0 f3 02 c0       	push   $0xc002f3d0
c00260a9:	6a 6b                	push   $0x6b
c00260ab:	68 3b 19 03 c0       	push   $0xc003193b
c00260b0:	e8 72 25 00 00       	call   c0028627 <debug_panic>

c00260b5 <intq_getc>:
{
c00260b5:	56                   	push   %esi
c00260b6:	53                   	push   %ebx
c00260b7:	83 ec 04             	sub    $0x4,%esp
c00260ba:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00260be:	e8 01 b9 ff ff       	call   c00219c4 <intr_get_level>
c00260c3:	85 c0                	test   %eax,%eax
c00260c5:	75 3b                	jne    c0026102 <intq_getc+0x4d>
      wait (q, &q->not_empty);
c00260c7:	8d 73 38             	lea    0x38(%ebx),%esi
  while (intq_empty (q)) 
c00260ca:	83 ec 0c             	sub    $0xc,%esp
c00260cd:	53                   	push   %ebx
c00260ce:	e8 00 fe ff ff       	call   c0025ed3 <intq_empty>
c00260d3:	83 c4 10             	add    $0x10,%esp
c00260d6:	84 c0                	test   %al,%al
c00260d8:	74 64                	je     c002613e <intq_getc+0x89>
      ASSERT (!intr_context ());
c00260da:	e8 43 bb ff ff       	call   c0021c22 <intr_context>
c00260df:	84 c0                	test   %al,%al
c00260e1:	75 3d                	jne    c0026120 <intq_getc+0x6b>
      lock_acquire (&q->lock);
c00260e3:	83 ec 0c             	sub    $0xc,%esp
c00260e6:	53                   	push   %ebx
c00260e7:	e8 91 cd ff ff       	call   c0022e7d <lock_acquire>
      wait (q, &q->not_empty);
c00260ec:	89 f2                	mov    %esi,%edx
c00260ee:	89 d8                	mov    %ebx,%eax
c00260f0:	e8 6d fe ff ff       	call   c0025f62 <wait>
      lock_release (&q->lock);
c00260f5:	89 1c 24             	mov    %ebx,(%esp)
c00260f8:	e8 1d cf ff ff       	call   c002301a <lock_release>
c00260fd:	83 c4 10             	add    $0x10,%esp
c0026100:	eb c8                	jmp    c00260ca <intq_getc+0x15>
  ASSERT (intr_get_level () == INTR_OFF);
c0026102:	83 ec 0c             	sub    $0xc,%esp
c0026105:	68 26 07 03 c0       	push   $0xc0030726
c002610a:	68 21 01 03 c0       	push   $0xc0030121
c002610f:	68 e0 f3 02 c0       	push   $0xc002f3e0
c0026114:	6a 2a                	push   $0x2a
c0026116:	68 3b 19 03 c0       	push   $0xc003193b
c002611b:	e8 07 25 00 00       	call   c0028627 <debug_panic>
      ASSERT (!intr_context ());
c0026120:	83 ec 0c             	sub    $0xc,%esp
c0026123:	68 f0 07 03 c0       	push   $0xc00307f0
c0026128:	68 21 01 03 c0       	push   $0xc0030121
c002612d:	68 e0 f3 02 c0       	push   $0xc002f3e0
c0026132:	6a 2d                	push   $0x2d
c0026134:	68 3b 19 03 c0       	push   $0xc003193b
c0026139:	e8 e9 24 00 00       	call   c0028627 <debug_panic>
  byte = q->buf[q->tail];
c002613e:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
c0026144:	0f b6 74 03 3c       	movzbl 0x3c(%ebx,%eax,1),%esi
  return (pos + 1) % INTQ_BUFSIZE;
c0026149:	40                   	inc    %eax
c002614a:	25 3f 00 00 80       	and    $0x8000003f,%eax
c002614f:	78 18                	js     c0026169 <intq_getc+0xb4>
  q->tail = next (q->tail);
c0026151:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
  signal (q, &q->not_full);
c0026157:	8d 53 34             	lea    0x34(%ebx),%edx
c002615a:	89 d8                	mov    %ebx,%eax
c002615c:	e8 b8 fe ff ff       	call   c0026019 <signal>
}
c0026161:	89 f0                	mov    %esi,%eax
c0026163:	83 c4 04             	add    $0x4,%esp
c0026166:	5b                   	pop    %ebx
c0026167:	5e                   	pop    %esi
c0026168:	c3                   	ret    
  return (pos + 1) % INTQ_BUFSIZE;
c0026169:	48                   	dec    %eax
c002616a:	83 c8 c0             	or     $0xffffffc0,%eax
c002616d:	40                   	inc    %eax
c002616e:	eb e1                	jmp    c0026151 <intq_getc+0x9c>

c0026170 <intq_putc>:
{
c0026170:	57                   	push   %edi
c0026171:	56                   	push   %esi
c0026172:	53                   	push   %ebx
c0026173:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0026177:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c002617b:	e8 44 b8 ff ff       	call   c00219c4 <intr_get_level>
c0026180:	85 c0                	test   %eax,%eax
c0026182:	75 3b                	jne    c00261bf <intq_putc+0x4f>
      wait (q, &q->not_full);
c0026184:	8d 73 34             	lea    0x34(%ebx),%esi
  while (intq_full (q))
c0026187:	83 ec 0c             	sub    $0xc,%esp
c002618a:	53                   	push   %ebx
c002618b:	e8 83 fd ff ff       	call   c0025f13 <intq_full>
c0026190:	83 c4 10             	add    $0x10,%esp
c0026193:	84 c0                	test   %al,%al
c0026195:	74 64                	je     c00261fb <intq_putc+0x8b>
      ASSERT (!intr_context ());
c0026197:	e8 86 ba ff ff       	call   c0021c22 <intr_context>
c002619c:	84 c0                	test   %al,%al
c002619e:	75 3d                	jne    c00261dd <intq_putc+0x6d>
      lock_acquire (&q->lock);
c00261a0:	83 ec 0c             	sub    $0xc,%esp
c00261a3:	53                   	push   %ebx
c00261a4:	e8 d4 cc ff ff       	call   c0022e7d <lock_acquire>
      wait (q, &q->not_full);
c00261a9:	89 f2                	mov    %esi,%edx
c00261ab:	89 d8                	mov    %ebx,%eax
c00261ad:	e8 b0 fd ff ff       	call   c0025f62 <wait>
      lock_release (&q->lock);
c00261b2:	89 1c 24             	mov    %ebx,(%esp)
c00261b5:	e8 60 ce ff ff       	call   c002301a <lock_release>
c00261ba:	83 c4 10             	add    $0x10,%esp
c00261bd:	eb c8                	jmp    c0026187 <intq_putc+0x17>
  ASSERT (intr_get_level () == INTR_OFF);
c00261bf:	83 ec 0c             	sub    $0xc,%esp
c00261c2:	68 26 07 03 c0       	push   $0xc0030726
c00261c7:	68 21 01 03 c0       	push   $0xc0030121
c00261cc:	68 c4 f3 02 c0       	push   $0xc002f3c4
c00261d1:	6a 3f                	push   $0x3f
c00261d3:	68 3b 19 03 c0       	push   $0xc003193b
c00261d8:	e8 4a 24 00 00       	call   c0028627 <debug_panic>
      ASSERT (!intr_context ());
c00261dd:	83 ec 0c             	sub    $0xc,%esp
c00261e0:	68 f0 07 03 c0       	push   $0xc00307f0
c00261e5:	68 21 01 03 c0       	push   $0xc0030121
c00261ea:	68 c4 f3 02 c0       	push   $0xc002f3c4
c00261ef:	6a 42                	push   $0x42
c00261f1:	68 3b 19 03 c0       	push   $0xc003193b
c00261f6:	e8 2c 24 00 00       	call   c0028627 <debug_panic>
  q->buf[q->head] = byte;
c00261fb:	8b 43 7c             	mov    0x7c(%ebx),%eax
c00261fe:	89 f9                	mov    %edi,%ecx
c0026200:	88 4c 03 3c          	mov    %cl,0x3c(%ebx,%eax,1)
  return (pos + 1) % INTQ_BUFSIZE;
c0026204:	40                   	inc    %eax
c0026205:	25 3f 00 00 80       	and    $0x8000003f,%eax
c002620a:	78 11                	js     c002621d <intq_putc+0xad>
  q->head = next (q->head);
c002620c:	89 43 7c             	mov    %eax,0x7c(%ebx)
  signal (q, &q->not_empty);
c002620f:	8d 53 38             	lea    0x38(%ebx),%edx
c0026212:	89 d8                	mov    %ebx,%eax
c0026214:	e8 00 fe ff ff       	call   c0026019 <signal>
}
c0026219:	5b                   	pop    %ebx
c002621a:	5e                   	pop    %esi
c002621b:	5f                   	pop    %edi
c002621c:	c3                   	ret    
  return (pos + 1) % INTQ_BUFSIZE;
c002621d:	48                   	dec    %eax
c002621e:	83 c8 c0             	or     $0xffffffc0,%eax
c0026221:	40                   	inc    %eax
c0026222:	eb e8                	jmp    c002620c <intq_putc+0x9c>

c0026224 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0026224:	55                   	push   %ebp
c0026225:	57                   	push   %edi
c0026226:	56                   	push   %esi
c0026227:	53                   	push   %ebx
c0026228:	83 ec 18             	sub    $0x18,%esp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002622b:	bf 00 00 00 00       	mov    $0x0,%edi
c0026230:	89 f8                	mov    %edi,%eax
c0026232:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026234:	e4 71                	in     $0x71,%al
c0026236:	88 c2                	mov    %al,%dl
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026238:	b0 02                	mov    $0x2,%al
c002623a:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002623c:	e4 71                	in     $0x71,%al
c002623e:	88 04 24             	mov    %al,(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026241:	b0 04                	mov    $0x4,%al
c0026243:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026245:	e4 71                	in     $0x71,%al
c0026247:	88 44 24 13          	mov    %al,0x13(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002624b:	b0 07                	mov    $0x7,%al
c002624d:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002624f:	e4 71                	in     $0x71,%al
c0026251:	89 c5                	mov    %eax,%ebp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026253:	b0 08                	mov    $0x8,%al
c0026255:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026257:	e4 71                	in     $0x71,%al
c0026259:	88 c3                	mov    %al,%bl
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002625b:	b0 09                	mov    $0x9,%al
c002625d:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002625f:	e4 71                	in     $0x71,%al
c0026261:	89 c6                	mov    %eax,%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026263:	89 f8                	mov    %edi,%eax
c0026265:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026267:	e4 71                	in     $0x71,%al

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c0026269:	88 c1                	mov    %al,%cl
c002626b:	c0 e9 04             	shr    $0x4,%cl
c002626e:	0f b6 c9             	movzbl %cl,%ecx
c0026271:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026274:	01 c9                	add    %ecx,%ecx
c0026276:	83 e0 0f             	and    $0xf,%eax
c0026279:	01 c8                	add    %ecx,%eax
c002627b:	88 d1                	mov    %dl,%cl
c002627d:	c0 e9 04             	shr    $0x4,%cl
c0026280:	0f b6 c9             	movzbl %cl,%ecx
c0026283:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026286:	01 c9                	add    %ecx,%ecx
c0026288:	83 e2 0f             	and    $0xf,%edx
c002628b:	01 ca                	add    %ecx,%edx
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c002628d:	39 d0                	cmp    %edx,%eax
c002628f:	75 9f                	jne    c0026230 <rtc_get_time+0xc>
  return (x & 0x0f) + ((x >> 4) * 10);
c0026291:	89 f2                	mov    %esi,%edx
c0026293:	c0 ea 04             	shr    $0x4,%dl
c0026296:	0f b6 d2             	movzbl %dl,%edx
c0026299:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002629c:	01 d2                	add    %edx,%edx
c002629e:	83 e6 0f             	and    $0xf,%esi
c00262a1:	01 d6                	add    %edx,%esi
  if (year < 70)
c00262a3:	83 fe 45             	cmp    $0x45,%esi
c00262a6:	7f 03                	jg     c00262ab <rtc_get_time+0x87>
    year += 100;
c00262a8:	83 c6 64             	add    $0x64,%esi
  return (x & 0x0f) + ((x >> 4) * 10);
c00262ab:	88 da                	mov    %bl,%dl
c00262ad:	c0 ea 04             	shr    $0x4,%dl
c00262b0:	0f b6 d2             	movzbl %dl,%edx
c00262b3:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00262b6:	01 d2                	add    %edx,%edx
c00262b8:	83 e3 0f             	and    $0xf,%ebx
c00262bb:	01 d3                	add    %edx,%ebx
  year -= 70;
c00262bd:	8d 7e ba             	lea    -0x46(%esi),%edi
c00262c0:	89 7c 24 14          	mov    %edi,0x14(%esp)
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c00262c4:	83 ee 47             	sub    $0x47,%esi
c00262c7:	89 f2                	mov    %esi,%edx
c00262c9:	85 f6                	test   %esi,%esi
c00262cb:	0f 88 de 00 00 00    	js     c00263af <rtc_get_time+0x18b>
c00262d1:	c1 fa 02             	sar    $0x2,%edx
c00262d4:	8b 7c 24 14          	mov    0x14(%esp),%edi
c00262d8:	8d 0c ff             	lea    (%edi,%edi,8),%ecx
c00262db:	8d 0c cf             	lea    (%edi,%ecx,8),%ecx
c00262de:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c00262e1:	01 ca                	add    %ecx,%edx
c00262e3:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c00262e6:	8d 0c 8a             	lea    (%edx,%ecx,4),%ecx
c00262e9:	8d 3c ca             	lea    (%edx,%ecx,8),%edi
c00262ec:	c1 e7 02             	shl    $0x2,%edi
c00262ef:	29 d7                	sub    %edx,%edi
c00262f1:	c1 e7 07             	shl    $0x7,%edi
  for (i = 1; i <= mon; i++)
c00262f4:	85 db                	test   %ebx,%ebx
c00262f6:	7e 24                	jle    c002631c <rtc_get_time+0xf8>
c00262f8:	be 01 00 00 00       	mov    $0x1,%esi
    time += days_per_month[i - 1] * 24 * 60 * 60;
c00262fd:	8b 0c b5 1c f4 02 c0 	mov    -0x3ffd0be4(,%esi,4),%ecx
c0026304:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
c0026307:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c002630a:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
c002630d:	c1 e2 02             	shl    $0x2,%edx
c0026310:	29 ca                	sub    %ecx,%edx
c0026312:	c1 e2 07             	shl    $0x7,%edx
c0026315:	01 d7                	add    %edx,%edi
  for (i = 1; i <= mon; i++)
c0026317:	46                   	inc    %esi
c0026318:	39 de                	cmp    %ebx,%esi
c002631a:	7e e1                	jle    c00262fd <rtc_get_time+0xd9>
  if (mon > 2 && year % 4 == 0)
c002631c:	83 fb 02             	cmp    $0x2,%ebx
c002631f:	7e 0d                	jle    c002632e <rtc_get_time+0x10a>
c0026321:	f6 44 24 14 03       	testb  $0x3,0x14(%esp)
c0026326:	75 06                	jne    c002632e <rtc_get_time+0x10a>
    time += 24 * 60 * 60;
c0026328:	81 c7 80 51 01 00    	add    $0x15180,%edi
  return (x & 0x0f) + ((x >> 4) * 10);
c002632e:	8a 5c 24 13          	mov    0x13(%esp),%bl
c0026332:	88 da                	mov    %bl,%dl
c0026334:	c0 ea 04             	shr    $0x4,%dl
c0026337:	0f b6 d2             	movzbl %dl,%edx
c002633a:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c002633d:	01 c9                	add    %ecx,%ecx
c002633f:	89 da                	mov    %ebx,%edx
c0026341:	83 e2 0f             	and    $0xf,%edx
c0026344:	01 ca                	add    %ecx,%edx
  time += hour * 60 * 60;
c0026346:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
c0026349:	01 d1                	add    %edx,%ecx
c002634b:	01 c9                	add    %ecx,%ecx
c002634d:	01 d1                	add    %edx,%ecx
c002634f:	c1 e1 05             	shl    $0x5,%ecx
c0026352:	01 d1                	add    %edx,%ecx
c0026354:	c1 e1 04             	shl    $0x4,%ecx
  return (x & 0x0f) + ((x >> 4) * 10);
c0026357:	8a 14 24             	mov    (%esp),%dl
c002635a:	c0 ea 04             	shr    $0x4,%dl
c002635d:	0f b6 d2             	movzbl %dl,%edx
c0026360:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026363:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
c0026366:	8b 14 24             	mov    (%esp),%edx
c0026369:	83 e2 0f             	and    $0xf,%edx
c002636c:	01 da                	add    %ebx,%edx
  time += min * 60;
c002636e:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
c0026371:	01 da                	add    %ebx,%edx
c0026373:	8d 14 92             	lea    (%edx,%edx,4),%edx
  time += sec;
c0026376:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c0026379:	01 d0                	add    %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c002637b:	89 ea                	mov    %ebp,%edx
c002637d:	c0 ea 04             	shr    $0x4,%dl
c0026380:	0f b6 d2             	movzbl %dl,%edx
c0026383:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026386:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
c0026389:	89 ea                	mov    %ebp,%edx
c002638b:	83 e2 0f             	and    $0xf,%edx
  time += (mday - 1) * 24 * 60 * 60;
c002638e:	8d 4c 11 ff          	lea    -0x1(%ecx,%edx,1),%ecx
c0026392:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
c0026395:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c0026398:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
c002639b:	c1 e2 02             	shl    $0x2,%edx
c002639e:	29 ca                	sub    %ecx,%edx
c00263a0:	c1 e2 07             	shl    $0x7,%edx
  time += sec;
c00263a3:	01 d0                	add    %edx,%eax
c00263a5:	01 f8                	add    %edi,%eax
}
c00263a7:	83 c4 18             	add    $0x18,%esp
c00263aa:	5b                   	pop    %ebx
c00263ab:	5e                   	pop    %esi
c00263ac:	5f                   	pop    %edi
c00263ad:	5d                   	pop    %ebp
c00263ae:	c3                   	ret    
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c00263af:	8d 56 03             	lea    0x3(%esi),%edx
c00263b2:	e9 1a ff ff ff       	jmp    c00262d1 <rtc_get_time+0xad>

c00263b7 <shutdown_configure>:
/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
  how = type;
c00263b7:	8b 44 24 04          	mov    0x4(%esp),%eax
c00263bb:	a3 c4 cc 03 c0       	mov    %eax,0xc003ccc4
c00263c0:	c3                   	ret    

c00263c1 <shutdown_reboot>:
}

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c00263c1:	56                   	push   %esi
c00263c2:	53                   	push   %ebx
c00263c3:	83 ec 10             	sub    $0x10,%esp
  printf ("Rebooting...\n");
c00263c6:	68 07 1a 03 c0       	push   $0xc0031a07
c00263cb:	e8 3e 3d 00 00       	call   c002a10e <puts>
c00263d0:	83 c4 10             	add    $0x10,%esp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00263d3:	be fe ff ff ff       	mov    $0xfffffffe,%esi
c00263d8:	eb 1f                	jmp    c00263f9 <shutdown_reboot+0x38>
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
          timer_udelay (2);
        }

      timer_udelay (50);
c00263da:	83 ec 08             	sub    $0x8,%esp
c00263dd:	6a 00                	push   $0x0
c00263df:	6a 32                	push   $0x32
c00263e1:	e8 70 df ff ff       	call   c0024356 <timer_udelay>
c00263e6:	89 f0                	mov    %esi,%eax
c00263e8:	e6 64                	out    %al,$0x64

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
      timer_udelay (50);
c00263ea:	83 c4 08             	add    $0x8,%esp
c00263ed:	6a 00                	push   $0x0
c00263ef:	6a 32                	push   $0x32
c00263f1:	e8 60 df ff ff       	call   c0024356 <timer_udelay>
    {
c00263f6:	83 c4 10             	add    $0x10,%esp
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00263f9:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c00263fb:	a8 02                	test   $0x2,%al
c00263fd:	74 db                	je     c00263da <shutdown_reboot+0x19>
          timer_udelay (2);
c00263ff:	83 ec 08             	sub    $0x8,%esp
c0026402:	6a 00                	push   $0x0
c0026404:	6a 02                	push   $0x2
c0026406:	e8 4b df ff ff       	call   c0024356 <timer_udelay>
c002640b:	83 c4 10             	add    $0x10,%esp
c002640e:	bb ff ff 00 00       	mov    $0xffff,%ebx
c0026413:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026415:	a8 02                	test   $0x2,%al
c0026417:	74 c1                	je     c00263da <shutdown_reboot+0x19>
          timer_udelay (2);
c0026419:	83 ec 08             	sub    $0x8,%esp
c002641c:	6a 00                	push   $0x0
c002641e:	6a 02                	push   $0x2
c0026420:	e8 31 df ff ff       	call   c0024356 <timer_udelay>
      for (i = 0; i < 0x10000; i++)
c0026425:	83 c4 10             	add    $0x10,%esp
c0026428:	4b                   	dec    %ebx
c0026429:	75 e8                	jne    c0026413 <shutdown_reboot+0x52>
c002642b:	eb ad                	jmp    c00263da <shutdown_reboot+0x19>

c002642d <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c002642d:	57                   	push   %edi
c002642e:	56                   	push   %esi
c002642f:	83 ec 14             	sub    $0x14,%esp
  const char s[] = "Shutdown";
c0026432:	8d 7c 24 07          	lea    0x7(%esp),%edi
c0026436:	be 35 1a 03 c0       	mov    $0xc0031a35,%esi
c002643b:	b9 09 00 00 00       	mov    $0x9,%ecx
c0026440:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  const char *p;

#ifdef FILESYS
  filesys_done ();
c0026442:	e8 54 5d 00 00       	call   c002c19b <filesys_done>

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
  timer_print_stats ();
c0026447:	e8 3c df ff ff       	call   c0024388 <timer_print_stats>
  thread_print_stats ();
c002644c:	e8 36 a8 ff ff       	call   c0020c87 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
c0026451:	e8 e4 e8 ff ff       	call   c0024d3a <block_print_stats>
#endif
  console_print_stats ();
c0026456:	e8 62 3c 00 00       	call   c002a0bd <console_print_stats>
  kbd_print_stats ();
c002645b:	e8 39 e1 ff ff       	call   c0024599 <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
c0026460:	e8 25 50 00 00       	call   c002b48a <exception_print_stats>
  printf ("Powering off...\n");
c0026465:	83 ec 0c             	sub    $0xc,%esp
c0026468:	68 14 1a 03 c0       	push   $0xc0031a14
c002646d:	e8 9c 3c 00 00       	call   c002a10e <puts>
  serial_flush ();
c0026472:	e8 09 e6 ff ff       	call   c0024a80 <serial_flush>
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026477:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c002647c:	b8 00 20 00 00       	mov    $0x2000,%eax
c0026481:	66 ef                	out    %ax,(%dx)
  for (p = s; *p != '\0'; p++)
c0026483:	8a 44 24 17          	mov    0x17(%esp),%al
c0026487:	83 c4 10             	add    $0x10,%esp
c002648a:	84 c0                	test   %al,%al
c002648c:	74 11                	je     c002649f <shutdown_power_off+0x72>
c002648e:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026492:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c0026497:	ee                   	out    %al,(%dx)
c0026498:	41                   	inc    %ecx
c0026499:	8a 01                	mov    (%ecx),%al
c002649b:	84 c0                	test   %al,%al
c002649d:	75 f8                	jne    c0026497 <shutdown_power_off+0x6a>
c002649f:	ba 01 05 00 00       	mov    $0x501,%edx
c00264a4:	b0 31                	mov    $0x31,%al
c00264a6:	ee                   	out    %al,(%dx)
  asm volatile ("cli; hlt" : : : "memory");
c00264a7:	fa                   	cli    
c00264a8:	f4                   	hlt    
  printf ("still running...\n");
c00264a9:	83 ec 0c             	sub    $0xc,%esp
c00264ac:	68 24 1a 03 c0       	push   $0xc0031a24
c00264b1:	e8 58 3c 00 00       	call   c002a10e <puts>
c00264b6:	83 c4 10             	add    $0x10,%esp
c00264b9:	eb fe                	jmp    c00264b9 <shutdown_power_off+0x8c>

c00264bb <shutdown>:
{
c00264bb:	83 ec 0c             	sub    $0xc,%esp
  switch (how)
c00264be:	a1 c4 cc 03 c0       	mov    0xc003ccc4,%eax
c00264c3:	83 f8 01             	cmp    $0x1,%eax
c00264c6:	74 09                	je     c00264d1 <shutdown+0x16>
c00264c8:	83 f8 02             	cmp    $0x2,%eax
c00264cb:	74 09                	je     c00264d6 <shutdown+0x1b>
}
c00264cd:	83 c4 0c             	add    $0xc,%esp
c00264d0:	c3                   	ret    
      shutdown_power_off ();
c00264d1:	e8 57 ff ff ff       	call   c002642d <shutdown_power_off>
      shutdown_reboot ();
c00264d6:	e8 e6 fe ff ff       	call   c00263c1 <shutdown_reboot>

c00264db <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c00264db:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_disable ();
c00264de:	e8 1e b5 ff ff       	call   c0021a01 <intr_disable>
c00264e3:	89 c2                	mov    %eax,%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00264e5:	e4 61                	in     $0x61,%al
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00264e7:	83 e0 fc             	and    $0xfffffffc,%eax
c00264ea:	e6 61                	out    %al,$0x61
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
  intr_set_level (old_level);
c00264ec:	83 ec 0c             	sub    $0xc,%esp
c00264ef:	52                   	push   %edx
c00264f0:	e8 13 b5 ff ff       	call   c0021a08 <intr_set_level>
}
c00264f5:	83 c4 1c             	add    $0x1c,%esp
c00264f8:	c3                   	ret    

c00264f9 <speaker_on>:
{
c00264f9:	56                   	push   %esi
c00264fa:	53                   	push   %ebx
c00264fb:	83 ec 04             	sub    $0x4,%esp
c00264fe:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (frequency >= 20 && frequency <= 20000)
c0026502:	8d 43 ec             	lea    -0x14(%ebx),%eax
c0026505:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c002650a:	76 0b                	jbe    c0026517 <speaker_on+0x1e>
      speaker_off ();
c002650c:	e8 ca ff ff ff       	call   c00264db <speaker_off>
}
c0026511:	83 c4 04             	add    $0x4,%esp
c0026514:	5b                   	pop    %ebx
c0026515:	5e                   	pop    %esi
c0026516:	c3                   	ret    
      enum intr_level old_level = intr_disable ();
c0026517:	e8 e5 b4 ff ff       	call   c0021a01 <intr_disable>
c002651c:	89 c6                	mov    %eax,%esi
      pit_configure_channel (2, 3, frequency);
c002651e:	83 ec 04             	sub    $0x4,%esp
c0026521:	53                   	push   %ebx
c0026522:	6a 03                	push   $0x3
c0026524:	6a 02                	push   $0x2
c0026526:	e8 86 d9 ff ff       	call   c0023eb1 <pit_configure_channel>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002652b:	e4 61                	in     $0x61,%al
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c002652d:	83 c8 03             	or     $0x3,%eax
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026530:	e6 61                	out    %al,$0x61
      intr_set_level (old_level);
c0026532:	89 34 24             	mov    %esi,(%esp)
c0026535:	e8 ce b4 ff ff       	call   c0021a08 <intr_set_level>
c002653a:	83 c4 10             	add    $0x10,%esp
c002653d:	eb d2                	jmp    c0026511 <speaker_on+0x18>

c002653f <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c002653f:	83 ec 0c             	sub    $0xc,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026542:	e8 7d b4 ff ff       	call   c00219c4 <intr_get_level>
c0026547:	83 f8 01             	cmp    $0x1,%eax
c002654a:	74 04                	je     c0026550 <speaker_beep+0x11>
    {
      speaker_on (440);
      timer_msleep (250);
      speaker_off ();
    }
}
c002654c:	83 c4 0c             	add    $0xc,%esp
c002654f:	c3                   	ret    
      speaker_on (440);
c0026550:	83 ec 0c             	sub    $0xc,%esp
c0026553:	68 b8 01 00 00       	push   $0x1b8
c0026558:	e8 9c ff ff ff       	call   c00264f9 <speaker_on>
      timer_msleep (250);
c002655d:	83 c4 08             	add    $0x8,%esp
c0026560:	6a 00                	push   $0x0
c0026562:	68 fa 00 00 00       	push   $0xfa
c0026567:	e8 86 dd ff ff       	call   c00242f2 <timer_msleep>
      speaker_off ();
c002656c:	e8 6a ff ff ff       	call   c00264db <speaker_off>
c0026571:	83 c4 10             	add    $0x10,%esp
}
c0026574:	eb d6                	jmp    c002654c <speaker_beep+0xd>

c0026576 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026576:	55                   	push   %ebp
c0026577:	89 e5                	mov    %esp,%ebp
c0026579:	53                   	push   %ebx
c002657a:	83 ec 0c             	sub    $0xc,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c002657d:	ff 75 04             	pushl  0x4(%ebp)
c0026580:	68 3e 1a 03 c0       	push   $0xc0031a3e
c0026585:	e8 ef 05 00 00       	call   c0026b79 <printf>
  for (frame = __builtin_frame_address (1);
c002658a:	8b 5d 00             	mov    0x0(%ebp),%ebx
c002658d:	83 c4 10             	add    $0x10,%esp
c0026590:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c0026596:	76 27                	jbe    c00265bf <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026598:	83 3b 00             	cmpl   $0x0,(%ebx)
c002659b:	74 22                	je     c00265bf <debug_backtrace+0x49>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c002659d:	83 ec 08             	sub    $0x8,%esp
c00265a0:	ff 73 04             	pushl  0x4(%ebx)
c00265a3:	68 49 1a 03 c0       	push   $0xc0031a49
c00265a8:	e8 cc 05 00 00       	call   c0026b79 <printf>
       frame = frame[0]) 
c00265ad:	8b 1b                	mov    (%ebx),%ebx
  for (frame = __builtin_frame_address (1);
c00265af:	83 c4 10             	add    $0x10,%esp
c00265b2:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c00265b8:	76 05                	jbe    c00265bf <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c00265ba:	83 3b 00             	cmpl   $0x0,(%ebx)
c00265bd:	75 de                	jne    c002659d <debug_backtrace+0x27>
  printf (".\n");
c00265bf:	83 ec 0c             	sub    $0xc,%esp
c00265c2:	68 d3 15 03 c0       	push   $0xc00315d3
c00265c7:	e8 42 3b 00 00       	call   c002a10e <puts>

  if (!explained) 
c00265cc:	83 c4 10             	add    $0x10,%esp
c00265cf:	80 3d c8 cc 03 c0 00 	cmpb   $0x0,0xc003ccc8
c00265d6:	74 05                	je     c00265dd <debug_backtrace+0x67>
      explained = true;
      printf ("The `backtrace' program can make call stacks useful.\n"
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c00265d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00265db:	c9                   	leave  
c00265dc:	c3                   	ret    
      explained = true;
c00265dd:	c6 05 c8 cc 03 c0 01 	movb   $0x1,0xc003ccc8
      printf ("The `backtrace' program can make call stacks useful.\n"
c00265e4:	83 ec 0c             	sub    $0xc,%esp
c00265e7:	68 50 1a 03 c0       	push   $0xc0031a50
c00265ec:	e8 1d 3b 00 00       	call   c002a10e <puts>
c00265f1:	83 c4 10             	add    $0x10,%esp
}
c00265f4:	eb e2                	jmp    c00265d8 <debug_backtrace+0x62>

c00265f6 <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c00265f6:	56                   	push   %esi
c00265f7:	53                   	push   %ebx
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c00265f8:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c00265fd:	88 80 00 cd 03 c0    	mov    %al,-0x3ffc3300(%eax)
  for (i = 0; i < 256; i++) 
c0026603:	40                   	inc    %eax
c0026604:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026609:	75 f2                	jne    c00265fd <random_init+0x7>
c002660b:	be 00 00 00 00       	mov    $0x0,%esi
c0026610:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = j = 0; i < 256; i++) 
    {
      j += s[i] + seedp[i % sizeof seed];
c0026615:	89 c1                	mov    %eax,%ecx
c0026617:	83 e1 03             	and    $0x3,%ecx
c002661a:	8a 98 00 cd 03 c0    	mov    -0x3ffc3300(%eax),%bl
c0026620:	88 da                	mov    %bl,%dl
c0026622:	02 54 0c 0c          	add    0xc(%esp,%ecx,1),%dl
c0026626:	88 d1                	mov    %dl,%cl
c0026628:	01 ce                	add    %ecx,%esi
      swap_byte (s + i, s + j);
c002662a:	89 f2                	mov    %esi,%edx
c002662c:	0f b6 ca             	movzbl %dl,%ecx
  *a = *b;
c002662f:	8a 91 00 cd 03 c0    	mov    -0x3ffc3300(%ecx),%dl
c0026635:	88 90 00 cd 03 c0    	mov    %dl,-0x3ffc3300(%eax)
  *b = t;
c002663b:	88 99 00 cd 03 c0    	mov    %bl,-0x3ffc3300(%ecx)
  for (i = j = 0; i < 256; i++) 
c0026641:	40                   	inc    %eax
c0026642:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026647:	75 cc                	jne    c0026615 <random_init+0x1f>
    }

  s_i = s_j = 0;
c0026649:	c6 05 e1 cc 03 c0 00 	movb   $0x0,0xc003cce1
c0026650:	c6 05 e2 cc 03 c0 00 	movb   $0x0,0xc003cce2
  inited = true;
c0026657:	c6 05 e0 cc 03 c0 01 	movb   $0x1,0xc003cce0
}
c002665e:	5b                   	pop    %ebx
c002665f:	5e                   	pop    %esi
c0026660:	c3                   	ret    

c0026661 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026661:	55                   	push   %ebp
c0026662:	57                   	push   %edi
c0026663:	56                   	push   %esi
c0026664:	53                   	push   %ebx
c0026665:	83 ec 04             	sub    $0x4,%esp
c0026668:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint8_t *buf;

  if (!inited)
c002666c:	80 3d e0 cc 03 c0 00 	cmpb   $0x0,0xc003cce0
c0026673:	0f 84 8c 00 00 00    	je     c0026705 <random_bytes+0xa4>
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c0026679:	8d 6f ff             	lea    -0x1(%edi),%ebp
c002667c:	85 ff                	test   %edi,%edi
c002667e:	74 7d                	je     c00266fd <random_bytes+0x9c>
c0026680:	0f b6 35 e1 cc 03 c0 	movzbl 0xc003cce1,%esi
c0026687:	a0 e2 cc 03 c0       	mov    0xc003cce2,%al
c002668c:	40                   	inc    %eax
c002668d:	88 44 24 03          	mov    %al,0x3(%esp)
c0026691:	03 7c 24 18          	add    0x18(%esp),%edi
c0026695:	88 44 24 01          	mov    %al,0x1(%esp)
c0026699:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    {
      uint8_t s_k;
      
      s_i++;
      s_j += s[s_i];
c002669d:	0f b6 54 24 01       	movzbl 0x1(%esp),%edx
c00266a2:	89 f3                	mov    %esi,%ebx
c00266a4:	02 9a 00 cd 03 c0    	add    -0x3ffc3300(%edx),%bl
c00266aa:	89 de                	mov    %ebx,%esi
      swap_byte (s + s_i, s + s_j);
c00266ac:	0f b6 c3             	movzbl %bl,%eax
  uint8_t t = *a;
c00266af:	8a 9a 00 cd 03 c0    	mov    -0x3ffc3300(%edx),%bl
c00266b5:	88 5c 24 02          	mov    %bl,0x2(%esp)
  *a = *b;
c00266b9:	8a 98 00 cd 03 c0    	mov    -0x3ffc3300(%eax),%bl
c00266bf:	88 9a 00 cd 03 c0    	mov    %bl,-0x3ffc3300(%edx)
  *b = t;
c00266c5:	8a 5c 24 02          	mov    0x2(%esp),%bl
c00266c9:	88 98 00 cd 03 c0    	mov    %bl,-0x3ffc3300(%eax)

      s_k = s[s_i] + s[s_j];
c00266cf:	88 d8                	mov    %bl,%al
c00266d1:	02 82 00 cd 03 c0    	add    -0x3ffc3300(%edx),%al
      *buf = s[s_k];
c00266d7:	0f b6 c0             	movzbl %al,%eax
c00266da:	8a 90 00 cd 03 c0    	mov    -0x3ffc3300(%eax),%dl
c00266e0:	88 11                	mov    %dl,(%ecx)
  for (buf = buf_; size-- > 0; buf++)
c00266e2:	41                   	inc    %ecx
c00266e3:	fe 44 24 01          	incb   0x1(%esp)
c00266e7:	39 f9                	cmp    %edi,%ecx
c00266e9:	75 b2                	jne    c002669d <random_bytes+0x3c>
c00266eb:	8a 44 24 03          	mov    0x3(%esp),%al
c00266ef:	01 e8                	add    %ebp,%eax
c00266f1:	a2 e2 cc 03 c0       	mov    %al,0xc003cce2
c00266f6:	89 f0                	mov    %esi,%eax
c00266f8:	a2 e1 cc 03 c0       	mov    %al,0xc003cce1
    }
}
c00266fd:	83 c4 04             	add    $0x4,%esp
c0026700:	5b                   	pop    %ebx
c0026701:	5e                   	pop    %esi
c0026702:	5f                   	pop    %edi
c0026703:	5d                   	pop    %ebp
c0026704:	c3                   	ret    
    random_init (0);
c0026705:	6a 00                	push   $0x0
c0026707:	e8 ea fe ff ff       	call   c00265f6 <random_init>
c002670c:	83 c4 04             	add    $0x4,%esp
c002670f:	e9 65 ff ff ff       	jmp    c0026679 <random_bytes+0x18>

c0026714 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0026714:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0026717:	6a 04                	push   $0x4
c0026719:	8d 44 24 10          	lea    0x10(%esp),%eax
c002671d:	50                   	push   %eax
c002671e:	e8 3e ff ff ff       	call   c0026661 <random_bytes>
  return ul;
}
c0026723:	8b 44 24 14          	mov    0x14(%esp),%eax
c0026727:	83 c4 18             	add    $0x18,%esp
c002672a:	c3                   	ret    

c002672b <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c002672b:	53                   	push   %ebx
c002672c:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0026730:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c0026734:	8b 50 04             	mov    0x4(%eax),%edx
c0026737:	8d 4a 01             	lea    0x1(%edx),%ecx
c002673a:	89 48 04             	mov    %ecx,0x4(%eax)
c002673d:	3b 50 08             	cmp    0x8(%eax),%edx
c0026740:	7d 09                	jge    c002674b <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c0026742:	8b 10                	mov    (%eax),%edx
c0026744:	8d 4a 01             	lea    0x1(%edx),%ecx
c0026747:	89 08                	mov    %ecx,(%eax)
c0026749:	88 1a                	mov    %bl,(%edx)
}
c002674b:	5b                   	pop    %ebx
c002674c:	c3                   	ret    

c002674d <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c002674d:	55                   	push   %ebp
c002674e:	57                   	push   %edi
c002674f:	56                   	push   %esi
c0026750:	53                   	push   %ebx
c0026751:	83 ec 0c             	sub    $0xc,%esp
c0026754:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c0026758:	85 d2                	test   %edx,%edx
c002675a:	74 18                	je     c0026774 <output_dup+0x27>
c002675c:	8d 5a ff             	lea    -0x1(%edx),%ebx
c002675f:	89 cd                	mov    %ecx,%ebp
    output (ch, aux);
c0026761:	0f be f0             	movsbl %al,%esi
c0026764:	83 ec 08             	sub    $0x8,%esp
c0026767:	57                   	push   %edi
c0026768:	56                   	push   %esi
c0026769:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c002676b:	4b                   	dec    %ebx
c002676c:	83 c4 10             	add    $0x10,%esp
c002676f:	83 fb ff             	cmp    $0xffffffff,%ebx
c0026772:	75 f0                	jne    c0026764 <output_dup+0x17>
}
c0026774:	83 c4 0c             	add    $0xc,%esp
c0026777:	5b                   	pop    %ebx
c0026778:	5e                   	pop    %esi
c0026779:	5f                   	pop    %edi
c002677a:	5d                   	pop    %ebp
c002677b:	c3                   	ret    

c002677c <format_integer>:
{
c002677c:	55                   	push   %ebp
c002677d:	57                   	push   %edi
c002677e:	56                   	push   %esi
c002677f:	53                   	push   %ebx
c0026780:	83 ec 7c             	sub    $0x7c,%esp
c0026783:	89 c6                	mov    %eax,%esi
c0026785:	89 d7                	mov    %edx,%edi
c0026787:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  if (is_signed) 
c002678e:	84 c9                	test   %cl,%cl
c0026790:	74 42                	je     c00267d4 <format_integer+0x58>
      if (c->flags & PLUS)
c0026792:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c0026799:	8b 11                	mov    (%ecx),%edx
c002679b:	f6 c2 02             	test   $0x2,%dl
c002679e:	74 10                	je     c00267b0 <format_integer+0x34>
        sign = negative ? '-' : '+';
c00267a0:	3c 01                	cmp    $0x1,%al
c00267a2:	19 c0                	sbb    %eax,%eax
c00267a4:	83 e0 fe             	and    $0xfffffffe,%eax
c00267a7:	83 c0 2d             	add    $0x2d,%eax
c00267aa:	89 44 24 24          	mov    %eax,0x24(%esp)
c00267ae:	eb 2c                	jmp    c00267dc <format_integer+0x60>
      else if (c->flags & SPACE)
c00267b0:	f6 c2 04             	test   $0x4,%dl
c00267b3:	74 10                	je     c00267c5 <format_integer+0x49>
        sign = negative ? '-' : ' ';
c00267b5:	3c 01                	cmp    $0x1,%al
c00267b7:	19 c0                	sbb    %eax,%eax
c00267b9:	83 e0 f3             	and    $0xfffffff3,%eax
c00267bc:	83 c0 2d             	add    $0x2d,%eax
c00267bf:	89 44 24 24          	mov    %eax,0x24(%esp)
c00267c3:	eb 17                	jmp    c00267dc <format_integer+0x60>
        sign = '-';
c00267c5:	3c 01                	cmp    $0x1,%al
c00267c7:	19 c0                	sbb    %eax,%eax
c00267c9:	f7 d0                	not    %eax
c00267cb:	83 e0 2d             	and    $0x2d,%eax
c00267ce:	89 44 24 24          	mov    %eax,0x24(%esp)
c00267d2:	eb 08                	jmp    c00267dc <format_integer+0x60>
  sign = 0;
c00267d4:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c00267db:	00 
  x = (c->flags & POUND) && value ? b->x : 0;
c00267dc:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00267e3:	8b 00                	mov    (%eax),%eax
c00267e5:	89 44 24 28          	mov    %eax,0x28(%esp)
c00267e9:	83 e0 08             	and    $0x8,%eax
c00267ec:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c00267f0:	74 1a                	je     c002680c <format_integer+0x90>
c00267f2:	89 fa                	mov    %edi,%edx
c00267f4:	09 f2                	or     %esi,%edx
c00267f6:	0f 84 cc 00 00 00    	je     c00268c8 <format_integer+0x14c>
c00267fc:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026803:	8b 40 08             	mov    0x8(%eax),%eax
c0026806:	89 44 24 20          	mov    %eax,0x20(%esp)
c002680a:	eb 12                	jmp    c002681e <format_integer+0xa2>
  while (value > 0) 
c002680c:	89 fa                	mov    %edi,%edx
c002680e:	09 f2                	or     %esi,%edx
c0026810:	0f 84 c3 01 00 00    	je     c00269d9 <format_integer+0x25d>
  x = (c->flags & POUND) && value ? b->x : 0;
c0026816:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c002681d:	00 
      *cp++ = b->digits[value % b->base];
c002681e:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026825:	8b 40 04             	mov    0x4(%eax),%eax
c0026828:	89 44 24 18          	mov    %eax,0x18(%esp)
c002682c:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026833:	8b 00                	mov    (%eax),%eax
c0026835:	89 44 24 08          	mov    %eax,0x8(%esp)
c0026839:	89 c1                	mov    %eax,%ecx
c002683b:	c1 f9 1f             	sar    $0x1f,%ecx
c002683e:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0026842:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0026849:	00 
c002684a:	8d 5c 24 30          	lea    0x30(%esp),%ebx
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c002684e:	8b 44 24 28          	mov    0x28(%esp),%eax
c0026852:	83 e0 20             	and    $0x20,%eax
c0026855:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0026859:	eb 3f                	jmp    c002689a <format_integer+0x11e>
c002685b:	89 dd                	mov    %ebx,%ebp
      *cp++ = b->digits[value % b->base];
c002685d:	8d 5d 01             	lea    0x1(%ebp),%ebx
c0026860:	ff 74 24 0c          	pushl  0xc(%esp)
c0026864:	ff 74 24 0c          	pushl  0xc(%esp)
c0026868:	57                   	push   %edi
c0026869:	56                   	push   %esi
c002686a:	e8 35 18 00 00       	call   c00280a4 <__umoddi3>
c002686f:	83 c4 10             	add    $0x10,%esp
c0026872:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c0026876:	8a 04 01             	mov    (%ecx,%eax,1),%al
c0026879:	88 45 00             	mov    %al,0x0(%ebp)
      value /= b->base;
c002687c:	ff 74 24 0c          	pushl  0xc(%esp)
c0026880:	ff 74 24 0c          	pushl  0xc(%esp)
c0026884:	57                   	push   %edi
c0026885:	56                   	push   %esi
c0026886:	e8 fd 17 00 00       	call   c0028088 <__udivdi3>
c002688b:	83 c4 10             	add    $0x10,%esp
c002688e:	89 c6                	mov    %eax,%esi
c0026890:	89 d7                	mov    %edx,%edi
      digit_cnt++;
c0026892:	ff 44 24 14          	incl   0x14(%esp)
  while (value > 0) 
c0026896:	09 c2                	or     %eax,%edx
c0026898:	74 3a                	je     c00268d4 <format_integer+0x158>
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c002689a:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c002689f:	74 ba                	je     c002685b <format_integer+0xdf>
c00268a1:	8b 44 24 14          	mov    0x14(%esp),%eax
c00268a5:	85 c0                	test   %eax,%eax
c00268a7:	7e 17                	jle    c00268c0 <format_integer+0x144>
c00268a9:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c00268b0:	99                   	cltd   
c00268b1:	f7 79 0c             	idivl  0xc(%ecx)
c00268b4:	85 d2                	test   %edx,%edx
c00268b6:	75 0c                	jne    c00268c4 <format_integer+0x148>
        *cp++ = ',';
c00268b8:	8d 6b 01             	lea    0x1(%ebx),%ebp
c00268bb:	c6 03 2c             	movb   $0x2c,(%ebx)
c00268be:	eb 9d                	jmp    c002685d <format_integer+0xe1>
c00268c0:	89 dd                	mov    %ebx,%ebp
c00268c2:	eb 99                	jmp    c002685d <format_integer+0xe1>
c00268c4:	89 dd                	mov    %ebx,%ebp
c00268c6:	eb 95                	jmp    c002685d <format_integer+0xe1>
  x = (c->flags & POUND) && value ? b->x : 0;
c00268c8:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c00268cf:	00 
  cp = buf;
c00268d0:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  precision = c->precision < 0 ? 1 : c->precision;
c00268d4:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00268db:	8b 50 08             	mov    0x8(%eax),%edx
c00268de:	85 d2                	test   %edx,%edx
c00268e0:	0f 88 04 01 00 00    	js     c00269ea <format_integer+0x26e>
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00268e6:	8d 7c 24 30          	lea    0x30(%esp),%edi
c00268ea:	89 d8                	mov    %ebx,%eax
c00268ec:	29 f8                	sub    %edi,%eax
c00268ee:	39 c2                	cmp    %eax,%edx
c00268f0:	7e 21                	jle    c0026913 <format_integer+0x197>
c00268f2:	8d 44 24 6f          	lea    0x6f(%esp),%eax
c00268f6:	39 c3                	cmp    %eax,%ebx
c00268f8:	73 19                	jae    c0026913 <format_integer+0x197>
c00268fa:	89 f9                	mov    %edi,%ecx
c00268fc:	89 c6                	mov    %eax,%esi
    *cp++ = '0';
c00268fe:	43                   	inc    %ebx
c00268ff:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0026903:	89 d8                	mov    %ebx,%eax
c0026905:	29 c8                	sub    %ecx,%eax
c0026907:	39 d0                	cmp    %edx,%eax
c0026909:	7d 08                	jge    c0026913 <format_integer+0x197>
c002690b:	39 f3                	cmp    %esi,%ebx
c002690d:	75 ef                	jne    c00268fe <format_integer+0x182>
    *cp++ = '0';
c002690f:	8d 5c 24 6f          	lea    0x6f(%esp),%ebx
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0026913:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0026918:	74 10                	je     c002692a <format_integer+0x1ae>
c002691a:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026921:	83 38 08             	cmpl   $0x8,(%eax)
c0026924:	0f 84 ca 00 00 00    	je     c00269f4 <format_integer+0x278>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c002692a:	29 df                	sub    %ebx,%edi
c002692c:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c0026933:	89 f8                	mov    %edi,%eax
c0026935:	03 41 04             	add    0x4(%ecx),%eax
c0026938:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c002693d:	0f 95 c2             	setne  %dl
c0026940:	0f b6 d2             	movzbl %dl,%edx
c0026943:	d1 e2                	shl    %edx
c0026945:	29 d0                	sub    %edx,%eax
c0026947:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c002694c:	0f 95 c2             	setne  %dl
c002694f:	0f b6 d2             	movzbl %dl,%edx
c0026952:	29 d0                	sub    %edx,%eax
c0026954:	89 c7                	mov    %eax,%edi
c0026956:	85 c0                	test   %eax,%eax
c0026958:	0f 88 b3 00 00 00    	js     c0026a11 <format_integer+0x295>
  if ((c->flags & (MINUS | ZERO)) == 0)
c002695e:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c0026963:	0f 84 b2 00 00 00    	je     c0026a1b <format_integer+0x29f>
  if (sign)
c0026969:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c002696e:	0f 85 cc 00 00 00    	jne    c0026a40 <format_integer+0x2c4>
  if (x) 
c0026974:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0026979:	0f 85 de 00 00 00    	jne    c0026a5d <format_integer+0x2e1>
  if (c->flags & ZERO)
c002697f:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0026986:	f6 00 10             	testb  $0x10,(%eax)
c0026989:	0f 85 00 01 00 00    	jne    c0026a8f <format_integer+0x313>
  while (cp > buf)
c002698f:	8d 44 24 30          	lea    0x30(%esp),%eax
c0026993:	39 c3                	cmp    %eax,%ebx
c0026995:	76 2a                	jbe    c00269c1 <format_integer+0x245>
c0026997:	89 c6                	mov    %eax,%esi
c0026999:	89 7c 24 08          	mov    %edi,0x8(%esp)
c002699d:	8b bc 24 9c 00 00 00 	mov    0x9c(%esp),%edi
c00269a4:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
    output (*--cp, aux);
c00269ab:	4b                   	dec    %ebx
c00269ac:	83 ec 08             	sub    $0x8,%esp
c00269af:	55                   	push   %ebp
c00269b0:	0f be 03             	movsbl (%ebx),%eax
c00269b3:	50                   	push   %eax
c00269b4:	ff d7                	call   *%edi
  while (cp > buf)
c00269b6:	83 c4 10             	add    $0x10,%esp
c00269b9:	39 f3                	cmp    %esi,%ebx
c00269bb:	75 ee                	jne    c00269ab <format_integer+0x22f>
c00269bd:	8b 7c 24 08          	mov    0x8(%esp),%edi
  if (c->flags & MINUS)
c00269c1:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00269c8:	f6 00 01             	testb  $0x1,(%eax)
c00269cb:	0f 85 e3 00 00 00    	jne    c0026ab4 <format_integer+0x338>
}
c00269d1:	83 c4 7c             	add    $0x7c,%esp
c00269d4:	5b                   	pop    %ebx
c00269d5:	5e                   	pop    %esi
c00269d6:	5f                   	pop    %edi
c00269d7:	5d                   	pop    %ebp
c00269d8:	c3                   	ret    
  x = (c->flags & POUND) && value ? b->x : 0;
c00269d9:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c00269e0:	00 
  cp = buf;
c00269e1:	8d 5c 24 30          	lea    0x30(%esp),%ebx
c00269e5:	e9 ea fe ff ff       	jmp    c00268d4 <format_integer+0x158>
  precision = c->precision < 0 ? 1 : c->precision;
c00269ea:	ba 01 00 00 00       	mov    $0x1,%edx
c00269ef:	e9 f2 fe ff ff       	jmp    c00268e6 <format_integer+0x16a>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00269f4:	8d 44 24 30          	lea    0x30(%esp),%eax
c00269f8:	39 c3                	cmp    %eax,%ebx
c00269fa:	74 0a                	je     c0026a06 <format_integer+0x28a>
c00269fc:	80 7b ff 30          	cmpb   $0x30,-0x1(%ebx)
c0026a00:	0f 84 24 ff ff ff    	je     c002692a <format_integer+0x1ae>
    *cp++ = '0';
c0026a06:	c6 03 30             	movb   $0x30,(%ebx)
c0026a09:	8d 5b 01             	lea    0x1(%ebx),%ebx
c0026a0c:	e9 19 ff ff ff       	jmp    c002692a <format_integer+0x1ae>
c0026a11:	bf 00 00 00 00       	mov    $0x0,%edi
c0026a16:	e9 43 ff ff ff       	jmp    c002695e <format_integer+0x1e2>
    output_dup (' ', pad_cnt, output, aux);
c0026a1b:	83 ec 0c             	sub    $0xc,%esp
c0026a1e:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0026a25:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0026a2c:	89 fa                	mov    %edi,%edx
c0026a2e:	b8 20 00 00 00       	mov    $0x20,%eax
c0026a33:	e8 15 fd ff ff       	call   c002674d <output_dup>
c0026a38:	83 c4 10             	add    $0x10,%esp
c0026a3b:	e9 29 ff ff ff       	jmp    c0026969 <format_integer+0x1ed>
    output (sign, aux);
c0026a40:	83 ec 08             	sub    $0x8,%esp
c0026a43:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0026a4a:	ff 74 24 30          	pushl  0x30(%esp)
c0026a4e:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0026a55:	83 c4 10             	add    $0x10,%esp
c0026a58:	e9 17 ff ff ff       	jmp    c0026974 <format_integer+0x1f8>
      output ('0', aux);
c0026a5d:	83 ec 08             	sub    $0x8,%esp
c0026a60:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0026a67:	6a 30                	push   $0x30
c0026a69:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c0026a70:	83 c4 08             	add    $0x8,%esp
c0026a73:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0026a7a:	0f be 44 24 2c       	movsbl 0x2c(%esp),%eax
c0026a7f:	50                   	push   %eax
c0026a80:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0026a87:	83 c4 10             	add    $0x10,%esp
c0026a8a:	e9 f0 fe ff ff       	jmp    c002697f <format_integer+0x203>
    output_dup ('0', pad_cnt, output, aux);
c0026a8f:	83 ec 0c             	sub    $0xc,%esp
c0026a92:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0026a99:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0026aa0:	89 fa                	mov    %edi,%edx
c0026aa2:	b8 30 00 00 00       	mov    $0x30,%eax
c0026aa7:	e8 a1 fc ff ff       	call   c002674d <output_dup>
c0026aac:	83 c4 10             	add    $0x10,%esp
c0026aaf:	e9 db fe ff ff       	jmp    c002698f <format_integer+0x213>
    output_dup (' ', pad_cnt, output, aux);
c0026ab4:	83 ec 0c             	sub    $0xc,%esp
c0026ab7:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0026abe:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0026ac5:	89 fa                	mov    %edi,%edx
c0026ac7:	b8 20 00 00 00       	mov    $0x20,%eax
c0026acc:	e8 7c fc ff ff       	call   c002674d <output_dup>
c0026ad1:	83 c4 10             	add    $0x10,%esp
}
c0026ad4:	e9 f8 fe ff ff       	jmp    c00269d1 <format_integer+0x255>

c0026ad9 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0026ad9:	55                   	push   %ebp
c0026ada:	57                   	push   %edi
c0026adb:	56                   	push   %esi
c0026adc:	53                   	push   %ebx
c0026add:	83 ec 1c             	sub    $0x1c,%esp
c0026ae0:	89 c5                	mov    %eax,%ebp
c0026ae2:	89 d3                	mov    %edx,%ebx
c0026ae4:	89 54 24 08          	mov    %edx,0x8(%esp)
c0026ae8:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0026aec:	8b 74 24 30          	mov    0x30(%esp),%esi
c0026af0:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0026af4:	8b 51 04             	mov    0x4(%ecx),%edx
c0026af7:	39 da                	cmp    %ebx,%edx
c0026af9:	7e 42                	jle    c0026b3d <format_string+0x64>
c0026afb:	89 c8                	mov    %ecx,%eax
c0026afd:	f6 00 01             	testb  $0x1,(%eax)
c0026b00:	74 20                	je     c0026b22 <format_string+0x49>
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0026b02:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0026b07:	7f 3b                	jg     c0026b44 <format_string+0x6b>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
c0026b09:	2b 54 24 08          	sub    0x8(%esp),%edx
c0026b0d:	83 ec 0c             	sub    $0xc,%esp
c0026b10:	57                   	push   %edi
c0026b11:	89 f1                	mov    %esi,%ecx
c0026b13:	b8 20 00 00 00       	mov    $0x20,%eax
c0026b18:	e8 30 fc ff ff       	call   c002674d <output_dup>
c0026b1d:	83 c4 10             	add    $0x10,%esp
}
c0026b20:	eb 4f                	jmp    c0026b71 <format_string+0x98>
    output_dup (' ', c->width - length, output, aux);
c0026b22:	29 da                	sub    %ebx,%edx
c0026b24:	83 ec 0c             	sub    $0xc,%esp
c0026b27:	57                   	push   %edi
c0026b28:	89 f1                	mov    %esi,%ecx
c0026b2a:	b8 20 00 00 00       	mov    $0x20,%eax
c0026b2f:	e8 19 fc ff ff       	call   c002674d <output_dup>
  for (i = 0; i < length; i++)
c0026b34:	83 c4 10             	add    $0x10,%esp
c0026b37:	85 db                	test   %ebx,%ebx
c0026b39:	7f 09                	jg     c0026b44 <format_string+0x6b>
c0026b3b:	eb 22                	jmp    c0026b5f <format_string+0x86>
c0026b3d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0026b42:	7e 2d                	jle    c0026b71 <format_string+0x98>
{
c0026b44:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
c0026b49:	83 ec 08             	sub    $0x8,%esp
c0026b4c:	57                   	push   %edi
c0026b4d:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c0026b52:	50                   	push   %eax
c0026b53:	ff d6                	call   *%esi
  for (i = 0; i < length; i++)
c0026b55:	43                   	inc    %ebx
c0026b56:	83 c4 10             	add    $0x10,%esp
c0026b59:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
c0026b5d:	7f ea                	jg     c0026b49 <format_string+0x70>
  if (c->width > length && (c->flags & MINUS) != 0)
c0026b5f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0026b63:	8b 50 04             	mov    0x4(%eax),%edx
c0026b66:	39 54 24 08          	cmp    %edx,0x8(%esp)
c0026b6a:	7d 05                	jge    c0026b71 <format_string+0x98>
c0026b6c:	f6 00 01             	testb  $0x1,(%eax)
c0026b6f:	75 98                	jne    c0026b09 <format_string+0x30>
}
c0026b71:	83 c4 1c             	add    $0x1c,%esp
c0026b74:	5b                   	pop    %ebx
c0026b75:	5e                   	pop    %esi
c0026b76:	5f                   	pop    %edi
c0026b77:	5d                   	pop    %ebp
c0026b78:	c3                   	ret    

c0026b79 <printf>:
{
c0026b79:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0026b7c:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c0026b80:	83 ec 08             	sub    $0x8,%esp
c0026b83:	50                   	push   %eax
c0026b84:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026b88:	e8 4d 35 00 00       	call   c002a0da <vprintf>
}
c0026b8d:	83 c4 1c             	add    $0x1c,%esp
c0026b90:	c3                   	ret    

c0026b91 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0026b91:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c0026b94:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c0026b98:	ff 74 24 18          	pushl  0x18(%esp)
c0026b9c:	ff 74 24 18          	pushl  0x18(%esp)
c0026ba0:	50                   	push   %eax
c0026ba1:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026ba5:	e8 04 00 00 00       	call   c0026bae <__vprintf>
  va_end (args);
}
c0026baa:	83 c4 1c             	add    $0x1c,%esp
c0026bad:	c3                   	ret    

c0026bae <__vprintf>:
{
c0026bae:	55                   	push   %ebp
c0026baf:	57                   	push   %edi
c0026bb0:	56                   	push   %esi
c0026bb1:	53                   	push   %ebx
c0026bb2:	83 ec 3c             	sub    $0x3c,%esp
c0026bb5:	8b 74 24 50          	mov    0x50(%esp),%esi
  for (; *format != '\0'; format++)
c0026bb9:	8a 06                	mov    (%esi),%al
c0026bbb:	84 c0                	test   %al,%al
c0026bbd:	75 44                	jne    c0026c03 <__vprintf+0x55>
}
c0026bbf:	83 c4 3c             	add    $0x3c,%esp
c0026bc2:	5b                   	pop    %ebx
c0026bc3:	5e                   	pop    %esi
c0026bc4:	5f                   	pop    %edi
c0026bc5:	5d                   	pop    %ebp
c0026bc6:	c3                   	ret    
      format++;
c0026bc7:	8d 5e 01             	lea    0x1(%esi),%ebx
      if (*format == '%') 
c0026bca:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c0026bce:	74 19                	je     c0026be9 <__vprintf+0x3b>
  c->flags = 0;
c0026bd0:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0026bd7:	00 
c0026bd8:	bf 00 00 00 00       	mov    $0x0,%edi
c0026bdd:	be 00 00 00 00       	mov    $0x0,%esi
c0026be2:	bd 01 00 00 00       	mov    $0x1,%ebp
c0026be7:	eb 3b                	jmp    c0026c24 <__vprintf+0x76>
          output ('%', aux);
c0026be9:	83 ec 08             	sub    $0x8,%esp
c0026bec:	ff 74 24 64          	pushl  0x64(%esp)
c0026bf0:	6a 25                	push   $0x25
c0026bf2:	ff 54 24 68          	call   *0x68(%esp)
          continue;
c0026bf6:	83 c4 10             	add    $0x10,%esp
  for (; *format != '\0'; format++)
c0026bf9:	8d 73 01             	lea    0x1(%ebx),%esi
c0026bfc:	8a 43 01             	mov    0x1(%ebx),%al
c0026bff:	84 c0                	test   %al,%al
c0026c01:	74 bc                	je     c0026bbf <__vprintf+0x11>
      if (*format != '%') 
c0026c03:	3c 25                	cmp    $0x25,%al
c0026c05:	74 c0                	je     c0026bc7 <__vprintf+0x19>
          output (*format, aux);
c0026c07:	83 ec 08             	sub    $0x8,%esp
c0026c0a:	ff 74 24 64          	pushl  0x64(%esp)
c0026c0e:	0f be c0             	movsbl %al,%eax
c0026c11:	50                   	push   %eax
c0026c12:	ff 54 24 68          	call   *0x68(%esp)
          continue;
c0026c16:	83 c4 10             	add    $0x10,%esp
c0026c19:	89 f3                	mov    %esi,%ebx
c0026c1b:	eb dc                	jmp    c0026bf9 <__vprintf+0x4b>
          c->flags |= MINUS;
c0026c1d:	83 ce 01             	or     $0x1,%esi
c0026c20:	89 ef                	mov    %ebp,%edi
      switch (*format++) 
c0026c22:	89 cb                	mov    %ecx,%ebx
c0026c24:	8d 4b 01             	lea    0x1(%ebx),%ecx
c0026c27:	8a 41 ff             	mov    -0x1(%ecx),%al
c0026c2a:	8d 50 e0             	lea    -0x20(%eax),%edx
c0026c2d:	80 fa 10             	cmp    $0x10,%dl
c0026c30:	77 23                	ja     c0026c55 <__vprintf+0xa7>
c0026c32:	0f b6 d2             	movzbl %dl,%edx
c0026c35:	ff 24 95 50 f4 02 c0 	jmp    *-0x3ffd0bb0(,%edx,4)
          c->flags |= PLUS;
c0026c3c:	83 ce 02             	or     $0x2,%esi
c0026c3f:	eb df                	jmp    c0026c20 <__vprintf+0x72>
          c->flags |= SPACE;
c0026c41:	83 ce 04             	or     $0x4,%esi
c0026c44:	eb da                	jmp    c0026c20 <__vprintf+0x72>
          c->flags |= POUND;
c0026c46:	83 ce 08             	or     $0x8,%esi
c0026c49:	eb d5                	jmp    c0026c20 <__vprintf+0x72>
          c->flags |= ZERO;
c0026c4b:	83 ce 10             	or     $0x10,%esi
c0026c4e:	eb d0                	jmp    c0026c20 <__vprintf+0x72>
          c->flags |= GROUP;
c0026c50:	83 ce 20             	or     $0x20,%esi
c0026c53:	eb cb                	jmp    c0026c20 <__vprintf+0x72>
c0026c55:	89 fa                	mov    %edi,%edx
c0026c57:	84 d2                	test   %dl,%dl
c0026c59:	0f 85 85 00 00 00    	jne    c0026ce4 <__vprintf+0x136>
  if (c->flags & PLUS)
c0026c5f:	8b 54 24 20          	mov    0x20(%esp),%edx
c0026c63:	f6 c2 02             	test   $0x2,%dl
c0026c66:	74 07                	je     c0026c6f <__vprintf+0xc1>
    c->flags &= ~SPACE;
c0026c68:	83 e2 fb             	and    $0xfffffffb,%edx
c0026c6b:	89 54 24 20          	mov    %edx,0x20(%esp)
  c->width = 0;
c0026c6f:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0026c76:	00 
  if (*format == '*')
c0026c77:	3c 2a                	cmp    $0x2a,%al
c0026c79:	0f 84 81 00 00 00    	je     c0026d00 <__vprintf+0x152>
      for (; isdigit (*format); format++)
c0026c7f:	0f be c0             	movsbl %al,%eax
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0026c82:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0026c85:	ba 00 00 00 00       	mov    $0x0,%edx
c0026c8a:	83 f9 09             	cmp    $0x9,%ecx
c0026c8d:	77 21                	ja     c0026cb0 <__vprintf+0x102>
        c->width = c->width * 10 + *format - '0';
c0026c8f:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026c92:	01 d2                	add    %edx,%edx
c0026c94:	8d 54 10 d0          	lea    -0x30(%eax,%edx,1),%edx
      for (; isdigit (*format); format++)
c0026c98:	43                   	inc    %ebx
c0026c99:	0f be 03             	movsbl (%ebx),%eax
c0026c9c:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0026c9f:	83 f9 09             	cmp    $0x9,%ecx
c0026ca2:	76 eb                	jbe    c0026c8f <__vprintf+0xe1>
c0026ca4:	89 54 24 24          	mov    %edx,0x24(%esp)
  if (c->width < 0) 
c0026ca8:	8b 44 24 24          	mov    0x24(%esp),%eax
c0026cac:	85 c0                	test   %eax,%eax
c0026cae:	78 69                	js     c0026d19 <__vprintf+0x16b>
  c->precision = -1;
c0026cb0:	c7 44 24 28 ff ff ff 	movl   $0xffffffff,0x28(%esp)
c0026cb7:	ff 
  if (*format == '.') 
c0026cb8:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c0026cbb:	74 69                	je     c0026d26 <__vprintf+0x178>
  if (c->precision >= 0)
c0026cbd:	8b 54 24 28          	mov    0x28(%esp),%edx
  c->type = INT;
c0026cc1:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c0026cc8:	00 
  switch (*format++) 
c0026cc9:	8d 7b 01             	lea    0x1(%ebx),%edi
c0026ccc:	8a 03                	mov    (%ebx),%al
c0026cce:	8d 48 98             	lea    -0x68(%eax),%ecx
c0026cd1:	80 f9 12             	cmp    $0x12,%cl
c0026cd4:	0f 87 d5 01 00 00    	ja     c0026eaf <__vprintf+0x301>
c0026cda:	0f b6 c9             	movzbl %cl,%ecx
c0026cdd:	ff 24 8d 94 f4 02 c0 	jmp    *-0x3ffd0b6c(,%ecx,4)
c0026ce4:	89 74 24 20          	mov    %esi,0x20(%esp)
  if (c->flags & MINUS)
c0026ce8:	f7 c6 01 00 00 00    	test   $0x1,%esi
c0026cee:	0f 84 6b ff ff ff    	je     c0026c5f <__vprintf+0xb1>
    c->flags &= ~ZERO;
c0026cf4:	83 e6 ef             	and    $0xffffffef,%esi
c0026cf7:	89 74 24 20          	mov    %esi,0x20(%esp)
c0026cfb:	e9 5f ff ff ff       	jmp    c0026c5f <__vprintf+0xb1>
      c->width = va_arg (*args, int);
c0026d00:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026d04:	8b 00                	mov    (%eax),%eax
c0026d06:	89 44 24 24          	mov    %eax,0x24(%esp)
c0026d0a:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026d0e:	8d 40 04             	lea    0x4(%eax),%eax
c0026d11:	89 44 24 54          	mov    %eax,0x54(%esp)
      switch (*format++) 
c0026d15:	89 cb                	mov    %ecx,%ebx
c0026d17:	eb 8f                	jmp    c0026ca8 <__vprintf+0xfa>
      c->width = -c->width;
c0026d19:	f7 d8                	neg    %eax
c0026d1b:	89 44 24 24          	mov    %eax,0x24(%esp)
      c->flags |= MINUS;
c0026d1f:	83 4c 24 20 01       	orl    $0x1,0x20(%esp)
c0026d24:	eb 8a                	jmp    c0026cb0 <__vprintf+0x102>
      format++;
c0026d26:	8d 53 01             	lea    0x1(%ebx),%edx
      if (*format == '*') 
c0026d29:	8a 43 01             	mov    0x1(%ebx),%al
c0026d2c:	3c 2a                	cmp    $0x2a,%al
c0026d2e:	74 45                	je     c0026d75 <__vprintf+0x1c7>
          c->precision = 0;
c0026d30:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
c0026d37:	00 
          for (; isdigit (*format); format++)
c0026d38:	0f be c0             	movsbl %al,%eax
c0026d3b:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0026d3e:	83 f9 09             	cmp    $0x9,%ecx
c0026d41:	77 59                	ja     c0026d9c <__vprintf+0x1ee>
c0026d43:	b9 00 00 00 00       	mov    $0x0,%ecx
            c->precision = c->precision * 10 + *format - '0';
c0026d48:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026d4b:	01 c9                	add    %ecx,%ecx
c0026d4d:	8d 4c 08 d0          	lea    -0x30(%eax,%ecx,1),%ecx
          for (; isdigit (*format); format++)
c0026d51:	42                   	inc    %edx
c0026d52:	0f be 02             	movsbl (%edx),%eax
c0026d55:	8d 58 d0             	lea    -0x30(%eax),%ebx
c0026d58:	83 fb 09             	cmp    $0x9,%ebx
c0026d5b:	76 eb                	jbe    c0026d48 <__vprintf+0x19a>
c0026d5d:	89 4c 24 28          	mov    %ecx,0x28(%esp)
c0026d61:	89 d3                	mov    %edx,%ebx
      if (c->precision < 0) 
c0026d63:	8b 54 24 28          	mov    0x28(%esp),%edx
c0026d67:	85 d2                	test   %edx,%edx
c0026d69:	78 24                	js     c0026d8f <__vprintf+0x1e1>
    c->flags &= ~ZERO;
c0026d6b:	83 64 24 20 ef       	andl   $0xffffffef,0x20(%esp)
c0026d70:	e9 4c ff ff ff       	jmp    c0026cc1 <__vprintf+0x113>
          format++;
c0026d75:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c0026d78:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026d7c:	8b 00                	mov    (%eax),%eax
c0026d7e:	89 44 24 28          	mov    %eax,0x28(%esp)
c0026d82:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026d86:	8d 40 04             	lea    0x4(%eax),%eax
c0026d89:	89 44 24 54          	mov    %eax,0x54(%esp)
c0026d8d:	eb d4                	jmp    c0026d63 <__vprintf+0x1b5>
        c->precision = -1;
c0026d8f:	c7 44 24 28 ff ff ff 	movl   $0xffffffff,0x28(%esp)
c0026d96:	ff 
c0026d97:	e9 21 ff ff ff       	jmp    c0026cbd <__vprintf+0x10f>
      format++;
c0026d9c:	89 d3                	mov    %edx,%ebx
  if (c->precision >= 0)
c0026d9e:	ba 00 00 00 00       	mov    $0x0,%edx
c0026da3:	eb c6                	jmp    c0026d6b <__vprintf+0x1bd>
      if (*format == 'h') 
c0026da5:	8a 43 01             	mov    0x1(%ebx),%al
c0026da8:	3c 68                	cmp    $0x68,%al
c0026daa:	74 21                	je     c0026dcd <__vprintf+0x21f>
        c->type = SHORT;
c0026dac:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c0026db3:	00 
      switch (*format) 
c0026db4:	0f be e8             	movsbl %al,%ebp
c0026db7:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026dba:	80 fb 33             	cmp    $0x33,%bl
c0026dbd:	0f 87 ba 04 00 00    	ja     c002727d <__vprintf+0x6cf>
c0026dc3:	0f b6 db             	movzbl %bl,%ebx
c0026dc6:	ff 24 9d e0 f4 02 c0 	jmp    *-0x3ffd0b20(,%ebx,4)
          format++;
c0026dcd:	8d 7b 02             	lea    0x2(%ebx),%edi
          c->type = CHAR;
c0026dd0:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c0026dd7:	00 
      switch (*format) 
c0026dd8:	8a 43 02             	mov    0x2(%ebx),%al
c0026ddb:	0f be e8             	movsbl %al,%ebp
c0026dde:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026de1:	80 fb 33             	cmp    $0x33,%bl
c0026de4:	0f 87 93 04 00 00    	ja     c002727d <__vprintf+0x6cf>
c0026dea:	0f b6 db             	movzbl %bl,%ebx
c0026ded:	ff 24 9d b0 f5 02 c0 	jmp    *-0x3ffd0a50(,%ebx,4)
      c->type = INTMAX;
c0026df4:	c7 44 24 2c 04 00 00 	movl   $0x4,0x2c(%esp)
c0026dfb:	00 
      switch (*format) 
c0026dfc:	8a 43 01             	mov    0x1(%ebx),%al
c0026dff:	0f be e8             	movsbl %al,%ebp
c0026e02:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e05:	80 fb 33             	cmp    $0x33,%bl
c0026e08:	0f 87 6f 04 00 00    	ja     c002727d <__vprintf+0x6cf>
c0026e0e:	0f b6 db             	movzbl %bl,%ebx
c0026e11:	ff 24 9d 80 f6 02 c0 	jmp    *-0x3ffd0980(,%ebx,4)
      if (*format == 'l')
c0026e18:	8a 43 01             	mov    0x1(%ebx),%al
c0026e1b:	3c 6c                	cmp    $0x6c,%al
c0026e1d:	74 21                	je     c0026e40 <__vprintf+0x292>
        c->type = LONG;
c0026e1f:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c0026e26:	00 
      switch (*format) 
c0026e27:	0f be e8             	movsbl %al,%ebp
c0026e2a:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e2d:	80 fb 33             	cmp    $0x33,%bl
c0026e30:	0f 87 47 04 00 00    	ja     c002727d <__vprintf+0x6cf>
c0026e36:	0f b6 db             	movzbl %bl,%ebx
c0026e39:	ff 24 9d 50 f7 02 c0 	jmp    *-0x3ffd08b0(,%ebx,4)
          format++;
c0026e40:	8d 7b 02             	lea    0x2(%ebx),%edi
          c->type = LONGLONG;
c0026e43:	c7 44 24 2c 06 00 00 	movl   $0x6,0x2c(%esp)
c0026e4a:	00 
      switch (*format) 
c0026e4b:	8a 43 02             	mov    0x2(%ebx),%al
c0026e4e:	0f be e8             	movsbl %al,%ebp
c0026e51:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e54:	80 fb 33             	cmp    $0x33,%bl
c0026e57:	0f 87 20 04 00 00    	ja     c002727d <__vprintf+0x6cf>
c0026e5d:	0f b6 db             	movzbl %bl,%ebx
c0026e60:	ff 24 9d 20 f8 02 c0 	jmp    *-0x3ffd07e0(,%ebx,4)
      c->type = PTRDIFFT;
c0026e67:	c7 44 24 2c 07 00 00 	movl   $0x7,0x2c(%esp)
c0026e6e:	00 
      switch (*format) 
c0026e6f:	8a 43 01             	mov    0x1(%ebx),%al
c0026e72:	0f be e8             	movsbl %al,%ebp
c0026e75:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e78:	80 fb 33             	cmp    $0x33,%bl
c0026e7b:	0f 87 fc 03 00 00    	ja     c002727d <__vprintf+0x6cf>
c0026e81:	0f b6 db             	movzbl %bl,%ebx
c0026e84:	ff 24 9d f0 f8 02 c0 	jmp    *-0x3ffd0710(,%ebx,4)
      c->type = SIZET;
c0026e8b:	c7 44 24 2c 08 00 00 	movl   $0x8,0x2c(%esp)
c0026e92:	00 
      switch (*format) 
c0026e93:	8a 43 01             	mov    0x1(%ebx),%al
c0026e96:	0f be e8             	movsbl %al,%ebp
c0026e99:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e9c:	80 fb 33             	cmp    $0x33,%bl
c0026e9f:	0f 87 d8 03 00 00    	ja     c002727d <__vprintf+0x6cf>
c0026ea5:	0f b6 db             	movzbl %bl,%ebx
c0026ea8:	ff 24 9d c0 f9 02 c0 	jmp    *-0x3ffd0640(,%ebx,4)
c0026eaf:	0f be e8             	movsbl %al,%ebp
c0026eb2:	8d 70 bb             	lea    -0x45(%eax),%esi
c0026eb5:	89 f1                	mov    %esi,%ecx
c0026eb7:	80 f9 33             	cmp    $0x33,%cl
c0026eba:	0f 87 bb 03 00 00    	ja     c002727b <__vprintf+0x6cd>
c0026ec0:	0f b6 f1             	movzbl %cl,%esi
c0026ec3:	ff 24 b5 90 fa 02 c0 	jmp    *-0x3ffd0570(,%esi,4)
c0026eca:	89 df                	mov    %ebx,%edi
            switch (c.type) 
c0026ecc:	83 7c 24 2c 08       	cmpl   $0x8,0x2c(%esp)
c0026ed1:	0f 87 fb 00 00 00    	ja     c0026fd2 <__vprintf+0x424>
c0026ed7:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0026edb:	ff 24 85 60 fb 02 c0 	jmp    *-0x3ffd04a0(,%eax,4)
                value = (signed char) va_arg (args, int);
c0026ee2:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026ee6:	0f be 08             	movsbl (%eax),%ecx
c0026ee9:	89 cb                	mov    %ecx,%ebx
c0026eeb:	c1 fb 1f             	sar    $0x1f,%ebx
c0026eee:	8d 40 04             	lea    0x4(%eax),%eax
c0026ef1:	89 44 24 54          	mov    %eax,0x54(%esp)
            format_integer (value < 0 ? -value : value,
c0026ef5:	89 c8                	mov    %ecx,%eax
c0026ef7:	89 da                	mov    %ebx,%edx
c0026ef9:	85 db                	test   %ebx,%ebx
c0026efb:	0f 88 f3 00 00 00    	js     c0026ff4 <__vprintf+0x446>
c0026f01:	83 ec 0c             	sub    $0xc,%esp
c0026f04:	ff 74 24 68          	pushl  0x68(%esp)
c0026f08:	ff 74 24 68          	pushl  0x68(%esp)
c0026f0c:	8d 74 24 34          	lea    0x34(%esp),%esi
c0026f10:	56                   	push   %esi
c0026f11:	68 c0 fb 02 c0       	push   $0xc002fbc0
c0026f16:	89 d9                	mov    %ebx,%ecx
c0026f18:	c1 e9 1f             	shr    $0x1f,%ecx
c0026f1b:	51                   	push   %ecx
c0026f1c:	b9 01 00 00 00       	mov    $0x1,%ecx
c0026f21:	e8 56 f8 ff ff       	call   c002677c <format_integer>
          break;
c0026f26:	83 c4 20             	add    $0x20,%esp
c0026f29:	89 fb                	mov    %edi,%ebx
c0026f2b:	e9 c9 fc ff ff       	jmp    c0026bf9 <__vprintf+0x4b>
                value = (short) va_arg (args, int);
c0026f30:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f34:	0f bf 08             	movswl (%eax),%ecx
c0026f37:	89 cb                	mov    %ecx,%ebx
c0026f39:	c1 fb 1f             	sar    $0x1f,%ebx
c0026f3c:	8d 40 04             	lea    0x4(%eax),%eax
c0026f3f:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026f43:	eb b0                	jmp    c0026ef5 <__vprintf+0x347>
                value = va_arg (args, int);
c0026f45:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f49:	8b 08                	mov    (%eax),%ecx
c0026f4b:	89 cb                	mov    %ecx,%ebx
c0026f4d:	c1 fb 1f             	sar    $0x1f,%ebx
c0026f50:	8d 40 04             	lea    0x4(%eax),%eax
c0026f53:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026f57:	eb 9c                	jmp    c0026ef5 <__vprintf+0x347>
                value = va_arg (args, intmax_t);
c0026f59:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f5d:	8b 08                	mov    (%eax),%ecx
c0026f5f:	8b 58 04             	mov    0x4(%eax),%ebx
c0026f62:	8d 40 08             	lea    0x8(%eax),%eax
c0026f65:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026f69:	eb 8a                	jmp    c0026ef5 <__vprintf+0x347>
                value = va_arg (args, long);
c0026f6b:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f6f:	8b 08                	mov    (%eax),%ecx
c0026f71:	89 cb                	mov    %ecx,%ebx
c0026f73:	c1 fb 1f             	sar    $0x1f,%ebx
c0026f76:	8d 40 04             	lea    0x4(%eax),%eax
c0026f79:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026f7d:	e9 73 ff ff ff       	jmp    c0026ef5 <__vprintf+0x347>
                value = va_arg (args, long long);
c0026f82:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f86:	8b 08                	mov    (%eax),%ecx
c0026f88:	8b 58 04             	mov    0x4(%eax),%ebx
c0026f8b:	8d 40 08             	lea    0x8(%eax),%eax
c0026f8e:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026f92:	e9 5e ff ff ff       	jmp    c0026ef5 <__vprintf+0x347>
                value = va_arg (args, ptrdiff_t);
c0026f97:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f9b:	8b 08                	mov    (%eax),%ecx
c0026f9d:	89 cb                	mov    %ecx,%ebx
c0026f9f:	c1 fb 1f             	sar    $0x1f,%ebx
c0026fa2:	8d 40 04             	lea    0x4(%eax),%eax
c0026fa5:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026fa9:	e9 47 ff ff ff       	jmp    c0026ef5 <__vprintf+0x347>
                value = va_arg (args, size_t);
c0026fae:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026fb2:	83 c0 04             	add    $0x4,%eax
c0026fb5:	8b 74 24 54          	mov    0x54(%esp),%esi
c0026fb9:	8b 0e                	mov    (%esi),%ecx
c0026fbb:	bb 00 00 00 00       	mov    $0x0,%ebx
                if (value > SIZE_MAX / 2)
c0026fc0:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
c0026fc6:	76 23                	jbe    c0026feb <__vprintf+0x43d>
                  value = value - SIZE_MAX - 1;
c0026fc8:	4b                   	dec    %ebx
                value = va_arg (args, size_t);
c0026fc9:	89 44 24 54          	mov    %eax,0x54(%esp)
c0026fcd:	e9 23 ff ff ff       	jmp    c0026ef5 <__vprintf+0x347>
                NOT_REACHED ();
c0026fd2:	68 84 08 03 c0       	push   $0xc0030884
c0026fd7:	68 84 fb 02 c0       	push   $0xc002fb84
c0026fdc:	68 dc 00 00 00       	push   $0xdc
c0026fe1:	68 f1 1a 03 c0       	push   $0xc0031af1
c0026fe6:	e8 3c 16 00 00       	call   c0028627 <debug_panic>
                value = va_arg (args, size_t);
c0026feb:	89 44 24 54          	mov    %eax,0x54(%esp)
c0026fef:	e9 01 ff ff ff       	jmp    c0026ef5 <__vprintf+0x347>
            format_integer (value < 0 ? -value : value,
c0026ff4:	f7 d8                	neg    %eax
c0026ff6:	83 d2 00             	adc    $0x0,%edx
c0026ff9:	f7 da                	neg    %edx
c0026ffb:	e9 01 ff ff ff       	jmp    c0026f01 <__vprintf+0x353>
                value = va_arg (args, unsigned);
c0027000:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0027004:	8b 3f                	mov    (%edi),%edi
c0027006:	bd 00 00 00 00       	mov    $0x0,%ebp
c002700b:	89 7c 24 08          	mov    %edi,0x8(%esp)
c002700f:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
c0027013:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0027017:	8d 7f 04             	lea    0x4(%edi),%edi
c002701a:	89 7c 24 54          	mov    %edi,0x54(%esp)
            switch (*format) 
c002701e:	3c 6f                	cmp    $0x6f,%al
c0027020:	0f 84 68 01 00 00    	je     c002718e <__vprintf+0x5e0>
c0027026:	3c 6f                	cmp    $0x6f,%al
c0027028:	0f 8e 0a 01 00 00    	jle    c0027138 <__vprintf+0x58a>
c002702e:	3c 75                	cmp    $0x75,%al
c0027030:	0f 84 0d 01 00 00    	je     c0027143 <__vprintf+0x595>
c0027036:	3c 78                	cmp    $0x78,%al
c0027038:	0f 85 37 01 00 00    	jne    c0027175 <__vprintf+0x5c7>
              case 'x': b = &base_x; break;
c002703e:	b8 a0 fb 02 c0       	mov    $0xc002fba0,%eax
c0027043:	e9 00 01 00 00       	jmp    c0027148 <__vprintf+0x59a>
                value = (unsigned char) va_arg (args, unsigned);
c0027048:	8b 74 24 54          	mov    0x54(%esp),%esi
c002704c:	0f b6 16             	movzbl (%esi),%edx
c002704f:	89 54 24 08          	mov    %edx,0x8(%esp)
c0027053:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002705a:	00 
                break;
c002705b:	89 fb                	mov    %edi,%ebx
                value = (unsigned char) va_arg (args, unsigned);
c002705d:	8d 7e 04             	lea    0x4(%esi),%edi
c0027060:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0027064:	eb b8                	jmp    c002701e <__vprintf+0x470>
                value = (unsigned short) va_arg (args, unsigned);
c0027066:	8b 74 24 54          	mov    0x54(%esp),%esi
c002706a:	0f b7 16             	movzwl (%esi),%edx
c002706d:	89 54 24 08          	mov    %edx,0x8(%esp)
c0027071:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027078:	00 
                break;
c0027079:	89 fb                	mov    %edi,%ebx
                value = (unsigned short) va_arg (args, unsigned);
c002707b:	8d 7e 04             	lea    0x4(%esi),%edi
c002707e:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0027082:	eb 9a                	jmp    c002701e <__vprintf+0x470>
                value = va_arg (args, uintmax_t);
c0027084:	8b 74 24 54          	mov    0x54(%esp),%esi
c0027088:	8b 1e                	mov    (%esi),%ebx
c002708a:	8b 76 04             	mov    0x4(%esi),%esi
c002708d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0027091:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c0027095:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, uintmax_t);
c0027097:	8b 7c 24 54          	mov    0x54(%esp),%edi
c002709b:	8d 7f 08             	lea    0x8(%edi),%edi
c002709e:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c00270a2:	e9 77 ff ff ff       	jmp    c002701e <__vprintf+0x470>
                value = va_arg (args, unsigned long);
c00270a7:	8b 74 24 54          	mov    0x54(%esp),%esi
c00270ab:	8b 1e                	mov    (%esi),%ebx
c00270ad:	be 00 00 00 00       	mov    $0x0,%esi
c00270b2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c00270b6:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c00270ba:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, unsigned long);
c00270bc:	8b 7c 24 54          	mov    0x54(%esp),%edi
c00270c0:	8d 7f 04             	lea    0x4(%edi),%edi
c00270c3:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c00270c7:	e9 52 ff ff ff       	jmp    c002701e <__vprintf+0x470>
                value = va_arg (args, unsigned long long);
c00270cc:	8b 74 24 54          	mov    0x54(%esp),%esi
c00270d0:	8b 1e                	mov    (%esi),%ebx
c00270d2:	8b 76 04             	mov    0x4(%esi),%esi
c00270d5:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c00270d9:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c00270dd:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, unsigned long long);
c00270df:	8b 7c 24 54          	mov    0x54(%esp),%edi
c00270e3:	8d 7f 08             	lea    0x8(%edi),%edi
c00270e6:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c00270ea:	e9 2f ff ff ff       	jmp    c002701e <__vprintf+0x470>
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c00270ef:	8b 74 24 54          	mov    0x54(%esp),%esi
c00270f3:	8b 36                	mov    (%esi),%esi
c00270f5:	89 74 24 08          	mov    %esi,0x8(%esp)
c00270f9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027100:	00 
                break;
c0027101:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, ptrdiff_t);
c0027103:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0027107:	8d 7f 04             	lea    0x4(%edi),%edi
c002710a:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c002710e:	e9 0b ff ff ff       	jmp    c002701e <__vprintf+0x470>
                value = va_arg (args, size_t);
c0027113:	8b 74 24 54          	mov    0x54(%esp),%esi
c0027117:	8b 1e                	mov    (%esi),%ebx
c0027119:	be 00 00 00 00       	mov    $0x0,%esi
c002711e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0027122:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c0027126:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, size_t);
c0027128:	8b 7c 24 54          	mov    0x54(%esp),%edi
c002712c:	8d 7f 04             	lea    0x4(%edi),%edi
c002712f:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0027133:	e9 e6 fe ff ff       	jmp    c002701e <__vprintf+0x470>
            switch (*format) 
c0027138:	3c 58                	cmp    $0x58,%al
c002713a:	75 39                	jne    c0027175 <__vprintf+0x5c7>
              case 'X': b = &base_X; break;
c002713c:	b8 90 fb 02 c0       	mov    $0xc002fb90,%eax
c0027141:	eb 05                	jmp    c0027148 <__vprintf+0x59a>
              case 'u': b = &base_d; break;
c0027143:	b8 c0 fb 02 c0       	mov    $0xc002fbc0,%eax
            format_integer (value, false, false, b, &c, output, aux);
c0027148:	83 ec 0c             	sub    $0xc,%esp
c002714b:	ff 74 24 68          	pushl  0x68(%esp)
c002714f:	ff 74 24 68          	pushl  0x68(%esp)
c0027153:	8d 7c 24 34          	lea    0x34(%esp),%edi
c0027157:	57                   	push   %edi
c0027158:	50                   	push   %eax
c0027159:	6a 00                	push   $0x0
c002715b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027160:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027164:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0027168:	e8 0f f6 ff ff       	call   c002677c <format_integer>
          break;
c002716d:	83 c4 20             	add    $0x20,%esp
c0027170:	e9 84 fa ff ff       	jmp    c0026bf9 <__vprintf+0x4b>
              default: NOT_REACHED ();
c0027175:	68 84 08 03 c0       	push   $0xc0030884
c002717a:	68 84 fb 02 c0       	push   $0xc002fb84
c002717f:	68 14 01 00 00       	push   $0x114
c0027184:	68 f1 1a 03 c0       	push   $0xc0031af1
c0027189:	e8 99 14 00 00       	call   c0028627 <debug_panic>
              case 'o': b = &base_o; break;
c002718e:	b8 b0 fb 02 c0       	mov    $0xc002fbb0,%eax
c0027193:	eb b3                	jmp    c0027148 <__vprintf+0x59a>
      switch (*format) 
c0027195:	89 df                	mov    %ebx,%edi
            char ch = va_arg (args, int);
c0027197:	8b 44 24 54          	mov    0x54(%esp),%eax
c002719b:	8d 70 04             	lea    0x4(%eax),%esi
c002719e:	8b 00                	mov    (%eax),%eax
c00271a0:	88 44 24 1f          	mov    %al,0x1f(%esp)
            format_string (&ch, 1, &c, output, aux);
c00271a4:	83 ec 08             	sub    $0x8,%esp
c00271a7:	ff 74 24 64          	pushl  0x64(%esp)
c00271ab:	ff 74 24 64          	pushl  0x64(%esp)
c00271af:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c00271b3:	ba 01 00 00 00       	mov    $0x1,%edx
c00271b8:	8d 44 24 2f          	lea    0x2f(%esp),%eax
c00271bc:	e8 18 f9 ff ff       	call   c0026ad9 <format_string>
          break;
c00271c1:	83 c4 10             	add    $0x10,%esp
c00271c4:	89 fb                	mov    %edi,%ebx
            char ch = va_arg (args, int);
c00271c6:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c00271ca:	e9 2a fa ff ff       	jmp    c0026bf9 <__vprintf+0x4b>
      switch (*format) 
c00271cf:	89 df                	mov    %ebx,%edi
            const char *s = va_arg (args, char *);
c00271d1:	8b 44 24 54          	mov    0x54(%esp),%eax
c00271d5:	8d 70 04             	lea    0x4(%eax),%esi
c00271d8:	8b 18                	mov    (%eax),%ebx
            if (s == NULL)
c00271da:	85 db                	test   %ebx,%ebx
c00271dc:	74 30                	je     c002720e <__vprintf+0x660>
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c00271de:	83 ec 08             	sub    $0x8,%esp
c00271e1:	52                   	push   %edx
c00271e2:	53                   	push   %ebx
c00271e3:	e8 0e 0b 00 00       	call   c0027cf6 <strnlen>
c00271e8:	83 c4 08             	add    $0x8,%esp
c00271eb:	ff 74 24 64          	pushl  0x64(%esp)
c00271ef:	ff 74 24 64          	pushl  0x64(%esp)
c00271f3:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c00271f7:	89 c2                	mov    %eax,%edx
c00271f9:	89 d8                	mov    %ebx,%eax
c00271fb:	e8 d9 f8 ff ff       	call   c0026ad9 <format_string>
          break;
c0027200:	83 c4 10             	add    $0x10,%esp
c0027203:	89 fb                	mov    %edi,%ebx
            const char *s = va_arg (args, char *);
c0027205:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c0027209:	e9 eb f9 ff ff       	jmp    c0026bf9 <__vprintf+0x4b>
              s = "(null)";
c002720e:	bb ea 1a 03 c0       	mov    $0xc0031aea,%ebx
c0027213:	eb c9                	jmp    c00271de <__vprintf+0x630>
      switch (*format) 
c0027215:	89 df                	mov    %ebx,%edi
            void *p = va_arg (args, void *);
c0027217:	8b 44 24 54          	mov    0x54(%esp),%eax
c002721b:	8d 70 04             	lea    0x4(%eax),%esi
c002721e:	8b 00                	mov    (%eax),%eax
            c.flags = POUND;
c0027220:	c7 44 24 20 08 00 00 	movl   $0x8,0x20(%esp)
c0027227:	00 
            format_integer ((uintptr_t) p, false, false,
c0027228:	83 ec 0c             	sub    $0xc,%esp
c002722b:	ff 74 24 68          	pushl  0x68(%esp)
c002722f:	ff 74 24 68          	pushl  0x68(%esp)
c0027233:	8d 5c 24 34          	lea    0x34(%esp),%ebx
c0027237:	53                   	push   %ebx
c0027238:	68 a0 fb 02 c0       	push   $0xc002fba0
c002723d:	6a 00                	push   $0x0
c002723f:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027244:	ba 00 00 00 00       	mov    $0x0,%edx
c0027249:	e8 2e f5 ff ff       	call   c002677c <format_integer>
          break;
c002724e:	83 c4 20             	add    $0x20,%esp
c0027251:	89 fb                	mov    %edi,%ebx
            void *p = va_arg (args, void *);
c0027253:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c0027257:	e9 9d f9 ff ff       	jmp    c0026bf9 <__vprintf+0x4b>
      switch (*format) 
c002725c:	89 df                	mov    %ebx,%edi
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c002725e:	55                   	push   %ebp
c002725f:	ff 74 24 60          	pushl  0x60(%esp)
c0027263:	ff 74 24 60          	pushl  0x60(%esp)
c0027267:	68 03 1b 03 c0       	push   $0xc0031b03
c002726c:	e8 20 f9 ff ff       	call   c0026b91 <__printf>
          break;
c0027271:	83 c4 10             	add    $0x10,%esp
c0027274:	89 fb                	mov    %edi,%ebx
c0027276:	e9 7e f9 ff ff       	jmp    c0026bf9 <__vprintf+0x4b>
      switch (*format) 
c002727b:	89 df                	mov    %ebx,%edi
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c002727d:	55                   	push   %ebp
c002727e:	ff 74 24 60          	pushl  0x60(%esp)
c0027282:	ff 74 24 60          	pushl  0x60(%esp)
c0027286:	68 19 1b 03 c0       	push   $0xc0031b19
c002728b:	e8 01 f9 ff ff       	call   c0026b91 <__printf>
          break;
c0027290:	83 c4 10             	add    $0x10,%esp
c0027293:	89 fb                	mov    %edi,%ebx
c0027295:	e9 5f f9 ff ff       	jmp    c0026bf9 <__vprintf+0x4b>

c002729a <vsnprintf>:
{
c002729a:	53                   	push   %ebx
c002729b:	83 ec 18             	sub    $0x18,%esp
c002729e:	8b 44 24 24          	mov    0x24(%esp),%eax
c00272a2:	8b 54 24 28          	mov    0x28(%esp),%edx
c00272a6:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c00272aa:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c00272ae:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  aux.length = 0;
c00272b2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c00272b9:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c00272ba:	85 c0                	test   %eax,%eax
c00272bc:	74 29                	je     c00272e7 <vsnprintf+0x4d>
c00272be:	48                   	dec    %eax
c00272bf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf (format, args, vsnprintf_helper, &aux);
c00272c3:	8d 44 24 04          	lea    0x4(%esp),%eax
c00272c7:	50                   	push   %eax
c00272c8:	68 2b 67 02 c0       	push   $0xc002672b
c00272cd:	51                   	push   %ecx
c00272ce:	52                   	push   %edx
c00272cf:	e8 da f8 ff ff       	call   c0026bae <__vprintf>
    *aux.p = '\0';
c00272d4:	8b 44 24 14          	mov    0x14(%esp),%eax
c00272d8:	c6 00 00             	movb   $0x0,(%eax)
c00272db:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c00272de:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c00272e2:	83 c4 18             	add    $0x18,%esp
c00272e5:	5b                   	pop    %ebx
c00272e6:	c3                   	ret    
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c00272e7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c00272ee:	00 
  __vprintf (format, args, vsnprintf_helper, &aux);
c00272ef:	8d 44 24 04          	lea    0x4(%esp),%eax
c00272f3:	50                   	push   %eax
c00272f4:	68 2b 67 02 c0       	push   $0xc002672b
c00272f9:	51                   	push   %ecx
c00272fa:	52                   	push   %edx
c00272fb:	e8 ae f8 ff ff       	call   c0026bae <__vprintf>
c0027300:	83 c4 10             	add    $0x10,%esp
c0027303:	eb d9                	jmp    c00272de <vsnprintf+0x44>

c0027305 <snprintf>:
{
c0027305:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0027308:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c002730c:	50                   	push   %eax
c002730d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027311:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027315:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027319:	e8 7c ff ff ff       	call   c002729a <vsnprintf>
}
c002731e:	83 c4 1c             	add    $0x1c,%esp
c0027321:	c3                   	ret    

c0027322 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027322:	55                   	push   %ebp
c0027323:	57                   	push   %edi
c0027324:	56                   	push   %esi
c0027325:	53                   	push   %ebx
c0027326:	83 ec 1c             	sub    $0x1c,%esp
c0027329:	8a 44 24 3c          	mov    0x3c(%esp),%al
c002732d:	88 44 24 0f          	mov    %al,0xf(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027331:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0027336:	0f 84 d9 01 00 00    	je     c0027515 <hex_dump+0x1f3>
c002733c:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027340:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027344:	e9 87 00 00 00       	jmp    c00273d0 <hex_dump+0xae>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
c0027349:	8b 44 24 38          	mov    0x38(%esp),%eax
c002734d:	89 44 24 04          	mov    %eax,0x4(%esp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c0027351:	89 f3                	mov    %esi,%ebx
c0027353:	e9 e2 00 00 00       	jmp    c002743a <hex_dump+0x118>
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c0027358:	b8 2d 00 00 00       	mov    $0x2d,%eax
c002735d:	e9 f0 00 00 00       	jmp    c0027452 <hex_dump+0x130>
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c0027362:	83 ec 0c             	sub    $0xc,%esp
c0027365:	0f b6 c0             	movzbl %al,%eax
c0027368:	50                   	push   %eax
c0027369:	e8 0c 2e 00 00       	call   c002a17a <putchar>
          for (; i < end; i++)
c002736e:	43                   	inc    %ebx
c002736f:	83 c4 10             	add    $0x10,%esp
c0027372:	39 fb                	cmp    %edi,%ebx
c0027374:	73 12                	jae    c0027388 <hex_dump+0x66>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027376:	8a 04 1e             	mov    (%esi,%ebx,1),%al
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027379:	0f b6 d0             	movzbl %al,%edx
c002737c:	83 ea 20             	sub    $0x20,%edx
            printf ("%c",
c002737f:	83 fa 5e             	cmp    $0x5e,%edx
c0027382:	76 de                	jbe    c0027362 <hex_dump+0x40>
c0027384:	89 e8                	mov    %ebp,%eax
c0027386:	eb da                	jmp    c0027362 <hex_dump+0x40>
          for (; i < per_line; i++)
c0027388:	83 fb 0f             	cmp    $0xf,%ebx
c002738b:	77 13                	ja     c00273a0 <hex_dump+0x7e>
            printf (" ");
c002738d:	83 ec 0c             	sub    $0xc,%esp
c0027390:	6a 20                	push   $0x20
c0027392:	e8 e3 2d 00 00       	call   c002a17a <putchar>
          for (; i < per_line; i++)
c0027397:	43                   	inc    %ebx
c0027398:	83 c4 10             	add    $0x10,%esp
c002739b:	83 fb 0f             	cmp    $0xf,%ebx
c002739e:	76 ed                	jbe    c002738d <hex_dump+0x6b>
          printf ("|");
c00273a0:	83 ec 0c             	sub    $0xc,%esp
c00273a3:	6a 7c                	push   $0x7c
c00273a5:	e8 d0 2d 00 00       	call   c002a17a <putchar>
c00273aa:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c00273ad:	83 ec 0c             	sub    $0xc,%esp
c00273b0:	6a 0a                	push   $0xa
c00273b2:	e8 c3 2d 00 00       	call   c002a17a <putchar>

      ofs += n;
c00273b7:	8b 44 24 14          	mov    0x14(%esp),%eax
c00273bb:	01 44 24 40          	add    %eax,0x40(%esp)
      buf += n;
c00273bf:	01 44 24 18          	add    %eax,0x18(%esp)
  while (size > 0)
c00273c3:	83 c4 10             	add    $0x10,%esp
c00273c6:	29 44 24 38          	sub    %eax,0x38(%esp)
c00273ca:	0f 84 45 01 00 00    	je     c0027515 <hex_dump+0x1f3>
      start = ofs % per_line;
c00273d0:	8b 74 24 30          	mov    0x30(%esp),%esi
c00273d4:	83 e6 0f             	and    $0xf,%esi
      if (end - start > size)
c00273d7:	b8 10 00 00 00       	mov    $0x10,%eax
c00273dc:	29 f0                	sub    %esi,%eax
c00273de:	89 44 24 04          	mov    %eax,0x4(%esp)
c00273e2:	3b 44 24 38          	cmp    0x38(%esp),%eax
c00273e6:	0f 86 ea 00 00 00    	jbe    c00274d6 <hex_dump+0x1b4>
        end = start + size;
c00273ec:	89 f7                	mov    %esi,%edi
c00273ee:	03 7c 24 38          	add    0x38(%esp),%edi
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c00273f2:	83 ec 04             	sub    $0x4,%esp
c00273f5:	8b 44 24 34          	mov    0x34(%esp),%eax
c00273f9:	83 e0 f0             	and    $0xfffffff0,%eax
c00273fc:	ba 00 00 00 00       	mov    $0x0,%edx
c0027401:	52                   	push   %edx
c0027402:	50                   	push   %eax
c0027403:	68 30 1b 03 c0       	push   $0xc0031b30
c0027408:	e8 6c f7 ff ff       	call   c0026b79 <printf>
      for (i = 0; i < start; i++)
c002740d:	83 c4 10             	add    $0x10,%esp
c0027410:	85 f6                	test   %esi,%esi
c0027412:	0f 84 31 ff ff ff    	je     c0027349 <hex_dump+0x27>
      n = end - start;
c0027418:	8b 44 24 38          	mov    0x38(%esp),%eax
c002741c:	89 44 24 04          	mov    %eax,0x4(%esp)
      end = per_line;
c0027420:	bb 00 00 00 00       	mov    $0x0,%ebx
        printf ("   ");
c0027425:	83 ec 0c             	sub    $0xc,%esp
c0027428:	68 38 1b 03 c0       	push   $0xc0031b38
c002742d:	e8 47 f7 ff ff       	call   c0026b79 <printf>
      for (i = 0; i < start; i++)
c0027432:	43                   	inc    %ebx
c0027433:	83 c4 10             	add    $0x10,%esp
c0027436:	39 de                	cmp    %ebx,%esi
c0027438:	77 eb                	ja     c0027425 <hex_dump+0x103>
      for (; i < end; i++) 
c002743a:	39 fb                	cmp    %edi,%ebx
c002743c:	73 30                	jae    c002746e <hex_dump+0x14c>
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c002743e:	8b 6c 24 08          	mov    0x8(%esp),%ebp
c0027442:	29 f5                	sub    %esi,%ebp
        printf ("%02hhx%c",
c0027444:	83 fb 07             	cmp    $0x7,%ebx
c0027447:	0f 84 0b ff ff ff    	je     c0027358 <hex_dump+0x36>
c002744d:	b8 20 00 00 00       	mov    $0x20,%eax
c0027452:	83 ec 04             	sub    $0x4,%esp
c0027455:	50                   	push   %eax
c0027456:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
c002745b:	50                   	push   %eax
c002745c:	68 3c 1b 03 c0       	push   $0xc0031b3c
c0027461:	e8 13 f7 ff ff       	call   c0026b79 <printf>
      for (; i < end; i++) 
c0027466:	43                   	inc    %ebx
c0027467:	83 c4 10             	add    $0x10,%esp
c002746a:	39 fb                	cmp    %edi,%ebx
c002746c:	72 d6                	jb     c0027444 <hex_dump+0x122>
      if (ascii) 
c002746e:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0027473:	0f 84 34 ff ff ff    	je     c00273ad <hex_dump+0x8b>
          for (; i < per_line; i++)
c0027479:	83 fb 0f             	cmp    $0xf,%ebx
c002747c:	77 16                	ja     c0027494 <hex_dump+0x172>
            printf ("   ");
c002747e:	83 ec 0c             	sub    $0xc,%esp
c0027481:	68 38 1b 03 c0       	push   $0xc0031b38
c0027486:	e8 ee f6 ff ff       	call   c0026b79 <printf>
          for (; i < per_line; i++)
c002748b:	43                   	inc    %ebx
c002748c:	83 c4 10             	add    $0x10,%esp
c002748f:	83 fb 10             	cmp    $0x10,%ebx
c0027492:	75 ea                	jne    c002747e <hex_dump+0x15c>
          printf ("|");
c0027494:	83 ec 0c             	sub    $0xc,%esp
c0027497:	6a 7c                	push   $0x7c
c0027499:	e8 dc 2c 00 00       	call   c002a17a <putchar>
          for (i = 0; i < start; i++)
c002749e:	83 c4 10             	add    $0x10,%esp
c00274a1:	85 f6                	test   %esi,%esi
c00274a3:	74 63                	je     c0027508 <hex_dump+0x1e6>
c00274a5:	bb 00 00 00 00       	mov    $0x0,%ebx
            printf (" ");
c00274aa:	83 ec 0c             	sub    $0xc,%esp
c00274ad:	6a 20                	push   $0x20
c00274af:	e8 c6 2c 00 00       	call   c002a17a <putchar>
          for (i = 0; i < start; i++)
c00274b4:	43                   	inc    %ebx
c00274b5:	83 c4 10             	add    $0x10,%esp
c00274b8:	39 de                	cmp    %ebx,%esi
c00274ba:	75 ee                	jne    c00274aa <hex_dump+0x188>
          for (; i < end; i++)
c00274bc:	39 fb                	cmp    %edi,%ebx
c00274be:	0f 83 c4 fe ff ff    	jae    c0027388 <hex_dump+0x66>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c00274c4:	8b 44 24 08          	mov    0x8(%esp),%eax
c00274c8:	29 f0                	sub    %esi,%eax
c00274ca:	89 c6                	mov    %eax,%esi
c00274cc:	bd 2e 00 00 00       	mov    $0x2e,%ebp
c00274d1:	e9 a0 fe ff ff       	jmp    c0027376 <hex_dump+0x54>
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c00274d6:	83 ec 04             	sub    $0x4,%esp
c00274d9:	8b 44 24 34          	mov    0x34(%esp),%eax
c00274dd:	83 e0 f0             	and    $0xfffffff0,%eax
c00274e0:	ba 00 00 00 00       	mov    $0x0,%edx
c00274e5:	52                   	push   %edx
c00274e6:	50                   	push   %eax
c00274e7:	68 30 1b 03 c0       	push   $0xc0031b30
c00274ec:	e8 88 f6 ff ff       	call   c0026b79 <printf>
      for (i = 0; i < start; i++)
c00274f1:	83 c4 10             	add    $0x10,%esp
      end = per_line;
c00274f4:	bf 10 00 00 00       	mov    $0x10,%edi
      for (i = 0; i < start; i++)
c00274f9:	89 f3                	mov    %esi,%ebx
c00274fb:	85 f6                	test   %esi,%esi
c00274fd:	0f 85 1d ff ff ff    	jne    c0027420 <hex_dump+0xfe>
c0027503:	e9 36 ff ff ff       	jmp    c002743e <hex_dump+0x11c>
          for (i = 0; i < start; i++)
c0027508:	89 f3                	mov    %esi,%ebx
          for (; i < end; i++)
c002750a:	85 ff                	test   %edi,%edi
c002750c:	75 b6                	jne    c00274c4 <hex_dump+0x1a2>
          for (i = 0; i < start; i++)
c002750e:	89 fb                	mov    %edi,%ebx
c0027510:	e9 78 fe ff ff       	jmp    c002738d <hex_dump+0x6b>
      size -= n;
    }
}
c0027515:	83 c4 1c             	add    $0x1c,%esp
c0027518:	5b                   	pop    %ebx
c0027519:	5e                   	pop    %esi
c002751a:	5f                   	pop    %edi
c002751b:	5d                   	pop    %ebp
c002751c:	c3                   	ret    

c002751d <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c002751d:	57                   	push   %edi
c002751e:	56                   	push   %esi
c002751f:	83 ec 04             	sub    $0x4,%esp
c0027522:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027526:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
c002752a:	89 f0                	mov    %esi,%eax
c002752c:	83 f0 01             	xor    $0x1,%eax
c002752f:	89 fa                	mov    %edi,%edx
c0027531:	09 c2                	or     %eax,%edx
c0027533:	74 1d                	je     c0027552 <print_human_readable_size+0x35>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027535:	83 ff 00             	cmp    $0x0,%edi
c0027538:	77 08                	ja     c0027542 <print_human_readable_size+0x25>
c002753a:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0027540:	76 5d                	jbe    c002759f <print_human_readable_size+0x82>
c0027542:	b9 34 b0 03 c0       	mov    $0xc003b034,%ecx
c0027547:	83 3d 38 b0 03 c0 00 	cmpl   $0x0,0xc003b038
c002754e:	75 1a                	jne    c002756a <print_human_readable_size+0x4d>
c0027550:	eb 36                	jmp    c0027588 <print_human_readable_size+0x6b>
    printf ("1 byte");
c0027552:	83 ec 0c             	sub    $0xc,%esp
c0027555:	68 45 1b 03 c0       	push   $0xc0031b45
c002755a:	e8 1a f6 ff ff       	call   c0026b79 <printf>
c002755f:	83 c4 10             	add    $0x10,%esp
c0027562:	eb 35                	jmp    c0027599 <print_human_readable_size+0x7c>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027564:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
c0027568:	74 1e                	je     c0027588 <print_human_readable_size+0x6b>
        size /= 1024;
c002756a:	89 f0                	mov    %esi,%eax
c002756c:	89 fa                	mov    %edi,%edx
c002756e:	0f ac f8 0a          	shrd   $0xa,%edi,%eax
c0027572:	c1 ea 0a             	shr    $0xa,%edx
c0027575:	89 c6                	mov    %eax,%esi
c0027577:	89 d7                	mov    %edx,%edi
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027579:	83 c1 04             	add    $0x4,%ecx
c002757c:	83 fa 00             	cmp    $0x0,%edx
c002757f:	77 e3                	ja     c0027564 <print_human_readable_size+0x47>
c0027581:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c0027586:	77 dc                	ja     c0027564 <print_human_readable_size+0x47>
      printf ("%"PRIu64" %s", size, *fp);
c0027588:	ff 31                	pushl  (%ecx)
c002758a:	57                   	push   %edi
c002758b:	56                   	push   %esi
c002758c:	68 4c 1b 03 c0       	push   $0xc0031b4c
c0027591:	e8 e3 f5 ff ff       	call   c0026b79 <printf>
c0027596:	83 c4 10             	add    $0x10,%esp
    }
}
c0027599:	83 c4 04             	add    $0x4,%esp
c002759c:	5e                   	pop    %esi
c002759d:	5f                   	pop    %edi
c002759e:	c3                   	ret    
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002759f:	b9 34 b0 03 c0       	mov    $0xc003b034,%ecx
c00275a4:	eb e2                	jmp    c0027588 <print_human_readable_size+0x6b>

c00275a6 <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c00275a6:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c00275a9:	ff 74 24 1c          	pushl  0x1c(%esp)
c00275ad:	ff 74 24 1c          	pushl  0x1c(%esp)
c00275b1:	8b 44 24 28          	mov    0x28(%esp),%eax
c00275b5:	ff 10                	call   *(%eax)
}
c00275b7:	83 c4 1c             	add    $0x1c,%esp
c00275ba:	c3                   	ret    

c00275bb <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c00275bb:	55                   	push   %ebp
c00275bc:	57                   	push   %edi
c00275bd:	56                   	push   %esi
c00275be:	53                   	push   %ebx
c00275bf:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c00275c3:	8d 72 ff             	lea    -0x1(%edx),%esi
c00275c6:	0f af f7             	imul   %edi,%esi
  unsigned char *b = array + (b_idx - 1) * size;
c00275c9:	8d 59 ff             	lea    -0x1(%ecx),%ebx
c00275cc:	0f af df             	imul   %edi,%ebx
  size_t i;

  for (i = 0; i < size; i++)
c00275cf:	85 ff                	test   %edi,%edi
c00275d1:	74 1d                	je     c00275f0 <do_swap+0x35>
c00275d3:	8d 14 30             	lea    (%eax,%esi,1),%edx
c00275d6:	01 f7                	add    %esi,%edi
c00275d8:	01 c7                	add    %eax,%edi
    {
      unsigned char t = a[i];
c00275da:	0f b6 2a             	movzbl (%edx),%ebp
c00275dd:	89 d1                	mov    %edx,%ecx
c00275df:	29 f1                	sub    %esi,%ecx
      a[i] = b[i];
c00275e1:	8a 04 19             	mov    (%ecx,%ebx,1),%al
c00275e4:	88 02                	mov    %al,(%edx)
      b[i] = t;
c00275e6:	89 e8                	mov    %ebp,%eax
c00275e8:	88 04 19             	mov    %al,(%ecx,%ebx,1)
c00275eb:	42                   	inc    %edx
  for (i = 0; i < size; i++)
c00275ec:	39 fa                	cmp    %edi,%edx
c00275ee:	75 ea                	jne    c00275da <do_swap+0x1f>
    }
}
c00275f0:	5b                   	pop    %ebx
c00275f1:	5e                   	pop    %esi
c00275f2:	5f                   	pop    %edi
c00275f3:	5d                   	pop    %ebp
c00275f4:	c3                   	ret    

c00275f5 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c00275f5:	55                   	push   %ebp
c00275f6:	57                   	push   %edi
c00275f7:	56                   	push   %esi
c00275f8:	53                   	push   %ebx
c00275f9:	83 ec 1c             	sub    $0x1c,%esp
c00275fc:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027600:	89 d6                	mov    %edx,%esi
c0027602:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027606:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c002760a:	eb 4a                	jmp    c0027656 <heapify+0x61>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c002760c:	83 ec 04             	sub    $0x4,%esp
c002760f:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027613:	8d 46 ff             	lea    -0x1(%esi),%eax
c0027616:	0f af c5             	imul   %ebp,%eax
c0027619:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002761d:	01 c8                	add    %ecx,%eax
c002761f:	50                   	push   %eax
c0027620:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027623:	0f af c5             	imul   %ebp,%eax
c0027626:	01 c8                	add    %ecx,%eax
c0027628:	50                   	push   %eax
c0027629:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c002762d:	83 c4 10             	add    $0x10,%esp
c0027630:	85 c0                	test   %eax,%eax
c0027632:	7e 2e                	jle    c0027662 <heapify+0x6d>
        max = left;
      if (right <= cnt
c0027634:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c0027638:	76 5b                	jbe    c0027695 <heapify+0xa0>
        max = left;
c002763a:	89 df                	mov    %ebx,%edi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c002763c:	39 fe                	cmp    %edi,%esi
c002763e:	74 4d                	je     c002768d <heapify+0x98>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0027640:	83 ec 0c             	sub    $0xc,%esp
c0027643:	55                   	push   %ebp
c0027644:	89 f9                	mov    %edi,%ecx
c0027646:	89 f2                	mov    %esi,%edx
c0027648:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002764c:	e8 6a ff ff ff       	call   c00275bb <do_swap>
c0027651:	89 fe                	mov    %edi,%esi
    {
c0027653:	83 c4 10             	add    $0x10,%esp
      size_t left = 2 * i;
c0027656:	8d 1c 36             	lea    (%esi,%esi,1),%ebx
      size_t right = 2 * i + 1;
c0027659:	8d 7b 01             	lea    0x1(%ebx),%edi
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c002765c:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0027660:	76 aa                	jbe    c002760c <heapify+0x17>
      if (right <= cnt
c0027662:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c0027666:	77 25                	ja     c002768d <heapify+0x98>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027668:	83 ec 04             	sub    $0x4,%esp
c002766b:	ff 74 24 3c          	pushl  0x3c(%esp)
c002766f:	8d 46 ff             	lea    -0x1(%esi),%eax
c0027672:	0f af c5             	imul   %ebp,%eax
c0027675:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027679:	01 d0                	add    %edx,%eax
c002767b:	50                   	push   %eax
c002767c:	0f af dd             	imul   %ebp,%ebx
c002767f:	01 d3                	add    %edx,%ebx
c0027681:	53                   	push   %ebx
c0027682:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0027686:	83 c4 10             	add    $0x10,%esp
c0027689:	85 c0                	test   %eax,%eax
c002768b:	7f af                	jg     c002763c <heapify+0x47>
      i = max;
    }
}
c002768d:	83 c4 1c             	add    $0x1c,%esp
c0027690:	5b                   	pop    %ebx
c0027691:	5e                   	pop    %esi
c0027692:	5f                   	pop    %edi
c0027693:	5d                   	pop    %ebp
c0027694:	c3                   	ret    
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027695:	83 ec 04             	sub    $0x4,%esp
c0027698:	ff 74 24 3c          	pushl  0x3c(%esp)
c002769c:	8d 43 ff             	lea    -0x1(%ebx),%eax
c002769f:	0f af c5             	imul   %ebp,%eax
c00276a2:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00276a6:	01 c8                	add    %ecx,%eax
c00276a8:	50                   	push   %eax
c00276a9:	89 d8                	mov    %ebx,%eax
c00276ab:	0f af c5             	imul   %ebp,%eax
c00276ae:	01 c8                	add    %ecx,%eax
c00276b0:	50                   	push   %eax
c00276b1:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c00276b5:	83 c4 10             	add    $0x10,%esp
c00276b8:	85 c0                	test   %eax,%eax
c00276ba:	7f 80                	jg     c002763c <heapify+0x47>
        max = left;
c00276bc:	89 df                	mov    %ebx,%edi
c00276be:	e9 79 ff ff ff       	jmp    c002763c <heapify+0x47>

c00276c3 <atoi>:
{
c00276c3:	56                   	push   %esi
c00276c4:	53                   	push   %ebx
c00276c5:	83 ec 04             	sub    $0x4,%esp
c00276c8:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (s != NULL);
c00276cc:	85 d2                	test   %edx,%edx
c00276ce:	75 1f                	jne    c00276ef <atoi+0x2c>
c00276d0:	83 ec 0c             	sub    $0xc,%esp
c00276d3:	68 eb 1b 03 c0       	push   $0xc0031beb
c00276d8:	68 21 01 03 c0       	push   $0xc0030121
c00276dd:	68 d8 fb 02 c0       	push   $0xc002fbd8
c00276e2:	6a 0f                	push   $0xf
c00276e4:	68 9c 1b 03 c0       	push   $0xc0031b9c
c00276e9:	e8 39 0f 00 00       	call   c0028627 <debug_panic>
    s++;
c00276ee:	42                   	inc    %edx
  while (isspace ((unsigned char) *s))
c00276ef:	8a 02                	mov    (%edx),%al
          || c == '\r' || c == '\t' || c == '\v');
c00276f1:	3c 20                	cmp    $0x20,%al
c00276f3:	74 f9                	je     c00276ee <atoi+0x2b>
c00276f5:	8d 48 f7             	lea    -0x9(%eax),%ecx
c00276f8:	80 f9 04             	cmp    $0x4,%cl
c00276fb:	76 f1                	jbe    c00276ee <atoi+0x2b>
  if (*s == '+')
c00276fd:	3c 2b                	cmp    $0x2b,%al
c00276ff:	74 3e                	je     c002773f <atoi+0x7c>
  else if (*s == '-')
c0027701:	3c 2d                	cmp    $0x2d,%al
c0027703:	74 3d                	je     c0027742 <atoi+0x7f>
  for (value = 0; isdigit (*s); s++)
c0027705:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027708:	8d 41 d0             	lea    -0x30(%ecx),%eax
c002770b:	be 00 00 00 00       	mov    $0x0,%esi
c0027710:	83 f8 09             	cmp    $0x9,%eax
c0027713:	77 4c                	ja     c0027761 <atoi+0x9e>
      negative = true;
c0027715:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c002771a:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002771d:	89 c3                	mov    %eax,%ebx
c002771f:	29 cb                	sub    %ecx,%ebx
c0027721:	8d 44 03 30          	lea    0x30(%ebx,%eax,1),%eax
  for (value = 0; isdigit (*s); s++)
c0027725:	42                   	inc    %edx
c0027726:	0f be 0a             	movsbl (%edx),%ecx
c0027729:	8d 59 d0             	lea    -0x30(%ecx),%ebx
c002772c:	83 fb 09             	cmp    $0x9,%ebx
c002772f:	76 e9                	jbe    c002771a <atoi+0x57>
  if (!negative)
c0027731:	89 f3                	mov    %esi,%ebx
c0027733:	84 db                	test   %bl,%bl
c0027735:	75 02                	jne    c0027739 <atoi+0x76>
    value = -value;
c0027737:	f7 d8                	neg    %eax
}
c0027739:	83 c4 04             	add    $0x4,%esp
c002773c:	5b                   	pop    %ebx
c002773d:	5e                   	pop    %esi
c002773e:	c3                   	ret    
    s++;
c002773f:	42                   	inc    %edx
c0027740:	eb c3                	jmp    c0027705 <atoi+0x42>
      s++;
c0027742:	8d 42 01             	lea    0x1(%edx),%eax
  for (value = 0; isdigit (*s); s++)
c0027745:	0f be 4a 01          	movsbl 0x1(%edx),%ecx
c0027749:	8d 51 d0             	lea    -0x30(%ecx),%edx
c002774c:	83 fa 09             	cmp    $0x9,%edx
c002774f:	77 09                	ja     c002775a <atoi+0x97>
      s++;
c0027751:	89 c2                	mov    %eax,%edx
      negative = true;
c0027753:	be 01 00 00 00       	mov    $0x1,%esi
c0027758:	eb bb                	jmp    c0027715 <atoi+0x52>
  for (value = 0; isdigit (*s); s++)
c002775a:	b8 00 00 00 00       	mov    $0x0,%eax
  return value;
c002775f:	eb d8                	jmp    c0027739 <atoi+0x76>
  for (value = 0; isdigit (*s); s++)
c0027761:	b8 00 00 00 00       	mov    $0x0,%eax
c0027766:	eb cf                	jmp    c0027737 <atoi+0x74>

c0027768 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c0027768:	55                   	push   %ebp
c0027769:	57                   	push   %edi
c002776a:	56                   	push   %esi
c002776b:	53                   	push   %ebx
c002776c:	83 ec 0c             	sub    $0xc,%esp
c002776f:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c0027773:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0027777:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002777b:	8b 74 24 30          	mov    0x30(%esp),%esi
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c002777f:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0027784:	74 7b                	je     c0027801 <sort+0x99>
  ASSERT (compare != NULL);
c0027786:	85 ed                	test   %ebp,%ebp
c0027788:	0f 84 98 00 00 00    	je     c0027826 <sort+0xbe>
  ASSERT (size > 0);
c002778e:	85 ff                	test   %edi,%edi
c0027790:	0f 84 b1 00 00 00    	je     c0027847 <sort+0xdf>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0027796:	89 d8                	mov    %ebx,%eax
c0027798:	d1 e8                	shr    %eax
c002779a:	74 25                	je     c00277c1 <sort+0x59>
c002779c:	89 5c 24 24          	mov    %ebx,0x24(%esp)
c00277a0:	89 c3                	mov    %eax,%ebx
    heapify (array, i, cnt, size, compare, aux);
c00277a2:	83 ec 04             	sub    $0x4,%esp
c00277a5:	56                   	push   %esi
c00277a6:	55                   	push   %ebp
c00277a7:	57                   	push   %edi
c00277a8:	8b 4c 24 34          	mov    0x34(%esp),%ecx
c00277ac:	89 da                	mov    %ebx,%edx
c00277ae:	8b 44 24 30          	mov    0x30(%esp),%eax
c00277b2:	e8 3e fe ff ff       	call   c00275f5 <heapify>
  for (i = cnt / 2; i > 0; i--)
c00277b7:	83 c4 10             	add    $0x10,%esp
c00277ba:	4b                   	dec    %ebx
c00277bb:	75 e5                	jne    c00277a2 <sort+0x3a>
c00277bd:	8b 5c 24 24          	mov    0x24(%esp),%ebx

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c00277c1:	83 fb 01             	cmp    $0x1,%ebx
c00277c4:	76 33                	jbe    c00277f9 <sort+0x91>
    {
      do_swap (array, 1, i, size);
c00277c6:	83 ec 0c             	sub    $0xc,%esp
c00277c9:	57                   	push   %edi
c00277ca:	89 d9                	mov    %ebx,%ecx
c00277cc:	ba 01 00 00 00       	mov    $0x1,%edx
c00277d1:	8b 44 24 30          	mov    0x30(%esp),%eax
c00277d5:	e8 e1 fd ff ff       	call   c00275bb <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c00277da:	4b                   	dec    %ebx
c00277db:	83 c4 0c             	add    $0xc,%esp
c00277de:	56                   	push   %esi
c00277df:	55                   	push   %ebp
c00277e0:	57                   	push   %edi
c00277e1:	89 d9                	mov    %ebx,%ecx
c00277e3:	ba 01 00 00 00       	mov    $0x1,%edx
c00277e8:	8b 44 24 30          	mov    0x30(%esp),%eax
c00277ec:	e8 04 fe ff ff       	call   c00275f5 <heapify>
  for (i = cnt; i > 1; i--) 
c00277f1:	83 c4 10             	add    $0x10,%esp
c00277f4:	83 fb 01             	cmp    $0x1,%ebx
c00277f7:	75 cd                	jne    c00277c6 <sort+0x5e>
    }
}
c00277f9:	83 c4 0c             	add    $0xc,%esp
c00277fc:	5b                   	pop    %ebx
c00277fd:	5e                   	pop    %esi
c00277fe:	5f                   	pop    %edi
c00277ff:	5d                   	pop    %ebp
c0027800:	c3                   	ret    
  ASSERT (array != NULL || cnt == 0);
c0027801:	85 db                	test   %ebx,%ebx
c0027803:	74 81                	je     c0027786 <sort+0x1e>
c0027805:	83 ec 0c             	sub    $0xc,%esp
c0027808:	68 af 1b 03 c0       	push   $0xc0031baf
c002780d:	68 21 01 03 c0       	push   $0xc0030121
c0027812:	68 d0 fb 02 c0       	push   $0xc002fbd0
c0027817:	68 8a 00 00 00       	push   $0x8a
c002781c:	68 9c 1b 03 c0       	push   $0xc0031b9c
c0027821:	e8 01 0e 00 00       	call   c0028627 <debug_panic>
  ASSERT (compare != NULL);
c0027826:	83 ec 0c             	sub    $0xc,%esp
c0027829:	68 c9 1b 03 c0       	push   $0xc0031bc9
c002782e:	68 21 01 03 c0       	push   $0xc0030121
c0027833:	68 d0 fb 02 c0       	push   $0xc002fbd0
c0027838:	68 8b 00 00 00       	push   $0x8b
c002783d:	68 9c 1b 03 c0       	push   $0xc0031b9c
c0027842:	e8 e0 0d 00 00       	call   c0028627 <debug_panic>
  ASSERT (size > 0);
c0027847:	83 ec 0c             	sub    $0xc,%esp
c002784a:	68 d9 1b 03 c0       	push   $0xc0031bd9
c002784f:	68 21 01 03 c0       	push   $0xc0030121
c0027854:	68 d0 fb 02 c0       	push   $0xc002fbd0
c0027859:	68 8c 00 00 00       	push   $0x8c
c002785e:	68 9c 1b 03 c0       	push   $0xc0031b9c
c0027863:	e8 bf 0d 00 00       	call   c0028627 <debug_panic>

c0027868 <qsort>:
{
c0027868:	83 ec 18             	sub    $0x18,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c002786b:	8d 44 24 28          	lea    0x28(%esp),%eax
c002786f:	50                   	push   %eax
c0027870:	68 a6 75 02 c0       	push   $0xc00275a6
c0027875:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027879:	ff 74 24 2c          	pushl  0x2c(%esp)
c002787d:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027881:	e8 e2 fe ff ff       	call   c0027768 <sort>
}
c0027886:	83 c4 2c             	add    $0x2c,%esp
c0027889:	c3                   	ret    

c002788a <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c002788a:	55                   	push   %ebp
c002788b:	57                   	push   %edi
c002788c:	56                   	push   %esi
c002788d:	53                   	push   %ebx
c002788e:	83 ec 0c             	sub    $0xc,%esp
c0027891:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027895:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c0027899:	89 fd                	mov    %edi,%ebp
c002789b:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c00278a0:	01 f5                	add    %esi,%ebp

  while (first < last) 
c00278a2:	39 ee                	cmp    %ebp,%esi
c00278a4:	72 0d                	jb     c00278b3 <binary_search+0x29>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c00278a6:	b8 00 00 00 00       	mov    $0x0,%eax
c00278ab:	eb 3e                	jmp    c00278eb <binary_search+0x61>
      const unsigned char *middle = first + (range / 2) * size;
c00278ad:	89 dd                	mov    %ebx,%ebp
  while (first < last) 
c00278af:	39 ee                	cmp    %ebp,%esi
c00278b1:	73 33                	jae    c00278e6 <binary_search+0x5c>
      size_t range = (last - first) / size;
c00278b3:	89 e8                	mov    %ebp,%eax
c00278b5:	29 f0                	sub    %esi,%eax
c00278b7:	ba 00 00 00 00       	mov    $0x0,%edx
c00278bc:	f7 f7                	div    %edi
      const unsigned char *middle = first + (range / 2) * size;
c00278be:	d1 e8                	shr    %eax
c00278c0:	0f af c7             	imul   %edi,%eax
c00278c3:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c00278c6:	83 ec 04             	sub    $0x4,%esp
c00278c9:	ff 74 24 38          	pushl  0x38(%esp)
c00278cd:	53                   	push   %ebx
c00278ce:	ff 74 24 2c          	pushl  0x2c(%esp)
c00278d2:	ff 54 24 40          	call   *0x40(%esp)
      if (cmp < 0) 
c00278d6:	83 c4 10             	add    $0x10,%esp
c00278d9:	85 c0                	test   %eax,%eax
c00278db:	78 d0                	js     c00278ad <binary_search+0x23>
      else if (cmp > 0) 
c00278dd:	85 c0                	test   %eax,%eax
c00278df:	7e 12                	jle    c00278f3 <binary_search+0x69>
        first = middle + size;
c00278e1:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c00278e4:	eb c9                	jmp    c00278af <binary_search+0x25>
  return NULL;
c00278e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00278eb:	83 c4 0c             	add    $0xc,%esp
c00278ee:	5b                   	pop    %ebx
c00278ef:	5e                   	pop    %esi
c00278f0:	5f                   	pop    %edi
c00278f1:	5d                   	pop    %ebp
c00278f2:	c3                   	ret    
      const unsigned char *middle = first + (range / 2) * size;
c00278f3:	89 d8                	mov    %ebx,%eax
c00278f5:	eb f4                	jmp    c00278eb <binary_search+0x61>

c00278f7 <bsearch>:
{
c00278f7:	83 ec 14             	sub    $0x14,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00278fa:	8d 44 24 28          	lea    0x28(%esp),%eax
c00278fe:	50                   	push   %eax
c00278ff:	68 a6 75 02 c0       	push   $0xc00275a6
c0027904:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027908:	ff 74 24 2c          	pushl  0x2c(%esp)
c002790c:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027910:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027914:	e8 71 ff ff ff       	call   c002788a <binary_search>
}
c0027919:	83 c4 2c             	add    $0x2c,%esp
c002791c:	c3                   	ret    

c002791d <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c002791d:	56                   	push   %esi
c002791e:	53                   	push   %ebx
c002791f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027923:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0027927:	8b 74 24 14          	mov    0x14(%esp),%esi
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c002792b:	85 f6                	test   %esi,%esi
c002792d:	74 10                	je     c002793f <memcpy+0x22>
c002792f:	ba 00 00 00 00       	mov    $0x0,%edx
    *dst++ = *src++;
c0027934:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
c0027937:	88 0c 10             	mov    %cl,(%eax,%edx,1)
c002793a:	42                   	inc    %edx
  while (size-- > 0)
c002793b:	39 f2                	cmp    %esi,%edx
c002793d:	75 f5                	jne    c0027934 <memcpy+0x17>

  return dst_;
}
c002793f:	5b                   	pop    %ebx
c0027940:	5e                   	pop    %esi
c0027941:	c3                   	ret    

c0027942 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c0027942:	57                   	push   %edi
c0027943:	56                   	push   %esi
c0027944:	53                   	push   %ebx
c0027945:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0027949:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002794d:	8b 74 24 18          	mov    0x18(%esp),%esi
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
c0027951:	39 d9                	cmp    %ebx,%ecx
c0027953:	73 1d                	jae    c0027972 <memmove+0x30>
    {
      while (size-- > 0)
c0027955:	85 f6                	test   %esi,%esi
c0027957:	74 35                	je     c002798e <memmove+0x4c>
c0027959:	b8 00 00 00 00       	mov    $0x0,%eax
        *dst++ = *src++;
c002795e:	8a 14 03             	mov    (%ebx,%eax,1),%dl
c0027961:	88 14 01             	mov    %dl,(%ecx,%eax,1)
c0027964:	40                   	inc    %eax
      while (size-- > 0)
c0027965:	39 f0                	cmp    %esi,%eax
c0027967:	75 f5                	jne    c002795e <memmove+0x1c>
c0027969:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c002796c:	89 f8                	mov    %edi,%eax
c002796e:	5b                   	pop    %ebx
c002796f:	5e                   	pop    %esi
c0027970:	5f                   	pop    %edi
c0027971:	c3                   	ret    
      dst += size;
c0027972:	8d 3c 31             	lea    (%ecx,%esi,1),%edi
      while (size-- > 0)
c0027975:	8d 56 ff             	lea    -0x1(%esi),%edx
c0027978:	85 f6                	test   %esi,%esi
c002797a:	74 f0                	je     c002796c <memmove+0x2a>
c002797c:	89 ce                	mov    %ecx,%esi
c002797e:	89 f7                	mov    %esi,%edi
        *--dst = *--src;
c0027980:	8a 04 13             	mov    (%ebx,%edx,1),%al
c0027983:	88 04 11             	mov    %al,(%ecx,%edx,1)
      while (size-- > 0)
c0027986:	4a                   	dec    %edx
c0027987:	83 fa ff             	cmp    $0xffffffff,%edx
c002798a:	75 f2                	jne    c002797e <memmove+0x3c>
c002798c:	eb de                	jmp    c002796c <memmove+0x2a>
      while (size-- > 0)
c002798e:	89 cf                	mov    %ecx,%edi
c0027990:	eb da                	jmp    c002796c <memmove+0x2a>

c0027992 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0027992:	57                   	push   %edi
c0027993:	56                   	push   %esi
c0027994:	53                   	push   %ebx
c0027995:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027999:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002799d:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c00279a1:	85 db                	test   %ebx,%ebx
c00279a3:	74 30                	je     c00279d5 <memcmp+0x43>
    if (*a != *b)
c00279a5:	8a 16                	mov    (%esi),%dl
c00279a7:	8a 0f                	mov    (%edi),%cl
c00279a9:	38 ca                	cmp    %cl,%dl
c00279ab:	75 15                	jne    c00279c2 <memcmp+0x30>
c00279ad:	b8 01 00 00 00       	mov    $0x1,%eax
  for (; size-- > 0; a++, b++)
c00279b2:	39 d8                	cmp    %ebx,%eax
c00279b4:	74 18                	je     c00279ce <memcmp+0x3c>
    if (*a != *b)
c00279b6:	8a 14 06             	mov    (%esi,%eax,1),%dl
c00279b9:	40                   	inc    %eax
c00279ba:	8a 4c 07 ff          	mov    -0x1(%edi,%eax,1),%cl
c00279be:	38 ca                	cmp    %cl,%dl
c00279c0:	74 f0                	je     c00279b2 <memcmp+0x20>
      return *a > *b ? +1 : -1;
c00279c2:	38 d1                	cmp    %dl,%cl
c00279c4:	19 c0                	sbb    %eax,%eax
c00279c6:	83 e0 02             	and    $0x2,%eax
c00279c9:	48                   	dec    %eax
  return 0;
}
c00279ca:	5b                   	pop    %ebx
c00279cb:	5e                   	pop    %esi
c00279cc:	5f                   	pop    %edi
c00279cd:	c3                   	ret    
  return 0;
c00279ce:	b8 00 00 00 00       	mov    $0x0,%eax
c00279d3:	eb f5                	jmp    c00279ca <memcmp+0x38>
c00279d5:	b8 00 00 00 00       	mov    $0x0,%eax
c00279da:	eb ee                	jmp    c00279ca <memcmp+0x38>

c00279dc <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c00279dc:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00279e0:	8b 44 24 08          	mov    0x8(%esp),%eax
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c00279e4:	8a 11                	mov    (%ecx),%dl
c00279e6:	84 d2                	test   %dl,%dl
c00279e8:	74 10                	je     c00279fa <strcmp+0x1e>
c00279ea:	3a 10                	cmp    (%eax),%dl
c00279ec:	75 0c                	jne    c00279fa <strcmp+0x1e>
    {
      a++;
c00279ee:	41                   	inc    %ecx
      b++;
c00279ef:	40                   	inc    %eax
  while (*a != '\0' && *a == *b) 
c00279f0:	8a 11                	mov    (%ecx),%dl
c00279f2:	84 d2                	test   %dl,%dl
c00279f4:	74 04                	je     c00279fa <strcmp+0x1e>
c00279f6:	3a 10                	cmp    (%eax),%dl
c00279f8:	74 f4                	je     c00279ee <strcmp+0x12>
    }

  return *a < *b ? -1 : *a > *b;
c00279fa:	8a 00                	mov    (%eax),%al
c00279fc:	38 d0                	cmp    %dl,%al
c00279fe:	77 07                	ja     c0027a07 <strcmp+0x2b>
c0027a00:	0f 92 c0             	setb   %al
c0027a03:	0f b6 c0             	movzbl %al,%eax
c0027a06:	c3                   	ret    
c0027a07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0027a0c:	c3                   	ret    

c0027a0d <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0027a0d:	53                   	push   %ebx
c0027a0e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027a12:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027a16:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0027a1a:	85 d2                	test   %edx,%edx
c0027a1c:	74 1a                	je     c0027a38 <memchr+0x2b>
c0027a1e:	88 d9                	mov    %bl,%cl
    if (*block == ch)
c0027a20:	3a 18                	cmp    (%eax),%bl
c0027a22:	74 12                	je     c0027a36 <memchr+0x29>
c0027a24:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c0027a26:	40                   	inc    %eax
c0027a27:	39 c2                	cmp    %eax,%edx
c0027a29:	74 06                	je     c0027a31 <memchr+0x24>
    if (*block == ch)
c0027a2b:	3a 08                	cmp    (%eax),%cl
c0027a2d:	75 f7                	jne    c0027a26 <memchr+0x19>
c0027a2f:	eb 05                	jmp    c0027a36 <memchr+0x29>
      return (void *) block;

  return NULL;
c0027a31:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0027a36:	5b                   	pop    %ebx
c0027a37:	c3                   	ret    
  return NULL;
c0027a38:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a3d:	eb f7                	jmp    c0027a36 <memchr+0x29>

c0027a3f <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c0027a3f:	53                   	push   %ebx
c0027a40:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027a44:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c0027a48:	8a 18                	mov    (%eax),%bl
c0027a4a:	38 da                	cmp    %bl,%dl
c0027a4c:	74 16                	je     c0027a64 <strchr+0x25>
c0027a4e:	88 d1                	mov    %dl,%cl
      return (char *) string;
    else if (*string == '\0')
c0027a50:	84 db                	test   %bl,%bl
c0027a52:	74 12                	je     c0027a66 <strchr+0x27>
      return NULL;
    else
      string++;
c0027a54:	40                   	inc    %eax
    if (*string == c)
c0027a55:	8a 10                	mov    (%eax),%dl
c0027a57:	38 d1                	cmp    %dl,%cl
c0027a59:	74 09                	je     c0027a64 <strchr+0x25>
    else if (*string == '\0')
c0027a5b:	84 d2                	test   %dl,%dl
c0027a5d:	75 f5                	jne    c0027a54 <strchr+0x15>
      return NULL;
c0027a5f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0027a64:	5b                   	pop    %ebx
c0027a65:	c3                   	ret    
      return NULL;
c0027a66:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a6b:	eb f7                	jmp    c0027a64 <strchr+0x25>

c0027a6d <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c0027a6d:	57                   	push   %edi
c0027a6e:	56                   	push   %esi
c0027a6f:	53                   	push   %ebx
c0027a70:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027a74:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0027a78:	8a 06                	mov    (%esi),%al
c0027a7a:	84 c0                	test   %al,%al
c0027a7c:	74 24                	je     c0027aa2 <strcspn+0x35>
c0027a7e:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c0027a83:	0f be c0             	movsbl %al,%eax
c0027a86:	50                   	push   %eax
c0027a87:	57                   	push   %edi
c0027a88:	e8 b2 ff ff ff       	call   c0027a3f <strchr>
c0027a8d:	83 c4 08             	add    $0x8,%esp
c0027a90:	85 c0                	test   %eax,%eax
c0027a92:	75 08                	jne    c0027a9c <strcspn+0x2f>
  for (length = 0; string[length] != '\0'; length++)
c0027a94:	43                   	inc    %ebx
c0027a95:	8a 04 1e             	mov    (%esi,%ebx,1),%al
c0027a98:	84 c0                	test   %al,%al
c0027a9a:	75 e7                	jne    c0027a83 <strcspn+0x16>
      break;
  return length;
}
c0027a9c:	89 d8                	mov    %ebx,%eax
c0027a9e:	5b                   	pop    %ebx
c0027a9f:	5e                   	pop    %esi
c0027aa0:	5f                   	pop    %edi
c0027aa1:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0027aa2:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0027aa7:	eb f3                	jmp    c0027a9c <strcspn+0x2f>

c0027aa9 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c0027aa9:	56                   	push   %esi
c0027aaa:	53                   	push   %ebx
c0027aab:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027aaf:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c0027ab3:	8a 13                	mov    (%ebx),%dl
c0027ab5:	84 d2                	test   %dl,%dl
c0027ab7:	74 1a                	je     c0027ad3 <strpbrk+0x2a>
    if (strchr (stop, *string) != NULL)
c0027ab9:	0f be d2             	movsbl %dl,%edx
c0027abc:	52                   	push   %edx
c0027abd:	56                   	push   %esi
c0027abe:	e8 7c ff ff ff       	call   c0027a3f <strchr>
c0027ac3:	83 c4 08             	add    $0x8,%esp
c0027ac6:	85 c0                	test   %eax,%eax
c0027ac8:	75 10                	jne    c0027ada <strpbrk+0x31>
  for (; *string != '\0'; string++)
c0027aca:	43                   	inc    %ebx
c0027acb:	8a 13                	mov    (%ebx),%dl
c0027acd:	84 d2                	test   %dl,%dl
c0027acf:	75 e8                	jne    c0027ab9 <strpbrk+0x10>
c0027ad1:	eb 09                	jmp    c0027adc <strpbrk+0x33>
      return (char *) string;
  return NULL;
c0027ad3:	b8 00 00 00 00       	mov    $0x0,%eax
c0027ad8:	eb 02                	jmp    c0027adc <strpbrk+0x33>
c0027ada:	89 d8                	mov    %ebx,%eax
}
c0027adc:	5b                   	pop    %ebx
c0027add:	5e                   	pop    %esi
c0027ade:	c3                   	ret    

c0027adf <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0027adf:	53                   	push   %ebx
c0027ae0:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c0027ae4:	8a 5c 24 0c          	mov    0xc(%esp),%bl
  const char *p = NULL;

  for (; *string != '\0'; string++)
c0027ae8:	8a 0a                	mov    (%edx),%cl
c0027aea:	84 c9                	test   %cl,%cl
c0027aec:	74 16                	je     c0027b04 <strrchr+0x25>
c0027aee:	b8 00 00 00 00       	mov    $0x0,%eax
c0027af3:	eb 07                	jmp    c0027afc <strrchr+0x1d>
c0027af5:	42                   	inc    %edx
c0027af6:	8a 0a                	mov    (%edx),%cl
c0027af8:	84 c9                	test   %cl,%cl
c0027afa:	74 0d                	je     c0027b09 <strrchr+0x2a>
    if (*string == c)
c0027afc:	38 cb                	cmp    %cl,%bl
c0027afe:	75 f5                	jne    c0027af5 <strrchr+0x16>
c0027b00:	89 d0                	mov    %edx,%eax
c0027b02:	eb f1                	jmp    c0027af5 <strrchr+0x16>
  const char *p = NULL;
c0027b04:	b8 00 00 00 00       	mov    $0x0,%eax
      p = string;
  return (char *) p;
}
c0027b09:	5b                   	pop    %ebx
c0027b0a:	c3                   	ret    

c0027b0b <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0027b0b:	57                   	push   %edi
c0027b0c:	56                   	push   %esi
c0027b0d:	53                   	push   %ebx
c0027b0e:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027b12:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0027b16:	8a 06                	mov    (%esi),%al
c0027b18:	84 c0                	test   %al,%al
c0027b1a:	74 24                	je     c0027b40 <strspn+0x35>
c0027b1c:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c0027b21:	0f be c0             	movsbl %al,%eax
c0027b24:	50                   	push   %eax
c0027b25:	57                   	push   %edi
c0027b26:	e8 14 ff ff ff       	call   c0027a3f <strchr>
c0027b2b:	83 c4 08             	add    $0x8,%esp
c0027b2e:	85 c0                	test   %eax,%eax
c0027b30:	74 08                	je     c0027b3a <strspn+0x2f>
  for (length = 0; string[length] != '\0'; length++)
c0027b32:	43                   	inc    %ebx
c0027b33:	8a 04 1e             	mov    (%esi,%ebx,1),%al
c0027b36:	84 c0                	test   %al,%al
c0027b38:	75 e7                	jne    c0027b21 <strspn+0x16>
      break;
  return length;
}
c0027b3a:	89 d8                	mov    %ebx,%eax
c0027b3c:	5b                   	pop    %ebx
c0027b3d:	5e                   	pop    %esi
c0027b3e:	5f                   	pop    %edi
c0027b3f:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0027b40:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0027b45:	eb f3                	jmp    c0027b3a <strspn+0x2f>

c0027b47 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0027b47:	55                   	push   %ebp
c0027b48:	57                   	push   %edi
c0027b49:	56                   	push   %esi
c0027b4a:	53                   	push   %ebx
c0027b4b:	83 ec 1c             	sub    $0x1c,%esp
c0027b4e:	8b 74 24 30          	mov    0x30(%esp),%esi
c0027b52:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
c0027b56:	85 ff                	test   %edi,%edi
c0027b58:	74 2c                	je     c0027b86 <strtok_r+0x3f>
  ASSERT (save_ptr != NULL);
c0027b5a:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0027b5f:	74 46                	je     c0027ba7 <strtok_r+0x60>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0027b61:	85 f6                	test   %esi,%esi
c0027b63:	74 63                	je     c0027bc8 <strtok_r+0x81>
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c0027b65:	8a 1e                	mov    (%esi),%bl
c0027b67:	83 ec 08             	sub    $0x8,%esp
c0027b6a:	0f be c3             	movsbl %bl,%eax
c0027b6d:	50                   	push   %eax
c0027b6e:	57                   	push   %edi
c0027b6f:	e8 cb fe ff ff       	call   c0027a3f <strchr>
c0027b74:	83 c4 10             	add    $0x10,%esp
c0027b77:	85 c0                	test   %eax,%eax
c0027b79:	0f 84 87 00 00 00    	je     c0027c06 <strtok_r+0xbf>
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0027b7f:	84 db                	test   %bl,%bl
c0027b81:	74 70                	je     c0027bf3 <strtok_r+0xac>
        {
          *save_ptr = s;
          return NULL;
        }

      s++;
c0027b83:	46                   	inc    %esi
c0027b84:	eb df                	jmp    c0027b65 <strtok_r+0x1e>
  ASSERT (delimiters != NULL);
c0027b86:	83 ec 0c             	sub    $0xc,%esp
c0027b89:	68 e2 1b 03 c0       	push   $0xc0031be2
c0027b8e:	68 21 01 03 c0       	push   $0xc0030121
c0027b93:	68 f0 fb 02 c0       	push   $0xc002fbf0
c0027b98:	68 ef 00 00 00       	push   $0xef
c0027b9d:	68 f5 1b 03 c0       	push   $0xc0031bf5
c0027ba2:	e8 80 0a 00 00       	call   c0028627 <debug_panic>
  ASSERT (save_ptr != NULL);
c0027ba7:	83 ec 0c             	sub    $0xc,%esp
c0027baa:	68 08 1c 03 c0       	push   $0xc0031c08
c0027baf:	68 21 01 03 c0       	push   $0xc0030121
c0027bb4:	68 f0 fb 02 c0       	push   $0xc002fbf0
c0027bb9:	68 f0 00 00 00       	push   $0xf0
c0027bbe:	68 f5 1b 03 c0       	push   $0xc0031bf5
c0027bc3:	e8 5f 0a 00 00       	call   c0028627 <debug_panic>
    s = *save_ptr;
c0027bc8:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027bcc:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
c0027bce:	85 f6                	test   %esi,%esi
c0027bd0:	75 93                	jne    c0027b65 <strtok_r+0x1e>
c0027bd2:	83 ec 0c             	sub    $0xc,%esp
c0027bd5:	68 eb 1b 03 c0       	push   $0xc0031beb
c0027bda:	68 21 01 03 c0       	push   $0xc0030121
c0027bdf:	68 f0 fb 02 c0       	push   $0xc002fbf0
c0027be4:	68 f6 00 00 00       	push   $0xf6
c0027be9:	68 f5 1b 03 c0       	push   $0xc0031bf5
c0027bee:	e8 34 0a 00 00       	call   c0028627 <debug_panic>
          *save_ptr = s;
c0027bf3:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027bf7:	89 30                	mov    %esi,(%eax)
          return NULL;
c0027bf9:	b8 00 00 00 00       	mov    $0x0,%eax
      *save_ptr = s + 1;
    }
  else 
    *save_ptr = s;
  return token;
}
c0027bfe:	83 c4 1c             	add    $0x1c,%esp
c0027c01:	5b                   	pop    %ebx
c0027c02:	5e                   	pop    %esi
c0027c03:	5f                   	pop    %edi
c0027c04:	5d                   	pop    %ebp
c0027c05:	c3                   	ret    
c0027c06:	89 f5                	mov    %esi,%ebp
c0027c08:	eb 04                	jmp    c0027c0e <strtok_r+0xc7>
    s++;
c0027c0a:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c0027c0e:	8d 45 01             	lea    0x1(%ebp),%eax
c0027c11:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (strchr (delimiters, *s) == NULL)
c0027c15:	8a 5d 01             	mov    0x1(%ebp),%bl
c0027c18:	83 ec 08             	sub    $0x8,%esp
c0027c1b:	0f be c3             	movsbl %bl,%eax
c0027c1e:	50                   	push   %eax
c0027c1f:	57                   	push   %edi
c0027c20:	e8 1a fe ff ff       	call   c0027a3f <strchr>
c0027c25:	83 c4 10             	add    $0x10,%esp
c0027c28:	85 c0                	test   %eax,%eax
c0027c2a:	74 de                	je     c0027c0a <strtok_r+0xc3>
  if (*s != '\0') 
c0027c2c:	84 db                	test   %bl,%bl
c0027c2e:	75 0e                	jne    c0027c3e <strtok_r+0xf7>
    *save_ptr = s;
c0027c30:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027c34:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027c38:	89 10                	mov    %edx,(%eax)
c0027c3a:	89 f0                	mov    %esi,%eax
c0027c3c:	eb c0                	jmp    c0027bfe <strtok_r+0xb7>
      *s = '\0';
c0027c3e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027c42:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0027c45:	83 c5 02             	add    $0x2,%ebp
c0027c48:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027c4c:	89 28                	mov    %ebp,(%eax)
c0027c4e:	89 f0                	mov    %esi,%eax
c0027c50:	eb ac                	jmp    c0027bfe <strtok_r+0xb7>

c0027c52 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0027c52:	53                   	push   %ebx
c0027c53:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027c57:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027c5b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0027c5f:	85 c9                	test   %ecx,%ecx
c0027c61:	74 0c                	je     c0027c6f <memset+0x1d>
c0027c63:	01 c1                	add    %eax,%ecx
c0027c65:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c0027c67:	42                   	inc    %edx
c0027c68:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c0027c6b:	39 d1                	cmp    %edx,%ecx
c0027c6d:	75 f8                	jne    c0027c67 <memset+0x15>

  return dst_;
}
c0027c6f:	5b                   	pop    %ebx
c0027c70:	c3                   	ret    

c0027c71 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0027c71:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT (string != NULL);

  for (p = string; *p != '\0'; p++)
c0027c75:	80 3a 00             	cmpb   $0x0,(%edx)
c0027c78:	74 0b                	je     c0027c85 <strlen+0x14>
c0027c7a:	89 d0                	mov    %edx,%eax
c0027c7c:	40                   	inc    %eax
c0027c7d:	80 38 00             	cmpb   $0x0,(%eax)
c0027c80:	75 fa                	jne    c0027c7c <strlen+0xb>
    continue;
  return p - string;
c0027c82:	29 d0                	sub    %edx,%eax
}
c0027c84:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c0027c85:	89 d0                	mov    %edx,%eax
c0027c87:	eb f9                	jmp    c0027c82 <strlen+0x11>

c0027c89 <strstr>:
{
c0027c89:	55                   	push   %ebp
c0027c8a:	57                   	push   %edi
c0027c8b:	56                   	push   %esi
c0027c8c:	53                   	push   %ebx
c0027c8d:	83 ec 04             	sub    $0x4,%esp
c0027c90:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c0027c94:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0027c99:	b0 00                	mov    $0x0,%al
c0027c9b:	89 d9                	mov    %ebx,%ecx
c0027c9d:	8b 7c 24 18          	mov    0x18(%esp),%edi
c0027ca1:	f2 ae                	repnz scas %es:(%edi),%al
c0027ca3:	f7 d1                	not    %ecx
c0027ca5:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c0027ca8:	89 d9                	mov    %ebx,%ecx
c0027caa:	89 ef                	mov    %ebp,%edi
c0027cac:	f2 ae                	repnz scas %es:(%edi),%al
c0027cae:	89 c8                	mov    %ecx,%eax
c0027cb0:	f7 d0                	not    %eax
c0027cb2:	8d 78 ff             	lea    -0x1(%eax),%edi
  if (haystack_len >= needle_len) 
c0027cb5:	39 fa                	cmp    %edi,%edx
c0027cb7:	72 2c                	jb     c0027ce5 <strstr+0x5c>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0027cb9:	29 fa                	sub    %edi,%edx
c0027cbb:	89 14 24             	mov    %edx,(%esp)
c0027cbe:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027cc3:	89 de                	mov    %ebx,%esi
c0027cc5:	03 74 24 18          	add    0x18(%esp),%esi
        if (!memcmp (haystack + i, needle, needle_len))
c0027cc9:	57                   	push   %edi
c0027cca:	55                   	push   %ebp
c0027ccb:	56                   	push   %esi
c0027ccc:	e8 c1 fc ff ff       	call   c0027992 <memcmp>
c0027cd1:	83 c4 0c             	add    $0xc,%esp
c0027cd4:	85 c0                	test   %eax,%eax
c0027cd6:	74 14                	je     c0027cec <strstr+0x63>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0027cd8:	43                   	inc    %ebx
c0027cd9:	3b 1c 24             	cmp    (%esp),%ebx
c0027cdc:	76 e5                	jbe    c0027cc3 <strstr+0x3a>
  return NULL;
c0027cde:	b8 00 00 00 00       	mov    $0x0,%eax
c0027ce3:	eb 09                	jmp    c0027cee <strstr+0x65>
c0027ce5:	b8 00 00 00 00       	mov    $0x0,%eax
c0027cea:	eb 02                	jmp    c0027cee <strstr+0x65>
        if (!memcmp (haystack + i, needle, needle_len))
c0027cec:	89 f0                	mov    %esi,%eax
}
c0027cee:	83 c4 04             	add    $0x4,%esp
c0027cf1:	5b                   	pop    %ebx
c0027cf2:	5e                   	pop    %esi
c0027cf3:	5f                   	pop    %edi
c0027cf4:	5d                   	pop    %ebp
c0027cf5:	c3                   	ret    

c0027cf6 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c0027cf6:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0027cfa:	8b 54 24 08          	mov    0x8(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0027cfe:	80 39 00             	cmpb   $0x0,(%ecx)
c0027d01:	74 15                	je     c0027d18 <strnlen+0x22>
c0027d03:	85 d2                	test   %edx,%edx
c0027d05:	74 17                	je     c0027d1e <strnlen+0x28>
c0027d07:	b8 00 00 00 00       	mov    $0x0,%eax
c0027d0c:	40                   	inc    %eax
c0027d0d:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
c0027d11:	74 0d                	je     c0027d20 <strnlen+0x2a>
c0027d13:	39 c2                	cmp    %eax,%edx
c0027d15:	75 f5                	jne    c0027d0c <strnlen+0x16>
c0027d17:	c3                   	ret    
c0027d18:	b8 00 00 00 00       	mov    $0x0,%eax
c0027d1d:	c3                   	ret    
c0027d1e:	89 d0                	mov    %edx,%eax
    continue;
  return length;
}
c0027d20:	c3                   	ret    

c0027d21 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0027d21:	55                   	push   %ebp
c0027d22:	57                   	push   %edi
c0027d23:	56                   	push   %esi
c0027d24:	53                   	push   %ebx
c0027d25:	83 ec 0c             	sub    $0xc,%esp
c0027d28:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0027d2c:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027d30:	8b 54 24 28          	mov    0x28(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c0027d34:	85 db                	test   %ebx,%ebx
c0027d36:	74 33                	je     c0027d6b <strlcpy+0x4a>
  ASSERT (src != NULL);
c0027d38:	85 f6                	test   %esi,%esi
c0027d3a:	74 50                	je     c0027d8c <strlcpy+0x6b>

  src_len = strlen (src);
c0027d3c:	b0 00                	mov    $0x0,%al
c0027d3e:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0027d43:	89 f7                	mov    %esi,%edi
c0027d45:	f2 ae                	repnz scas %es:(%edi),%al
c0027d47:	89 c8                	mov    %ecx,%eax
c0027d49:	f7 d0                	not    %eax
c0027d4b:	48                   	dec    %eax
  if (size > 0) 
c0027d4c:	85 d2                	test   %edx,%edx
c0027d4e:	74 13                	je     c0027d63 <strlcpy+0x42>
    {
      size_t dst_len = size - 1;
c0027d50:	4a                   	dec    %edx
c0027d51:	89 c5                	mov    %eax,%ebp
c0027d53:	39 d0                	cmp    %edx,%eax
c0027d55:	76 02                	jbe    c0027d59 <strlcpy+0x38>
c0027d57:	89 d5                	mov    %edx,%ebp
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c0027d59:	89 df                	mov    %ebx,%edi
c0027d5b:	89 e9                	mov    %ebp,%ecx
c0027d5d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
      dst[dst_len] = '\0';
c0027d5f:	c6 04 2b 00          	movb   $0x0,(%ebx,%ebp,1)
    }
  return src_len;
}
c0027d63:	83 c4 0c             	add    $0xc,%esp
c0027d66:	5b                   	pop    %ebx
c0027d67:	5e                   	pop    %esi
c0027d68:	5f                   	pop    %edi
c0027d69:	5d                   	pop    %ebp
c0027d6a:	c3                   	ret    
  ASSERT (dst != NULL);
c0027d6b:	83 ec 0c             	sub    $0xc,%esp
c0027d6e:	68 19 1c 03 c0       	push   $0xc0031c19
c0027d73:	68 21 01 03 c0       	push   $0xc0030121
c0027d78:	68 e8 fb 02 c0       	push   $0xc002fbe8
c0027d7d:	68 4a 01 00 00       	push   $0x14a
c0027d82:	68 f5 1b 03 c0       	push   $0xc0031bf5
c0027d87:	e8 9b 08 00 00       	call   c0028627 <debug_panic>
  ASSERT (src != NULL);
c0027d8c:	83 ec 0c             	sub    $0xc,%esp
c0027d8f:	68 25 1c 03 c0       	push   $0xc0031c25
c0027d94:	68 21 01 03 c0       	push   $0xc0030121
c0027d99:	68 e8 fb 02 c0       	push   $0xc002fbe8
c0027d9e:	68 4b 01 00 00       	push   $0x14b
c0027da3:	68 f5 1b 03 c0       	push   $0xc0031bf5
c0027da8:	e8 7a 08 00 00       	call   c0028627 <debug_panic>

c0027dad <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0027dad:	55                   	push   %ebp
c0027dae:	57                   	push   %edi
c0027daf:	56                   	push   %esi
c0027db0:	53                   	push   %ebx
c0027db1:	83 ec 0c             	sub    $0xc,%esp
c0027db4:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027db8:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0027dbc:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0027dc1:	74 4f                	je     c0027e12 <strlcat+0x65>
  ASSERT (src != NULL);
c0027dc3:	85 f6                	test   %esi,%esi
c0027dc5:	74 6c                	je     c0027e33 <strlcat+0x86>

  src_len = strlen (src);
c0027dc7:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c0027dcc:	b0 00                	mov    $0x0,%al
c0027dce:	89 e9                	mov    %ebp,%ecx
c0027dd0:	89 f7                	mov    %esi,%edi
c0027dd2:	f2 ae                	repnz scas %es:(%edi),%al
c0027dd4:	f7 d1                	not    %ecx
c0027dd6:	8d 51 ff             	lea    -0x1(%ecx),%edx
  dst_len = strlen (dst);
c0027dd9:	89 e9                	mov    %ebp,%ecx
c0027ddb:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0027ddf:	f2 ae                	repnz scas %es:(%edi),%al
c0027de1:	89 c8                	mov    %ecx,%eax
c0027de3:	f7 d0                	not    %eax
c0027de5:	48                   	dec    %eax
  if (size > 0 && dst_len < size) 
c0027de6:	85 db                	test   %ebx,%ebx
c0027de8:	74 1e                	je     c0027e08 <strlcat+0x5b>
c0027dea:	39 d8                	cmp    %ebx,%eax
c0027dec:	73 1a                	jae    c0027e08 <strlcat+0x5b>
    {
      size_t copy_cnt = size - dst_len - 1;
c0027dee:	8d 6b ff             	lea    -0x1(%ebx),%ebp
c0027df1:	29 c5                	sub    %eax,%ebp
c0027df3:	89 d1                	mov    %edx,%ecx
c0027df5:	39 ea                	cmp    %ebp,%edx
c0027df7:	76 02                	jbe    c0027dfb <strlcat+0x4e>
c0027df9:	89 e9                	mov    %ebp,%ecx
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c0027dfb:	89 c3                	mov    %eax,%ebx
c0027dfd:	03 5c 24 20          	add    0x20(%esp),%ebx
c0027e01:	89 df                	mov    %ebx,%edi
c0027e03:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
      dst[dst_len + copy_cnt] = '\0';
c0027e05:	c6 07 00             	movb   $0x0,(%edi)
    }
  return src_len + dst_len;
c0027e08:	01 d0                	add    %edx,%eax
}
c0027e0a:	83 c4 0c             	add    $0xc,%esp
c0027e0d:	5b                   	pop    %ebx
c0027e0e:	5e                   	pop    %esi
c0027e0f:	5f                   	pop    %edi
c0027e10:	5d                   	pop    %ebp
c0027e11:	c3                   	ret    
  ASSERT (dst != NULL);
c0027e12:	83 ec 0c             	sub    $0xc,%esp
c0027e15:	68 19 1c 03 c0       	push   $0xc0031c19
c0027e1a:	68 21 01 03 c0       	push   $0xc0030121
c0027e1f:	68 e0 fb 02 c0       	push   $0xc002fbe0
c0027e24:	68 68 01 00 00       	push   $0x168
c0027e29:	68 f5 1b 03 c0       	push   $0xc0031bf5
c0027e2e:	e8 f4 07 00 00       	call   c0028627 <debug_panic>
  ASSERT (src != NULL);
c0027e33:	83 ec 0c             	sub    $0xc,%esp
c0027e36:	68 25 1c 03 c0       	push   $0xc0031c25
c0027e3b:	68 21 01 03 c0       	push   $0xc0030121
c0027e40:	68 e0 fb 02 c0       	push   $0xc002fbe0
c0027e45:	68 69 01 00 00       	push   $0x169
c0027e4a:	68 f5 1b 03 c0       	push   $0xc0031bf5
c0027e4f:	e8 d3 07 00 00       	call   c0028627 <debug_panic>

c0027e54 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0027e54:	55                   	push   %ebp
c0027e55:	57                   	push   %edi
c0027e56:	56                   	push   %esi
c0027e57:	53                   	push   %ebx
c0027e58:	83 ec 1c             	sub    $0x1c,%esp
c0027e5b:	89 04 24             	mov    %eax,(%esp)
c0027e5e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027e62:	8b 74 24 30          	mov    0x30(%esp),%esi
c0027e66:	8b 7c 24 34          	mov    0x34(%esp),%edi
  if ((d >> 32) == 0) 
c0027e6a:	85 ff                	test   %edi,%edi
c0027e6c:	74 2f                	je     c0027e9d <udiv64+0x49>
c0027e6e:	89 fa                	mov    %edi,%edx
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0027e70:	8b 0c 24             	mov    (%esp),%ecx
c0027e73:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0027e77:	39 df                	cmp    %ebx,%edi
c0027e79:	0f 87 43 01 00 00    	ja     c0027fc2 <udiv64+0x16e>
c0027e7f:	72 08                	jb     c0027e89 <udiv64+0x35>
c0027e81:	39 ce                	cmp    %ecx,%esi
c0027e83:	0f 87 39 01 00 00    	ja     c0027fc2 <udiv64+0x16e>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
c0027e89:	89 d0                	mov    %edx,%eax
  if (x <= 0x0000FFFF)
c0027e8b:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
c0027e91:	77 56                	ja     c0027ee9 <udiv64+0x95>
      x <<= 16; 
c0027e93:	c1 e0 10             	shl    $0x10,%eax
      n += 16;
c0027e96:	b9 10 00 00 00       	mov    $0x10,%ecx
c0027e9b:	eb 51                	jmp    c0027eee <udiv64+0x9a>
      uint32_t n1 = n >> 32;
c0027e9d:	8b 44 24 04          	mov    0x4(%esp),%eax
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0027ea1:	ba 00 00 00 00       	mov    $0x0,%edx
c0027ea6:	f7 f6                	div    %esi
c0027ea8:	89 d1                	mov    %edx,%ecx
c0027eaa:	89 c5                	mov    %eax,%ebp
c0027eac:	b8 00 00 00 00       	mov    $0x0,%eax
c0027eb1:	89 ca                	mov    %ecx,%edx
c0027eb3:	8b 0c 24             	mov    (%esp),%ecx
c0027eb6:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027ebb:	01 c8                	add    %ecx,%eax
c0027ebd:	11 da                	adc    %ebx,%edx
  asm ("divl %4"
c0027ebf:	f7 f6                	div    %esi
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0027ec1:	be 00 00 00 00       	mov    $0x0,%esi
c0027ec6:	89 c1                	mov    %eax,%ecx
c0027ec8:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027ecd:	01 f1                	add    %esi,%ecx
c0027ecf:	11 eb                	adc    %ebp,%ebx
c0027ed1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027ed5:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
          return n - (q - 1) * d < d ? q - 1 : q; 
        }
    }
}
c0027ed9:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027edd:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027ee1:	83 c4 1c             	add    $0x1c,%esp
c0027ee4:	5b                   	pop    %ebx
c0027ee5:	5e                   	pop    %esi
c0027ee6:	5f                   	pop    %edi
c0027ee7:	5d                   	pop    %ebp
c0027ee8:	c3                   	ret    
  int n = 0;
c0027ee9:	b9 00 00 00 00       	mov    $0x0,%ecx
  if (x <= 0x00FFFFFF)
c0027eee:	3d ff ff ff 00       	cmp    $0xffffff,%eax
c0027ef3:	77 06                	ja     c0027efb <udiv64+0xa7>
      n += 8;
c0027ef5:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
c0027ef8:	c1 e0 08             	shl    $0x8,%eax
  if (x <= 0x0FFFFFFF)
c0027efb:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
c0027f00:	77 06                	ja     c0027f08 <udiv64+0xb4>
      n += 4;
c0027f02:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
c0027f05:	c1 e0 04             	shl    $0x4,%eax
  if (x <= 0x3FFFFFFF)
c0027f08:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
c0027f0d:	77 06                	ja     c0027f15 <udiv64+0xc1>
      n += 2;
c0027f0f:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
c0027f12:	c1 e0 02             	shl    $0x2,%eax
    n++;
c0027f15:	3d 00 00 00 80       	cmp    $0x80000000,%eax
c0027f1a:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c0027f1d:	8b 04 24             	mov    (%esp),%eax
c0027f20:	8b 54 24 04          	mov    0x4(%esp),%edx
c0027f24:	89 d3                	mov    %edx,%ebx
c0027f26:	d1 eb                	shr    %ebx
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0027f28:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0027f2c:	d1 ea                	shr    %edx
c0027f2e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027f32:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0027f36:	89 f0                	mov    %esi,%eax
c0027f38:	89 fa                	mov    %edi,%edx
c0027f3a:	0f a5 f2             	shld   %cl,%esi,%edx
c0027f3d:	d3 e0                	shl    %cl,%eax
c0027f3f:	f6 c1 20             	test   $0x20,%cl
c0027f42:	74 02                	je     c0027f46 <udiv64+0xf2>
c0027f44:	89 c2                	mov    %eax,%edx
c0027f46:	89 54 24 14          	mov    %edx,0x14(%esp)
  asm ("divl %4"
c0027f4a:	89 da                	mov    %ebx,%edx
c0027f4c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027f50:	f7 74 24 14          	divl   0x14(%esp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0027f54:	ba 1f 00 00 00       	mov    $0x1f,%edx
c0027f59:	29 ca                	sub    %ecx,%edx
c0027f5b:	89 d1                	mov    %edx,%ecx
c0027f5d:	d3 e8                	shr    %cl,%eax
c0027f5f:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027f64:	89 44 24 10          	mov    %eax,0x10(%esp)
c0027f68:	89 4c 24 14          	mov    %ecx,0x14(%esp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0027f6c:	89 cb                	mov    %ecx,%ebx
c0027f6e:	89 c1                	mov    %eax,%ecx
c0027f70:	83 c1 ff             	add    $0xffffffff,%ecx
c0027f73:	83 d3 ff             	adc    $0xffffffff,%ebx
c0027f76:	89 fd                	mov    %edi,%ebp
c0027f78:	0f af e9             	imul   %ecx,%ebp
c0027f7b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027f7f:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0027f83:	0f af de             	imul   %esi,%ebx
c0027f86:	01 dd                	add    %ebx,%ebp
c0027f88:	89 f0                	mov    %esi,%eax
c0027f8a:	f7 64 24 08          	mull   0x8(%esp)
c0027f8e:	01 ea                	add    %ebp,%edx
c0027f90:	8b 0c 24             	mov    (%esp),%ecx
c0027f93:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0027f97:	29 c1                	sub    %eax,%ecx
c0027f99:	19 d3                	sbb    %edx,%ebx
c0027f9b:	39 df                	cmp    %ebx,%edi
c0027f9d:	0f 87 36 ff ff ff    	ja     c0027ed9 <udiv64+0x85>
c0027fa3:	72 08                	jb     c0027fad <udiv64+0x159>
c0027fa5:	39 ce                	cmp    %ecx,%esi
c0027fa7:	0f 87 2c ff ff ff    	ja     c0027ed9 <udiv64+0x85>
c0027fad:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027fb1:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027fb5:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027fb9:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0027fbd:	e9 17 ff ff ff       	jmp    c0027ed9 <udiv64+0x85>
        return 0;
c0027fc2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0027fc9:	00 
c0027fca:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027fd1:	00 
c0027fd2:	e9 02 ff ff ff       	jmp    c0027ed9 <udiv64+0x85>

c0027fd7 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0027fd7:	57                   	push   %edi
c0027fd8:	56                   	push   %esi
c0027fd9:	53                   	push   %ebx
c0027fda:	83 ec 08             	sub    $0x8,%esp
c0027fdd:	89 04 24             	mov    %eax,(%esp)
c0027fe0:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027fe4:	8b 74 24 18          	mov    0x18(%esp),%esi
c0027fe8:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0027fec:	85 d2                	test   %edx,%edx
c0027fee:	78 32                	js     c0028022 <sdiv64+0x4b>
c0027ff0:	8b 04 24             	mov    (%esp),%eax
c0027ff3:	8b 54 24 04          	mov    0x4(%esp),%edx
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0027ff7:	85 ff                	test   %edi,%edi
c0027ff9:	78 30                	js     c002802b <sdiv64+0x54>
c0027ffb:	89 f1                	mov    %esi,%ecx
c0027ffd:	89 fb                	mov    %edi,%ebx
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0027fff:	53                   	push   %ebx
c0028000:	51                   	push   %ecx
c0028001:	e8 4e fe ff ff       	call   c0027e54 <udiv64>
c0028006:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028009:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002800d:	f7 d1                	not    %ecx
c002800f:	c1 e9 1f             	shr    $0x1f,%ecx
c0028012:	89 fb                	mov    %edi,%ebx
c0028014:	c1 eb 1f             	shr    $0x1f,%ebx
c0028017:	38 d9                	cmp    %bl,%cl
c0028019:	74 1d                	je     c0028038 <sdiv64+0x61>
}
c002801b:	83 c4 08             	add    $0x8,%esp
c002801e:	5b                   	pop    %ebx
c002801f:	5e                   	pop    %esi
c0028020:	5f                   	pop    %edi
c0028021:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028022:	f7 d8                	neg    %eax
c0028024:	83 d2 00             	adc    $0x0,%edx
c0028027:	f7 da                	neg    %edx
c0028029:	eb cc                	jmp    c0027ff7 <sdiv64+0x20>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c002802b:	89 f1                	mov    %esi,%ecx
c002802d:	89 fb                	mov    %edi,%ebx
c002802f:	f7 d9                	neg    %ecx
c0028031:	83 d3 00             	adc    $0x0,%ebx
c0028034:	f7 db                	neg    %ebx
c0028036:	eb c7                	jmp    c0027fff <sdiv64+0x28>
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028038:	f7 d8                	neg    %eax
c002803a:	83 d2 00             	adc    $0x0,%edx
c002803d:	f7 da                	neg    %edx
c002803f:	eb da                	jmp    c002801b <sdiv64+0x44>

c0028041 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0028041:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c0028044:	ff 74 24 14          	pushl  0x14(%esp)
c0028048:	ff 74 24 14          	pushl  0x14(%esp)
c002804c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028050:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028054:	e8 7e ff ff ff       	call   c0027fd7 <sdiv64>
}
c0028059:	83 c4 0c             	add    $0xc,%esp
c002805c:	c3                   	ret    

c002805d <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c002805d:	57                   	push   %edi
c002805e:	56                   	push   %esi
c002805f:	53                   	push   %ebx
c0028060:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028064:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028068:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64 (n, d);
c002806c:	57                   	push   %edi
c002806d:	56                   	push   %esi
c002806e:	89 d8                	mov    %ebx,%eax
c0028070:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028074:	e8 5e ff ff ff       	call   c0027fd7 <sdiv64>
c0028079:	83 c4 08             	add    $0x8,%esp
c002807c:	0f af c6             	imul   %esi,%eax
c002807f:	29 c3                	sub    %eax,%ebx
c0028081:	89 d8                	mov    %ebx,%eax
  return smod64 (n, d);
c0028083:	99                   	cltd   
}
c0028084:	5b                   	pop    %ebx
c0028085:	5e                   	pop    %esi
c0028086:	5f                   	pop    %edi
c0028087:	c3                   	ret    

c0028088 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0028088:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c002808b:	ff 74 24 14          	pushl  0x14(%esp)
c002808f:	ff 74 24 14          	pushl  0x14(%esp)
c0028093:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028097:	8b 54 24 14          	mov    0x14(%esp),%edx
c002809b:	e8 b4 fd ff ff       	call   c0027e54 <udiv64>
}
c00280a0:	83 c4 0c             	add    $0xc,%esp
c00280a3:	c3                   	ret    

c00280a4 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c00280a4:	57                   	push   %edi
c00280a5:	56                   	push   %esi
c00280a6:	53                   	push   %ebx
c00280a7:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00280ab:	8b 74 24 18          	mov    0x18(%esp),%esi
c00280af:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64 (n, d);
c00280b3:	57                   	push   %edi
c00280b4:	56                   	push   %esi
c00280b5:	89 d8                	mov    %ebx,%eax
c00280b7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c00280bb:	e8 94 fd ff ff       	call   c0027e54 <udiv64>
c00280c0:	83 c4 08             	add    $0x8,%esp
c00280c3:	0f af c6             	imul   %esi,%eax
c00280c6:	29 c3                	sub    %eax,%ebx
c00280c8:	89 d8                	mov    %ebx,%eax
  return umod64 (n, d);
}
c00280ca:	ba 00 00 00 00       	mov    $0x0,%edx
c00280cf:	5b                   	pop    %ebx
c00280d0:	5e                   	pop    %esi
c00280d1:	5f                   	pop    %edi
c00280d2:	c3                   	ret    

c00280d3 <parse_octal_field>:
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
c00280d3:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c00280d9:	85 d2                	test   %edx,%edx
c00280db:	74 46                	je     c0028123 <parse_octal_field+0x50>
{
c00280dd:	55                   	push   %ebp
c00280de:	57                   	push   %edi
c00280df:	56                   	push   %esi
c00280e0:	53                   	push   %ebx
c00280e1:	89 d5                	mov    %edx,%ebp
    {
      char c = s[ofs];
c00280e3:	8a 18                	mov    (%eax),%bl
      if (c >= '0' && c <= '7')
c00280e5:	8d 73 d0             	lea    -0x30(%ebx),%esi
c00280e8:	89 f2                	mov    %esi,%edx
  for (ofs = 0; ofs < size; ofs++)
c00280ea:	be 00 00 00 00       	mov    $0x0,%esi
      if (c >= '0' && c <= '7')
c00280ef:	80 fa 07             	cmp    $0x7,%dl
c00280f2:	77 39                	ja     c002812d <parse_octal_field+0x5a>
c00280f4:	bf 00 00 00 00       	mov    $0x0,%edi
c00280f9:	be 00 00 00 00       	mov    $0x0,%esi
          if (*value > ULONG_MAX / 8)
            {
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
c00280fe:	0f be db             	movsbl %bl,%ebx
c0028101:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c0028105:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c0028107:	46                   	inc    %esi
c0028108:	39 f5                	cmp    %esi,%ebp
c002810a:	74 1a                	je     c0028126 <parse_octal_field+0x53>
      char c = s[ofs];
c002810c:	8a 1c 30             	mov    (%eax,%esi,1),%bl
      if (c >= '0' && c <= '7')
c002810f:	8d 53 d0             	lea    -0x30(%ebx),%edx
c0028112:	80 fa 07             	cmp    $0x7,%dl
c0028115:	77 16                	ja     c002812d <parse_octal_field+0x5a>
          if (*value > ULONG_MAX / 8)
c0028117:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c002811d:	76 df                	jbe    c00280fe <parse_octal_field+0x2b>
              return false;
c002811f:	b0 00                	mov    $0x0,%al
c0028121:	eb 05                	jmp    c0028128 <parse_octal_field+0x55>
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0028123:	b0 00                	mov    $0x0,%al
c0028125:	c3                   	ret    
c0028126:	b0 00                	mov    $0x0,%al
}
c0028128:	5b                   	pop    %ebx
c0028129:	5e                   	pop    %esi
c002812a:	5f                   	pop    %edi
c002812b:	5d                   	pop    %ebp
c002812c:	c3                   	ret    
      else if (c == ' ' || c == '\0')
c002812d:	f6 c3 df             	test   $0xdf,%bl
c0028130:	75 07                	jne    c0028139 <parse_octal_field+0x66>
          return ofs > 0;
c0028132:	85 f6                	test   %esi,%esi
c0028134:	0f 95 c0             	setne  %al
c0028137:	eb ef                	jmp    c0028128 <parse_octal_field+0x55>
          return false;
c0028139:	b0 00                	mov    $0x0,%al
c002813b:	eb eb                	jmp    c0028128 <parse_octal_field+0x55>

c002813d <strip_antisocial_prefixes>:
{
c002813d:	55                   	push   %ebp
c002813e:	57                   	push   %edi
c002813f:	56                   	push   %esi
c0028140:	53                   	push   %ebx
c0028141:	83 ec 0c             	sub    $0xc,%esp
c0028144:	89 c5                	mov    %eax,%ebp
  while (*file_name == '/'
c0028146:	eb 11                	jmp    c0028159 <strip_antisocial_prefixes+0x1c>
    file_name = strchr (file_name, '/') + 1;
c0028148:	83 ec 08             	sub    $0x8,%esp
c002814b:	6a 2f                	push   $0x2f
c002814d:	55                   	push   %ebp
c002814e:	e8 ec f8 ff ff       	call   c0027a3f <strchr>
c0028153:	83 c4 10             	add    $0x10,%esp
c0028156:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/'
c0028159:	8a 5d 00             	mov    0x0(%ebp),%bl
c002815c:	80 fb 2f             	cmp    $0x2f,%bl
c002815f:	74 e7                	je     c0028148 <strip_antisocial_prefixes+0xb>
         || !memcmp (file_name, "./", 2)
c0028161:	83 ec 04             	sub    $0x4,%esp
c0028164:	6a 02                	push   $0x2
c0028166:	68 56 10 03 c0       	push   $0xc0031056
c002816b:	55                   	push   %ebp
c002816c:	e8 21 f8 ff ff       	call   c0027992 <memcmp>
c0028171:	83 c4 10             	add    $0x10,%esp
c0028174:	85 c0                	test   %eax,%eax
c0028176:	74 d0                	je     c0028148 <strip_antisocial_prefixes+0xb>
         || !memcmp (file_name, "../", 3))
c0028178:	83 ec 04             	sub    $0x4,%esp
c002817b:	6a 03                	push   $0x3
c002817d:	68 31 1c 03 c0       	push   $0xc0031c31
c0028182:	55                   	push   %ebp
c0028183:	e8 0a f8 ff ff       	call   c0027992 <memcmp>
c0028188:	83 c4 10             	add    $0x10,%esp
c002818b:	85 c0                	test   %eax,%eax
c002818d:	74 b9                	je     c0028148 <strip_antisocial_prefixes+0xb>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c002818f:	84 db                	test   %bl,%bl
c0028191:	74 23                	je     c00281b6 <strip_antisocial_prefixes+0x79>
c0028193:	bf d2 15 03 c0       	mov    $0xc00315d2,%edi
c0028198:	b9 03 00 00 00       	mov    $0x3,%ecx
c002819d:	89 ee                	mov    %ebp,%esi
c002819f:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00281a1:	0f 97 c2             	seta   %dl
c00281a4:	0f 92 c0             	setb   %al
c00281a7:	38 c2                	cmp    %al,%dl
c00281a9:	75 07                	jne    c00281b2 <strip_antisocial_prefixes+0x75>
c00281ab:	b8 d3 15 03 c0       	mov    $0xc00315d3,%eax
c00281b0:	eb 09                	jmp    c00281bb <strip_antisocial_prefixes+0x7e>
c00281b2:	89 e8                	mov    %ebp,%eax
c00281b4:	eb 05                	jmp    c00281bb <strip_antisocial_prefixes+0x7e>
c00281b6:	b8 d3 15 03 c0       	mov    $0xc00315d3,%eax
}
c00281bb:	83 c4 0c             	add    $0xc,%esp
c00281be:	5b                   	pop    %ebx
c00281bf:	5e                   	pop    %esi
c00281c0:	5f                   	pop    %edi
c00281c1:	5d                   	pop    %ebp
c00281c2:	c3                   	ret    

c00281c3 <ustar_make_header>:
{
c00281c3:	57                   	push   %edi
c00281c4:	56                   	push   %esi
c00281c5:	53                   	push   %ebx
c00281c6:	8b 44 24 10          	mov    0x10(%esp),%eax
c00281ca:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c00281ce:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c00281d2:	83 fb 30             	cmp    $0x30,%ebx
c00281d5:	0f 84 83 01 00 00    	je     c002835e <ustar_make_header+0x19b>
c00281db:	83 fb 35             	cmp    $0x35,%ebx
c00281de:	0f 85 3e 01 00 00    	jne    c0028322 <ustar_make_header+0x15f>
  file_name = strip_antisocial_prefixes (file_name);
c00281e4:	e8 54 ff ff ff       	call   c002813d <strip_antisocial_prefixes>
c00281e9:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c00281eb:	b0 00                	mov    $0x0,%al
c00281ed:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00281f2:	89 d7                	mov    %edx,%edi
c00281f4:	f2 ae                	repnz scas %es:(%edi),%al
c00281f6:	89 c8                	mov    %ecx,%eax
c00281f8:	f7 d0                	not    %eax
c00281fa:	48                   	dec    %eax
c00281fb:	83 f8 63             	cmp    $0x63,%eax
c00281fe:	0f 87 3c 01 00 00    	ja     c0028340 <ustar_make_header+0x17d>
  memset (h, 0, sizeof *h);
c0028204:	b9 80 00 00 00       	mov    $0x80,%ecx
c0028209:	b8 00 00 00 00       	mov    $0x0,%eax
c002820e:	89 f7                	mov    %esi,%edi
c0028210:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0028212:	83 ec 04             	sub    $0x4,%esp
c0028215:	6a 64                	push   $0x64
c0028217:	52                   	push   %edx
c0028218:	56                   	push   %esi
c0028219:	e8 03 fb ff ff       	call   c0027d21 <strlcpy>
c002821e:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c0028221:	b8 ed 01 00 00       	mov    $0x1ed,%eax
c0028226:	50                   	push   %eax
c0028227:	68 5f 1c 03 c0       	push   $0xc0031c5f
c002822c:	6a 08                	push   $0x8
c002822e:	8d 46 64             	lea    0x64(%esi),%eax
c0028231:	50                   	push   %eax
c0028232:	e8 ce f0 ff ff       	call   c0027305 <snprintf>
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0028237:	83 c4 0c             	add    $0xc,%esp
c002823a:	6a 08                	push   $0x8
c002823c:	68 64 1c 03 c0       	push   $0xc0031c64
c0028241:	8d 46 6c             	lea    0x6c(%esi),%eax
c0028244:	50                   	push   %eax
c0028245:	e8 d7 fa ff ff       	call   c0027d21 <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c002824a:	83 c4 0c             	add    $0xc,%esp
c002824d:	6a 08                	push   $0x8
c002824f:	68 64 1c 03 c0       	push   $0xc0031c64
c0028254:	8d 46 74             	lea    0x74(%esi),%eax
c0028257:	50                   	push   %eax
c0028258:	e8 c4 fa ff ff       	call   c0027d21 <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c002825d:	ff 74 24 28          	pushl  0x28(%esp)
c0028261:	68 6c 1c 03 c0       	push   $0xc0031c6c
c0028266:	6a 0c                	push   $0xc
c0028268:	8d 46 7c             	lea    0x7c(%esi),%eax
c002826b:	50                   	push   %eax
c002826c:	e8 94 f0 ff ff       	call   c0027305 <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0028271:	83 c4 20             	add    $0x20,%esp
c0028274:	68 00 8c b7 43       	push   $0x43b78c00
c0028279:	68 6c 1c 03 c0       	push   $0xc0031c6c
c002827e:	6a 0c                	push   $0xc
c0028280:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c0028286:	50                   	push   %eax
c0028287:	e8 79 f0 ff ff       	call   c0027305 <snprintf>
  h->typeflag = type;
c002828c:	88 9e 9c 00 00 00    	mov    %bl,0x9c(%esi)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0028292:	83 c4 0c             	add    $0xc,%esp
c0028295:	6a 06                	push   $0x6
c0028297:	68 72 1c 03 c0       	push   $0xc0031c72
c002829c:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c00282a2:	50                   	push   %eax
c00282a3:	e8 79 fa ff ff       	call   c0027d21 <strlcpy>
  h->version[0] = h->version[1] = '0';
c00282a8:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c00282af:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy (h->gname, "root", sizeof h->gname);
c00282b6:	83 c4 0c             	add    $0xc,%esp
c00282b9:	6a 20                	push   $0x20
c00282bb:	68 04 12 03 c0       	push   $0xc0031204
c00282c0:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c00282c6:	50                   	push   %eax
c00282c7:	e8 55 fa ff ff       	call   c0027d21 <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c00282cc:	83 c4 0c             	add    $0xc,%esp
c00282cf:	6a 20                	push   $0x20
c00282d1:	68 04 12 03 c0       	push   $0xc0031204
c00282d6:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c00282dc:	50                   	push   %eax
c00282dd:	e8 3f fa ff ff       	call   c0027d21 <strlcpy>
c00282e2:	83 c4 10             	add    $0x10,%esp
c00282e5:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c00282ea:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c00282ef:	b3 20                	mov    $0x20,%bl
c00282f1:	83 f8 07             	cmp    $0x7,%eax
c00282f4:	77 5f                	ja     c0028355 <ustar_make_header+0x192>
c00282f6:	88 da                	mov    %bl,%dl
c00282f8:	0f b6 d2             	movzbl %dl,%edx
c00282fb:	01 d1                	add    %edx,%ecx
c00282fd:	40                   	inc    %eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c00282fe:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028303:	75 ec                	jne    c00282f1 <ustar_make_header+0x12e>
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0028305:	51                   	push   %ecx
c0028306:	68 5f 1c 03 c0       	push   $0xc0031c5f
c002830b:	6a 08                	push   $0x8
c002830d:	81 c6 94 00 00 00    	add    $0x94,%esi
c0028313:	56                   	push   %esi
c0028314:	e8 ec ef ff ff       	call   c0027305 <snprintf>
  return true;
c0028319:	83 c4 10             	add    $0x10,%esp
c002831c:	b0 01                	mov    $0x1,%al
}
c002831e:	5b                   	pop    %ebx
c002831f:	5e                   	pop    %esi
c0028320:	5f                   	pop    %edi
c0028321:	c3                   	ret    
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028322:	83 ec 0c             	sub    $0xc,%esp
c0028325:	68 1c 1d 03 c0       	push   $0xc0031d1c
c002832a:	68 21 01 03 c0       	push   $0xc0030121
c002832f:	68 fc fb 02 c0       	push   $0xc002fbfc
c0028334:	6a 59                	push   $0x59
c0028336:	68 35 1c 03 c0       	push   $0xc0031c35
c002833b:	e8 e7 02 00 00       	call   c0028627 <debug_panic>
      printf ("%s: file name too long\n", file_name);
c0028340:	83 ec 08             	sub    $0x8,%esp
c0028343:	52                   	push   %edx
c0028344:	68 47 1c 03 c0       	push   $0xc0031c47
c0028349:	e8 2b e8 ff ff       	call   c0026b79 <printf>
      return false;
c002834e:	83 c4 10             	add    $0x10,%esp
c0028351:	b0 00                	mov    $0x0,%al
c0028353:	eb c9                	jmp    c002831e <ustar_make_header+0x15b>
      chksum += in_chksum_field ? ' ' : header[i];
c0028355:	8a 94 06 94 00 00 00 	mov    0x94(%esi,%eax,1),%dl
c002835c:	eb 9a                	jmp    c00282f8 <ustar_make_header+0x135>
  file_name = strip_antisocial_prefixes (file_name);
c002835e:	e8 da fd ff ff       	call   c002813d <strip_antisocial_prefixes>
c0028363:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c0028365:	b0 00                	mov    $0x0,%al
c0028367:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002836c:	89 d7                	mov    %edx,%edi
c002836e:	f2 ae                	repnz scas %es:(%edi),%al
c0028370:	89 c8                	mov    %ecx,%eax
c0028372:	f7 d0                	not    %eax
c0028374:	48                   	dec    %eax
c0028375:	83 f8 63             	cmp    $0x63,%eax
c0028378:	77 c6                	ja     c0028340 <ustar_make_header+0x17d>
  memset (h, 0, sizeof *h);
c002837a:	b9 80 00 00 00       	mov    $0x80,%ecx
c002837f:	b8 00 00 00 00       	mov    $0x0,%eax
c0028384:	89 f7                	mov    %esi,%edi
c0028386:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0028388:	83 ec 04             	sub    $0x4,%esp
c002838b:	6a 64                	push   $0x64
c002838d:	52                   	push   %edx
c002838e:	56                   	push   %esi
c002838f:	e8 8d f9 ff ff       	call   c0027d21 <strlcpy>
c0028394:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c0028397:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c002839c:	e9 85 fe ff ff       	jmp    c0028226 <ustar_make_header+0x63>

c00283a1 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c00283a1:	56                   	push   %esi
c00283a2:	53                   	push   %ebx
c00283a3:	83 ec 14             	sub    $0x14,%esp
c00283a6:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c00283aa:	8d 93 00 02 00 00    	lea    0x200(%ebx),%edx
c00283b0:	89 d8                	mov    %ebx,%eax
    if (*block++ != 0)
c00283b2:	40                   	inc    %eax
c00283b3:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c00283b7:	0f 85 47 01 00 00    	jne    c0028504 <ustar_parse_header+0x163>
  while (cnt-- > 0)
c00283bd:	39 c2                	cmp    %eax,%edx
c00283bf:	75 f1                	jne    c00283b2 <ustar_parse_header+0x11>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c00283c1:	8b 44 24 24          	mov    0x24(%esp),%eax
c00283c5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c00283cb:	8b 44 24 28          	mov    0x28(%esp),%eax
c00283cf:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c00283d5:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c00283d9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c00283df:	b8 00 00 00 00       	mov    $0x0,%eax
  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
  *type = h->typeflag;
  *size = size_ul;
  return NULL;
}
c00283e4:	83 c4 14             	add    $0x14,%esp
c00283e7:	5b                   	pop    %ebx
c00283e8:	5e                   	pop    %esi
c00283e9:	c3                   	ret    
  else if (h->version[0] != '0' || h->version[1] != '0')
c00283ea:	80 bb 08 01 00 00 30 	cmpb   $0x30,0x108(%ebx)
c00283f1:	74 07                	je     c00283fa <ustar_parse_header+0x59>
    return "invalid ustar version";
c00283f3:	b8 8c 1c 03 c0       	mov    $0xc0031c8c,%eax
c00283f8:	eb ea                	jmp    c00283e4 <ustar_parse_header+0x43>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c00283fa:	8d 83 94 00 00 00    	lea    0x94(%ebx),%eax
c0028400:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c0028404:	ba 08 00 00 00       	mov    $0x8,%edx
c0028409:	e8 c5 fc ff ff       	call   c00280d3 <parse_octal_field>
c002840e:	84 c0                	test   %al,%al
c0028410:	0f 84 b2 00 00 00    	je     c00284c8 <ustar_parse_header+0x127>
c0028416:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
c002841b:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c0028420:	be 20 00 00 00       	mov    $0x20,%esi
c0028425:	83 f8 07             	cmp    $0x7,%eax
c0028428:	77 1c                	ja     c0028446 <ustar_parse_header+0xa5>
c002842a:	89 f2                	mov    %esi,%edx
c002842c:	0f b6 d2             	movzbl %dl,%edx
c002842f:	01 d1                	add    %edx,%ecx
c0028431:	40                   	inc    %eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028432:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028437:	75 ec                	jne    c0028425 <ustar_parse_header+0x84>
  else if (chksum != calculate_chksum (h))
c0028439:	39 4c 24 0c          	cmp    %ecx,0xc(%esp)
c002843d:	74 10                	je     c002844f <ustar_parse_header+0xae>
    return "checksum mismatch";
c002843f:	b8 b7 1c 03 c0       	mov    $0xc0031cb7,%eax
c0028444:	eb 9e                	jmp    c00283e4 <ustar_parse_header+0x43>
      chksum += in_chksum_field ? ' ' : header[i];
c0028446:	8a 94 03 94 00 00 00 	mov    0x94(%ebx,%eax,1),%dl
c002844d:	eb dd                	jmp    c002842c <ustar_parse_header+0x8b>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c002844f:	80 7b 63 00          	cmpb   $0x0,0x63(%ebx)
c0028453:	75 7d                	jne    c00284d2 <ustar_parse_header+0x131>
c0028455:	80 bb 59 01 00 00 00 	cmpb   $0x0,0x159(%ebx)
c002845c:	75 7e                	jne    c00284dc <ustar_parse_header+0x13b>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c002845e:	8a 83 9c 00 00 00    	mov    0x9c(%ebx),%al
c0028464:	3c 30                	cmp    $0x30,%al
c0028466:	74 3a                	je     c00284a2 <ustar_parse_header+0x101>
c0028468:	3c 35                	cmp    $0x35,%al
c002846a:	75 7a                	jne    c00284e6 <ustar_parse_header+0x145>
    size_ul = 0;
c002846c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0028473:	00 
  *file_name = strip_antisocial_prefixes (h->name);
c0028474:	89 d8                	mov    %ebx,%eax
c0028476:	e8 c2 fc ff ff       	call   c002813d <strip_antisocial_prefixes>
c002847b:	8b 74 24 24          	mov    0x24(%esp),%esi
c002847f:	89 06                	mov    %eax,(%esi)
  *type = h->typeflag;
c0028481:	0f be 83 9c 00 00 00 	movsbl 0x9c(%ebx),%eax
c0028488:	8b 74 24 28          	mov    0x28(%esp),%esi
c002848c:	89 06                	mov    %eax,(%esi)
  *size = size_ul;
c002848e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028492:	8b 74 24 2c          	mov    0x2c(%esp),%esi
c0028496:	89 06                	mov    %eax,(%esi)
  return NULL;
c0028498:	b8 00 00 00 00       	mov    $0x0,%eax
c002849d:	e9 42 ff ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c00284a2:	8d 43 7c             	lea    0x7c(%ebx),%eax
c00284a5:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c00284a9:	ba 0c 00 00 00       	mov    $0xc,%edx
c00284ae:	e8 20 fc ff ff       	call   c00280d3 <parse_octal_field>
c00284b3:	84 c0                	test   %al,%al
c00284b5:	74 39                	je     c00284f0 <ustar_parse_header+0x14f>
      else if (size_ul > INT_MAX)
c00284b7:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c00284bc:	79 b6                	jns    c0028474 <ustar_parse_header+0xd3>
        return "file too large";
c00284be:	b8 0c 1d 03 c0       	mov    $0xc0031d0c,%eax
c00284c3:	e9 1c ff ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>
    return "corrupt chksum field";
c00284c8:	b8 a2 1c 03 c0       	mov    $0xc0031ca2,%eax
c00284cd:	e9 12 ff ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>
    return "file name too long";
c00284d2:	b8 c9 1c 03 c0       	mov    $0xc0031cc9,%eax
c00284d7:	e9 08 ff ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>
c00284dc:	b8 c9 1c 03 c0       	mov    $0xc0031cc9,%eax
c00284e1:	e9 fe fe ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>
    return "unimplemented file type";
c00284e6:	b8 dc 1c 03 c0       	mov    $0xc0031cdc,%eax
c00284eb:	e9 f4 fe ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>
        return "corrupt file size field";
c00284f0:	b8 f4 1c 03 c0       	mov    $0xc0031cf4,%eax
c00284f5:	e9 ea fe ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>
    return "not a ustar archive";
c00284fa:	b8 78 1c 03 c0       	mov    $0xc0031c78,%eax
c00284ff:	e9 e0 fe ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>
  if (memcmp (h->magic, "ustar", 6))
c0028504:	83 ec 04             	sub    $0x4,%esp
c0028507:	6a 06                	push   $0x6
c0028509:	68 72 1c 03 c0       	push   $0xc0031c72
c002850e:	8d 83 01 01 00 00    	lea    0x101(%ebx),%eax
c0028514:	50                   	push   %eax
c0028515:	e8 78 f4 ff ff       	call   c0027992 <memcmp>
c002851a:	83 c4 10             	add    $0x10,%esp
c002851d:	85 c0                	test   %eax,%eax
c002851f:	75 d9                	jne    c00284fa <ustar_parse_header+0x159>
  else if (h->version[0] != '0' || h->version[1] != '0')
c0028521:	80 bb 07 01 00 00 30 	cmpb   $0x30,0x107(%ebx)
c0028528:	0f 84 bc fe ff ff    	je     c00283ea <ustar_parse_header+0x49>
    return "invalid ustar version";
c002852e:	b8 8c 1c 03 c0       	mov    $0xc0031c8c,%eax
c0028533:	e9 ac fe ff ff       	jmp    c00283e4 <ustar_parse_header+0x43>

c0028538 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0028538:	55                   	push   %ebp
c0028539:	89 e5                	mov    %esp,%ebp
c002853b:	53                   	push   %ebx
c002853c:	83 ec 04             	sub    $0x4,%esp
c002853f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0028542:	8b 43 08             	mov    0x8(%ebx),%eax
c0028545:	83 f8 01             	cmp    $0x1,%eax
c0028548:	0f 84 ab 00 00 00    	je     c00285f9 <print_stacktrace+0xc1>
c002854e:	83 f8 01             	cmp    $0x1,%eax
c0028551:	72 10                	jb     c0028563 <print_stacktrace+0x2b>
c0028553:	83 f8 02             	cmp    $0x2,%eax
c0028556:	0f 84 a7 00 00 00    	je     c0028603 <print_stacktrace+0xcb>
  const char *status = "UNKNOWN";
c002855c:	b8 53 1d 03 c0       	mov    $0xc0031d53,%eax
c0028561:	eb 05                	jmp    c0028568 <print_stacktrace+0x30>
    case THREAD_RUNNING:  
      status = "RUNNING";
c0028563:	b8 d7 07 03 c0       	mov    $0xc00307d7,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0028568:	83 ec 04             	sub    $0x4,%esp
c002856b:	50                   	push   %eax
c002856c:	8d 43 0c             	lea    0xc(%ebx),%eax
c002856f:	50                   	push   %eax
c0028570:	68 78 1d 03 c0       	push   $0xc0031d78
c0028575:	e8 ff e5 ff ff       	call   c0026b79 <printf>

  if (t == thread_current()) 
c002857a:	e8 3d 87 ff ff       	call   c0020cbc <thread_current>
c002857f:	83 c4 10             	add    $0x10,%esp
c0028582:	39 c3                	cmp    %eax,%ebx
c0028584:	0f 84 83 00 00 00    	je     c002860d <print_stacktrace+0xd5>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c002858a:	8b 53 1c             	mov    0x1c(%ebx),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c002858d:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c0028593:	39 da                	cmp    %ebx,%edx
c0028595:	74 7e                	je     c0028615 <print_stacktrace+0xdd>
c0028597:	8b 42 10             	mov    0x10(%edx),%eax
c002859a:	3d 90 18 02 c0       	cmp    $0xc0021890,%eax
c002859f:	74 74                	je     c0028615 <print_stacktrace+0xdd>
        {
          printf (" thread was never scheduled.\n");
          return;
        }

      frame = (void **) saved_frame->ebp;
c00285a1:	8b 5a 08             	mov    0x8(%edx),%ebx
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c00285a4:	83 ec 08             	sub    $0x8,%esp
c00285a7:	50                   	push   %eax
c00285a8:	68 49 1a 03 c0       	push   $0xc0031a49
c00285ad:	e8 c7 e5 ff ff       	call   c0026b79 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00285b2:	83 c4 10             	add    $0x10,%esp
c00285b5:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c00285bb:	76 27                	jbe    c00285e4 <print_stacktrace+0xac>
c00285bd:	83 3b 00             	cmpl   $0x0,(%ebx)
c00285c0:	74 22                	je     c00285e4 <print_stacktrace+0xac>
    printf (" %p", frame[1]);
c00285c2:	83 ec 08             	sub    $0x8,%esp
c00285c5:	ff 73 04             	pushl  0x4(%ebx)
c00285c8:	68 49 1a 03 c0       	push   $0xc0031a49
c00285cd:	e8 a7 e5 ff ff       	call   c0026b79 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00285d2:	8b 1b                	mov    (%ebx),%ebx
c00285d4:	83 c4 10             	add    $0x10,%esp
c00285d7:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c00285dd:	76 05                	jbe    c00285e4 <print_stacktrace+0xac>
c00285df:	83 3b 00             	cmpl   $0x0,(%ebx)
c00285e2:	75 de                	jne    c00285c2 <print_stacktrace+0x8a>
  printf (".\n");
c00285e4:	83 ec 0c             	sub    $0xc,%esp
c00285e7:	68 d3 15 03 c0       	push   $0xc00315d3
c00285ec:	e8 1d 1b 00 00       	call   c002a10e <puts>
c00285f1:	83 c4 10             	add    $0x10,%esp
}
c00285f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00285f7:	c9                   	leave  
c00285f8:	c3                   	ret    
      status = "READY";
c00285f9:	b8 4d 1d 03 c0       	mov    $0xc0031d4d,%eax
      break;
c00285fe:	e9 65 ff ff ff       	jmp    c0028568 <print_stacktrace+0x30>
      status = "BLOCKED";
c0028603:	b8 93 07 03 c0       	mov    $0xc0030793,%eax
      break;
c0028608:	e9 5b ff ff ff       	jmp    c0028568 <print_stacktrace+0x30>
      frame = __builtin_frame_address (1);
c002860d:	8b 5d 00             	mov    0x0(%ebp),%ebx
      retaddr = __builtin_return_address (0);
c0028610:	8b 45 04             	mov    0x4(%ebp),%eax
c0028613:	eb 8f                	jmp    c00285a4 <print_stacktrace+0x6c>
          printf (" thread was never scheduled.\n");
c0028615:	83 ec 0c             	sub    $0xc,%esp
c0028618:	68 5b 1d 03 c0       	push   $0xc0031d5b
c002861d:	e8 ec 1a 00 00       	call   c002a10e <puts>
          return;
c0028622:	83 c4 10             	add    $0x10,%esp
c0028625:	eb cd                	jmp    c00285f4 <print_stacktrace+0xbc>

c0028627 <debug_panic>:
{
c0028627:	57                   	push   %edi
c0028628:	56                   	push   %esi
c0028629:	53                   	push   %ebx
c002862a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002862e:	8b 74 24 14          	mov    0x14(%esp),%esi
c0028632:	8b 7c 24 18          	mov    0x18(%esp),%edi
  intr_disable ();
c0028636:	e8 c6 93 ff ff       	call   c0021a01 <intr_disable>
  console_panic ();
c002863b:	e8 75 1a 00 00       	call   c002a0b5 <console_panic>
  level++;
c0028640:	a1 00 ce 03 c0       	mov    0xc003ce00,%eax
c0028645:	40                   	inc    %eax
c0028646:	a3 00 ce 03 c0       	mov    %eax,0xc003ce00
  if (level == 1) 
c002864b:	83 f8 01             	cmp    $0x1,%eax
c002864e:	74 11                	je     c0028661 <debug_panic+0x3a>
  else if (level == 2)
c0028650:	83 f8 02             	cmp    $0x2,%eax
c0028653:	74 40                	je     c0028695 <debug_panic+0x6e>
  serial_flush ();
c0028655:	e8 26 c4 ff ff       	call   c0024a80 <serial_flush>
  shutdown ();
c002865a:	e8 5c de ff ff       	call   c00264bb <shutdown>
c002865f:	eb fe                	jmp    c002865f <debug_panic+0x38>
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0028661:	57                   	push   %edi
c0028662:	56                   	push   %esi
c0028663:	53                   	push   %ebx
c0028664:	68 a0 1d 03 c0       	push   $0xc0031da0
c0028669:	e8 0b e5 ff ff       	call   c0026b79 <printf>
      va_start (args, message);
c002866e:	8d 44 24 30          	lea    0x30(%esp),%eax
      vprintf (message, args);
c0028672:	83 c4 08             	add    $0x8,%esp
c0028675:	50                   	push   %eax
c0028676:	ff 74 24 28          	pushl  0x28(%esp)
c002867a:	e8 5b 1a 00 00       	call   c002a0da <vprintf>
      printf ("\n");
c002867f:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0028686:	e8 ef 1a 00 00       	call   c002a17a <putchar>
      debug_backtrace ();
c002868b:	e8 e6 de ff ff       	call   c0026576 <debug_backtrace>
c0028690:	83 c4 10             	add    $0x10,%esp
c0028693:	eb c0                	jmp    c0028655 <debug_panic+0x2e>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c0028695:	57                   	push   %edi
c0028696:	56                   	push   %esi
c0028697:	53                   	push   %ebx
c0028698:	68 c0 1d 03 c0       	push   $0xc0031dc0
c002869d:	e8 d7 e4 ff ff       	call   c0026b79 <printf>
c00286a2:	83 c4 10             	add    $0x10,%esp
c00286a5:	eb ae                	jmp    c0028655 <debug_panic+0x2e>

c00286a7 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c00286a7:	53                   	push   %ebx
c00286a8:	83 ec 08             	sub    $0x8,%esp
  enum intr_level oldlevel = intr_disable ();
c00286ab:	e8 51 93 ff ff       	call   c0021a01 <intr_disable>
c00286b0:	89 c3                	mov    %eax,%ebx

  thread_foreach (print_stacktrace, 0);
c00286b2:	83 ec 08             	sub    $0x8,%esp
c00286b5:	6a 00                	push   $0x0
c00286b7:	68 38 85 02 c0       	push   $0xc0028538
c00286bc:	e8 de 86 ff ff       	call   c0020d9f <thread_foreach>
  intr_set_level (oldlevel);
c00286c1:	89 1c 24             	mov    %ebx,(%esp)
c00286c4:	e8 3f 93 ff ff       	call   c0021a08 <intr_set_level>
}
c00286c9:	83 c4 18             	add    $0x18,%esp
c00286cc:	5b                   	pop    %ebx
c00286cd:	c3                   	ret    

c00286ce <list_init>:
}

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c00286ce:	83 ec 0c             	sub    $0xc,%esp
c00286d1:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00286d5:	85 c0                	test   %eax,%eax
c00286d7:	74 1a                	je     c00286f3 <list_init+0x25>
  list->head.prev = NULL;
c00286d9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c00286df:	8d 50 08             	lea    0x8(%eax),%edx
c00286e2:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c00286e5:	89 40 08             	mov    %eax,0x8(%eax)
  list->tail.next = NULL;
c00286e8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c00286ef:	83 c4 0c             	add    $0xc,%esp
c00286f2:	c3                   	ret    
  ASSERT (list != NULL);
c00286f3:	83 ec 0c             	sub    $0xc,%esp
c00286f6:	68 ea 1d 03 c0       	push   $0xc0031dea
c00286fb:	68 21 01 03 c0       	push   $0xc0030121
c0028700:	68 f8 fc 02 c0       	push   $0xc002fcf8
c0028705:	6a 3d                	push   $0x3d
c0028707:	68 f7 1d 03 c0       	push   $0xc0031df7
c002870c:	e8 16 ff ff ff       	call   c0028627 <debug_panic>

c0028711 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c0028711:	83 ec 0c             	sub    $0xc,%esp
c0028714:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0028718:	85 c0                	test   %eax,%eax
c002871a:	74 07                	je     c0028723 <list_begin+0x12>
  return list->head.next;
c002871c:	8b 40 04             	mov    0x4(%eax),%eax
}
c002871f:	83 c4 0c             	add    $0xc,%esp
c0028722:	c3                   	ret    
  ASSERT (list != NULL);
c0028723:	83 ec 0c             	sub    $0xc,%esp
c0028726:	68 ea 1d 03 c0       	push   $0xc0031dea
c002872b:	68 21 01 03 c0       	push   $0xc0030121
c0028730:	68 ec fc 02 c0       	push   $0xc002fcec
c0028735:	6a 48                	push   $0x48
c0028737:	68 f7 1d 03 c0       	push   $0xc0031df7
c002873c:	e8 e6 fe ff ff       	call   c0028627 <debug_panic>

c0028741 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0028741:	83 ec 0c             	sub    $0xc,%esp
c0028744:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0028748:	85 c0                	test   %eax,%eax
c002874a:	74 1f                	je     c002876b <list_next+0x2a>
c002874c:	83 38 00             	cmpl   $0x0,(%eax)
c002874f:	74 12                	je     c0028763 <list_next+0x22>
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028751:	83 38 00             	cmpl   $0x0,(%eax)
c0028754:	74 15                	je     c002876b <list_next+0x2a>
c0028756:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002875a:	74 0f                	je     c002876b <list_next+0x2a>
  ASSERT (is_head (elem) || is_interior (elem));
  return elem->next;
c002875c:	8b 40 04             	mov    0x4(%eax),%eax
}
c002875f:	83 c4 0c             	add    $0xc,%esp
c0028762:	c3                   	ret    
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0028763:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0028767:	75 f3                	jne    c002875c <list_next+0x1b>
c0028769:	eb e6                	jmp    c0028751 <list_next+0x10>
  ASSERT (is_head (elem) || is_interior (elem));
c002876b:	83 ec 0c             	sub    $0xc,%esp
c002876e:	68 ac 1e 03 c0       	push   $0xc0031eac
c0028773:	68 21 01 03 c0       	push   $0xc0030121
c0028778:	68 e0 fc 02 c0       	push   $0xc002fce0
c002877d:	6a 52                	push   $0x52
c002877f:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028784:	e8 9e fe ff ff       	call   c0028627 <debug_panic>

c0028789 <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0028789:	83 ec 0c             	sub    $0xc,%esp
c002878c:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0028790:	85 c0                	test   %eax,%eax
c0028792:	74 07                	je     c002879b <list_end+0x12>
  return &list->tail;
c0028794:	83 c0 08             	add    $0x8,%eax
}
c0028797:	83 c4 0c             	add    $0xc,%esp
c002879a:	c3                   	ret    
  ASSERT (list != NULL);
c002879b:	83 ec 0c             	sub    $0xc,%esp
c002879e:	68 ea 1d 03 c0       	push   $0xc0031dea
c00287a3:	68 21 01 03 c0       	push   $0xc0030121
c00287a8:	68 d4 fc 02 c0       	push   $0xc002fcd4
c00287ad:	6a 5e                	push   $0x5e
c00287af:	68 f7 1d 03 c0       	push   $0xc0031df7
c00287b4:	e8 6e fe ff ff       	call   c0028627 <debug_panic>

c00287b9 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c00287b9:	83 ec 0c             	sub    $0xc,%esp
c00287bc:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00287c0:	85 c0                	test   %eax,%eax
c00287c2:	74 07                	je     c00287cb <list_rbegin+0x12>
  return list->tail.prev;
c00287c4:	8b 40 08             	mov    0x8(%eax),%eax
}
c00287c7:	83 c4 0c             	add    $0xc,%esp
c00287ca:	c3                   	ret    
  ASSERT (list != NULL);
c00287cb:	83 ec 0c             	sub    $0xc,%esp
c00287ce:	68 ea 1d 03 c0       	push   $0xc0031dea
c00287d3:	68 21 01 03 c0       	push   $0xc0030121
c00287d8:	68 c8 fc 02 c0       	push   $0xc002fcc8
c00287dd:	6a 67                	push   $0x67
c00287df:	68 f7 1d 03 c0       	push   $0xc0031df7
c00287e4:	e8 3e fe ff ff       	call   c0028627 <debug_panic>

c00287e9 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c00287e9:	83 ec 0c             	sub    $0xc,%esp
c00287ec:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00287f0:	85 c0                	test   %eax,%eax
c00287f2:	74 1c                	je     c0028810 <list_prev+0x27>
c00287f4:	83 38 00             	cmpl   $0x0,(%eax)
c00287f7:	74 0c                	je     c0028805 <list_prev+0x1c>
c00287f9:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00287fd:	74 06                	je     c0028805 <list_prev+0x1c>
  ASSERT (is_interior (elem) || is_tail (elem));
  return elem->prev;
c00287ff:	8b 00                	mov    (%eax),%eax
}
c0028801:	83 c4 0c             	add    $0xc,%esp
c0028804:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0028805:	83 38 00             	cmpl   $0x0,(%eax)
c0028808:	74 06                	je     c0028810 <list_prev+0x27>
c002880a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002880e:	74 ef                	je     c00287ff <list_prev+0x16>
  ASSERT (is_interior (elem) || is_tail (elem));
c0028810:	83 ec 0c             	sub    $0xc,%esp
c0028813:	68 d4 1e 03 c0       	push   $0xc0031ed4
c0028818:	68 21 01 03 c0       	push   $0xc0030121
c002881d:	68 bc fc 02 c0       	push   $0xc002fcbc
c0028822:	6a 71                	push   $0x71
c0028824:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028829:	e8 f9 fd ff ff       	call   c0028627 <debug_panic>

c002882e <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c002882e:	55                   	push   %ebp
c002882f:	57                   	push   %edi
c0028830:	56                   	push   %esi
c0028831:	53                   	push   %ebx
c0028832:	83 ec 0c             	sub    $0xc,%esp
c0028835:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  ASSERT (a != NULL);
c0028839:	85 c0                	test   %eax,%eax
c002883b:	74 50                	je     c002888d <find_end_of_run+0x5f>
c002883d:	89 c3                	mov    %eax,%ebx
c002883f:	89 d6                	mov    %edx,%esi
c0028841:	89 cf                	mov    %ecx,%edi
  ASSERT (b != NULL);
c0028843:	85 d2                	test   %edx,%edx
c0028845:	74 67                	je     c00288ae <find_end_of_run+0x80>
  ASSERT (less != NULL);
c0028847:	85 c9                	test   %ecx,%ecx
c0028849:	0f 84 80 00 00 00    	je     c00288cf <find_end_of_run+0xa1>
  ASSERT (a != b);
c002884f:	39 d0                	cmp    %edx,%eax
c0028851:	0f 84 99 00 00 00    	je     c00288f0 <find_end_of_run+0xc2>
  
  do 
    {
      a = list_next (a);
c0028857:	83 ec 0c             	sub    $0xc,%esp
c002885a:	53                   	push   %ebx
c002885b:	e8 e1 fe ff ff       	call   c0028741 <list_next>
c0028860:	83 c4 10             	add    $0x10,%esp
c0028863:	89 c3                	mov    %eax,%ebx
    }
  while (a != b && !less (a, list_prev (a), aux));
c0028865:	39 c6                	cmp    %eax,%esi
c0028867:	74 1a                	je     c0028883 <find_end_of_run+0x55>
c0028869:	83 ec 0c             	sub    $0xc,%esp
c002886c:	50                   	push   %eax
c002886d:	e8 77 ff ff ff       	call   c00287e9 <list_prev>
c0028872:	83 c4 0c             	add    $0xc,%esp
c0028875:	55                   	push   %ebp
c0028876:	50                   	push   %eax
c0028877:	53                   	push   %ebx
c0028878:	ff d7                	call   *%edi
c002887a:	83 c4 10             	add    $0x10,%esp
c002887d:	84 c0                	test   %al,%al
c002887f:	74 d6                	je     c0028857 <find_end_of_run+0x29>
      a = list_next (a);
c0028881:	89 de                	mov    %ebx,%esi
  return a;
}
c0028883:	89 f0                	mov    %esi,%eax
c0028885:	83 c4 0c             	add    $0xc,%esp
c0028888:	5b                   	pop    %ebx
c0028889:	5e                   	pop    %esi
c002888a:	5f                   	pop    %edi
c002888b:	5d                   	pop    %ebp
c002888c:	c3                   	ret    
  ASSERT (a != NULL);
c002888d:	83 ec 0c             	sub    $0xc,%esp
c0028890:	68 51 0c 03 c0       	push   $0xc0030c51
c0028895:	68 21 01 03 c0       	push   $0xc0030121
c002889a:	68 40 fc 02 c0       	push   $0xc002fc40
c002889f:	68 67 01 00 00       	push   $0x167
c00288a4:	68 f7 1d 03 c0       	push   $0xc0031df7
c00288a9:	e8 79 fd ff ff       	call   c0028627 <debug_panic>
  ASSERT (b != NULL);
c00288ae:	83 ec 0c             	sub    $0xc,%esp
c00288b1:	68 0f 1e 03 c0       	push   $0xc0031e0f
c00288b6:	68 21 01 03 c0       	push   $0xc0030121
c00288bb:	68 40 fc 02 c0       	push   $0xc002fc40
c00288c0:	68 68 01 00 00       	push   $0x168
c00288c5:	68 f7 1d 03 c0       	push   $0xc0031df7
c00288ca:	e8 58 fd ff ff       	call   c0028627 <debug_panic>
  ASSERT (less != NULL);
c00288cf:	83 ec 0c             	sub    $0xc,%esp
c00288d2:	68 19 1e 03 c0       	push   $0xc0031e19
c00288d7:	68 21 01 03 c0       	push   $0xc0030121
c00288dc:	68 40 fc 02 c0       	push   $0xc002fc40
c00288e1:	68 69 01 00 00       	push   $0x169
c00288e6:	68 f7 1d 03 c0       	push   $0xc0031df7
c00288eb:	e8 37 fd ff ff       	call   c0028627 <debug_panic>
  ASSERT (a != b);
c00288f0:	83 ec 0c             	sub    $0xc,%esp
c00288f3:	68 26 1e 03 c0       	push   $0xc0031e26
c00288f8:	68 21 01 03 c0       	push   $0xc0030121
c00288fd:	68 40 fc 02 c0       	push   $0xc002fc40
c0028902:	68 6a 01 00 00       	push   $0x16a
c0028907:	68 f7 1d 03 c0       	push   $0xc0031df7
c002890c:	e8 16 fd ff ff       	call   c0028627 <debug_panic>

c0028911 <list_rend>:
{
c0028911:	83 ec 0c             	sub    $0xc,%esp
c0028914:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0028918:	85 c0                	test   %eax,%eax
c002891a:	74 04                	je     c0028920 <list_rend+0xf>
}
c002891c:	83 c4 0c             	add    $0xc,%esp
c002891f:	c3                   	ret    
  ASSERT (list != NULL);
c0028920:	83 ec 0c             	sub    $0xc,%esp
c0028923:	68 ea 1d 03 c0       	push   $0xc0031dea
c0028928:	68 21 01 03 c0       	push   $0xc0030121
c002892d:	68 b0 fc 02 c0       	push   $0xc002fcb0
c0028932:	68 85 00 00 00       	push   $0x85
c0028937:	68 f7 1d 03 c0       	push   $0xc0031df7
c002893c:	e8 e6 fc ff ff       	call   c0028627 <debug_panic>

c0028941 <list_head>:
{
c0028941:	83 ec 0c             	sub    $0xc,%esp
c0028944:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0028948:	85 c0                	test   %eax,%eax
c002894a:	74 04                	je     c0028950 <list_head+0xf>
}
c002894c:	83 c4 0c             	add    $0xc,%esp
c002894f:	c3                   	ret    
  ASSERT (list != NULL);
c0028950:	83 ec 0c             	sub    $0xc,%esp
c0028953:	68 ea 1d 03 c0       	push   $0xc0031dea
c0028958:	68 21 01 03 c0       	push   $0xc0030121
c002895d:	68 a4 fc 02 c0       	push   $0xc002fca4
c0028962:	68 97 00 00 00       	push   $0x97
c0028967:	68 f7 1d 03 c0       	push   $0xc0031df7
c002896c:	e8 b6 fc ff ff       	call   c0028627 <debug_panic>

c0028971 <list_tail>:
{
c0028971:	83 ec 0c             	sub    $0xc,%esp
c0028974:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0028978:	85 c0                	test   %eax,%eax
c002897a:	74 07                	je     c0028983 <list_tail+0x12>
  return &list->tail;
c002897c:	83 c0 08             	add    $0x8,%eax
}
c002897f:	83 c4 0c             	add    $0xc,%esp
c0028982:	c3                   	ret    
  ASSERT (list != NULL);
c0028983:	83 ec 0c             	sub    $0xc,%esp
c0028986:	68 ea 1d 03 c0       	push   $0xc0031dea
c002898b:	68 21 01 03 c0       	push   $0xc0030121
c0028990:	68 98 fc 02 c0       	push   $0xc002fc98
c0028995:	68 9f 00 00 00       	push   $0x9f
c002899a:	68 f7 1d 03 c0       	push   $0xc0031df7
c002899f:	e8 83 fc ff ff       	call   c0028627 <debug_panic>

c00289a4 <list_insert>:
{
c00289a4:	83 ec 0c             	sub    $0xc,%esp
c00289a7:	8b 44 24 10          	mov    0x10(%esp),%eax
c00289ab:	8b 54 24 14          	mov    0x14(%esp),%edx
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00289af:	85 c0                	test   %eax,%eax
c00289b1:	74 2c                	je     c00289df <list_insert+0x3b>
c00289b3:	83 38 00             	cmpl   $0x0,(%eax)
c00289b6:	74 1c                	je     c00289d4 <list_insert+0x30>
c00289b8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00289bc:	74 16                	je     c00289d4 <list_insert+0x30>
  ASSERT (elem != NULL);
c00289be:	85 d2                	test   %edx,%edx
c00289c0:	74 3e                	je     c0028a00 <list_insert+0x5c>
  elem->prev = before->prev;
c00289c2:	8b 08                	mov    (%eax),%ecx
c00289c4:	89 0a                	mov    %ecx,(%edx)
  elem->next = before;
c00289c6:	89 42 04             	mov    %eax,0x4(%edx)
  before->prev->next = elem;
c00289c9:	8b 08                	mov    (%eax),%ecx
c00289cb:	89 51 04             	mov    %edx,0x4(%ecx)
  before->prev = elem;
c00289ce:	89 10                	mov    %edx,(%eax)
}
c00289d0:	83 c4 0c             	add    $0xc,%esp
c00289d3:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00289d4:	83 38 00             	cmpl   $0x0,(%eax)
c00289d7:	74 06                	je     c00289df <list_insert+0x3b>
c00289d9:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00289dd:	74 df                	je     c00289be <list_insert+0x1a>
  ASSERT (is_interior (before) || is_tail (before));
c00289df:	83 ec 0c             	sub    $0xc,%esp
c00289e2:	68 fc 1e 03 c0       	push   $0xc0031efc
c00289e7:	68 21 01 03 c0       	push   $0xc0030121
c00289ec:	68 8c fc 02 c0       	push   $0xc002fc8c
c00289f1:	68 a9 00 00 00       	push   $0xa9
c00289f6:	68 f7 1d 03 c0       	push   $0xc0031df7
c00289fb:	e8 27 fc ff ff       	call   c0028627 <debug_panic>
  ASSERT (elem != NULL);
c0028a00:	83 ec 0c             	sub    $0xc,%esp
c0028a03:	68 2d 1e 03 c0       	push   $0xc0031e2d
c0028a08:	68 21 01 03 c0       	push   $0xc0030121
c0028a0d:	68 8c fc 02 c0       	push   $0xc002fc8c
c0028a12:	68 aa 00 00 00       	push   $0xaa
c0028a17:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028a1c:	e8 06 fc ff ff       	call   c0028627 <debug_panic>

c0028a21 <list_splice>:
{
c0028a21:	56                   	push   %esi
c0028a22:	53                   	push   %ebx
c0028a23:	83 ec 04             	sub    $0x4,%esp
c0028a26:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028a2a:	8b 74 24 14          	mov    0x14(%esp),%esi
c0028a2e:	8b 44 24 18          	mov    0x18(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028a32:	85 db                	test   %ebx,%ebx
c0028a34:	74 64                	je     c0028a9a <list_splice+0x79>
c0028a36:	83 3b 00             	cmpl   $0x0,(%ebx)
c0028a39:	74 54                	je     c0028a8f <list_splice+0x6e>
c0028a3b:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0028a3f:	74 4e                	je     c0028a8f <list_splice+0x6e>
  if (first == last)
c0028a41:	39 c6                	cmp    %eax,%esi
c0028a43:	74 44                	je     c0028a89 <list_splice+0x68>
  last = list_prev (last);
c0028a45:	83 ec 0c             	sub    $0xc,%esp
c0028a48:	50                   	push   %eax
c0028a49:	e8 9b fd ff ff       	call   c00287e9 <list_prev>
c0028a4e:	83 c4 10             	add    $0x10,%esp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028a51:	85 f6                	test   %esi,%esi
c0028a53:	74 66                	je     c0028abb <list_splice+0x9a>
c0028a55:	8b 16                	mov    (%esi),%edx
c0028a57:	85 d2                	test   %edx,%edx
c0028a59:	74 60                	je     c0028abb <list_splice+0x9a>
c0028a5b:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0028a5f:	74 5a                	je     c0028abb <list_splice+0x9a>
c0028a61:	85 c0                	test   %eax,%eax
c0028a63:	74 77                	je     c0028adc <list_splice+0xbb>
c0028a65:	83 38 00             	cmpl   $0x0,(%eax)
c0028a68:	74 72                	je     c0028adc <list_splice+0xbb>
c0028a6a:	8b 48 04             	mov    0x4(%eax),%ecx
c0028a6d:	85 c9                	test   %ecx,%ecx
c0028a6f:	74 6b                	je     c0028adc <list_splice+0xbb>
  first->prev->next = last->next;
c0028a71:	89 4a 04             	mov    %ecx,0x4(%edx)
  last->next->prev = first->prev;
c0028a74:	8b 50 04             	mov    0x4(%eax),%edx
c0028a77:	8b 0e                	mov    (%esi),%ecx
c0028a79:	89 0a                	mov    %ecx,(%edx)
  first->prev = before->prev;
c0028a7b:	8b 13                	mov    (%ebx),%edx
c0028a7d:	89 16                	mov    %edx,(%esi)
  last->next = before;
c0028a7f:	89 58 04             	mov    %ebx,0x4(%eax)
  before->prev->next = first;
c0028a82:	8b 13                	mov    (%ebx),%edx
c0028a84:	89 72 04             	mov    %esi,0x4(%edx)
  before->prev = last;
c0028a87:	89 03                	mov    %eax,(%ebx)
}
c0028a89:	83 c4 04             	add    $0x4,%esp
c0028a8c:	5b                   	pop    %ebx
c0028a8d:	5e                   	pop    %esi
c0028a8e:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0028a8f:	83 3b 00             	cmpl   $0x0,(%ebx)
c0028a92:	74 06                	je     c0028a9a <list_splice+0x79>
c0028a94:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0028a98:	74 a7                	je     c0028a41 <list_splice+0x20>
  ASSERT (is_interior (before) || is_tail (before));
c0028a9a:	83 ec 0c             	sub    $0xc,%esp
c0028a9d:	68 fc 1e 03 c0       	push   $0xc0031efc
c0028aa2:	68 21 01 03 c0       	push   $0xc0030121
c0028aa7:	68 80 fc 02 c0       	push   $0xc002fc80
c0028aac:	68 b9 00 00 00       	push   $0xb9
c0028ab1:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028ab6:	e8 6c fb ff ff       	call   c0028627 <debug_panic>
  ASSERT (is_interior (first));
c0028abb:	83 ec 0c             	sub    $0xc,%esp
c0028abe:	68 3a 1e 03 c0       	push   $0xc0031e3a
c0028ac3:	68 21 01 03 c0       	push   $0xc0030121
c0028ac8:	68 80 fc 02 c0       	push   $0xc002fc80
c0028acd:	68 be 00 00 00       	push   $0xbe
c0028ad2:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028ad7:	e8 4b fb ff ff       	call   c0028627 <debug_panic>
  ASSERT (is_interior (last));
c0028adc:	83 ec 0c             	sub    $0xc,%esp
c0028adf:	68 4e 1e 03 c0       	push   $0xc0031e4e
c0028ae4:	68 21 01 03 c0       	push   $0xc0030121
c0028ae9:	68 80 fc 02 c0       	push   $0xc002fc80
c0028aee:	68 bf 00 00 00       	push   $0xbf
c0028af3:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028af8:	e8 2a fb ff ff       	call   c0028627 <debug_panic>

c0028afd <list_push_front>:
{
c0028afd:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_begin (list), elem);
c0028b00:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028b04:	e8 08 fc ff ff       	call   c0028711 <list_begin>
c0028b09:	83 c4 08             	add    $0x8,%esp
c0028b0c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028b10:	50                   	push   %eax
c0028b11:	e8 8e fe ff ff       	call   c00289a4 <list_insert>
}
c0028b16:	83 c4 1c             	add    $0x1c,%esp
c0028b19:	c3                   	ret    

c0028b1a <list_push_back>:
{
c0028b1a:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_end (list), elem);
c0028b1d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028b21:	e8 63 fc ff ff       	call   c0028789 <list_end>
c0028b26:	83 c4 08             	add    $0x8,%esp
c0028b29:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028b2d:	50                   	push   %eax
c0028b2e:	e8 71 fe ff ff       	call   c00289a4 <list_insert>
}
c0028b33:	83 c4 1c             	add    $0x1c,%esp
c0028b36:	c3                   	ret    

c0028b37 <list_remove>:
{
c0028b37:	83 ec 0c             	sub    $0xc,%esp
c0028b3a:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028b3e:	85 c0                	test   %eax,%eax
c0028b40:	74 1e                	je     c0028b60 <list_remove+0x29>
c0028b42:	8b 10                	mov    (%eax),%edx
c0028b44:	85 d2                	test   %edx,%edx
c0028b46:	74 18                	je     c0028b60 <list_remove+0x29>
c0028b48:	8b 48 04             	mov    0x4(%eax),%ecx
c0028b4b:	85 c9                	test   %ecx,%ecx
c0028b4d:	74 11                	je     c0028b60 <list_remove+0x29>
  elem->prev->next = elem->next;
c0028b4f:	89 4a 04             	mov    %ecx,0x4(%edx)
  elem->next->prev = elem->prev;
c0028b52:	8b 50 04             	mov    0x4(%eax),%edx
c0028b55:	8b 08                	mov    (%eax),%ecx
c0028b57:	89 0a                	mov    %ecx,(%edx)
  return elem->next;
c0028b59:	8b 40 04             	mov    0x4(%eax),%eax
}
c0028b5c:	83 c4 0c             	add    $0xc,%esp
c0028b5f:	c3                   	ret    
  ASSERT (is_interior (elem));
c0028b60:	83 ec 0c             	sub    $0xc,%esp
c0028b63:	68 61 1e 03 c0       	push   $0xc0031e61
c0028b68:	68 21 01 03 c0       	push   $0xc0030121
c0028b6d:	68 74 fc 02 c0       	push   $0xc002fc74
c0028b72:	68 f9 00 00 00       	push   $0xf9
c0028b77:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028b7c:	e8 a6 fa ff ff       	call   c0028627 <debug_panic>

c0028b81 <list_size>:
{
c0028b81:	57                   	push   %edi
c0028b82:	56                   	push   %esi
c0028b83:	53                   	push   %ebx
c0028b84:	8b 7c 24 10          	mov    0x10(%esp),%edi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028b88:	83 ec 0c             	sub    $0xc,%esp
c0028b8b:	57                   	push   %edi
c0028b8c:	e8 80 fb ff ff       	call   c0028711 <list_begin>
c0028b91:	83 c4 10             	add    $0x10,%esp
c0028b94:	89 c3                	mov    %eax,%ebx
  size_t cnt = 0;
c0028b96:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028b9b:	eb 0f                	jmp    c0028bac <list_size+0x2b>
    cnt++;
c0028b9d:	46                   	inc    %esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028b9e:	83 ec 0c             	sub    $0xc,%esp
c0028ba1:	53                   	push   %ebx
c0028ba2:	e8 9a fb ff ff       	call   c0028741 <list_next>
c0028ba7:	83 c4 10             	add    $0x10,%esp
c0028baa:	89 c3                	mov    %eax,%ebx
c0028bac:	83 ec 0c             	sub    $0xc,%esp
c0028baf:	57                   	push   %edi
c0028bb0:	e8 d4 fb ff ff       	call   c0028789 <list_end>
c0028bb5:	83 c4 10             	add    $0x10,%esp
c0028bb8:	39 c3                	cmp    %eax,%ebx
c0028bba:	75 e1                	jne    c0028b9d <list_size+0x1c>
}
c0028bbc:	89 f0                	mov    %esi,%eax
c0028bbe:	5b                   	pop    %ebx
c0028bbf:	5e                   	pop    %esi
c0028bc0:	5f                   	pop    %edi
c0028bc1:	c3                   	ret    

c0028bc2 <list_empty>:
{
c0028bc2:	56                   	push   %esi
c0028bc3:	53                   	push   %ebx
c0028bc4:	83 ec 10             	sub    $0x10,%esp
c0028bc7:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  return list_begin (list) == list_end (list);
c0028bcb:	53                   	push   %ebx
c0028bcc:	e8 40 fb ff ff       	call   c0028711 <list_begin>
c0028bd1:	89 c6                	mov    %eax,%esi
c0028bd3:	89 1c 24             	mov    %ebx,(%esp)
c0028bd6:	e8 ae fb ff ff       	call   c0028789 <list_end>
c0028bdb:	39 c6                	cmp    %eax,%esi
c0028bdd:	0f 94 c0             	sete   %al
}
c0028be0:	83 c4 14             	add    $0x14,%esp
c0028be3:	5b                   	pop    %ebx
c0028be4:	5e                   	pop    %esi
c0028be5:	c3                   	ret    

c0028be6 <list_front>:
{
c0028be6:	53                   	push   %ebx
c0028be7:	83 ec 14             	sub    $0x14,%esp
c0028bea:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  ASSERT (!list_empty (list));
c0028bee:	53                   	push   %ebx
c0028bef:	e8 ce ff ff ff       	call   c0028bc2 <list_empty>
c0028bf4:	83 c4 10             	add    $0x10,%esp
c0028bf7:	84 c0                	test   %al,%al
c0028bf9:	75 08                	jne    c0028c03 <list_front+0x1d>
  return list->head.next;
c0028bfb:	8b 43 04             	mov    0x4(%ebx),%eax
}
c0028bfe:	83 c4 08             	add    $0x8,%esp
c0028c01:	5b                   	pop    %ebx
c0028c02:	c3                   	ret    
  ASSERT (!list_empty (list));
c0028c03:	83 ec 0c             	sub    $0xc,%esp
c0028c06:	68 74 1e 03 c0       	push   $0xc0031e74
c0028c0b:	68 21 01 03 c0       	push   $0xc0030121
c0028c10:	68 68 fc 02 c0       	push   $0xc002fc68
c0028c15:	68 18 01 00 00       	push   $0x118
c0028c1a:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028c1f:	e8 03 fa ff ff       	call   c0028627 <debug_panic>

c0028c24 <list_pop_front>:
{
c0028c24:	53                   	push   %ebx
c0028c25:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *front = list_front (list);
c0028c28:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028c2c:	e8 b5 ff ff ff       	call   c0028be6 <list_front>
c0028c31:	89 c3                	mov    %eax,%ebx
  list_remove (front);
c0028c33:	89 04 24             	mov    %eax,(%esp)
c0028c36:	e8 fc fe ff ff       	call   c0028b37 <list_remove>
}
c0028c3b:	89 d8                	mov    %ebx,%eax
c0028c3d:	83 c4 18             	add    $0x18,%esp
c0028c40:	5b                   	pop    %ebx
c0028c41:	c3                   	ret    

c0028c42 <list_back>:
{
c0028c42:	53                   	push   %ebx
c0028c43:	83 ec 14             	sub    $0x14,%esp
c0028c46:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  ASSERT (!list_empty (list));
c0028c4a:	53                   	push   %ebx
c0028c4b:	e8 72 ff ff ff       	call   c0028bc2 <list_empty>
c0028c50:	83 c4 10             	add    $0x10,%esp
c0028c53:	84 c0                	test   %al,%al
c0028c55:	75 08                	jne    c0028c5f <list_back+0x1d>
  return list->tail.prev;
c0028c57:	8b 43 08             	mov    0x8(%ebx),%eax
}
c0028c5a:	83 c4 08             	add    $0x8,%esp
c0028c5d:	5b                   	pop    %ebx
c0028c5e:	c3                   	ret    
  ASSERT (!list_empty (list));
c0028c5f:	83 ec 0c             	sub    $0xc,%esp
c0028c62:	68 74 1e 03 c0       	push   $0xc0031e74
c0028c67:	68 21 01 03 c0       	push   $0xc0030121
c0028c6c:	68 5c fc 02 c0       	push   $0xc002fc5c
c0028c71:	68 21 01 00 00       	push   $0x121
c0028c76:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028c7b:	e8 a7 f9 ff ff       	call   c0028627 <debug_panic>

c0028c80 <list_pop_back>:
{
c0028c80:	53                   	push   %ebx
c0028c81:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *back = list_back (list);
c0028c84:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028c88:	e8 b5 ff ff ff       	call   c0028c42 <list_back>
c0028c8d:	89 c3                	mov    %eax,%ebx
  list_remove (back);
c0028c8f:	89 04 24             	mov    %eax,(%esp)
c0028c92:	e8 a0 fe ff ff       	call   c0028b37 <list_remove>
}
c0028c97:	89 d8                	mov    %ebx,%eax
c0028c99:	83 c4 18             	add    $0x18,%esp
c0028c9c:	5b                   	pop    %ebx
c0028c9d:	c3                   	ret    

c0028c9e <list_reverse>:
{
c0028c9e:	56                   	push   %esi
c0028c9f:	53                   	push   %ebx
c0028ca0:	83 ec 10             	sub    $0x10,%esp
c0028ca3:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  if (!list_empty (list)) 
c0028ca7:	56                   	push   %esi
c0028ca8:	e8 15 ff ff ff       	call   c0028bc2 <list_empty>
c0028cad:	83 c4 10             	add    $0x10,%esp
c0028cb0:	84 c0                	test   %al,%al
c0028cb2:	74 06                	je     c0028cba <list_reverse+0x1c>
}
c0028cb4:	83 c4 04             	add    $0x4,%esp
c0028cb7:	5b                   	pop    %ebx
c0028cb8:	5e                   	pop    %esi
c0028cb9:	c3                   	ret    
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0028cba:	83 ec 0c             	sub    $0xc,%esp
c0028cbd:	56                   	push   %esi
c0028cbe:	e8 4e fa ff ff       	call   c0028711 <list_begin>
c0028cc3:	83 c4 10             	add    $0x10,%esp
c0028cc6:	89 c3                	mov    %eax,%ebx
c0028cc8:	eb 0c                	jmp    c0028cd6 <list_reverse+0x38>
  struct list_elem *t = *a;
c0028cca:	8b 13                	mov    (%ebx),%edx
  *a = *b;
c0028ccc:	8b 43 04             	mov    0x4(%ebx),%eax
c0028ccf:	89 03                	mov    %eax,(%ebx)
  *b = t;
c0028cd1:	89 53 04             	mov    %edx,0x4(%ebx)
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0028cd4:	89 c3                	mov    %eax,%ebx
c0028cd6:	83 ec 0c             	sub    $0xc,%esp
c0028cd9:	56                   	push   %esi
c0028cda:	e8 aa fa ff ff       	call   c0028789 <list_end>
c0028cdf:	83 c4 10             	add    $0x10,%esp
c0028ce2:	39 c3                	cmp    %eax,%ebx
c0028ce4:	75 e4                	jne    c0028cca <list_reverse+0x2c>
  struct list_elem *t = *a;
c0028ce6:	8b 46 04             	mov    0x4(%esi),%eax
  *a = *b;
c0028ce9:	8b 56 08             	mov    0x8(%esi),%edx
c0028cec:	89 56 04             	mov    %edx,0x4(%esi)
  *b = t;
c0028cef:	89 46 08             	mov    %eax,0x8(%esi)
  struct list_elem *t = *a;
c0028cf2:	8b 0a                	mov    (%edx),%ecx
  *a = *b;
c0028cf4:	8b 58 04             	mov    0x4(%eax),%ebx
c0028cf7:	89 1a                	mov    %ebx,(%edx)
  *b = t;
c0028cf9:	89 48 04             	mov    %ecx,0x4(%eax)
}
c0028cfc:	eb b6                	jmp    c0028cb4 <list_reverse+0x16>

c0028cfe <is_sorted>:
{
c0028cfe:	55                   	push   %ebp
c0028cff:	57                   	push   %edi
c0028d00:	56                   	push   %esi
c0028d01:	53                   	push   %ebx
c0028d02:	83 ec 0c             	sub    $0xc,%esp
c0028d05:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0028d09:	8b 74 24 24          	mov    0x24(%esp),%esi
c0028d0d:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c0028d11:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  return true;
c0028d15:	b0 01                	mov    $0x1,%al
  if (a != b)
c0028d17:	39 f3                	cmp    %esi,%ebx
c0028d19:	74 30                	je     c0028d4b <is_sorted+0x4d>
    while ((a = list_next (a)) != b) 
c0028d1b:	83 ec 0c             	sub    $0xc,%esp
c0028d1e:	53                   	push   %ebx
c0028d1f:	e8 1d fa ff ff       	call   c0028741 <list_next>
c0028d24:	83 c4 10             	add    $0x10,%esp
c0028d27:	89 c3                	mov    %eax,%ebx
c0028d29:	39 c6                	cmp    %eax,%esi
c0028d2b:	74 1c                	je     c0028d49 <is_sorted+0x4b>
      if (less (a, list_prev (a), aux))
c0028d2d:	83 ec 0c             	sub    $0xc,%esp
c0028d30:	53                   	push   %ebx
c0028d31:	e8 b3 fa ff ff       	call   c00287e9 <list_prev>
c0028d36:	83 c4 0c             	add    $0xc,%esp
c0028d39:	57                   	push   %edi
c0028d3a:	50                   	push   %eax
c0028d3b:	53                   	push   %ebx
c0028d3c:	ff d5                	call   *%ebp
c0028d3e:	83 c4 10             	add    $0x10,%esp
c0028d41:	84 c0                	test   %al,%al
c0028d43:	74 d6                	je     c0028d1b <is_sorted+0x1d>
        return false;
c0028d45:	b0 00                	mov    $0x0,%al
c0028d47:	eb 02                	jmp    c0028d4b <is_sorted+0x4d>
  return true;
c0028d49:	b0 01                	mov    $0x1,%al
}
c0028d4b:	83 c4 0c             	add    $0xc,%esp
c0028d4e:	5b                   	pop    %ebx
c0028d4f:	5e                   	pop    %esi
c0028d50:	5f                   	pop    %edi
c0028d51:	5d                   	pop    %ebp
c0028d52:	c3                   	ret    

c0028d53 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c0028d53:	55                   	push   %ebp
c0028d54:	57                   	push   %edi
c0028d55:	56                   	push   %esi
c0028d56:	53                   	push   %ebx
c0028d57:	83 ec 1c             	sub    $0x1c,%esp
c0028d5a:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028d5e:	8b 7c 24 38          	mov    0x38(%esp),%edi
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c0028d62:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0028d67:	74 29                	je     c0028d92 <list_sort+0x3f>
  ASSERT (less != NULL);
c0028d69:	85 ed                	test   %ebp,%ebp
c0028d6b:	0f 85 ee 01 00 00    	jne    c0028f5f <list_sort+0x20c>
c0028d71:	83 ec 0c             	sub    $0xc,%esp
c0028d74:	68 19 1e 03 c0       	push   $0xc0031e19
c0028d79:	68 21 01 03 c0       	push   $0xc0030121
c0028d7e:	68 50 fc 02 c0       	push   $0xc002fc50
c0028d83:	68 98 01 00 00       	push   $0x198
c0028d88:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028d8d:	e8 95 f8 ff ff       	call   c0028627 <debug_panic>
  ASSERT (list != NULL);
c0028d92:	83 ec 0c             	sub    $0xc,%esp
c0028d95:	68 ea 1d 03 c0       	push   $0xc0031dea
c0028d9a:	68 21 01 03 c0       	push   $0xc0030121
c0028d9f:	68 50 fc 02 c0       	push   $0xc002fc50
c0028da4:	68 97 01 00 00       	push   $0x197
c0028da9:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028dae:	e8 74 f8 ff ff       	call   c0028627 <debug_panic>
  ASSERT (a0 != NULL);
c0028db3:	83 ec 0c             	sub    $0xc,%esp
c0028db6:	68 87 1e 03 c0       	push   $0xc0031e87
c0028dbb:	68 21 01 03 c0       	push   $0xc0030121
c0028dc0:	68 30 fc 02 c0       	push   $0xc002fc30
c0028dc5:	68 7e 01 00 00       	push   $0x17e
c0028dca:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028dcf:	e8 53 f8 ff ff       	call   c0028627 <debug_panic>
  ASSERT (a1b0 != NULL);
c0028dd4:	83 ec 0c             	sub    $0xc,%esp
c0028dd7:	68 92 1e 03 c0       	push   $0xc0031e92
c0028ddc:	68 21 01 03 c0       	push   $0xc0030121
c0028de1:	68 30 fc 02 c0       	push   $0xc002fc30
c0028de6:	68 7f 01 00 00       	push   $0x17f
c0028deb:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028df0:	e8 32 f8 ff ff       	call   c0028627 <debug_panic>
  ASSERT (b1 != NULL);
c0028df5:	83 ec 0c             	sub    $0xc,%esp
c0028df8:	68 9f 1e 03 c0       	push   $0xc0031e9f
c0028dfd:	68 21 01 03 c0       	push   $0xc0030121
c0028e02:	68 30 fc 02 c0       	push   $0xc002fc30
c0028e07:	68 80 01 00 00       	push   $0x180
c0028e0c:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028e11:	e8 11 f8 ff ff       	call   c0028627 <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0028e16:	83 ec 0c             	sub    $0xc,%esp
c0028e19:	68 28 1f 03 c0       	push   $0xc0031f28
c0028e1e:	68 21 01 03 c0       	push   $0xc0030121
c0028e23:	68 30 fc 02 c0       	push   $0xc002fc30
c0028e28:	68 82 01 00 00       	push   $0x182
c0028e2d:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028e32:	e8 f0 f7 ff ff       	call   c0028627 <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0028e37:	83 ec 0c             	sub    $0xc,%esp
c0028e3a:	68 48 1f 03 c0       	push   $0xc0031f48
c0028e3f:	68 21 01 03 c0       	push   $0xc0030121
c0028e44:	68 30 fc 02 c0       	push   $0xc002fc30
c0028e49:	68 83 01 00 00       	push   $0x183
c0028e4e:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028e53:	e8 cf f7 ff ff       	call   c0028627 <debug_panic>
        a1b0 = list_next (a1b0);
c0028e58:	83 ec 0c             	sub    $0xc,%esp
c0028e5b:	53                   	push   %ebx
c0028e5c:	e8 e0 f8 ff ff       	call   c0028741 <list_next>
c0028e61:	89 c3                	mov    %eax,%ebx
        list_splice (a0, list_prev (a1b0), a1b0);
c0028e63:	89 04 24             	mov    %eax,(%esp)
c0028e66:	e8 7e f9 ff ff       	call   c00287e9 <list_prev>
c0028e6b:	83 c4 0c             	add    $0xc,%esp
c0028e6e:	53                   	push   %ebx
c0028e6f:	50                   	push   %eax
c0028e70:	56                   	push   %esi
c0028e71:	e8 ab fb ff ff       	call   c0028a21 <list_splice>
c0028e76:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c0028e79:	39 f3                	cmp    %esi,%ebx
c0028e7b:	74 25                	je     c0028ea2 <list_sort+0x14f>
c0028e7d:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
c0028e81:	74 1f                	je     c0028ea2 <list_sort+0x14f>
    if (!less (a1b0, a0, aux)) 
c0028e83:	83 ec 04             	sub    $0x4,%esp
c0028e86:	57                   	push   %edi
c0028e87:	56                   	push   %esi
c0028e88:	53                   	push   %ebx
c0028e89:	ff d5                	call   *%ebp
c0028e8b:	83 c4 10             	add    $0x10,%esp
c0028e8e:	84 c0                	test   %al,%al
c0028e90:	75 c6                	jne    c0028e58 <list_sort+0x105>
      a0 = list_next (a0);
c0028e92:	83 ec 0c             	sub    $0xc,%esp
c0028e95:	56                   	push   %esi
c0028e96:	e8 a6 f8 ff ff       	call   c0028741 <list_next>
c0028e9b:	83 c4 10             	add    $0x10,%esp
c0028e9e:	89 c6                	mov    %eax,%esi
c0028ea0:	eb d7                	jmp    c0028e79 <list_sort+0x126>
{
c0028ea2:	8b 74 24 08          	mov    0x8(%esp),%esi
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028ea6:	83 ec 0c             	sub    $0xc,%esp
c0028ea9:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028ead:	e8 d7 f8 ff ff       	call   c0028789 <list_end>
c0028eb2:	83 c4 10             	add    $0x10,%esp
c0028eb5:	39 c6                	cmp    %eax,%esi
c0028eb7:	0f 84 9b 00 00 00    	je     c0028f58 <list_sort+0x205>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c0028ebd:	ff 44 24 0c          	incl   0xc(%esp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c0028ec1:	83 ec 0c             	sub    $0xc,%esp
c0028ec4:	57                   	push   %edi
c0028ec5:	89 e9                	mov    %ebp,%ecx
c0028ec7:	89 c2                	mov    %eax,%edx
c0028ec9:	89 f0                	mov    %esi,%eax
c0028ecb:	e8 5e f9 ff ff       	call   c002882e <find_end_of_run>
c0028ed0:	89 c3                	mov    %eax,%ebx
          if (a1b0 == list_end (list))
c0028ed2:	83 c4 04             	add    $0x4,%esp
c0028ed5:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028ed9:	e8 ab f8 ff ff       	call   c0028789 <list_end>
c0028ede:	83 c4 10             	add    $0x10,%esp
c0028ee1:	39 c3                	cmp    %eax,%ebx
c0028ee3:	74 73                	je     c0028f58 <list_sort+0x205>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c0028ee5:	83 ec 0c             	sub    $0xc,%esp
c0028ee8:	57                   	push   %edi
c0028ee9:	89 e9                	mov    %ebp,%ecx
c0028eeb:	89 c2                	mov    %eax,%edx
c0028eed:	89 d8                	mov    %ebx,%eax
c0028eef:	e8 3a f9 ff ff       	call   c002882e <find_end_of_run>
c0028ef4:	89 44 24 18          	mov    %eax,0x18(%esp)
  ASSERT (a0 != NULL);
c0028ef8:	83 c4 10             	add    $0x10,%esp
c0028efb:	85 f6                	test   %esi,%esi
c0028efd:	0f 84 b0 fe ff ff    	je     c0028db3 <list_sort+0x60>
  ASSERT (a1b0 != NULL);
c0028f03:	85 db                	test   %ebx,%ebx
c0028f05:	0f 84 c9 fe ff ff    	je     c0028dd4 <list_sort+0x81>
  ASSERT (b1 != NULL);
c0028f0b:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028f10:	0f 84 df fe ff ff    	je     c0028df5 <list_sort+0xa2>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0028f16:	57                   	push   %edi
c0028f17:	55                   	push   %ebp
c0028f18:	53                   	push   %ebx
c0028f19:	56                   	push   %esi
c0028f1a:	e8 df fd ff ff       	call   c0028cfe <is_sorted>
c0028f1f:	83 c4 10             	add    $0x10,%esp
c0028f22:	84 c0                	test   %al,%al
c0028f24:	0f 84 ec fe ff ff    	je     c0028e16 <list_sort+0xc3>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0028f2a:	57                   	push   %edi
c0028f2b:	55                   	push   %ebp
c0028f2c:	ff 74 24 10          	pushl  0x10(%esp)
c0028f30:	53                   	push   %ebx
c0028f31:	e8 c8 fd ff ff       	call   c0028cfe <is_sorted>
c0028f36:	83 c4 10             	add    $0x10,%esp
c0028f39:	84 c0                	test   %al,%al
c0028f3b:	0f 84 f6 fe ff ff    	je     c0028e37 <list_sort+0xe4>
  while (a0 != a1b0 && a1b0 != b1)
c0028f41:	39 de                	cmp    %ebx,%esi
c0028f43:	0f 84 59 ff ff ff    	je     c0028ea2 <list_sort+0x14f>
c0028f49:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0028f4d:	0f 85 30 ff ff ff    	jne    c0028e83 <list_sort+0x130>
c0028f53:	e9 4a ff ff ff       	jmp    c0028ea2 <list_sort+0x14f>

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c0028f58:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
c0028f5d:	76 1e                	jbe    c0028f7d <list_sort+0x22a>
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028f5f:	83 ec 0c             	sub    $0xc,%esp
c0028f62:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028f66:	e8 a6 f7 ff ff       	call   c0028711 <list_begin>
c0028f6b:	83 c4 10             	add    $0x10,%esp
c0028f6e:	89 c6                	mov    %eax,%esi
      output_run_cnt = 0;
c0028f70:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0028f77:	00 
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028f78:	e9 29 ff ff ff       	jmp    c0028ea6 <list_sort+0x153>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0028f7d:	83 ec 0c             	sub    $0xc,%esp
c0028f80:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028f84:	e8 00 f8 ff ff       	call   c0028789 <list_end>
c0028f89:	83 c4 04             	add    $0x4,%esp
c0028f8c:	89 c3                	mov    %eax,%ebx
c0028f8e:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028f92:	e8 7a f7 ff ff       	call   c0028711 <list_begin>
c0028f97:	83 c4 10             	add    $0x10,%esp
c0028f9a:	57                   	push   %edi
c0028f9b:	55                   	push   %ebp
c0028f9c:	53                   	push   %ebx
c0028f9d:	50                   	push   %eax
c0028f9e:	e8 5b fd ff ff       	call   c0028cfe <is_sorted>
c0028fa3:	83 c4 10             	add    $0x10,%esp
c0028fa6:	84 c0                	test   %al,%al
c0028fa8:	74 08                	je     c0028fb2 <list_sort+0x25f>
}
c0028faa:	83 c4 1c             	add    $0x1c,%esp
c0028fad:	5b                   	pop    %ebx
c0028fae:	5e                   	pop    %esi
c0028faf:	5f                   	pop    %edi
c0028fb0:	5d                   	pop    %ebp
c0028fb1:	c3                   	ret    
  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0028fb2:	83 ec 0c             	sub    $0xc,%esp
c0028fb5:	68 68 1f 03 c0       	push   $0xc0031f68
c0028fba:	68 21 01 03 c0       	push   $0xc0030121
c0028fbf:	68 50 fc 02 c0       	push   $0xc002fc50
c0028fc4:	68 b5 01 00 00       	push   $0x1b5
c0028fc9:	68 f7 1d 03 c0       	push   $0xc0031df7
c0028fce:	e8 54 f6 ff ff       	call   c0028627 <debug_panic>

c0028fd3 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c0028fd3:	55                   	push   %ebp
c0028fd4:	57                   	push   %edi
c0028fd5:	56                   	push   %esi
c0028fd6:	53                   	push   %ebx
c0028fd7:	83 ec 0c             	sub    $0xc,%esp
c0028fda:	8b 74 24 20          	mov    0x20(%esp),%esi
c0028fde:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028fe2:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *e;

  ASSERT (list != NULL);
c0028fe6:	85 f6                	test   %esi,%esi
c0028fe8:	74 50                	je     c002903a <list_insert_ordered+0x67>
  ASSERT (elem != NULL);
c0028fea:	85 ff                	test   %edi,%edi
c0028fec:	74 6d                	je     c002905b <list_insert_ordered+0x88>
  ASSERT (less != NULL);
c0028fee:	85 ed                	test   %ebp,%ebp
c0028ff0:	0f 84 86 00 00 00    	je     c002907c <list_insert_ordered+0xa9>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028ff6:	83 ec 0c             	sub    $0xc,%esp
c0028ff9:	56                   	push   %esi
c0028ffa:	e8 12 f7 ff ff       	call   c0028711 <list_begin>
c0028fff:	83 c4 10             	add    $0x10,%esp
c0029002:	89 c3                	mov    %eax,%ebx
c0029004:	83 ec 0c             	sub    $0xc,%esp
c0029007:	56                   	push   %esi
c0029008:	e8 7c f7 ff ff       	call   c0028789 <list_end>
c002900d:	83 c4 10             	add    $0x10,%esp
c0029010:	39 c3                	cmp    %eax,%ebx
c0029012:	0f 84 85 00 00 00    	je     c002909d <list_insert_ordered+0xca>
    if (less (elem, e, aux))
c0029018:	83 ec 04             	sub    $0x4,%esp
c002901b:	ff 74 24 30          	pushl  0x30(%esp)
c002901f:	53                   	push   %ebx
c0029020:	57                   	push   %edi
c0029021:	ff d5                	call   *%ebp
c0029023:	83 c4 10             	add    $0x10,%esp
c0029026:	84 c0                	test   %al,%al
c0029028:	75 73                	jne    c002909d <list_insert_ordered+0xca>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002902a:	83 ec 0c             	sub    $0xc,%esp
c002902d:	53                   	push   %ebx
c002902e:	e8 0e f7 ff ff       	call   c0028741 <list_next>
c0029033:	83 c4 10             	add    $0x10,%esp
c0029036:	89 c3                	mov    %eax,%ebx
c0029038:	eb ca                	jmp    c0029004 <list_insert_ordered+0x31>
  ASSERT (list != NULL);
c002903a:	83 ec 0c             	sub    $0xc,%esp
c002903d:	68 ea 1d 03 c0       	push   $0xc0031dea
c0029042:	68 21 01 03 c0       	push   $0xc0030121
c0029047:	68 1c fc 02 c0       	push   $0xc002fc1c
c002904c:	68 c1 01 00 00       	push   $0x1c1
c0029051:	68 f7 1d 03 c0       	push   $0xc0031df7
c0029056:	e8 cc f5 ff ff       	call   c0028627 <debug_panic>
  ASSERT (elem != NULL);
c002905b:	83 ec 0c             	sub    $0xc,%esp
c002905e:	68 2d 1e 03 c0       	push   $0xc0031e2d
c0029063:	68 21 01 03 c0       	push   $0xc0030121
c0029068:	68 1c fc 02 c0       	push   $0xc002fc1c
c002906d:	68 c2 01 00 00       	push   $0x1c2
c0029072:	68 f7 1d 03 c0       	push   $0xc0031df7
c0029077:	e8 ab f5 ff ff       	call   c0028627 <debug_panic>
  ASSERT (less != NULL);
c002907c:	83 ec 0c             	sub    $0xc,%esp
c002907f:	68 19 1e 03 c0       	push   $0xc0031e19
c0029084:	68 21 01 03 c0       	push   $0xc0030121
c0029089:	68 1c fc 02 c0       	push   $0xc002fc1c
c002908e:	68 c3 01 00 00       	push   $0x1c3
c0029093:	68 f7 1d 03 c0       	push   $0xc0031df7
c0029098:	e8 8a f5 ff ff       	call   c0028627 <debug_panic>
      break;
  return list_insert (e, elem);
c002909d:	83 ec 08             	sub    $0x8,%esp
c00290a0:	57                   	push   %edi
c00290a1:	53                   	push   %ebx
c00290a2:	e8 fd f8 ff ff       	call   c00289a4 <list_insert>
}
c00290a7:	83 c4 1c             	add    $0x1c,%esp
c00290aa:	5b                   	pop    %ebx
c00290ab:	5e                   	pop    %esi
c00290ac:	5f                   	pop    %edi
c00290ad:	5d                   	pop    %ebp
c00290ae:	c3                   	ret    

c00290af <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c00290af:	55                   	push   %ebp
c00290b0:	57                   	push   %edi
c00290b1:	56                   	push   %esi
c00290b2:	53                   	push   %ebx
c00290b3:	83 ec 0c             	sub    $0xc,%esp
c00290b6:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00290ba:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c00290be:	85 ff                	test   %edi,%edi
c00290c0:	74 1c                	je     c00290de <list_unique+0x2f>
  ASSERT (less != NULL);
c00290c2:	85 ed                	test   %ebp,%ebp
c00290c4:	74 39                	je     c00290ff <list_unique+0x50>
  if (list_empty (list))
c00290c6:	83 ec 0c             	sub    $0xc,%esp
c00290c9:	57                   	push   %edi
c00290ca:	e8 f3 fa ff ff       	call   c0028bc2 <list_empty>
c00290cf:	83 c4 10             	add    $0x10,%esp
c00290d2:	84 c0                	test   %al,%al
c00290d4:	74 4a                	je     c0029120 <list_unique+0x71>
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c00290d6:	83 c4 0c             	add    $0xc,%esp
c00290d9:	5b                   	pop    %ebx
c00290da:	5e                   	pop    %esi
c00290db:	5f                   	pop    %edi
c00290dc:	5d                   	pop    %ebp
c00290dd:	c3                   	ret    
  ASSERT (list != NULL);
c00290de:	83 ec 0c             	sub    $0xc,%esp
c00290e1:	68 ea 1d 03 c0       	push   $0xc0031dea
c00290e6:	68 21 01 03 c0       	push   $0xc0030121
c00290eb:	68 10 fc 02 c0       	push   $0xc002fc10
c00290f0:	68 d5 01 00 00       	push   $0x1d5
c00290f5:	68 f7 1d 03 c0       	push   $0xc0031df7
c00290fa:	e8 28 f5 ff ff       	call   c0028627 <debug_panic>
  ASSERT (less != NULL);
c00290ff:	83 ec 0c             	sub    $0xc,%esp
c0029102:	68 19 1e 03 c0       	push   $0xc0031e19
c0029107:	68 21 01 03 c0       	push   $0xc0030121
c002910c:	68 10 fc 02 c0       	push   $0xc002fc10
c0029111:	68 d6 01 00 00       	push   $0x1d6
c0029116:	68 f7 1d 03 c0       	push   $0xc0031df7
c002911b:	e8 07 f5 ff ff       	call   c0028627 <debug_panic>
  elem = list_begin (list);
c0029120:	83 ec 0c             	sub    $0xc,%esp
c0029123:	57                   	push   %edi
c0029124:	e8 e8 f5 ff ff       	call   c0028711 <list_begin>
c0029129:	83 c4 10             	add    $0x10,%esp
c002912c:	89 c6                	mov    %eax,%esi
  while ((next = list_next (elem)) != list_end (list))
c002912e:	eb 04                	jmp    c0029134 <list_unique+0x85>
c0029130:	89 f3                	mov    %esi,%ebx
c0029132:	89 de                	mov    %ebx,%esi
c0029134:	83 ec 0c             	sub    $0xc,%esp
c0029137:	56                   	push   %esi
c0029138:	e8 04 f6 ff ff       	call   c0028741 <list_next>
c002913d:	89 c3                	mov    %eax,%ebx
c002913f:	89 3c 24             	mov    %edi,(%esp)
c0029142:	e8 42 f6 ff ff       	call   c0028789 <list_end>
c0029147:	83 c4 10             	add    $0x10,%esp
c002914a:	39 c3                	cmp    %eax,%ebx
c002914c:	74 88                	je     c00290d6 <list_unique+0x27>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002914e:	83 ec 04             	sub    $0x4,%esp
c0029151:	ff 74 24 30          	pushl  0x30(%esp)
c0029155:	53                   	push   %ebx
c0029156:	56                   	push   %esi
c0029157:	ff d5                	call   *%ebp
c0029159:	83 c4 10             	add    $0x10,%esp
c002915c:	84 c0                	test   %al,%al
c002915e:	75 d2                	jne    c0029132 <list_unique+0x83>
c0029160:	83 ec 04             	sub    $0x4,%esp
c0029163:	ff 74 24 30          	pushl  0x30(%esp)
c0029167:	56                   	push   %esi
c0029168:	53                   	push   %ebx
c0029169:	ff d5                	call   *%ebp
c002916b:	83 c4 10             	add    $0x10,%esp
c002916e:	84 c0                	test   %al,%al
c0029170:	75 c0                	jne    c0029132 <list_unique+0x83>
        list_remove (next);
c0029172:	83 ec 0c             	sub    $0xc,%esp
c0029175:	53                   	push   %ebx
c0029176:	e8 bc f9 ff ff       	call   c0028b37 <list_remove>
        if (duplicates != NULL)
c002917b:	83 c4 10             	add    $0x10,%esp
c002917e:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0029183:	74 ab                	je     c0029130 <list_unique+0x81>
          list_push_back (duplicates, next);
c0029185:	83 ec 08             	sub    $0x8,%esp
c0029188:	53                   	push   %ebx
c0029189:	ff 74 24 30          	pushl  0x30(%esp)
c002918d:	e8 88 f9 ff ff       	call   c0028b1a <list_push_back>
c0029192:	83 c4 10             	add    $0x10,%esp
c0029195:	89 f3                	mov    %esi,%ebx
c0029197:	eb 99                	jmp    c0029132 <list_unique+0x83>

c0029199 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c0029199:	55                   	push   %ebp
c002919a:	57                   	push   %edi
c002919b:	56                   	push   %esi
c002919c:	53                   	push   %ebx
c002919d:	83 ec 18             	sub    $0x18,%esp
c00291a0:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c00291a4:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *max = list_begin (list);
c00291a8:	57                   	push   %edi
c00291a9:	e8 63 f5 ff ff       	call   c0028711 <list_begin>
c00291ae:	89 c6                	mov    %eax,%esi
  if (max != list_end (list)) 
c00291b0:	89 3c 24             	mov    %edi,(%esp)
c00291b3:	e8 d1 f5 ff ff       	call   c0028789 <list_end>
c00291b8:	83 c4 10             	add    $0x10,%esp
c00291bb:	39 c6                	cmp    %eax,%esi
c00291bd:	74 43                	je     c0029202 <list_max+0x69>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c00291bf:	83 ec 0c             	sub    $0xc,%esp
c00291c2:	56                   	push   %esi
c00291c3:	e8 79 f5 ff ff       	call   c0028741 <list_next>
c00291c8:	83 c4 10             	add    $0x10,%esp
c00291cb:	89 c3                	mov    %eax,%ebx
c00291cd:	eb 0e                	jmp    c00291dd <list_max+0x44>
c00291cf:	83 ec 0c             	sub    $0xc,%esp
c00291d2:	53                   	push   %ebx
c00291d3:	e8 69 f5 ff ff       	call   c0028741 <list_next>
c00291d8:	83 c4 10             	add    $0x10,%esp
c00291db:	89 c3                	mov    %eax,%ebx
c00291dd:	83 ec 0c             	sub    $0xc,%esp
c00291e0:	57                   	push   %edi
c00291e1:	e8 a3 f5 ff ff       	call   c0028789 <list_end>
c00291e6:	83 c4 10             	add    $0x10,%esp
c00291e9:	39 c3                	cmp    %eax,%ebx
c00291eb:	74 17                	je     c0029204 <list_max+0x6b>
        if (less (max, e, aux))
c00291ed:	83 ec 04             	sub    $0x4,%esp
c00291f0:	55                   	push   %ebp
c00291f1:	53                   	push   %ebx
c00291f2:	56                   	push   %esi
c00291f3:	ff 54 24 34          	call   *0x34(%esp)
c00291f7:	83 c4 10             	add    $0x10,%esp
c00291fa:	84 c0                	test   %al,%al
c00291fc:	74 d1                	je     c00291cf <list_max+0x36>
          max = e; 
c00291fe:	89 de                	mov    %ebx,%esi
c0029200:	eb cd                	jmp    c00291cf <list_max+0x36>
  struct list_elem *max = list_begin (list);
c0029202:	89 c6                	mov    %eax,%esi
    }
  return max;
}
c0029204:	89 f0                	mov    %esi,%eax
c0029206:	83 c4 0c             	add    $0xc,%esp
c0029209:	5b                   	pop    %ebx
c002920a:	5e                   	pop    %esi
c002920b:	5f                   	pop    %edi
c002920c:	5d                   	pop    %ebp
c002920d:	c3                   	ret    

c002920e <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002920e:	55                   	push   %ebp
c002920f:	57                   	push   %edi
c0029210:	56                   	push   %esi
c0029211:	53                   	push   %ebx
c0029212:	83 ec 18             	sub    $0x18,%esp
c0029215:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029219:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *min = list_begin (list);
c002921d:	57                   	push   %edi
c002921e:	e8 ee f4 ff ff       	call   c0028711 <list_begin>
c0029223:	89 c6                	mov    %eax,%esi
  if (min != list_end (list)) 
c0029225:	89 3c 24             	mov    %edi,(%esp)
c0029228:	e8 5c f5 ff ff       	call   c0028789 <list_end>
c002922d:	83 c4 10             	add    $0x10,%esp
c0029230:	39 c6                	cmp    %eax,%esi
c0029232:	74 43                	je     c0029277 <list_min+0x69>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c0029234:	83 ec 0c             	sub    $0xc,%esp
c0029237:	56                   	push   %esi
c0029238:	e8 04 f5 ff ff       	call   c0028741 <list_next>
c002923d:	83 c4 10             	add    $0x10,%esp
c0029240:	89 c3                	mov    %eax,%ebx
c0029242:	eb 0e                	jmp    c0029252 <list_min+0x44>
c0029244:	83 ec 0c             	sub    $0xc,%esp
c0029247:	53                   	push   %ebx
c0029248:	e8 f4 f4 ff ff       	call   c0028741 <list_next>
c002924d:	83 c4 10             	add    $0x10,%esp
c0029250:	89 c3                	mov    %eax,%ebx
c0029252:	83 ec 0c             	sub    $0xc,%esp
c0029255:	57                   	push   %edi
c0029256:	e8 2e f5 ff ff       	call   c0028789 <list_end>
c002925b:	83 c4 10             	add    $0x10,%esp
c002925e:	39 c3                	cmp    %eax,%ebx
c0029260:	74 17                	je     c0029279 <list_min+0x6b>
        if (less (e, min, aux))
c0029262:	83 ec 04             	sub    $0x4,%esp
c0029265:	55                   	push   %ebp
c0029266:	56                   	push   %esi
c0029267:	53                   	push   %ebx
c0029268:	ff 54 24 34          	call   *0x34(%esp)
c002926c:	83 c4 10             	add    $0x10,%esp
c002926f:	84 c0                	test   %al,%al
c0029271:	74 d1                	je     c0029244 <list_min+0x36>
          min = e; 
c0029273:	89 de                	mov    %ebx,%esi
c0029275:	eb cd                	jmp    c0029244 <list_min+0x36>
  struct list_elem *min = list_begin (list);
c0029277:	89 c6                	mov    %eax,%esi
    }
  return min;
}
c0029279:	89 f0                	mov    %esi,%eax
c002927b:	83 c4 0c             	add    $0xc,%esp
c002927e:	5b                   	pop    %ebx
c002927f:	5e                   	pop    %esi
c0029280:	5f                   	pop    %edi
c0029281:	5d                   	pop    %ebp
c0029282:	c3                   	ret    

c0029283 <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029283:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029287:	83 c0 1f             	add    $0x1f,%eax
c002928a:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002928d:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c0029294:	c3                   	ret    

c0029295 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c0029295:	53                   	push   %ebx
c0029296:	83 ec 08             	sub    $0x8,%esp
c0029299:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (b != NULL) 
c002929d:	85 db                	test   %ebx,%ebx
c002929f:	74 16                	je     c00292b7 <bitmap_destroy+0x22>
    {
      free (b->bits);
c00292a1:	83 ec 0c             	sub    $0xc,%esp
c00292a4:	ff 73 04             	pushl  0x4(%ebx)
c00292a7:	e8 c5 a8 ff ff       	call   c0023b71 <free>
      free (b);
c00292ac:	89 1c 24             	mov    %ebx,(%esp)
c00292af:	e8 bd a8 ff ff       	call   c0023b71 <free>
c00292b4:	83 c4 10             	add    $0x10,%esp
    }
}
c00292b7:	83 c4 08             	add    $0x8,%esp
c00292ba:	5b                   	pop    %ebx
c00292bb:	c3                   	ret    

c00292bc <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c00292bc:	8b 44 24 04          	mov    0x4(%esp),%eax
c00292c0:	8b 00                	mov    (%eax),%eax
}
c00292c2:	c3                   	ret    

c00292c3 <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c00292c3:	53                   	push   %ebx
c00292c4:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c00292c8:	89 cb                	mov    %ecx,%ebx
c00292ca:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c00292cd:	8b 44 24 08          	mov    0x8(%esp),%eax
c00292d1:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c00292d4:	b8 01 00 00 00       	mov    $0x1,%eax
c00292d9:	d3 e0                	shl    %cl,%eax
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c00292db:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c00292de:	5b                   	pop    %ebx
c00292df:	c3                   	ret    

c00292e0 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c00292e0:	53                   	push   %ebx
c00292e1:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c00292e5:	89 cb                	mov    %ecx,%ebx
c00292e7:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c00292ea:	8b 44 24 08          	mov    0x8(%esp),%eax
c00292ee:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c00292f1:	b8 01 00 00 00       	mov    $0x1,%eax
c00292f6:	d3 e0                	shl    %cl,%eax
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c00292f8:	f7 d0                	not    %eax
c00292fa:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c00292fd:	5b                   	pop    %ebx
c00292fe:	c3                   	ret    

c00292ff <bitmap_set>:
{
c00292ff:	83 ec 0c             	sub    $0xc,%esp
c0029302:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029306:	8b 54 24 14          	mov    0x14(%esp),%edx
c002930a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c002930e:	85 c0                	test   %eax,%eax
c0029310:	74 19                	je     c002932b <bitmap_set+0x2c>
  ASSERT (idx < b->bit_cnt);
c0029312:	39 10                	cmp    %edx,(%eax)
c0029314:	76 36                	jbe    c002934c <bitmap_set+0x4d>
  if (value)
c0029316:	84 c9                	test   %cl,%cl
c0029318:	75 53                	jne    c002936d <bitmap_set+0x6e>
    bitmap_reset (b, idx);
c002931a:	83 ec 08             	sub    $0x8,%esp
c002931d:	52                   	push   %edx
c002931e:	50                   	push   %eax
c002931f:	e8 bc ff ff ff       	call   c00292e0 <bitmap_reset>
c0029324:	83 c4 10             	add    $0x10,%esp
}
c0029327:	83 c4 0c             	add    $0xc,%esp
c002932a:	c3                   	ret    
  ASSERT (b != NULL);
c002932b:	83 ec 0c             	sub    $0xc,%esp
c002932e:	68 0f 1e 03 c0       	push   $0xc0031e0f
c0029333:	68 21 01 03 c0       	push   $0xc0030121
c0029338:	68 60 fd 02 c0       	push   $0xc002fd60
c002933d:	68 93 00 00 00       	push   $0x93
c0029342:	68 a2 1f 03 c0       	push   $0xc0031fa2
c0029347:	e8 db f2 ff ff       	call   c0028627 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002934c:	83 ec 0c             	sub    $0xc,%esp
c002934f:	68 bc 1f 03 c0       	push   $0xc0031fbc
c0029354:	68 21 01 03 c0       	push   $0xc0030121
c0029359:	68 60 fd 02 c0       	push   $0xc002fd60
c002935e:	68 94 00 00 00       	push   $0x94
c0029363:	68 a2 1f 03 c0       	push   $0xc0031fa2
c0029368:	e8 ba f2 ff ff       	call   c0028627 <debug_panic>
    bitmap_mark (b, idx);
c002936d:	83 ec 08             	sub    $0x8,%esp
c0029370:	52                   	push   %edx
c0029371:	50                   	push   %eax
c0029372:	e8 4c ff ff ff       	call   c00292c3 <bitmap_mark>
c0029377:	83 c4 10             	add    $0x10,%esp
c002937a:	eb ab                	jmp    c0029327 <bitmap_set+0x28>

c002937c <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002937c:	53                   	push   %ebx
c002937d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029381:	89 cb                	mov    %ecx,%ebx
c0029383:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029386:	8b 44 24 08          	mov    0x8(%esp),%eax
c002938a:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002938d:	b8 01 00 00 00       	mov    $0x1,%eax
c0029392:	d3 e0                	shl    %cl,%eax
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029394:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c0029397:	5b                   	pop    %ebx
c0029398:	c3                   	ret    

c0029399 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c0029399:	53                   	push   %ebx
c002939a:	83 ec 08             	sub    $0x8,%esp
c002939d:	8b 44 24 10          	mov    0x10(%esp),%eax
c00293a1:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c00293a5:	85 c0                	test   %eax,%eax
c00293a7:	74 1e                	je     c00293c7 <bitmap_test+0x2e>
  ASSERT (idx < b->bit_cnt);
c00293a9:	39 08                	cmp    %ecx,(%eax)
c00293ab:	76 3b                	jbe    c00293e8 <bitmap_test+0x4f>
  return bit_idx / ELEM_BITS;
c00293ad:	89 cb                	mov    %ecx,%ebx
c00293af:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c00293b2:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c00293b5:	b8 01 00 00 00       	mov    $0x1,%eax
c00293ba:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c00293bc:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c00293bf:	0f 95 c0             	setne  %al
}
c00293c2:	83 c4 08             	add    $0x8,%esp
c00293c5:	5b                   	pop    %ebx
c00293c6:	c3                   	ret    
  ASSERT (b != NULL);
c00293c7:	83 ec 0c             	sub    $0xc,%esp
c00293ca:	68 0f 1e 03 c0       	push   $0xc0031e0f
c00293cf:	68 21 01 03 c0       	push   $0xc0030121
c00293d4:	68 54 fd 02 c0       	push   $0xc002fd54
c00293d9:	68 c8 00 00 00       	push   $0xc8
c00293de:	68 a2 1f 03 c0       	push   $0xc0031fa2
c00293e3:	e8 3f f2 ff ff       	call   c0028627 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c00293e8:	83 ec 0c             	sub    $0xc,%esp
c00293eb:	68 bc 1f 03 c0       	push   $0xc0031fbc
c00293f0:	68 21 01 03 c0       	push   $0xc0030121
c00293f5:	68 54 fd 02 c0       	push   $0xc002fd54
c00293fa:	68 c9 00 00 00       	push   $0xc9
c00293ff:	68 a2 1f 03 c0       	push   $0xc0031fa2
c0029404:	e8 1e f2 ff ff       	call   c0028627 <debug_panic>

c0029409 <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0029409:	55                   	push   %ebp
c002940a:	57                   	push   %edi
c002940b:	56                   	push   %esi
c002940c:	53                   	push   %ebx
c002940d:	83 ec 0c             	sub    $0xc,%esp
c0029410:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029414:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c0029418:	8b 54 24 28          	mov    0x28(%esp),%edx
c002941c:	8a 44 24 2c          	mov    0x2c(%esp),%al
  size_t i;
  
  ASSERT (b != NULL);
c0029420:	85 f6                	test   %esi,%esi
c0029422:	74 2f                	je     c0029453 <bitmap_set_multiple+0x4a>
  ASSERT (start <= b->bit_cnt);
c0029424:	8b 0e                	mov    (%esi),%ecx
c0029426:	39 d9                	cmp    %ebx,%ecx
c0029428:	72 4a                	jb     c0029474 <bitmap_set_multiple+0x6b>
  ASSERT (start + cnt <= b->bit_cnt);
c002942a:	8d 2c 13             	lea    (%ebx,%edx,1),%ebp
c002942d:	39 e9                	cmp    %ebp,%ecx
c002942f:	72 64                	jb     c0029495 <bitmap_set_multiple+0x8c>

  for (i = 0; i < cnt; i++)
c0029431:	85 d2                	test   %edx,%edx
c0029433:	74 16                	je     c002944b <bitmap_set_multiple+0x42>
    bitmap_set (b, start + i, value);
c0029435:	0f b6 f8             	movzbl %al,%edi
c0029438:	83 ec 04             	sub    $0x4,%esp
c002943b:	57                   	push   %edi
c002943c:	53                   	push   %ebx
c002943d:	56                   	push   %esi
c002943e:	e8 bc fe ff ff       	call   c00292ff <bitmap_set>
c0029443:	43                   	inc    %ebx
  for (i = 0; i < cnt; i++)
c0029444:	83 c4 10             	add    $0x10,%esp
c0029447:	39 dd                	cmp    %ebx,%ebp
c0029449:	75 ed                	jne    c0029438 <bitmap_set_multiple+0x2f>
}
c002944b:	83 c4 0c             	add    $0xc,%esp
c002944e:	5b                   	pop    %ebx
c002944f:	5e                   	pop    %esi
c0029450:	5f                   	pop    %edi
c0029451:	5d                   	pop    %ebp
c0029452:	c3                   	ret    
  ASSERT (b != NULL);
c0029453:	83 ec 0c             	sub    $0xc,%esp
c0029456:	68 0f 1e 03 c0       	push   $0xc0031e0f
c002945b:	68 21 01 03 c0       	push   $0xc0030121
c0029460:	68 30 fd 02 c0       	push   $0xc002fd30
c0029465:	68 de 00 00 00       	push   $0xde
c002946a:	68 a2 1f 03 c0       	push   $0xc0031fa2
c002946f:	e8 b3 f1 ff ff       	call   c0028627 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0029474:	83 ec 0c             	sub    $0xc,%esp
c0029477:	68 cd 1f 03 c0       	push   $0xc0031fcd
c002947c:	68 21 01 03 c0       	push   $0xc0030121
c0029481:	68 30 fd 02 c0       	push   $0xc002fd30
c0029486:	68 df 00 00 00       	push   $0xdf
c002948b:	68 a2 1f 03 c0       	push   $0xc0031fa2
c0029490:	e8 92 f1 ff ff       	call   c0028627 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c0029495:	83 ec 0c             	sub    $0xc,%esp
c0029498:	68 e1 1f 03 c0       	push   $0xc0031fe1
c002949d:	68 21 01 03 c0       	push   $0xc0030121
c00294a2:	68 30 fd 02 c0       	push   $0xc002fd30
c00294a7:	68 e0 00 00 00       	push   $0xe0
c00294ac:	68 a2 1f 03 c0       	push   $0xc0031fa2
c00294b1:	e8 71 f1 ff ff       	call   c0028627 <debug_panic>

c00294b6 <bitmap_set_all>:
{
c00294b6:	83 ec 0c             	sub    $0xc,%esp
c00294b9:	8b 44 24 10          	mov    0x10(%esp),%eax
c00294bd:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c00294c1:	85 c0                	test   %eax,%eax
c00294c3:	74 12                	je     c00294d7 <bitmap_set_all+0x21>
  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c00294c5:	0f b6 d2             	movzbl %dl,%edx
c00294c8:	52                   	push   %edx
c00294c9:	ff 30                	pushl  (%eax)
c00294cb:	6a 00                	push   $0x0
c00294cd:	50                   	push   %eax
c00294ce:	e8 36 ff ff ff       	call   c0029409 <bitmap_set_multiple>
}
c00294d3:	83 c4 1c             	add    $0x1c,%esp
c00294d6:	c3                   	ret    
  ASSERT (b != NULL);
c00294d7:	83 ec 0c             	sub    $0xc,%esp
c00294da:	68 0f 1e 03 c0       	push   $0xc0031e0f
c00294df:	68 21 01 03 c0       	push   $0xc0030121
c00294e4:	68 44 fd 02 c0       	push   $0xc002fd44
c00294e9:	68 d3 00 00 00       	push   $0xd3
c00294ee:	68 a2 1f 03 c0       	push   $0xc0031fa2
c00294f3:	e8 2f f1 ff ff       	call   c0028627 <debug_panic>

c00294f8 <bitmap_create>:
{
c00294f8:	56                   	push   %esi
c00294f9:	53                   	push   %ebx
c00294fa:	83 ec 10             	sub    $0x10,%esp
c00294fd:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct bitmap *b = malloc (sizeof *b);
c0029501:	6a 08                	push   $0x8
c0029503:	e8 c6 a4 ff ff       	call   c00239ce <malloc>
c0029508:	89 c3                	mov    %eax,%ebx
  if (b != NULL)
c002950a:	83 c4 10             	add    $0x10,%esp
c002950d:	85 c0                	test   %eax,%eax
c002950f:	74 2c                	je     c002953d <bitmap_create+0x45>
      b->bit_cnt = bit_cnt;
c0029511:	89 30                	mov    %esi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c0029513:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029516:	8d 46 1f             	lea    0x1f(%esi),%eax
c0029519:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002951c:	c1 e0 02             	shl    $0x2,%eax
      b->bits = malloc (byte_cnt (bit_cnt));
c002951f:	50                   	push   %eax
c0029520:	e8 a9 a4 ff ff       	call   c00239ce <malloc>
c0029525:	89 43 04             	mov    %eax,0x4(%ebx)
      if (b->bits != NULL || bit_cnt == 0)
c0029528:	83 c4 10             	add    $0x10,%esp
c002952b:	85 c0                	test   %eax,%eax
c002952d:	74 16                	je     c0029545 <bitmap_create+0x4d>
          bitmap_set_all (b, false);
c002952f:	83 ec 08             	sub    $0x8,%esp
c0029532:	6a 00                	push   $0x0
c0029534:	53                   	push   %ebx
c0029535:	e8 7c ff ff ff       	call   c00294b6 <bitmap_set_all>
          return b;
c002953a:	83 c4 10             	add    $0x10,%esp
}
c002953d:	89 d8                	mov    %ebx,%eax
c002953f:	83 c4 04             	add    $0x4,%esp
c0029542:	5b                   	pop    %ebx
c0029543:	5e                   	pop    %esi
c0029544:	c3                   	ret    
      if (b->bits != NULL || bit_cnt == 0)
c0029545:	85 f6                	test   %esi,%esi
c0029547:	74 e6                	je     c002952f <bitmap_create+0x37>
      free (b);
c0029549:	83 ec 0c             	sub    $0xc,%esp
c002954c:	53                   	push   %ebx
c002954d:	e8 1f a6 ff ff       	call   c0023b71 <free>
c0029552:	83 c4 10             	add    $0x10,%esp
  return NULL;
c0029555:	bb 00 00 00 00       	mov    $0x0,%ebx
c002955a:	eb e1                	jmp    c002953d <bitmap_create+0x45>

c002955c <bitmap_create_in_buf>:
{
c002955c:	56                   	push   %esi
c002955d:	53                   	push   %ebx
c002955e:	83 ec 04             	sub    $0x4,%esp
c0029561:	8b 74 24 10          	mov    0x10(%esp),%esi
c0029565:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c0029569:	56                   	push   %esi
c002956a:	e8 14 fd ff ff       	call   c0029283 <bitmap_buf_size>
c002956f:	83 c4 04             	add    $0x4,%esp
c0029572:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0029576:	77 1b                	ja     c0029593 <bitmap_create_in_buf+0x37>
  b->bit_cnt = bit_cnt;
c0029578:	89 33                	mov    %esi,(%ebx)
  b->bits = (elem_type *) (b + 1);
c002957a:	8d 43 08             	lea    0x8(%ebx),%eax
c002957d:	89 43 04             	mov    %eax,0x4(%ebx)
  bitmap_set_all (b, false);
c0029580:	83 ec 08             	sub    $0x8,%esp
c0029583:	6a 00                	push   $0x0
c0029585:	53                   	push   %ebx
c0029586:	e8 2b ff ff ff       	call   c00294b6 <bitmap_set_all>
}
c002958b:	89 d8                	mov    %ebx,%eax
c002958d:	83 c4 14             	add    $0x14,%esp
c0029590:	5b                   	pop    %ebx
c0029591:	5e                   	pop    %esi
c0029592:	c3                   	ret    
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c0029593:	83 ec 0c             	sub    $0xc,%esp
c0029596:	68 fc 1f 03 c0       	push   $0xc0031ffc
c002959b:	68 21 01 03 c0       	push   $0xc0030121
c00295a0:	68 6c fd 02 c0       	push   $0xc002fd6c
c00295a5:	6a 68                	push   $0x68
c00295a7:	68 a2 1f 03 c0       	push   $0xc0031fa2
c00295ac:	e8 76 f0 ff ff       	call   c0028627 <debug_panic>

c00295b1 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c00295b1:	55                   	push   %ebp
c00295b2:	57                   	push   %edi
c00295b3:	56                   	push   %esi
c00295b4:	53                   	push   %ebx
c00295b5:	83 ec 1c             	sub    $0x1c,%esp
c00295b8:	8b 7c 24 30          	mov    0x30(%esp),%edi
c00295bc:	8b 74 24 34          	mov    0x34(%esp),%esi
c00295c0:	8b 44 24 38          	mov    0x38(%esp),%eax
c00295c4:	8a 5c 24 3c          	mov    0x3c(%esp),%bl
  size_t i, value_cnt;

  ASSERT (b != NULL);
c00295c8:	85 ff                	test   %edi,%edi
c00295ca:	74 29                	je     c00295f5 <bitmap_count+0x44>
  ASSERT (start <= b->bit_cnt);
c00295cc:	8b 17                	mov    (%edi),%edx
c00295ce:	39 f2                	cmp    %esi,%edx
c00295d0:	72 44                	jb     c0029616 <bitmap_count+0x65>
  ASSERT (start + cnt <= b->bit_cnt);
c00295d2:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c00295d5:	39 ea                	cmp    %ebp,%edx
c00295d7:	72 5e                	jb     c0029637 <bitmap_count+0x86>

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
c00295d9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c00295e0:	00 
c00295e1:	85 c0                	test   %eax,%eax
c00295e3:	75 78                	jne    c002965d <bitmap_count+0xac>
c00295e5:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (bitmap_test (b, start + i) == value)
      value_cnt++;
  return value_cnt;
}
c00295e9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00295ed:	83 c4 1c             	add    $0x1c,%esp
c00295f0:	5b                   	pop    %ebx
c00295f1:	5e                   	pop    %esi
c00295f2:	5f                   	pop    %edi
c00295f3:	5d                   	pop    %ebp
c00295f4:	c3                   	ret    
  ASSERT (b != NULL);
c00295f5:	83 ec 0c             	sub    $0xc,%esp
c00295f8:	68 0f 1e 03 c0       	push   $0xc0031e0f
c00295fd:	68 21 01 03 c0       	push   $0xc0030121
c0029602:	68 20 fd 02 c0       	push   $0xc002fd20
c0029607:	68 ed 00 00 00       	push   $0xed
c002960c:	68 a2 1f 03 c0       	push   $0xc0031fa2
c0029611:	e8 11 f0 ff ff       	call   c0028627 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0029616:	83 ec 0c             	sub    $0xc,%esp
c0029619:	68 cd 1f 03 c0       	push   $0xc0031fcd
c002961e:	68 21 01 03 c0       	push   $0xc0030121
c0029623:	68 20 fd 02 c0       	push   $0xc002fd20
c0029628:	68 ee 00 00 00       	push   $0xee
c002962d:	68 a2 1f 03 c0       	push   $0xc0031fa2
c0029632:	e8 f0 ef ff ff       	call   c0028627 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c0029637:	83 ec 0c             	sub    $0xc,%esp
c002963a:	68 e1 1f 03 c0       	push   $0xc0031fe1
c002963f:	68 21 01 03 c0       	push   $0xc0030121
c0029644:	68 20 fd 02 c0       	push   $0xc002fd20
c0029649:	68 ef 00 00 00       	push   $0xef
c002964e:	68 a2 1f 03 c0       	push   $0xc0031fa2
c0029653:	e8 cf ef ff ff       	call   c0028627 <debug_panic>
c0029658:	46                   	inc    %esi
  for (i = 0; i < cnt; i++)
c0029659:	39 f5                	cmp    %esi,%ebp
c002965b:	74 8c                	je     c00295e9 <bitmap_count+0x38>
    if (bitmap_test (b, start + i) == value)
c002965d:	83 ec 08             	sub    $0x8,%esp
c0029660:	56                   	push   %esi
c0029661:	57                   	push   %edi
c0029662:	e8 32 fd ff ff       	call   c0029399 <bitmap_test>
c0029667:	83 c4 10             	add    $0x10,%esp
c002966a:	38 d8                	cmp    %bl,%al
c002966c:	75 ea                	jne    c0029658 <bitmap_count+0xa7>
      value_cnt++;
c002966e:	ff 44 24 0c          	incl   0xc(%esp)
c0029672:	eb e4                	jmp    c0029658 <bitmap_count+0xa7>

c0029674 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0029674:	55                   	push   %ebp
c0029675:	57                   	push   %edi
c0029676:	56                   	push   %esi
c0029677:	53                   	push   %ebx
c0029678:	83 ec 0c             	sub    $0xc,%esp
c002967b:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002967f:	8b 74 24 24          	mov    0x24(%esp),%esi
c0029683:	8b 44 24 28          	mov    0x28(%esp),%eax
c0029687:	8a 5c 24 2c          	mov    0x2c(%esp),%bl
  size_t i;
  
  ASSERT (b != NULL);
c002968b:	85 ff                	test   %edi,%edi
c002968d:	74 2b                	je     c00296ba <bitmap_contains+0x46>
  ASSERT (start <= b->bit_cnt);
c002968f:	8b 17                	mov    (%edi),%edx
c0029691:	39 f2                	cmp    %esi,%edx
c0029693:	72 46                	jb     c00296db <bitmap_contains+0x67>
  ASSERT (start + cnt <= b->bit_cnt);
c0029695:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c0029698:	39 ea                	cmp    %ebp,%edx
c002969a:	72 60                	jb     c00296fc <bitmap_contains+0x88>

  for (i = 0; i < cnt; i++)
c002969c:	85 c0                	test   %eax,%eax
c002969e:	74 7f                	je     c002971f <bitmap_contains+0xab>
    if (bitmap_test (b, start + i) == value)
c00296a0:	83 ec 08             	sub    $0x8,%esp
c00296a3:	56                   	push   %esi
c00296a4:	57                   	push   %edi
c00296a5:	e8 ef fc ff ff       	call   c0029399 <bitmap_test>
c00296aa:	83 c4 10             	add    $0x10,%esp
c00296ad:	38 d8                	cmp    %bl,%al
c00296af:	74 6c                	je     c002971d <bitmap_contains+0xa9>
c00296b1:	46                   	inc    %esi
  for (i = 0; i < cnt; i++)
c00296b2:	39 f5                	cmp    %esi,%ebp
c00296b4:	75 ea                	jne    c00296a0 <bitmap_contains+0x2c>
      return true;
  return false;
c00296b6:	b0 00                	mov    $0x0,%al
c00296b8:	eb 65                	jmp    c002971f <bitmap_contains+0xab>
  ASSERT (b != NULL);
c00296ba:	83 ec 0c             	sub    $0xc,%esp
c00296bd:	68 0f 1e 03 c0       	push   $0xc0031e0f
c00296c2:	68 21 01 03 c0       	push   $0xc0030121
c00296c7:	68 10 fd 02 c0       	push   $0xc002fd10
c00296cc:	68 ff 00 00 00       	push   $0xff
c00296d1:	68 a2 1f 03 c0       	push   $0xc0031fa2
c00296d6:	e8 4c ef ff ff       	call   c0028627 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c00296db:	83 ec 0c             	sub    $0xc,%esp
c00296de:	68 cd 1f 03 c0       	push   $0xc0031fcd
c00296e3:	68 21 01 03 c0       	push   $0xc0030121
c00296e8:	68 10 fd 02 c0       	push   $0xc002fd10
c00296ed:	68 00 01 00 00       	push   $0x100
c00296f2:	68 a2 1f 03 c0       	push   $0xc0031fa2
c00296f7:	e8 2b ef ff ff       	call   c0028627 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c00296fc:	83 ec 0c             	sub    $0xc,%esp
c00296ff:	68 e1 1f 03 c0       	push   $0xc0031fe1
c0029704:	68 21 01 03 c0       	push   $0xc0030121
c0029709:	68 10 fd 02 c0       	push   $0xc002fd10
c002970e:	68 01 01 00 00       	push   $0x101
c0029713:	68 a2 1f 03 c0       	push   $0xc0031fa2
c0029718:	e8 0a ef ff ff       	call   c0028627 <debug_panic>
      return true;
c002971d:	b0 01                	mov    $0x1,%al
}
c002971f:	83 c4 0c             	add    $0xc,%esp
c0029722:	5b                   	pop    %ebx
c0029723:	5e                   	pop    %esi
c0029724:	5f                   	pop    %edi
c0029725:	5d                   	pop    %ebp
c0029726:	c3                   	ret    

c0029727 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c0029727:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c002972a:	6a 01                	push   $0x1
c002972c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029730:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029734:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029738:	e8 37 ff ff ff       	call   c0029674 <bitmap_contains>
}
c002973d:	83 c4 1c             	add    $0x1c,%esp
c0029740:	c3                   	ret    

c0029741 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c0029741:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c0029744:	6a 01                	push   $0x1
c0029746:	ff 74 24 1c          	pushl  0x1c(%esp)
c002974a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002974e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029752:	e8 1d ff ff ff       	call   c0029674 <bitmap_contains>
c0029757:	83 f0 01             	xor    $0x1,%eax
}
c002975a:	83 c4 1c             	add    $0x1c,%esp
c002975d:	c3                   	ret    

c002975e <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002975e:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c0029761:	6a 00                	push   $0x0
c0029763:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029767:	ff 74 24 1c          	pushl  0x1c(%esp)
c002976b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002976f:	e8 00 ff ff ff       	call   c0029674 <bitmap_contains>
c0029774:	83 f0 01             	xor    $0x1,%eax
}
c0029777:	83 c4 1c             	add    $0x1c,%esp
c002977a:	c3                   	ret    

c002977b <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002977b:	55                   	push   %ebp
c002977c:	57                   	push   %edi
c002977d:	56                   	push   %esi
c002977e:	53                   	push   %ebx
c002977f:	83 ec 1c             	sub    $0x1c,%esp
c0029782:	8b 74 24 30          	mov    0x30(%esp),%esi
c0029786:	8b 5c 24 34          	mov    0x34(%esp),%ebx
c002978a:	8b 7c 24 38          	mov    0x38(%esp),%edi
c002978e:	8a 54 24 3c          	mov    0x3c(%esp),%dl
  ASSERT (b != NULL);
c0029792:	85 f6                	test   %esi,%esi
c0029794:	74 17                	je     c00297ad <bitmap_scan+0x32>
  ASSERT (start <= b->bit_cnt);
c0029796:	8b 06                	mov    (%esi),%eax
c0029798:	39 d8                	cmp    %ebx,%eax
c002979a:	72 32                	jb     c00297ce <bitmap_scan+0x53>

  if (cnt <= b->bit_cnt) 
c002979c:	39 f8                	cmp    %edi,%eax
c002979e:	73 4f                	jae    c00297ef <bitmap_scan+0x74>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c00297a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c00297a5:	83 c4 1c             	add    $0x1c,%esp
c00297a8:	5b                   	pop    %ebx
c00297a9:	5e                   	pop    %esi
c00297aa:	5f                   	pop    %edi
c00297ab:	5d                   	pop    %ebp
c00297ac:	c3                   	ret    
  ASSERT (b != NULL);
c00297ad:	83 ec 0c             	sub    $0xc,%esp
c00297b0:	68 0f 1e 03 c0       	push   $0xc0031e0f
c00297b5:	68 21 01 03 c0       	push   $0xc0030121
c00297ba:	68 04 fd 02 c0       	push   $0xc002fd04
c00297bf:	68 2a 01 00 00       	push   $0x12a
c00297c4:	68 a2 1f 03 c0       	push   $0xc0031fa2
c00297c9:	e8 59 ee ff ff       	call   c0028627 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c00297ce:	83 ec 0c             	sub    $0xc,%esp
c00297d1:	68 cd 1f 03 c0       	push   $0xc0031fcd
c00297d6:	68 21 01 03 c0       	push   $0xc0030121
c00297db:	68 04 fd 02 c0       	push   $0xc002fd04
c00297e0:	68 2b 01 00 00       	push   $0x12b
c00297e5:	68 a2 1f 03 c0       	push   $0xc0031fa2
c00297ea:	e8 38 ee ff ff       	call   c0028627 <debug_panic>
      size_t last = b->bit_cnt - cnt;
c00297ef:	29 f8                	sub    %edi,%eax
c00297f1:	89 44 24 0c          	mov    %eax,0xc(%esp)
      for (i = start; i <= last; i++)
c00297f5:	39 c3                	cmp    %eax,%ebx
c00297f7:	77 24                	ja     c002981d <bitmap_scan+0xa2>
        if (!bitmap_contains (b, i, cnt, !value))
c00297f9:	83 f2 01             	xor    $0x1,%edx
c00297fc:	0f b6 ea             	movzbl %dl,%ebp
c00297ff:	55                   	push   %ebp
c0029800:	57                   	push   %edi
c0029801:	53                   	push   %ebx
c0029802:	56                   	push   %esi
c0029803:	e8 6c fe ff ff       	call   c0029674 <bitmap_contains>
c0029808:	83 c4 10             	add    $0x10,%esp
c002980b:	84 c0                	test   %al,%al
c002980d:	74 15                	je     c0029824 <bitmap_scan+0xa9>
      for (i = start; i <= last; i++)
c002980f:	43                   	inc    %ebx
c0029810:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c0029814:	73 e9                	jae    c00297ff <bitmap_scan+0x84>
  return BITMAP_ERROR;
c0029816:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002981b:	eb 88                	jmp    c00297a5 <bitmap_scan+0x2a>
c002981d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0029822:	eb 81                	jmp    c00297a5 <bitmap_scan+0x2a>
c0029824:	89 d8                	mov    %ebx,%eax
c0029826:	e9 7a ff ff ff       	jmp    c00297a5 <bitmap_scan+0x2a>

c002982b <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002982b:	55                   	push   %ebp
c002982c:	57                   	push   %edi
c002982d:	56                   	push   %esi
c002982e:	53                   	push   %ebx
c002982f:	83 ec 0c             	sub    $0xc,%esp
c0029832:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0029836:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002983a:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c002983e:	0f b6 c3             	movzbl %bl,%eax
c0029841:	50                   	push   %eax
c0029842:	55                   	push   %ebp
c0029843:	ff 74 24 2c          	pushl  0x2c(%esp)
c0029847:	57                   	push   %edi
c0029848:	e8 2e ff ff ff       	call   c002977b <bitmap_scan>
c002984d:	83 c4 10             	add    $0x10,%esp
c0029850:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c0029852:	83 f8 ff             	cmp    $0xffffffff,%eax
c0029855:	74 12                	je     c0029869 <bitmap_scan_and_flip+0x3e>
    bitmap_set_multiple (b, idx, cnt, !value);
c0029857:	83 f3 01             	xor    $0x1,%ebx
c002985a:	0f b6 db             	movzbl %bl,%ebx
c002985d:	53                   	push   %ebx
c002985e:	55                   	push   %ebp
c002985f:	50                   	push   %eax
c0029860:	57                   	push   %edi
c0029861:	e8 a3 fb ff ff       	call   c0029409 <bitmap_set_multiple>
c0029866:	83 c4 10             	add    $0x10,%esp
  return idx;
}
c0029869:	89 f0                	mov    %esi,%eax
c002986b:	83 c4 0c             	add    $0xc,%esp
c002986e:	5b                   	pop    %ebx
c002986f:	5e                   	pop    %esi
c0029870:	5f                   	pop    %edi
c0029871:	5d                   	pop    %ebp
c0029872:	c3                   	ret    

c0029873 <bitmap_file_size>:
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029873:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029877:	8b 00                	mov    (%eax),%eax
c0029879:	83 c0 1f             	add    $0x1f,%eax
c002987c:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002987f:	c1 e0 02             	shl    $0x2,%eax
/* Returns the number of bytes needed to store B in a file. */
size_t
bitmap_file_size (const struct bitmap *b) 
{
  return byte_cnt (b->bit_cnt);
}
c0029882:	c3                   	ret    

c0029883 <bitmap_read>:

/* Reads B from FILE.  Returns true if successful, false
   otherwise. */
bool
bitmap_read (struct bitmap *b, struct file *file) 
{
c0029883:	56                   	push   %esi
c0029884:	53                   	push   %ebx
c0029885:	83 ec 04             	sub    $0x4,%esp
c0029888:	8b 74 24 10          	mov    0x10(%esp),%esi
  bool success = true;
  if (b->bit_cnt > 0) 
c002988c:	8b 06                	mov    (%esi),%eax
c002988e:	85 c0                	test   %eax,%eax
c0029890:	75 08                	jne    c002989a <bitmap_read+0x17>
  bool success = true;
c0029892:	b0 01                	mov    $0x1,%al
      off_t size = byte_cnt (b->bit_cnt);
      success = file_read_at (file, b->bits, size, 0) == size;
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
    }
  return success;
}
c0029894:	83 c4 04             	add    $0x4,%esp
c0029897:	5b                   	pop    %ebx
c0029898:	5e                   	pop    %esi
c0029899:	c3                   	ret    
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002989a:	83 c0 1f             	add    $0x1f,%eax
c002989d:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c00298a0:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
      success = file_read_at (file, b->bits, size, 0) == size;
c00298a7:	6a 00                	push   $0x0
c00298a9:	53                   	push   %ebx
c00298aa:	ff 76 04             	pushl  0x4(%esi)
c00298ad:	ff 74 24 20          	pushl  0x20(%esp)
c00298b1:	e8 6c 30 00 00       	call   c002c922 <file_read_at>
c00298b6:	83 c4 10             	add    $0x10,%esp
c00298b9:	39 c3                	cmp    %eax,%ebx
c00298bb:	0f 94 c0             	sete   %al
  int last_bits = b->bit_cnt % ELEM_BITS;
c00298be:	8b 16                	mov    (%esi),%edx
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c00298c0:	89 d1                	mov    %edx,%ecx
c00298c2:	83 e1 1f             	and    $0x1f,%ecx
c00298c5:	74 19                	je     c00298e0 <bitmap_read+0x5d>
c00298c7:	bb 01 00 00 00       	mov    $0x1,%ebx
c00298cc:	d3 e3                	shl    %cl,%ebx
c00298ce:	8d 4b ff             	lea    -0x1(%ebx),%ecx
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c00298d1:	83 c2 1f             	add    $0x1f,%edx
c00298d4:	c1 ea 05             	shr    $0x5,%edx
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
c00298d7:	8b 5e 04             	mov    0x4(%esi),%ebx
c00298da:	21 4c 93 fc          	and    %ecx,-0x4(%ebx,%edx,4)
c00298de:	eb b4                	jmp    c0029894 <bitmap_read+0x11>
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c00298e0:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00298e5:	eb ea                	jmp    c00298d1 <bitmap_read+0x4e>

c00298e7 <bitmap_write>:

/* Writes B to FILE.  Return true if successful, false
   otherwise. */
bool
bitmap_write (const struct bitmap *b, struct file *file)
{
c00298e7:	53                   	push   %ebx
c00298e8:	83 ec 08             	sub    $0x8,%esp
c00298eb:	8b 44 24 10          	mov    0x10(%esp),%eax
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c00298ef:	8b 10                	mov    (%eax),%edx
c00298f1:	8d 5a 1f             	lea    0x1f(%edx),%ebx
c00298f4:	c1 eb 05             	shr    $0x5,%ebx
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c00298f7:	c1 e3 02             	shl    $0x2,%ebx
  off_t size = byte_cnt (b->bit_cnt);
  return file_write_at (file, b->bits, size, 0) == size;
c00298fa:	6a 00                	push   $0x0
c00298fc:	53                   	push   %ebx
c00298fd:	ff 70 04             	pushl  0x4(%eax)
c0029900:	ff 74 24 20          	pushl  0x20(%esp)
c0029904:	e8 59 30 00 00       	call   c002c962 <file_write_at>
c0029909:	39 c3                	cmp    %eax,%ebx
c002990b:	0f 94 c0             	sete   %al
}
c002990e:	83 c4 18             	add    $0x18,%esp
c0029911:	5b                   	pop    %ebx
c0029912:	c3                   	ret    

c0029913 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c0029913:	83 ec 0c             	sub    $0xc,%esp
c0029916:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002991a:	6a 00                	push   $0x0
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002991c:	8b 02                	mov    (%edx),%eax
c002991e:	83 c0 1f             	add    $0x1f,%eax
c0029921:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c0029924:	c1 e0 02             	shl    $0x2,%eax
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c0029927:	50                   	push   %eax
c0029928:	ff 72 04             	pushl  0x4(%edx)
c002992b:	6a 00                	push   $0x0
c002992d:	e8 f0 d9 ff ff       	call   c0027322 <hex_dump>
}
c0029932:	83 c4 1c             	add    $0x1c,%esp
c0029935:	c3                   	ret    

c0029936 <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c0029936:	53                   	push   %ebx
c0029937:	83 ec 10             	sub    $0x10,%esp
c002993a:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002993c:	ff 70 14             	pushl  0x14(%eax)
c002993f:	52                   	push   %edx
c0029940:	ff 50 0c             	call   *0xc(%eax)
c0029943:	8b 4b 04             	mov    0x4(%ebx),%ecx
c0029946:	8d 51 ff             	lea    -0x1(%ecx),%edx
c0029949:	21 d0                	and    %edx,%eax
  return &h->buckets[bucket_idx];
c002994b:	c1 e0 04             	shl    $0x4,%eax
c002994e:	03 43 08             	add    0x8(%ebx),%eax
}
c0029951:	83 c4 18             	add    $0x18,%esp
c0029954:	5b                   	pop    %ebx
c0029955:	c3                   	ret    

c0029956 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c0029956:	55                   	push   %ebp
c0029957:	57                   	push   %edi
c0029958:	56                   	push   %esi
c0029959:	53                   	push   %ebx
c002995a:	83 ec 18             	sub    $0x18,%esp
c002995d:	89 c6                	mov    %eax,%esi
c002995f:	89 d5                	mov    %edx,%ebp
c0029961:	89 cf                	mov    %ecx,%edi
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c0029963:	52                   	push   %edx
c0029964:	e8 a8 ed ff ff       	call   c0028711 <list_begin>
c0029969:	89 c3                	mov    %eax,%ebx
c002996b:	83 c4 10             	add    $0x10,%esp
c002996e:	eb 0e                	jmp    c002997e <find_elem+0x28>
c0029970:	83 ec 0c             	sub    $0xc,%esp
c0029973:	53                   	push   %ebx
c0029974:	e8 c8 ed ff ff       	call   c0028741 <list_next>
c0029979:	89 c3                	mov    %eax,%ebx
c002997b:	83 c4 10             	add    $0x10,%esp
c002997e:	83 ec 0c             	sub    $0xc,%esp
c0029981:	55                   	push   %ebp
c0029982:	e8 02 ee ff ff       	call   c0028789 <list_end>
c0029987:	83 c4 10             	add    $0x10,%esp
c002998a:	39 c3                	cmp    %eax,%ebx
c002998c:	74 28                	je     c00299b6 <find_elem+0x60>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002998e:	83 ec 04             	sub    $0x4,%esp
c0029991:	ff 76 14             	pushl  0x14(%esi)
c0029994:	57                   	push   %edi
c0029995:	53                   	push   %ebx
c0029996:	ff 56 10             	call   *0x10(%esi)
c0029999:	83 c4 10             	add    $0x10,%esp
c002999c:	84 c0                	test   %al,%al
c002999e:	75 d0                	jne    c0029970 <find_elem+0x1a>
c00299a0:	83 ec 04             	sub    $0x4,%esp
c00299a3:	ff 76 14             	pushl  0x14(%esi)
c00299a6:	53                   	push   %ebx
c00299a7:	57                   	push   %edi
c00299a8:	ff 56 10             	call   *0x10(%esi)
c00299ab:	83 c4 10             	add    $0x10,%esp
c00299ae:	84 c0                	test   %al,%al
c00299b0:	75 be                	jne    c0029970 <find_elem+0x1a>
c00299b2:	89 d8                	mov    %ebx,%eax
c00299b4:	eb 05                	jmp    c00299bb <find_elem+0x65>
        return hi; 
    }
  return NULL;
c00299b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00299bb:	83 c4 0c             	add    $0xc,%esp
c00299be:	5b                   	pop    %ebx
c00299bf:	5e                   	pop    %esi
c00299c0:	5f                   	pop    %edi
c00299c1:	5d                   	pop    %ebp
c00299c2:	c3                   	ret    

c00299c3 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c00299c3:	55                   	push   %ebp
c00299c4:	57                   	push   %edi
c00299c5:	56                   	push   %esi
c00299c6:	53                   	push   %ebx
c00299c7:	83 ec 2c             	sub    $0x2c,%esp
c00299ca:	89 44 24 0c          	mov    %eax,0xc(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c00299ce:	85 c0                	test   %eax,%eax
c00299d0:	74 21                	je     c00299f3 <rehash+0x30>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c00299d2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00299d6:	8b 48 04             	mov    0x4(%eax),%ecx
c00299d9:	89 4c 24 18          	mov    %ecx,0x18(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c00299dd:	8b 00                	mov    (%eax),%eax
c00299df:	89 44 24 10          	mov    %eax,0x10(%esp)
c00299e3:	89 c3                	mov    %eax,%ebx
c00299e5:	d1 eb                	shr    %ebx
c00299e7:	83 fb 04             	cmp    $0x4,%ebx
c00299ea:	73 2d                	jae    c0029a19 <rehash+0x56>
c00299ec:	bb 04 00 00 00       	mov    $0x4,%ebx
c00299f1:	eb 26                	jmp    c0029a19 <rehash+0x56>
  ASSERT (h != NULL);
c00299f3:	83 ec 0c             	sub    $0xc,%esp
c00299f6:	68 24 20 03 c0       	push   $0xc0032024
c00299fb:	68 21 01 03 c0       	push   $0xc0030121
c0029a00:	68 c0 fd 02 c0       	push   $0xc002fdc0
c0029a05:	68 66 01 00 00       	push   $0x166
c0029a0a:	68 2e 20 03 c0       	push   $0xc003202e
c0029a0f:	e8 13 ec ff ff       	call   c0028627 <debug_panic>
  return x & (x - 1);
c0029a14:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0029a17:	21 c3                	and    %eax,%ebx
  return x != 0 && turn_off_least_1bit (x) == 0;
c0029a19:	85 db                	test   %ebx,%ebx
c0029a1b:	74 f7                	je     c0029a14 <rehash+0x51>
  return x & (x - 1);
c0029a1d:	8d 43 ff             	lea    -0x1(%ebx),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c0029a20:	21 d8                	and    %ebx,%eax
c0029a22:	75 f0                	jne    c0029a14 <rehash+0x51>
c0029a24:	89 c6                	mov    %eax,%esi
c0029a26:	89 44 24 10          	mov    %eax,0x10(%esp)
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c0029a2a:	3b 5c 24 18          	cmp    0x18(%esp),%ebx
c0029a2e:	0f 84 ce 00 00 00    	je     c0029b02 <rehash+0x13f>
  old_buckets = h->buckets;
c0029a34:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029a38:	8b 40 08             	mov    0x8(%eax),%eax
c0029a3b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c0029a3f:	83 ec 0c             	sub    $0xc,%esp
c0029a42:	89 d8                	mov    %ebx,%eax
c0029a44:	c1 e0 04             	shl    $0x4,%eax
c0029a47:	50                   	push   %eax
c0029a48:	e8 81 9f ff ff       	call   c00239ce <malloc>
c0029a4d:	89 c5                	mov    %eax,%ebp
  if (new_buckets == NULL) 
c0029a4f:	83 c4 10             	add    $0x10,%esp
c0029a52:	85 c0                	test   %eax,%eax
c0029a54:	0f 84 a8 00 00 00    	je     c0029b02 <rehash+0x13f>
c0029a5a:	89 c7                	mov    %eax,%edi
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c0029a5c:	83 ec 0c             	sub    $0xc,%esp
c0029a5f:	57                   	push   %edi
c0029a60:	e8 69 ec ff ff       	call   c00286ce <list_init>
  for (i = 0; i < new_bucket_cnt; i++) 
c0029a65:	46                   	inc    %esi
c0029a66:	83 c7 10             	add    $0x10,%edi
c0029a69:	83 c4 10             	add    $0x10,%esp
c0029a6c:	39 f3                	cmp    %esi,%ebx
c0029a6e:	75 ec                	jne    c0029a5c <rehash+0x99>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c0029a70:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029a74:	89 68 08             	mov    %ebp,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c0029a77:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c0029a7a:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0029a7f:	74 72                	je     c0029af3 <rehash+0x130>
c0029a81:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0029a85:	89 44 24 14          	mov    %eax,0x14(%esp)
c0029a89:	eb 52                	jmp    c0029add <rehash+0x11a>

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c0029a8b:	89 da                	mov    %ebx,%edx
c0029a8d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029a91:	e8 a0 fe ff ff       	call   c0029936 <find_bucket>
c0029a96:	89 c7                	mov    %eax,%edi
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c0029a98:	83 ec 0c             	sub    $0xc,%esp
c0029a9b:	53                   	push   %ebx
c0029a9c:	e8 a0 ec ff ff       	call   c0028741 <list_next>
c0029aa1:	89 c6                	mov    %eax,%esi
          list_remove (elem);
c0029aa3:	89 1c 24             	mov    %ebx,(%esp)
c0029aa6:	e8 8c f0 ff ff       	call   c0028b37 <list_remove>
          list_push_front (new_bucket, elem);
c0029aab:	83 c4 08             	add    $0x8,%esp
c0029aae:	53                   	push   %ebx
c0029aaf:	57                   	push   %edi
c0029ab0:	e8 48 f0 ff ff       	call   c0028afd <list_push_front>
           elem != list_end (old_bucket); elem = next) 
c0029ab5:	83 c4 10             	add    $0x10,%esp
c0029ab8:	89 f3                	mov    %esi,%ebx
c0029aba:	83 ec 0c             	sub    $0xc,%esp
c0029abd:	55                   	push   %ebp
c0029abe:	e8 c6 ec ff ff       	call   c0028789 <list_end>
      for (elem = list_begin (old_bucket);
c0029ac3:	83 c4 10             	add    $0x10,%esp
c0029ac6:	39 c3                	cmp    %eax,%ebx
c0029ac8:	75 c1                	jne    c0029a8b <rehash+0xc8>
  for (i = 0; i < old_bucket_cnt; i++) 
c0029aca:	ff 44 24 10          	incl   0x10(%esp)
c0029ace:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029ad2:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c0029ad7:	39 44 24 18          	cmp    %eax,0x18(%esp)
c0029adb:	74 16                	je     c0029af3 <rehash+0x130>
      old_bucket = &old_buckets[i];
c0029add:	8b 44 24 14          	mov    0x14(%esp),%eax
c0029ae1:	89 c5                	mov    %eax,%ebp
      for (elem = list_begin (old_bucket);
c0029ae3:	83 ec 0c             	sub    $0xc,%esp
c0029ae6:	50                   	push   %eax
c0029ae7:	e8 25 ec ff ff       	call   c0028711 <list_begin>
c0029aec:	89 c3                	mov    %eax,%ebx
c0029aee:	83 c4 10             	add    $0x10,%esp
c0029af1:	eb c7                	jmp    c0029aba <rehash+0xf7>
        }
    }

  free (old_buckets);
c0029af3:	83 ec 0c             	sub    $0xc,%esp
c0029af6:	ff 74 24 28          	pushl  0x28(%esp)
c0029afa:	e8 72 a0 ff ff       	call   c0023b71 <free>
c0029aff:	83 c4 10             	add    $0x10,%esp
}
c0029b02:	83 c4 2c             	add    $0x2c,%esp
c0029b05:	5b                   	pop    %ebx
c0029b06:	5e                   	pop    %esi
c0029b07:	5f                   	pop    %edi
c0029b08:	5d                   	pop    %ebp
c0029b09:	c3                   	ret    

c0029b0a <hash_clear>:
{
c0029b0a:	55                   	push   %ebp
c0029b0b:	57                   	push   %edi
c0029b0c:	56                   	push   %esi
c0029b0d:	53                   	push   %ebx
c0029b0e:	83 ec 0c             	sub    $0xc,%esp
c0029b11:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029b15:	8b 7c 24 24          	mov    0x24(%esp),%edi
  for (i = 0; i < h->bucket_cnt; i++) 
c0029b19:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029b1d:	74 4c                	je     c0029b6b <hash_clear+0x61>
c0029b1f:	bd 00 00 00 00       	mov    $0x0,%ebp
c0029b24:	eb 37                	jmp    c0029b5d <hash_clear+0x53>
            struct list_elem *list_elem = list_pop_front (bucket);
c0029b26:	83 ec 0c             	sub    $0xc,%esp
c0029b29:	53                   	push   %ebx
c0029b2a:	e8 f5 f0 ff ff       	call   c0028c24 <list_pop_front>
            destructor (hash_elem, h->aux);
c0029b2f:	83 c4 08             	add    $0x8,%esp
c0029b32:	ff 76 14             	pushl  0x14(%esi)
c0029b35:	50                   	push   %eax
c0029b36:	ff d7                	call   *%edi
c0029b38:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c0029b3b:	83 ec 0c             	sub    $0xc,%esp
c0029b3e:	53                   	push   %ebx
c0029b3f:	e8 7e f0 ff ff       	call   c0028bc2 <list_empty>
c0029b44:	83 c4 10             	add    $0x10,%esp
c0029b47:	84 c0                	test   %al,%al
c0029b49:	74 db                	je     c0029b26 <hash_clear+0x1c>
      list_init (bucket); 
c0029b4b:	83 ec 0c             	sub    $0xc,%esp
c0029b4e:	53                   	push   %ebx
c0029b4f:	e8 7a eb ff ff       	call   c00286ce <list_init>
  for (i = 0; i < h->bucket_cnt; i++) 
c0029b54:	45                   	inc    %ebp
c0029b55:	83 c4 10             	add    $0x10,%esp
c0029b58:	39 6e 04             	cmp    %ebp,0x4(%esi)
c0029b5b:	76 0e                	jbe    c0029b6b <hash_clear+0x61>
      struct list *bucket = &h->buckets[i];
c0029b5d:	89 eb                	mov    %ebp,%ebx
c0029b5f:	c1 e3 04             	shl    $0x4,%ebx
c0029b62:	03 5e 08             	add    0x8(%esi),%ebx
      if (destructor != NULL) 
c0029b65:	85 ff                	test   %edi,%edi
c0029b67:	75 d2                	jne    c0029b3b <hash_clear+0x31>
c0029b69:	eb e0                	jmp    c0029b4b <hash_clear+0x41>
  h->elem_cnt = 0;
c0029b6b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
c0029b71:	83 c4 0c             	add    $0xc,%esp
c0029b74:	5b                   	pop    %ebx
c0029b75:	5e                   	pop    %esi
c0029b76:	5f                   	pop    %edi
c0029b77:	5d                   	pop    %ebp
c0029b78:	c3                   	ret    

c0029b79 <hash_init>:
{
c0029b79:	53                   	push   %ebx
c0029b7a:	83 ec 14             	sub    $0x14,%esp
c0029b7d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  h->elem_cnt = 0;
c0029b81:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  h->bucket_cnt = 4;
c0029b87:	c7 43 04 04 00 00 00 	movl   $0x4,0x4(%ebx)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c0029b8e:	6a 40                	push   $0x40
c0029b90:	e8 39 9e ff ff       	call   c00239ce <malloc>
c0029b95:	89 43 08             	mov    %eax,0x8(%ebx)
  h->hash = hash;
c0029b98:	8b 54 24 24          	mov    0x24(%esp),%edx
c0029b9c:	89 53 0c             	mov    %edx,0xc(%ebx)
  h->less = less;
c0029b9f:	8b 54 24 28          	mov    0x28(%esp),%edx
c0029ba3:	89 53 10             	mov    %edx,0x10(%ebx)
  h->aux = aux;
c0029ba6:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0029baa:	89 53 14             	mov    %edx,0x14(%ebx)
  if (h->buckets != NULL) 
c0029bad:	83 c4 10             	add    $0x10,%esp
c0029bb0:	85 c0                	test   %eax,%eax
c0029bb2:	74 15                	je     c0029bc9 <hash_init+0x50>
      hash_clear (h, NULL);
c0029bb4:	83 ec 08             	sub    $0x8,%esp
c0029bb7:	6a 00                	push   $0x0
c0029bb9:	53                   	push   %ebx
c0029bba:	e8 4b ff ff ff       	call   c0029b0a <hash_clear>
      return true;
c0029bbf:	83 c4 10             	add    $0x10,%esp
c0029bc2:	b0 01                	mov    $0x1,%al
}
c0029bc4:	83 c4 08             	add    $0x8,%esp
c0029bc7:	5b                   	pop    %ebx
c0029bc8:	c3                   	ret    
    return false;
c0029bc9:	b0 00                	mov    $0x0,%al
c0029bcb:	eb f7                	jmp    c0029bc4 <hash_init+0x4b>

c0029bcd <hash_destroy>:
{
c0029bcd:	53                   	push   %ebx
c0029bce:	83 ec 08             	sub    $0x8,%esp
c0029bd1:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0029bd5:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c0029bd9:	85 c0                	test   %eax,%eax
c0029bdb:	74 0d                	je     c0029bea <hash_destroy+0x1d>
    hash_clear (h, destructor);
c0029bdd:	83 ec 08             	sub    $0x8,%esp
c0029be0:	50                   	push   %eax
c0029be1:	53                   	push   %ebx
c0029be2:	e8 23 ff ff ff       	call   c0029b0a <hash_clear>
c0029be7:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c0029bea:	83 ec 0c             	sub    $0xc,%esp
c0029bed:	ff 73 08             	pushl  0x8(%ebx)
c0029bf0:	e8 7c 9f ff ff       	call   c0023b71 <free>
}
c0029bf5:	83 c4 18             	add    $0x18,%esp
c0029bf8:	5b                   	pop    %ebx
c0029bf9:	c3                   	ret    

c0029bfa <hash_insert>:
{
c0029bfa:	55                   	push   %ebp
c0029bfb:	57                   	push   %edi
c0029bfc:	56                   	push   %esi
c0029bfd:	53                   	push   %ebx
c0029bfe:	83 ec 0c             	sub    $0xc,%esp
c0029c01:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0029c05:	8b 74 24 24          	mov    0x24(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c0029c09:	89 f2                	mov    %esi,%edx
c0029c0b:	89 d8                	mov    %ebx,%eax
c0029c0d:	e8 24 fd ff ff       	call   c0029936 <find_bucket>
c0029c12:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c0029c14:	89 f1                	mov    %esi,%ecx
c0029c16:	89 c2                	mov    %eax,%edx
c0029c18:	89 d8                	mov    %ebx,%eax
c0029c1a:	e8 37 fd ff ff       	call   c0029956 <find_elem>
c0029c1f:	89 c7                	mov    %eax,%edi
  if (old == NULL) 
c0029c21:	85 c0                	test   %eax,%eax
c0029c23:	74 11                	je     c0029c36 <hash_insert+0x3c>
  rehash (h);
c0029c25:	89 d8                	mov    %ebx,%eax
c0029c27:	e8 97 fd ff ff       	call   c00299c3 <rehash>
}
c0029c2c:	89 f8                	mov    %edi,%eax
c0029c2e:	83 c4 0c             	add    $0xc,%esp
c0029c31:	5b                   	pop    %ebx
c0029c32:	5e                   	pop    %esi
c0029c33:	5f                   	pop    %edi
c0029c34:	5d                   	pop    %ebp
c0029c35:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c0029c36:	ff 03                	incl   (%ebx)
  list_push_front (bucket, &e->list_elem);
c0029c38:	83 ec 08             	sub    $0x8,%esp
c0029c3b:	56                   	push   %esi
c0029c3c:	55                   	push   %ebp
c0029c3d:	e8 bb ee ff ff       	call   c0028afd <list_push_front>
c0029c42:	83 c4 10             	add    $0x10,%esp
c0029c45:	eb de                	jmp    c0029c25 <hash_insert+0x2b>

c0029c47 <hash_replace>:
{
c0029c47:	55                   	push   %ebp
c0029c48:	57                   	push   %edi
c0029c49:	56                   	push   %esi
c0029c4a:	53                   	push   %ebx
c0029c4b:	83 ec 0c             	sub    $0xc,%esp
c0029c4e:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0029c52:	8b 74 24 24          	mov    0x24(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c0029c56:	89 f2                	mov    %esi,%edx
c0029c58:	89 d8                	mov    %ebx,%eax
c0029c5a:	e8 d7 fc ff ff       	call   c0029936 <find_bucket>
c0029c5f:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c0029c61:	89 f1                	mov    %esi,%ecx
c0029c63:	89 c2                	mov    %eax,%edx
c0029c65:	89 d8                	mov    %ebx,%eax
c0029c67:	e8 ea fc ff ff       	call   c0029956 <find_elem>
c0029c6c:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c0029c6e:	85 c0                	test   %eax,%eax
c0029c70:	74 0e                	je     c0029c80 <hash_replace+0x39>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c0029c72:	ff 0b                	decl   (%ebx)
  list_remove (&e->list_elem);
c0029c74:	83 ec 0c             	sub    $0xc,%esp
c0029c77:	50                   	push   %eax
c0029c78:	e8 ba ee ff ff       	call   c0028b37 <list_remove>
c0029c7d:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c0029c80:	ff 03                	incl   (%ebx)
  list_push_front (bucket, &e->list_elem);
c0029c82:	83 ec 08             	sub    $0x8,%esp
c0029c85:	56                   	push   %esi
c0029c86:	55                   	push   %ebp
c0029c87:	e8 71 ee ff ff       	call   c0028afd <list_push_front>
  rehash (h);
c0029c8c:	89 d8                	mov    %ebx,%eax
c0029c8e:	e8 30 fd ff ff       	call   c00299c3 <rehash>
}
c0029c93:	89 f8                	mov    %edi,%eax
c0029c95:	83 c4 1c             	add    $0x1c,%esp
c0029c98:	5b                   	pop    %ebx
c0029c99:	5e                   	pop    %esi
c0029c9a:	5f                   	pop    %edi
c0029c9b:	5d                   	pop    %ebp
c0029c9c:	c3                   	ret    

c0029c9d <hash_find>:
{
c0029c9d:	83 ec 0c             	sub    $0xc,%esp
  return find_elem (h, find_bucket (h, e), e);
c0029ca0:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029ca4:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029ca8:	e8 89 fc ff ff       	call   c0029936 <find_bucket>
c0029cad:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0029cb1:	89 c2                	mov    %eax,%edx
c0029cb3:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029cb7:	e8 9a fc ff ff       	call   c0029956 <find_elem>
}
c0029cbc:	83 c4 0c             	add    $0xc,%esp
c0029cbf:	c3                   	ret    

c0029cc0 <hash_delete>:
{
c0029cc0:	56                   	push   %esi
c0029cc1:	53                   	push   %ebx
c0029cc2:	83 ec 04             	sub    $0x4,%esp
c0029cc5:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0029cc9:	8b 74 24 14          	mov    0x14(%esp),%esi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c0029ccd:	89 f2                	mov    %esi,%edx
c0029ccf:	89 d8                	mov    %ebx,%eax
c0029cd1:	e8 60 fc ff ff       	call   c0029936 <find_bucket>
c0029cd6:	89 f1                	mov    %esi,%ecx
c0029cd8:	89 c2                	mov    %eax,%edx
c0029cda:	89 d8                	mov    %ebx,%eax
c0029cdc:	e8 75 fc ff ff       	call   c0029956 <find_elem>
c0029ce1:	89 c6                	mov    %eax,%esi
  if (found != NULL) 
c0029ce3:	85 c0                	test   %eax,%eax
c0029ce5:	74 15                	je     c0029cfc <hash_delete+0x3c>
  h->elem_cnt--;
c0029ce7:	ff 0b                	decl   (%ebx)
  list_remove (&e->list_elem);
c0029ce9:	83 ec 0c             	sub    $0xc,%esp
c0029cec:	50                   	push   %eax
c0029ced:	e8 45 ee ff ff       	call   c0028b37 <list_remove>
      rehash (h); 
c0029cf2:	89 d8                	mov    %ebx,%eax
c0029cf4:	e8 ca fc ff ff       	call   c00299c3 <rehash>
c0029cf9:	83 c4 10             	add    $0x10,%esp
}
c0029cfc:	89 f0                	mov    %esi,%eax
c0029cfe:	83 c4 04             	add    $0x4,%esp
c0029d01:	5b                   	pop    %ebx
c0029d02:	5e                   	pop    %esi
c0029d03:	c3                   	ret    

c0029d04 <hash_apply>:
{
c0029d04:	55                   	push   %ebp
c0029d05:	57                   	push   %edi
c0029d06:	56                   	push   %esi
c0029d07:	53                   	push   %ebx
c0029d08:	83 ec 1c             	sub    $0x1c,%esp
c0029d0b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (action != NULL);
c0029d0f:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c0029d14:	74 16                	je     c0029d2c <hash_apply+0x28>
  for (i = 0; i < h->bucket_cnt; i++) 
c0029d16:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0029d1d:	00 
c0029d1e:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c0029d22:	75 61                	jne    c0029d85 <hash_apply+0x81>
}
c0029d24:	83 c4 1c             	add    $0x1c,%esp
c0029d27:	5b                   	pop    %ebx
c0029d28:	5e                   	pop    %esi
c0029d29:	5f                   	pop    %edi
c0029d2a:	5d                   	pop    %ebp
c0029d2b:	c3                   	ret    
  ASSERT (action != NULL);
c0029d2c:	83 ec 0c             	sub    $0xc,%esp
c0029d2f:	68 46 20 03 c0       	push   $0xc0032046
c0029d34:	68 21 01 03 c0       	push   $0xc0030121
c0029d39:	68 b4 fd 02 c0       	push   $0xc002fdb4
c0029d3e:	68 a7 00 00 00       	push   $0xa7
c0029d43:	68 2e 20 03 c0       	push   $0xc003202e
c0029d48:	e8 da e8 ff ff       	call   c0028627 <debug_panic>
          next = list_next (elem);
c0029d4d:	83 ec 0c             	sub    $0xc,%esp
c0029d50:	53                   	push   %ebx
c0029d51:	e8 eb e9 ff ff       	call   c0028741 <list_next>
c0029d56:	89 c6                	mov    %eax,%esi
          action (list_elem_to_hash_elem (elem), h->aux);
c0029d58:	83 c4 08             	add    $0x8,%esp
c0029d5b:	ff 75 14             	pushl  0x14(%ebp)
c0029d5e:	53                   	push   %ebx
c0029d5f:	ff 54 24 44          	call   *0x44(%esp)
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c0029d63:	83 c4 10             	add    $0x10,%esp
c0029d66:	89 f3                	mov    %esi,%ebx
c0029d68:	83 ec 0c             	sub    $0xc,%esp
c0029d6b:	57                   	push   %edi
c0029d6c:	e8 18 ea ff ff       	call   c0028789 <list_end>
c0029d71:	83 c4 10             	add    $0x10,%esp
c0029d74:	39 c3                	cmp    %eax,%ebx
c0029d76:	75 d5                	jne    c0029d4d <hash_apply+0x49>
  for (i = 0; i < h->bucket_cnt; i++) 
c0029d78:	ff 44 24 0c          	incl   0xc(%esp)
c0029d7c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029d80:	39 45 04             	cmp    %eax,0x4(%ebp)
c0029d83:	76 9f                	jbe    c0029d24 <hash_apply+0x20>
      struct list *bucket = &h->buckets[i];
c0029d85:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0029d89:	c1 e7 04             	shl    $0x4,%edi
c0029d8c:	03 7d 08             	add    0x8(%ebp),%edi
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c0029d8f:	83 ec 0c             	sub    $0xc,%esp
c0029d92:	57                   	push   %edi
c0029d93:	e8 79 e9 ff ff       	call   c0028711 <list_begin>
c0029d98:	89 c3                	mov    %eax,%ebx
c0029d9a:	83 c4 10             	add    $0x10,%esp
c0029d9d:	eb c9                	jmp    c0029d68 <hash_apply+0x64>

c0029d9f <hash_first>:
{
c0029d9f:	53                   	push   %ebx
c0029da0:	83 ec 08             	sub    $0x8,%esp
c0029da3:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0029da7:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c0029dab:	85 db                	test   %ebx,%ebx
c0029dad:	74 1d                	je     c0029dcc <hash_first+0x2d>
  ASSERT (h != NULL);
c0029daf:	85 c0                	test   %eax,%eax
c0029db1:	74 3a                	je     c0029ded <hash_first+0x4e>
  i->hash = h;
c0029db3:	89 03                	mov    %eax,(%ebx)
  i->bucket = i->hash->buckets;
c0029db5:	8b 40 08             	mov    0x8(%eax),%eax
c0029db8:	89 43 04             	mov    %eax,0x4(%ebx)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c0029dbb:	83 ec 0c             	sub    $0xc,%esp
c0029dbe:	50                   	push   %eax
c0029dbf:	e8 7d eb ff ff       	call   c0028941 <list_head>
c0029dc4:	89 43 08             	mov    %eax,0x8(%ebx)
}
c0029dc7:	83 c4 18             	add    $0x18,%esp
c0029dca:	5b                   	pop    %ebx
c0029dcb:	c3                   	ret    
  ASSERT (i != NULL);
c0029dcc:	83 ec 0c             	sub    $0xc,%esp
c0029dcf:	68 55 20 03 c0       	push   $0xc0032055
c0029dd4:	68 21 01 03 c0       	push   $0xc0030121
c0029dd9:	68 a8 fd 02 c0       	push   $0xc002fda8
c0029dde:	68 ca 00 00 00       	push   $0xca
c0029de3:	68 2e 20 03 c0       	push   $0xc003202e
c0029de8:	e8 3a e8 ff ff       	call   c0028627 <debug_panic>
  ASSERT (h != NULL);
c0029ded:	83 ec 0c             	sub    $0xc,%esp
c0029df0:	68 24 20 03 c0       	push   $0xc0032024
c0029df5:	68 21 01 03 c0       	push   $0xc0030121
c0029dfa:	68 a8 fd 02 c0       	push   $0xc002fda8
c0029dff:	68 cb 00 00 00       	push   $0xcb
c0029e04:	68 2e 20 03 c0       	push   $0xc003202e
c0029e09:	e8 19 e8 ff ff       	call   c0028627 <debug_panic>

c0029e0e <hash_next>:
{
c0029e0e:	56                   	push   %esi
c0029e0f:	53                   	push   %ebx
c0029e10:	83 ec 04             	sub    $0x4,%esp
c0029e13:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (i != NULL);
c0029e17:	85 db                	test   %ebx,%ebx
c0029e19:	74 4f                	je     c0029e6a <hash_next+0x5c>
  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c0029e1b:	83 ec 0c             	sub    $0xc,%esp
c0029e1e:	ff 73 08             	pushl  0x8(%ebx)
c0029e21:	e8 1b e9 ff ff       	call   c0028741 <list_next>
c0029e26:	89 43 08             	mov    %eax,0x8(%ebx)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c0029e29:	83 c4 10             	add    $0x10,%esp
c0029e2c:	8b 73 08             	mov    0x8(%ebx),%esi
c0029e2f:	83 ec 0c             	sub    $0xc,%esp
c0029e32:	ff 73 04             	pushl  0x4(%ebx)
c0029e35:	e8 4f e9 ff ff       	call   c0028789 <list_end>
c0029e3a:	83 c4 10             	add    $0x10,%esp
c0029e3d:	39 c6                	cmp    %eax,%esi
c0029e3f:	75 51                	jne    c0029e92 <hash_next+0x84>
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c0029e41:	8b 43 04             	mov    0x4(%ebx),%eax
c0029e44:	8d 50 10             	lea    0x10(%eax),%edx
c0029e47:	89 53 04             	mov    %edx,0x4(%ebx)
c0029e4a:	8b 0b                	mov    (%ebx),%ecx
c0029e4c:	8b 41 04             	mov    0x4(%ecx),%eax
c0029e4f:	c1 e0 04             	shl    $0x4,%eax
c0029e52:	03 41 08             	add    0x8(%ecx),%eax
c0029e55:	39 c2                	cmp    %eax,%edx
c0029e57:	73 32                	jae    c0029e8b <hash_next+0x7d>
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c0029e59:	83 ec 0c             	sub    $0xc,%esp
c0029e5c:	52                   	push   %edx
c0029e5d:	e8 af e8 ff ff       	call   c0028711 <list_begin>
c0029e62:	89 43 08             	mov    %eax,0x8(%ebx)
c0029e65:	83 c4 10             	add    $0x10,%esp
c0029e68:	eb c2                	jmp    c0029e2c <hash_next+0x1e>
  ASSERT (i != NULL);
c0029e6a:	83 ec 0c             	sub    $0xc,%esp
c0029e6d:	68 55 20 03 c0       	push   $0xc0032055
c0029e72:	68 21 01 03 c0       	push   $0xc0030121
c0029e77:	68 9c fd 02 c0       	push   $0xc002fd9c
c0029e7c:	68 dd 00 00 00       	push   $0xdd
c0029e81:	68 2e 20 03 c0       	push   $0xc003202e
c0029e86:	e8 9c e7 ff ff       	call   c0028627 <debug_panic>
          i->elem = NULL;
c0029e8b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  return i->elem;
c0029e92:	8b 43 08             	mov    0x8(%ebx),%eax
}
c0029e95:	83 c4 04             	add    $0x4,%esp
c0029e98:	5b                   	pop    %ebx
c0029e99:	5e                   	pop    %esi
c0029e9a:	c3                   	ret    

c0029e9b <hash_cur>:
  return i->elem;
c0029e9b:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029e9f:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029ea2:	c3                   	ret    

c0029ea3 <hash_size>:
  return h->elem_cnt;
c0029ea3:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029ea7:	8b 00                	mov    (%eax),%eax
}
c0029ea9:	c3                   	ret    

c0029eaa <hash_empty>:
  return h->elem_cnt == 0;
c0029eaa:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029eae:	83 38 00             	cmpl   $0x0,(%eax)
c0029eb1:	0f 94 c0             	sete   %al
}
c0029eb4:	c3                   	ret    

c0029eb5 <hash_bytes>:
{
c0029eb5:	53                   	push   %ebx
c0029eb6:	83 ec 08             	sub    $0x8,%esp
c0029eb9:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0029ebd:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (buf != NULL);
c0029ec1:	85 c9                	test   %ecx,%ecx
c0029ec3:	74 35                	je     c0029efa <hash_bytes+0x45>
  while (size-- > 0)
c0029ec5:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
c0029eca:	85 db                	test   %ebx,%ebx
c0029ecc:	74 27                	je     c0029ef5 <hash_bytes+0x40>
c0029ece:	01 cb                	add    %ecx,%ebx
c0029ed0:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c0029ed5:	89 c2                	mov    %eax,%edx
c0029ed7:	c1 e2 10             	shl    $0x10,%edx
c0029eda:	01 c2                	add    %eax,%edx
c0029edc:	01 d2                	add    %edx,%edx
c0029ede:	01 c2                	add    %eax,%edx
c0029ee0:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029ee3:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029ee6:	01 d2                	add    %edx,%edx
c0029ee8:	01 d0                	add    %edx,%eax
c0029eea:	41                   	inc    %ecx
c0029eeb:	0f b6 51 ff          	movzbl -0x1(%ecx),%edx
c0029eef:	31 d0                	xor    %edx,%eax
  while (size-- > 0)
c0029ef1:	39 d9                	cmp    %ebx,%ecx
c0029ef3:	75 e0                	jne    c0029ed5 <hash_bytes+0x20>
} 
c0029ef5:	83 c4 08             	add    $0x8,%esp
c0029ef8:	5b                   	pop    %ebx
c0029ef9:	c3                   	ret    
  ASSERT (buf != NULL);
c0029efa:	83 ec 0c             	sub    $0xc,%esp
c0029efd:	68 5f 20 03 c0       	push   $0xc003205f
c0029f02:	68 21 01 03 c0       	push   $0xc0030121
c0029f07:	68 90 fd 02 c0       	push   $0xc002fd90
c0029f0c:	68 10 01 00 00       	push   $0x110
c0029f11:	68 2e 20 03 c0       	push   $0xc003202e
c0029f16:	e8 0c e7 ff ff       	call   c0028627 <debug_panic>

c0029f1b <hash_string>:
{
c0029f1b:	53                   	push   %ebx
c0029f1c:	83 ec 08             	sub    $0x8,%esp
c0029f1f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (s != NULL);
c0029f23:	85 db                	test   %ebx,%ebx
c0029f25:	74 36                	je     c0029f5d <hash_string+0x42>
  while (*s != '\0')
c0029f27:	8a 0b                	mov    (%ebx),%cl
c0029f29:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
c0029f2e:	84 c9                	test   %cl,%cl
c0029f30:	74 26                	je     c0029f58 <hash_string+0x3d>
c0029f32:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
    hash = (hash * FNV_32_PRIME) ^ *s++;
c0029f37:	89 c2                	mov    %eax,%edx
c0029f39:	c1 e2 10             	shl    $0x10,%edx
c0029f3c:	01 c2                	add    %eax,%edx
c0029f3e:	01 d2                	add    %edx,%edx
c0029f40:	01 c2                	add    %eax,%edx
c0029f42:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029f45:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029f48:	01 d2                	add    %edx,%edx
c0029f4a:	01 d0                	add    %edx,%eax
c0029f4c:	43                   	inc    %ebx
c0029f4d:	0f b6 c9             	movzbl %cl,%ecx
c0029f50:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c0029f52:	8a 0b                	mov    (%ebx),%cl
c0029f54:	84 c9                	test   %cl,%cl
c0029f56:	75 df                	jne    c0029f37 <hash_string+0x1c>
}
c0029f58:	83 c4 08             	add    $0x8,%esp
c0029f5b:	5b                   	pop    %ebx
c0029f5c:	c3                   	ret    
  ASSERT (s != NULL);
c0029f5d:	83 ec 0c             	sub    $0xc,%esp
c0029f60:	68 eb 1b 03 c0       	push   $0xc0031beb
c0029f65:	68 21 01 03 c0       	push   $0xc0030121
c0029f6a:	68 84 fd 02 c0       	push   $0xc002fd84
c0029f6f:	68 20 01 00 00       	push   $0x120
c0029f74:	68 2e 20 03 c0       	push   $0xc003202e
c0029f79:	e8 a9 e6 ff ff       	call   c0028627 <debug_panic>

c0029f7e <hash_int>:
{
c0029f7e:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c0029f81:	6a 04                	push   $0x4
c0029f83:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0029f87:	50                   	push   %eax
c0029f88:	e8 28 ff ff ff       	call   c0029eb5 <hash_bytes>
}
c0029f8d:	83 c4 1c             	add    $0x1c,%esp
c0029f90:	c3                   	ret    

c0029f91 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c0029f91:	53                   	push   %ebx
c0029f92:	83 ec 08             	sub    $0x8,%esp
c0029f95:	89 c3                	mov    %eax,%ebx
  return (intr_context ()
c0029f97:	e8 86 7c ff ff       	call   c0021c22 <intr_context>
          || lock_held_by_current_thread (&console_lock));
c0029f9c:	84 c0                	test   %al,%al
c0029f9e:	75 09                	jne    c0029fa9 <putchar_have_lock+0x18>
          || !use_console_lock
c0029fa0:	80 3d 2c ce 03 c0 00 	cmpb   $0x0,0xc003ce2c
c0029fa7:	75 27                	jne    c0029fd0 <putchar_have_lock+0x3f>
  ASSERT (console_locked_by_current_thread ());
  write_cnt++;
c0029fa9:	83 05 20 ce 03 c0 01 	addl   $0x1,0xc003ce20
c0029fb0:	83 15 24 ce 03 c0 00 	adcl   $0x0,0xc003ce24
  serial_putc (c);
c0029fb7:	0f b6 db             	movzbl %bl,%ebx
c0029fba:	83 ec 0c             	sub    $0xc,%esp
c0029fbd:	53                   	push   %ebx
c0029fbe:	e8 34 aa ff ff       	call   c00249f7 <serial_putc>
  vga_putc (c);
c0029fc3:	89 1c 24             	mov    %ebx,(%esp)
c0029fc6:	e8 7e a6 ff ff       	call   c0024649 <vga_putc>
}
c0029fcb:	83 c4 18             	add    $0x18,%esp
c0029fce:	5b                   	pop    %ebx
c0029fcf:	c3                   	ret    
          || lock_held_by_current_thread (&console_lock));
c0029fd0:	83 ec 0c             	sub    $0xc,%esp
c0029fd3:	68 40 ce 03 c0       	push   $0xc003ce40
c0029fd8:	e8 62 8e ff ff       	call   c0022e3f <lock_held_by_current_thread>
  ASSERT (console_locked_by_current_thread ());
c0029fdd:	83 c4 10             	add    $0x10,%esp
c0029fe0:	84 c0                	test   %al,%al
c0029fe2:	75 c5                	jne    c0029fa9 <putchar_have_lock+0x18>
c0029fe4:	83 ec 0c             	sub    $0xc,%esp
c0029fe7:	68 6c 20 03 c0       	push   $0xc003206c
c0029fec:	68 21 01 03 c0       	push   $0xc0030121
c0029ff1:	68 c8 fd 02 c0       	push   $0xc002fdc8
c0029ff6:	68 bb 00 00 00       	push   $0xbb
c0029ffb:	68 b1 20 03 c0       	push   $0xc00320b1
c002a000:	e8 22 e6 ff ff       	call   c0028627 <debug_panic>

c002a005 <vprintf_helper>:
{
c002a005:	83 ec 0c             	sub    $0xc,%esp
c002a008:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c002a00c:	ff 00                	incl   (%eax)
  putchar_have_lock (c);
c002a00e:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002a013:	e8 79 ff ff ff       	call   c0029f91 <putchar_have_lock>
}
c002a018:	83 c4 0c             	add    $0xc,%esp
c002a01b:	c3                   	ret    

c002a01c <acquire_console>:
{
c002a01c:	83 ec 0c             	sub    $0xc,%esp
  if (!intr_context () && use_console_lock) 
c002a01f:	e8 fe 7b ff ff       	call   c0021c22 <intr_context>
c002a024:	84 c0                	test   %al,%al
c002a026:	75 09                	jne    c002a031 <acquire_console+0x15>
c002a028:	80 3d 2c ce 03 c0 00 	cmpb   $0x0,0xc003ce2c
c002a02f:	75 04                	jne    c002a035 <acquire_console+0x19>
}
c002a031:	83 c4 0c             	add    $0xc,%esp
c002a034:	c3                   	ret    
      if (lock_held_by_current_thread (&console_lock)) 
c002a035:	83 ec 0c             	sub    $0xc,%esp
c002a038:	68 40 ce 03 c0       	push   $0xc003ce40
c002a03d:	e8 fd 8d ff ff       	call   c0022e3f <lock_held_by_current_thread>
c002a042:	83 c4 10             	add    $0x10,%esp
c002a045:	84 c0                	test   %al,%al
c002a047:	74 08                	je     c002a051 <acquire_console+0x35>
        console_lock_depth++; 
c002a049:	ff 05 28 ce 03 c0    	incl   0xc003ce28
c002a04f:	eb e0                	jmp    c002a031 <acquire_console+0x15>
        lock_acquire (&console_lock); 
c002a051:	83 ec 0c             	sub    $0xc,%esp
c002a054:	68 40 ce 03 c0       	push   $0xc003ce40
c002a059:	e8 1f 8e ff ff       	call   c0022e7d <lock_acquire>
c002a05e:	83 c4 10             	add    $0x10,%esp
}
c002a061:	eb ce                	jmp    c002a031 <acquire_console+0x15>

c002a063 <release_console>:
{
c002a063:	83 ec 0c             	sub    $0xc,%esp
  if (!intr_context () && use_console_lock) 
c002a066:	e8 b7 7b ff ff       	call   c0021c22 <intr_context>
c002a06b:	84 c0                	test   %al,%al
c002a06d:	75 18                	jne    c002a087 <release_console+0x24>
c002a06f:	80 3d 2c ce 03 c0 00 	cmpb   $0x0,0xc003ce2c
c002a076:	74 0f                	je     c002a087 <release_console+0x24>
      if (console_lock_depth > 0)
c002a078:	a1 28 ce 03 c0       	mov    0xc003ce28,%eax
c002a07d:	85 c0                	test   %eax,%eax
c002a07f:	7e 0a                	jle    c002a08b <release_console+0x28>
        console_lock_depth--;
c002a081:	48                   	dec    %eax
c002a082:	a3 28 ce 03 c0       	mov    %eax,0xc003ce28
}
c002a087:	83 c4 0c             	add    $0xc,%esp
c002a08a:	c3                   	ret    
        lock_release (&console_lock); 
c002a08b:	83 ec 0c             	sub    $0xc,%esp
c002a08e:	68 40 ce 03 c0       	push   $0xc003ce40
c002a093:	e8 82 8f ff ff       	call   c002301a <lock_release>
c002a098:	83 c4 10             	add    $0x10,%esp
}
c002a09b:	eb ea                	jmp    c002a087 <release_console+0x24>

c002a09d <console_init>:
{
c002a09d:	83 ec 18             	sub    $0x18,%esp
  lock_init (&console_lock);
c002a0a0:	68 40 ce 03 c0       	push   $0xc003ce40
c002a0a5:	e8 5f 8c ff ff       	call   c0022d09 <lock_init>
  use_console_lock = true;
c002a0aa:	c6 05 2c ce 03 c0 01 	movb   $0x1,0xc003ce2c
}
c002a0b1:	83 c4 1c             	add    $0x1c,%esp
c002a0b4:	c3                   	ret    

c002a0b5 <console_panic>:
  use_console_lock = false;
c002a0b5:	c6 05 2c ce 03 c0 00 	movb   $0x0,0xc003ce2c
c002a0bc:	c3                   	ret    

c002a0bd <console_print_stats>:
{
c002a0bd:	83 ec 10             	sub    $0x10,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002a0c0:	ff 35 24 ce 03 c0    	pushl  0xc003ce24
c002a0c6:	ff 35 20 ce 03 c0    	pushl  0xc003ce20
c002a0cc:	68 90 20 03 c0       	push   $0xc0032090
c002a0d1:	e8 a3 ca ff ff       	call   c0026b79 <printf>
}
c002a0d6:	83 c4 1c             	add    $0x1c,%esp
c002a0d9:	c3                   	ret    

c002a0da <vprintf>:
{
c002a0da:	83 ec 1c             	sub    $0x1c,%esp
  int char_cnt = 0;
c002a0dd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002a0e4:	00 
  acquire_console ();
c002a0e5:	e8 32 ff ff ff       	call   c002a01c <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002a0ea:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002a0ee:	50                   	push   %eax
c002a0ef:	68 05 a0 02 c0       	push   $0xc002a005
c002a0f4:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a0f8:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a0fc:	e8 ad ca ff ff       	call   c0026bae <__vprintf>
  release_console ();
c002a101:	e8 5d ff ff ff       	call   c002a063 <release_console>
}
c002a106:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a10a:	83 c4 2c             	add    $0x2c,%esp
c002a10d:	c3                   	ret    

c002a10e <puts>:
{
c002a10e:	53                   	push   %ebx
c002a10f:	83 ec 08             	sub    $0x8,%esp
c002a112:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002a116:	e8 01 ff ff ff       	call   c002a01c <acquire_console>
  while (*s != '\0')
c002a11b:	8a 03                	mov    (%ebx),%al
c002a11d:	84 c0                	test   %al,%al
c002a11f:	74 0f                	je     c002a130 <puts+0x22>
    putchar_have_lock (*s++);
c002a121:	43                   	inc    %ebx
c002a122:	0f b6 c0             	movzbl %al,%eax
c002a125:	e8 67 fe ff ff       	call   c0029f91 <putchar_have_lock>
  while (*s != '\0')
c002a12a:	8a 03                	mov    (%ebx),%al
c002a12c:	84 c0                	test   %al,%al
c002a12e:	75 f1                	jne    c002a121 <puts+0x13>
  putchar_have_lock ('\n');
c002a130:	b8 0a 00 00 00       	mov    $0xa,%eax
c002a135:	e8 57 fe ff ff       	call   c0029f91 <putchar_have_lock>
  release_console ();
c002a13a:	e8 24 ff ff ff       	call   c002a063 <release_console>
}
c002a13f:	b8 00 00 00 00       	mov    $0x0,%eax
c002a144:	83 c4 08             	add    $0x8,%esp
c002a147:	5b                   	pop    %ebx
c002a148:	c3                   	ret    

c002a149 <putbuf>:
{
c002a149:	56                   	push   %esi
c002a14a:	53                   	push   %ebx
c002a14b:	83 ec 04             	sub    $0x4,%esp
c002a14e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002a152:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console ();
c002a156:	e8 c1 fe ff ff       	call   c002a01c <acquire_console>
  while (n-- > 0)
c002a15b:	85 f6                	test   %esi,%esi
c002a15d:	74 10                	je     c002a16f <putbuf+0x26>
c002a15f:	01 de                	add    %ebx,%esi
    putchar_have_lock (*buffer++);
c002a161:	43                   	inc    %ebx
c002a162:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c002a166:	e8 26 fe ff ff       	call   c0029f91 <putchar_have_lock>
  while (n-- > 0)
c002a16b:	39 de                	cmp    %ebx,%esi
c002a16d:	75 f2                	jne    c002a161 <putbuf+0x18>
  release_console ();
c002a16f:	e8 ef fe ff ff       	call   c002a063 <release_console>
}
c002a174:	83 c4 04             	add    $0x4,%esp
c002a177:	5b                   	pop    %ebx
c002a178:	5e                   	pop    %esi
c002a179:	c3                   	ret    

c002a17a <putchar>:
{
c002a17a:	83 ec 0c             	sub    $0xc,%esp
  acquire_console ();
c002a17d:	e8 9a fe ff ff       	call   c002a01c <acquire_console>
  putchar_have_lock (c);
c002a182:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002a187:	e8 05 fe ff ff       	call   c0029f91 <putchar_have_lock>
  release_console ();
c002a18c:	e8 d2 fe ff ff       	call   c002a063 <release_console>
}
c002a191:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a195:	83 c4 0c             	add    $0xc,%esp
c002a198:	c3                   	ret    

c002a199 <install_page>:
   with palloc_get_page().
   Returns true on success, false if UPAGE is already mapped or
   if memory allocation fails. */
static bool
install_page (void *upage, void *kpage, bool writable)
{
c002a199:	55                   	push   %ebp
c002a19a:	57                   	push   %edi
c002a19b:	56                   	push   %esi
c002a19c:	53                   	push   %ebx
c002a19d:	83 ec 0c             	sub    $0xc,%esp
c002a1a0:	89 c6                	mov    %eax,%esi
c002a1a2:	89 d5                	mov    %edx,%ebp
c002a1a4:	89 cf                	mov    %ecx,%edi
  struct thread *t = thread_current ();
c002a1a6:	e8 11 6b ff ff       	call   c0020cbc <thread_current>
c002a1ab:	89 c3                	mov    %eax,%ebx

  /* Verify that there's not already a page at that virtual
     address, then map our page there. */
  return (pagedir_get_page (t->pagedir, upage) == NULL
c002a1ad:	83 ec 08             	sub    $0x8,%esp
c002a1b0:	56                   	push   %esi
c002a1b1:	ff 70 64             	pushl  0x64(%eax)
c002a1b4:	e8 f6 0d 00 00       	call   c002afaf <pagedir_get_page>
          && pagedir_set_page (t->pagedir, upage, kpage, writable));
c002a1b9:	83 c4 10             	add    $0x10,%esp
c002a1bc:	85 c0                	test   %eax,%eax
c002a1be:	74 10                	je     c002a1d0 <install_page+0x37>
c002a1c0:	b8 00 00 00 00       	mov    $0x0,%eax
c002a1c5:	83 e0 01             	and    $0x1,%eax
}
c002a1c8:	83 c4 0c             	add    $0xc,%esp
c002a1cb:	5b                   	pop    %ebx
c002a1cc:	5e                   	pop    %esi
c002a1cd:	5f                   	pop    %edi
c002a1ce:	5d                   	pop    %ebp
c002a1cf:	c3                   	ret    
          && pagedir_set_page (t->pagedir, upage, kpage, writable));
c002a1d0:	89 f8                	mov    %edi,%eax
c002a1d2:	0f b6 f8             	movzbl %al,%edi
c002a1d5:	57                   	push   %edi
c002a1d6:	55                   	push   %ebp
c002a1d7:	56                   	push   %esi
c002a1d8:	ff 73 64             	pushl  0x64(%ebx)
c002a1db:	e8 5a 0c 00 00       	call   c002ae3a <pagedir_set_page>
c002a1e0:	0f b6 c0             	movzbl %al,%eax
c002a1e3:	83 c4 10             	add    $0x10,%esp
c002a1e6:	eb dd                	jmp    c002a1c5 <install_page+0x2c>

c002a1e8 <process_execute>:
{
c002a1e8:	55                   	push   %ebp
c002a1e9:	57                   	push   %edi
c002a1ea:	56                   	push   %esi
c002a1eb:	53                   	push   %ebx
c002a1ec:	83 ec 28             	sub    $0x28,%esp
c002a1ef:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
	fn_copy = palloc_get_page (0);
c002a1f3:	6a 00                	push   $0x0
c002a1f5:	e8 5e 94 ff ff       	call   c0023658 <palloc_get_page>
	if (fn_copy == NULL) {
c002a1fa:	83 c4 10             	add    $0x10,%esp
c002a1fd:	85 c0                	test   %eax,%eax
c002a1ff:	0f 84 a4 00 00 00    	je     c002a2a9 <process_execute+0xc1>
c002a205:	89 c6                	mov    %eax,%esi
	strlcpy (fn_copy, file_name, PGSIZE);
c002a207:	83 ec 04             	sub    $0x4,%esp
c002a20a:	68 00 10 00 00       	push   $0x1000
c002a20f:	53                   	push   %ebx
c002a210:	50                   	push   %eax
c002a211:	e8 0b db ff ff       	call   c0027d21 <strlcpy>
	char *fn_cp = malloc(strlen(file_name)+1);
c002a216:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002a21b:	89 df                	mov    %ebx,%edi
c002a21d:	b0 00                	mov    $0x0,%al
c002a21f:	f2 ae                	repnz scas %es:(%edi),%al
c002a221:	f7 d1                	not    %ecx
c002a223:	89 0c 24             	mov    %ecx,(%esp)
c002a226:	e8 a3 97 ff ff       	call   c00239ce <malloc>
c002a22b:	89 c5                	mov    %eax,%ebp
	strlcpy (fn_cp, file_name, strlen(file_name)+1);
c002a22d:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002a232:	89 df                	mov    %ebx,%edi
c002a234:	b0 00                	mov    $0x0,%al
c002a236:	f2 ae                	repnz scas %es:(%edi),%al
c002a238:	f7 d1                	not    %ecx
c002a23a:	83 c4 0c             	add    $0xc,%esp
c002a23d:	51                   	push   %ecx
c002a23e:	53                   	push   %ebx
c002a23f:	55                   	push   %ebp
c002a240:	e8 dc da ff ff       	call   c0027d21 <strlcpy>
	token = strtok_r(fn_cp, " ", &save_ptr);
c002a245:	83 c4 0c             	add    $0xc,%esp
c002a248:	8d 44 24 10          	lea    0x10(%esp),%eax
c002a24c:	50                   	push   %eax
c002a24d:	68 3a 1b 03 c0       	push   $0xc0031b3a
c002a252:	55                   	push   %ebp
c002a253:	e8 ef d8 ff ff       	call   c0027b47 <strtok_r>
c002a258:	89 c3                	mov    %eax,%ebx
  struct thread *current_thread = thread_current();
c002a25a:	e8 5d 6a ff ff       	call   c0020cbc <thread_current>
c002a25f:	89 c5                	mov    %eax,%ebp
	tid = thread_create (token, PRI_DEFAULT, start_process, fn_copy);
c002a261:	56                   	push   %esi
c002a262:	68 48 a4 02 c0       	push   $0xc002a448
c002a267:	6a 1f                	push   $0x1f
c002a269:	53                   	push   %ebx
c002a26a:	e8 04 73 ff ff       	call   c0021573 <thread_create>
c002a26f:	89 c3                	mov    %eax,%ebx
	if (tid == TID_ERROR) {
c002a271:	83 c4 20             	add    $0x20,%esp
c002a274:	83 f8 ff             	cmp    $0xffffffff,%eax
c002a277:	74 22                	je     c002a29b <process_execute+0xb3>
		sema_down(&current_thread->load_sema);
c002a279:	83 ec 0c             	sub    $0xc,%esp
c002a27c:	8d 45 78             	lea    0x78(%ebp),%eax
c002a27f:	50                   	push   %eax
c002a280:	e8 18 88 ff ff       	call   c0022a9d <sema_down>
		if (!current_thread->load_success)
c002a285:	83 c4 10             	add    $0x10,%esp
c002a288:	80 bd a0 00 00 00 00 	cmpb   $0x0,0xa0(%ebp)
c002a28f:	74 1f                	je     c002a2b0 <process_execute+0xc8>
}
c002a291:	89 d8                	mov    %ebx,%eax
c002a293:	83 c4 1c             	add    $0x1c,%esp
c002a296:	5b                   	pop    %ebx
c002a297:	5e                   	pop    %esi
c002a298:	5f                   	pop    %edi
c002a299:	5d                   	pop    %ebp
c002a29a:	c3                   	ret    
		palloc_free_page (fn_copy);
c002a29b:	83 ec 0c             	sub    $0xc,%esp
c002a29e:	56                   	push   %esi
c002a29f:	e8 de 94 ff ff       	call   c0023782 <palloc_free_page>
c002a2a4:	83 c4 10             	add    $0x10,%esp
c002a2a7:	eb e8                	jmp    c002a291 <process_execute+0xa9>
		return TID_ERROR;
c002a2a9:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002a2ae:	eb e1                	jmp    c002a291 <process_execute+0xa9>
			return -1;
c002a2b0:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002a2b5:	eb da                	jmp    c002a291 <process_execute+0xa9>

c002a2b7 <process_wait>:
{
c002a2b7:	56                   	push   %esi
c002a2b8:	53                   	push   %ebx
c002a2b9:	83 ec 04             	sub    $0x4,%esp
	struct thread *t = thread_current ();
c002a2bc:	e8 fb 69 ff ff       	call   c0020cbc <thread_current>
c002a2c1:	89 c6                	mov    %eax,%esi
	struct child_process *ch = get_child_by_tid(&t->children, child_tid);
c002a2c3:	83 ec 08             	sub    $0x8,%esp
c002a2c6:	ff 74 24 18          	pushl  0x18(%esp)
c002a2ca:	8d 80 a8 00 00 00    	lea    0xa8(%eax),%eax
c002a2d0:	50                   	push   %eax
c002a2d1:	e8 32 74 ff ff       	call   c0021708 <get_child_by_tid>
	if (ch == NULL) {
c002a2d6:	83 c4 10             	add    $0x10,%esp
c002a2d9:	85 c0                	test   %eax,%eax
c002a2db:	74 3b                	je     c002a318 <process_wait+0x61>
c002a2dd:	89 c3                	mov    %eax,%ebx
	if (ch->waited) {
c002a2df:	80 78 09 00          	cmpb   $0x0,0x9(%eax)
c002a2e3:	75 3a                	jne    c002a31f <process_wait+0x68>
	ch->waited = true;
c002a2e5:	c6 40 09 01          	movb   $0x1,0x9(%eax)
	t->wait_tid = ch->tid;
c002a2e9:	8b 00                	mov    (%eax),%eax
c002a2eb:	89 46 74             	mov    %eax,0x74(%esi)
	if (!ch->done)
c002a2ee:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
c002a2f2:	74 10                	je     c002a304 <process_wait+0x4d>
	t->wait_tid = -1;
c002a2f4:	c7 46 74 ff ff ff ff 	movl   $0xffffffff,0x74(%esi)
	return ch->ret_status;
c002a2fb:	8b 43 04             	mov    0x4(%ebx),%eax
}
c002a2fe:	83 c4 04             	add    $0x4,%esp
c002a301:	5b                   	pop    %ebx
c002a302:	5e                   	pop    %esi
c002a303:	c3                   	ret    
		sema_down(&t->wait_sema);
c002a304:	83 ec 0c             	sub    $0xc,%esp
c002a307:	8d 86 8c 00 00 00    	lea    0x8c(%esi),%eax
c002a30d:	50                   	push   %eax
c002a30e:	e8 8a 87 ff ff       	call   c0022a9d <sema_down>
c002a313:	83 c4 10             	add    $0x10,%esp
c002a316:	eb dc                	jmp    c002a2f4 <process_wait+0x3d>
		return -1;
c002a318:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a31d:	eb df                	jmp    c002a2fe <process_wait+0x47>
		return -1;
c002a31f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a324:	eb d8                	jmp    c002a2fe <process_wait+0x47>

c002a326 <process_exit>:
{
c002a326:	55                   	push   %ebp
c002a327:	57                   	push   %edi
c002a328:	56                   	push   %esi
c002a329:	53                   	push   %ebx
c002a32a:	83 ec 0c             	sub    $0xc,%esp
	struct thread *cur = thread_current ();
c002a32d:	e8 8a 69 ff ff       	call   c0020cbc <thread_current>
c002a332:	89 c6                	mov    %eax,%esi
  printf("%s: exit(%d)\n", cur->name, cur->ret_status);
c002a334:	83 ec 04             	sub    $0x4,%esp
c002a337:	ff 70 68             	pushl  0x68(%eax)
c002a33a:	8d 40 0c             	lea    0xc(%eax),%eax
c002a33d:	50                   	push   %eax
c002a33e:	68 cc 20 03 c0       	push   $0xc00320cc
c002a343:	e8 31 c8 ff ff       	call   c0026b79 <printf>
	if (!lock_held_by_current_thread(&filesys_lock))
c002a348:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002a34f:	e8 eb 8a ff ff       	call   c0022e3f <lock_held_by_current_thread>
c002a354:	83 c4 10             	add    $0x10,%esp
c002a357:	84 c0                	test   %al,%al
c002a359:	74 19                	je     c002a374 <process_exit+0x4e>
	file_close(cur->self);
c002a35b:	83 ec 0c             	sub    $0xc,%esp
c002a35e:	ff b6 b8 00 00 00    	pushl  0xb8(%esi)
c002a364:	e8 a9 26 00 00       	call   c002ca12 <file_close>
	while (!list_empty(&cur->files)) {
c002a369:	83 c4 10             	add    $0x10,%esp
c002a36c:	8d be bc 00 00 00    	lea    0xbc(%esi),%edi
c002a372:	eb 3e                	jmp    c002a3b2 <process_exit+0x8c>
		lock_acquire(&filesys_lock);
c002a374:	83 ec 0c             	sub    $0xc,%esp
c002a377:	68 60 55 04 c0       	push   $0xc0045560
c002a37c:	e8 fc 8a ff ff       	call   c0022e7d <lock_acquire>
c002a381:	83 c4 10             	add    $0x10,%esp
c002a384:	eb d5                	jmp    c002a35b <process_exit+0x35>
		entry = list_entry (list_pop_front(&cur->files), struct fd_t, elem);
c002a386:	83 ec 0c             	sub    $0xc,%esp
c002a389:	57                   	push   %edi
c002a38a:	e8 95 e8 ff ff       	call   c0028c24 <list_pop_front>
c002a38f:	89 c3                	mov    %eax,%ebx
		file_close(entry->ptr);
c002a391:	83 c4 04             	add    $0x4,%esp
c002a394:	ff 70 f4             	pushl  -0xc(%eax)
c002a397:	e8 76 26 00 00       	call   c002ca12 <file_close>
		list_remove(&entry->elem);
c002a39c:	8d 6b f4             	lea    -0xc(%ebx),%ebp
c002a39f:	89 1c 24             	mov    %ebx,(%esp)
c002a3a2:	e8 90 e7 ff ff       	call   c0028b37 <list_remove>
		free(entry);
c002a3a7:	89 2c 24             	mov    %ebp,(%esp)
c002a3aa:	e8 c2 97 ff ff       	call   c0023b71 <free>
c002a3af:	83 c4 10             	add    $0x10,%esp
	while (!list_empty(&cur->files)) {
c002a3b2:	83 ec 0c             	sub    $0xc,%esp
c002a3b5:	57                   	push   %edi
c002a3b6:	e8 07 e8 ff ff       	call   c0028bc2 <list_empty>
c002a3bb:	83 c4 10             	add    $0x10,%esp
c002a3be:	84 c0                	test   %al,%al
c002a3c0:	74 c4                	je     c002a386 <process_exit+0x60>
	lock_release(&filesys_lock);
c002a3c2:	83 ec 0c             	sub    $0xc,%esp
c002a3c5:	68 60 55 04 c0       	push   $0xc0045560
c002a3ca:	e8 4b 8c ff ff       	call   c002301a <lock_release>
	while (!list_empty(&cur->children)) {
c002a3cf:	83 c4 10             	add    $0x10,%esp
c002a3d2:	8d 9e a8 00 00 00    	lea    0xa8(%esi),%ebx
c002a3d8:	eb 17                	jmp    c002a3f1 <process_exit+0xcb>
		struct child_process *entry = list_entry(list_pop_front(&cur->children), struct child_process, elem);
c002a3da:	83 ec 0c             	sub    $0xc,%esp
c002a3dd:	53                   	push   %ebx
c002a3de:	e8 41 e8 ff ff       	call   c0028c24 <list_pop_front>
		free(entry);
c002a3e3:	83 e8 0c             	sub    $0xc,%eax
c002a3e6:	89 04 24             	mov    %eax,(%esp)
c002a3e9:	e8 83 97 ff ff       	call   c0023b71 <free>
c002a3ee:	83 c4 10             	add    $0x10,%esp
	while (!list_empty(&cur->children)) {
c002a3f1:	83 ec 0c             	sub    $0xc,%esp
c002a3f4:	53                   	push   %ebx
c002a3f5:	e8 c8 e7 ff ff       	call   c0028bc2 <list_empty>
c002a3fa:	83 c4 10             	add    $0x10,%esp
c002a3fd:	84 c0                	test   %al,%al
c002a3ff:	74 d9                	je     c002a3da <process_exit+0xb4>
  pd = cur->pagedir;
c002a401:	8b 5e 64             	mov    0x64(%esi),%ebx
  if (pd != NULL) 
c002a404:	85 db                	test   %ebx,%ebx
c002a406:	74 1c                	je     c002a424 <process_exit+0xfe>
      cur->pagedir = NULL;
c002a408:	c7 46 64 00 00 00 00 	movl   $0x0,0x64(%esi)
      pagedir_activate (NULL);
c002a40f:	83 ec 0c             	sub    $0xc,%esp
c002a412:	6a 00                	push   $0x0
c002a414:	e8 84 0c 00 00       	call   c002b09d <pagedir_activate>
      pagedir_destroy (pd);
c002a419:	89 1c 24             	mov    %ebx,(%esp)
c002a41c:	e8 fa 08 00 00       	call   c002ad1b <pagedir_destroy>
c002a421:	83 c4 10             	add    $0x10,%esp
}
c002a424:	83 c4 0c             	add    $0xc,%esp
c002a427:	5b                   	pop    %ebx
c002a428:	5e                   	pop    %esi
c002a429:	5f                   	pop    %edi
c002a42a:	5d                   	pop    %ebp
c002a42b:	c3                   	ret    

c002a42c <process_activate>:
{
c002a42c:	83 ec 0c             	sub    $0xc,%esp
  struct thread *t = thread_current ();
c002a42f:	e8 88 68 ff ff       	call   c0020cbc <thread_current>
  pagedir_activate (t->pagedir);
c002a434:	83 ec 0c             	sub    $0xc,%esp
c002a437:	ff 70 64             	pushl  0x64(%eax)
c002a43a:	e8 5e 0c 00 00       	call   c002b09d <pagedir_activate>
  tss_update ();
c002a43f:	e8 52 1c 00 00       	call   c002c096 <tss_update>
}
c002a444:	83 c4 1c             	add    $0x1c,%esp
c002a447:	c3                   	ret    

c002a448 <start_process>:
{
c002a448:	55                   	push   %ebp
c002a449:	57                   	push   %edi
c002a44a:	56                   	push   %esi
c002a44b:	53                   	push   %ebx
c002a44c:	81 ec ec 00 00 00    	sub    $0xec,%esp
  memset (&if_, 0, sizeof if_);
c002a452:	8d 94 24 90 00 00 00 	lea    0x90(%esp),%edx
c002a459:	b9 14 00 00 00       	mov    $0x14,%ecx
c002a45e:	b8 00 00 00 00       	mov    $0x0,%eax
c002a463:	89 d7                	mov    %edx,%edi
c002a465:	f3 ab                	rep stos %eax,%es:(%edi)
  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
c002a467:	66 c7 84 24 dc 00 00 	movw   $0x23,0xdc(%esp)
c002a46e:	00 23 00 
c002a471:	66 c7 84 24 bc 00 00 	movw   $0x23,0xbc(%esp)
c002a478:	00 23 00 
c002a47b:	66 c7 84 24 b8 00 00 	movw   $0x23,0xb8(%esp)
c002a482:	00 23 00 
c002a485:	66 c7 84 24 b4 00 00 	movw   $0x23,0xb4(%esp)
c002a48c:	00 23 00 
c002a48f:	66 c7 84 24 b0 00 00 	movw   $0x23,0xb0(%esp)
c002a496:	00 23 00 
  if_.cs = SEL_UCSEG;
c002a499:	66 c7 84 24 d0 00 00 	movw   $0x1b,0xd0(%esp)
c002a4a0:	00 1b 00 
  if_.eflags = FLAG_IF | FLAG_MBS;
c002a4a3:	c7 84 24 d4 00 00 00 	movl   $0x202,0xd4(%esp)
c002a4aa:	02 02 00 00 
	char *fn_cp = malloc(strlen(file_name) + 1);
c002a4ae:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002a4b3:	b3 00                	mov    $0x0,%bl
c002a4b5:	89 f1                	mov    %esi,%ecx
c002a4b7:	8b bc 24 00 01 00 00 	mov    0x100(%esp),%edi
c002a4be:	88 d8                	mov    %bl,%al
c002a4c0:	f2 ae                	repnz scas %es:(%edi),%al
c002a4c2:	f7 d1                	not    %ecx
c002a4c4:	83 ec 0c             	sub    $0xc,%esp
c002a4c7:	51                   	push   %ecx
c002a4c8:	e8 01 95 ff ff       	call   c00239ce <malloc>
c002a4cd:	89 c5                	mov    %eax,%ebp
	strlcpy (fn_cp, file_name, strlen(file_name) + 1);
c002a4cf:	89 f1                	mov    %esi,%ecx
c002a4d1:	8b bc 24 10 01 00 00 	mov    0x110(%esp),%edi
c002a4d8:	88 d8                	mov    %bl,%al
c002a4da:	f2 ae                	repnz scas %es:(%edi),%al
c002a4dc:	f7 d1                	not    %ecx
c002a4de:	83 c4 0c             	add    $0xc,%esp
c002a4e1:	51                   	push   %ecx
c002a4e2:	ff b4 24 08 01 00 00 	pushl  0x108(%esp)
c002a4e9:	55                   	push   %ebp
c002a4ea:	e8 32 d8 ff ff       	call   c0027d21 <strlcpy>
	token = strtok_r(fn_cp, " ", &save_ptr);
c002a4ef:	83 c4 0c             	add    $0xc,%esp
c002a4f2:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
c002a4f9:	50                   	push   %eax
c002a4fa:	68 3a 1b 03 c0       	push   $0xc0031b3a
c002a4ff:	55                   	push   %ebp
c002a500:	e8 42 d6 ff ff       	call   c0027b47 <strtok_r>
c002a505:	89 c6                	mov    %eax,%esi
  struct thread *t = thread_current ();
c002a507:	e8 b0 67 ff ff       	call   c0020cbc <thread_current>
c002a50c:	89 c3                	mov    %eax,%ebx
	lock_acquire(&filesys_lock);
c002a50e:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002a515:	e8 63 89 ff ff       	call   c0022e7d <lock_acquire>
  t->pagedir = pagedir_create ();
c002a51a:	e8 d4 07 00 00       	call   c002acf3 <pagedir_create>
c002a51f:	89 43 64             	mov    %eax,0x64(%ebx)
  if (t->pagedir == NULL) 
c002a522:	83 c4 10             	add    $0x10,%esp
c002a525:	85 c0                	test   %eax,%eax
c002a527:	0f 84 ea 04 00 00    	je     c002aa17 <start_process+0x5cf>
  process_activate ();
c002a52d:	e8 fa fe ff ff       	call   c002a42c <process_activate>
  file = filesys_open (file_name);
c002a532:	83 ec 0c             	sub    $0xc,%esp
c002a535:	56                   	push   %esi
c002a536:	e8 e7 1e 00 00       	call   c002c422 <filesys_open>
c002a53b:	89 c3                	mov    %eax,%ebx
  if (file == NULL)
c002a53d:	83 c4 10             	add    $0x10,%esp
c002a540:	85 c0                	test   %eax,%eax
c002a542:	0f 84 e9 00 00 00    	je     c002a631 <start_process+0x1e9>
	file_deny_write(file);
c002a548:	83 ec 0c             	sub    $0xc,%esp
c002a54b:	50                   	push   %eax
c002a54c:	e8 2f 24 00 00       	call   c002c980 <file_deny_write>
  if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
c002a551:	83 c4 0c             	add    $0xc,%esp
c002a554:	6a 34                	push   $0x34
c002a556:	8d 44 24 60          	lea    0x60(%esp),%eax
c002a55a:	50                   	push   %eax
c002a55b:	53                   	push   %ebx
c002a55c:	e8 9f 23 00 00       	call   c002c900 <file_read>
c002a561:	83 c4 10             	add    $0x10,%esp
c002a564:	83 f8 34             	cmp    $0x34,%eax
c002a567:	75 2d                	jne    c002a596 <start_process+0x14e>
      || memcmp (ehdr.e_ident, "\177ELF\1\1\1", 7)
c002a569:	83 ec 04             	sub    $0x4,%esp
c002a56c:	6a 07                	push   $0x7
c002a56e:	68 f1 20 03 c0       	push   $0xc00320f1
c002a573:	8d 44 24 64          	lea    0x64(%esp),%eax
c002a577:	50                   	push   %eax
c002a578:	e8 15 d4 ff ff       	call   c0027992 <memcmp>
c002a57d:	83 c4 10             	add    $0x10,%esp
c002a580:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002a584:	85 c0                	test   %eax,%eax
c002a586:	75 0e                	jne    c002a596 <start_process+0x14e>
      || ehdr.e_machine != 3
c002a588:	81 7c 24 68 02 00 03 	cmpl   $0x30002,0x68(%esp)
c002a58f:	00 
c002a590:	0f 84 b6 00 00 00    	je     c002a64c <start_process+0x204>
      printf ("load: %s: error loading executable\n", file_name);
c002a596:	83 ec 08             	sub    $0x8,%esp
c002a599:	56                   	push   %esi
c002a59a:	68 14 21 03 c0       	push   $0xc0032114
c002a59f:	e8 d5 c5 ff ff       	call   c0026b79 <printf>
c002a5a4:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002a5a7:	c6 44 24 0c 00       	movb   $0x0,0xc(%esp)
	lock_release(&filesys_lock);
c002a5ac:	83 ec 0c             	sub    $0xc,%esp
c002a5af:	68 60 55 04 c0       	push   $0xc0045560
c002a5b4:	e8 61 8a ff ff       	call   c002301a <lock_release>
  for (; token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
c002a5b9:	83 c4 10             	add    $0x10,%esp
c002a5bc:	85 f6                	test   %esi,%esi
c002a5be:	0f 84 5d 04 00 00    	je     c002aa21 <start_process+0x5d9>
c002a5c4:	bb 00 00 00 00       	mov    $0x0,%ebx
c002a5c9:	8d b4 24 8c 00 00 00 	lea    0x8c(%esp),%esi
	  argc++;
c002a5d0:	43                   	inc    %ebx
  for (; token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
c002a5d1:	83 ec 04             	sub    $0x4,%esp
c002a5d4:	56                   	push   %esi
c002a5d5:	68 3a 1b 03 c0       	push   $0xc0031b3a
c002a5da:	6a 00                	push   $0x0
c002a5dc:	e8 66 d5 ff ff       	call   c0027b47 <strtok_r>
c002a5e1:	83 c4 10             	add    $0x10,%esp
c002a5e4:	85 c0                	test   %eax,%eax
c002a5e6:	75 e8                	jne    c002a5d0 <start_process+0x188>
  free(fn_cp);
c002a5e8:	83 ec 0c             	sub    $0xc,%esp
c002a5eb:	55                   	push   %ebp
c002a5ec:	e8 80 95 ff ff       	call   c0023b71 <free>
	int *argv = calloc(argc, sizeof(int));
c002a5f1:	83 c4 08             	add    $0x8,%esp
c002a5f4:	6a 04                	push   $0x4
c002a5f6:	53                   	push   %ebx
c002a5f7:	e8 2b 95 ff ff       	call   c0023b27 <calloc>
c002a5fc:	89 c5                	mov    %eax,%ebp
	for (token = strtok_r(file_name, " ", &save_ptr); token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
c002a5fe:	83 c4 0c             	add    $0xc,%esp
c002a601:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
c002a608:	50                   	push   %eax
c002a609:	68 3a 1b 03 c0       	push   $0xc0031b3a
c002a60e:	ff b4 24 0c 01 00 00 	pushl  0x10c(%esp)
c002a615:	e8 2d d5 ff ff       	call   c0027b47 <strtok_r>
c002a61a:	89 c6                	mov    %eax,%esi
c002a61c:	83 c4 10             	add    $0x10,%esp
c002a61f:	85 c0                	test   %eax,%eax
c002a621:	0f 84 46 05 00 00    	je     c002ab6d <start_process+0x725>
c002a627:	bb 00 00 00 00       	mov    $0x0,%ebx
c002a62c:	e9 fc 03 00 00       	jmp    c002aa2d <start_process+0x5e5>
      printf ("load: %s: open failed\n", file_name);
c002a631:	83 ec 08             	sub    $0x8,%esp
c002a634:	56                   	push   %esi
c002a635:	68 da 20 03 c0       	push   $0xc00320da
c002a63a:	e8 3a c5 ff ff       	call   c0026b79 <printf>
c002a63f:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002a642:	c6 44 24 0c 00       	movb   $0x0,0xc(%esp)
c002a647:	e9 60 ff ff ff       	jmp    c002a5ac <start_process+0x164>
      || ehdr.e_version != 1
c002a64c:	83 7c 24 6c 01       	cmpl   $0x1,0x6c(%esp)
c002a651:	0f 85 3f ff ff ff    	jne    c002a596 <start_process+0x14e>
      || ehdr.e_phentsize != sizeof (struct Elf32_Phdr)
c002a657:	66 83 bc 24 82 00 00 	cmpw   $0x20,0x82(%esp)
c002a65e:	00 20 
c002a660:	0f 85 30 ff ff ff    	jne    c002a596 <start_process+0x14e>
      || ehdr.e_phnum > 1024) 
c002a666:	66 81 bc 24 84 00 00 	cmpw   $0x400,0x84(%esp)
c002a66d:	00 00 04 
c002a670:	0f 87 20 ff ff ff    	ja     c002a596 <start_process+0x14e>
  file_ofs = ehdr.e_phoff;
c002a676:	8b 44 24 74          	mov    0x74(%esp),%eax
c002a67a:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c002a67e:	89 6c 24 14          	mov    %ebp,0x14(%esp)
c002a682:	89 74 24 18          	mov    %esi,0x18(%esp)
c002a686:	89 5c 24 24          	mov    %ebx,0x24(%esp)
c002a68a:	eb 12                	jmp    c002a69e <start_process+0x256>
      switch (phdr.p_type) 
c002a68c:	83 f8 05             	cmp    $0x5,%eax
c002a68f:	0f 84 99 02 00 00    	je     c002a92e <start_process+0x4e6>
c002a695:	83 44 24 2c 20       	addl   $0x20,0x2c(%esp)
  for (i = 0; i < ehdr.e_phnum; i++) 
c002a69a:	ff 44 24 0c          	incl   0xc(%esp)
c002a69e:	0f b7 84 24 84 00 00 	movzwl 0x84(%esp),%eax
c002a6a5:	00 
c002a6a6:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c002a6aa:	0f 8d f3 02 00 00    	jge    c002a9a3 <start_process+0x55b>
      if (file_ofs < 0 || file_ofs > file_length (file))
c002a6b0:	8b 74 24 2c          	mov    0x2c(%esp),%esi
c002a6b4:	85 f6                	test   %esi,%esi
c002a6b6:	0f 88 3e 02 00 00    	js     c002a8fa <start_process+0x4b2>
c002a6bc:	83 ec 0c             	sub    $0xc,%esp
c002a6bf:	8b 5c 24 30          	mov    0x30(%esp),%ebx
c002a6c3:	53                   	push   %ebx
c002a6c4:	e8 83 23 00 00       	call   c002ca4c <file_length>
c002a6c9:	83 c4 10             	add    $0x10,%esp
c002a6cc:	39 c6                	cmp    %eax,%esi
c002a6ce:	0f 8f 33 02 00 00    	jg     c002a907 <start_process+0x4bf>
      file_seek (file, file_ofs);
c002a6d4:	83 ec 08             	sub    $0x8,%esp
c002a6d7:	56                   	push   %esi
c002a6d8:	53                   	push   %ebx
c002a6d9:	e8 a8 23 00 00       	call   c002ca86 <file_seek>
      if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
c002a6de:	83 c4 0c             	add    $0xc,%esp
c002a6e1:	6a 20                	push   $0x20
c002a6e3:	8d 44 24 40          	lea    0x40(%esp),%eax
c002a6e7:	50                   	push   %eax
c002a6e8:	53                   	push   %ebx
c002a6e9:	e8 12 22 00 00       	call   c002c900 <file_read>
c002a6ee:	83 c4 10             	add    $0x10,%esp
c002a6f1:	83 f8 20             	cmp    $0x20,%eax
c002a6f4:	0f 85 1a 02 00 00    	jne    c002a914 <start_process+0x4cc>
      switch (phdr.p_type) 
c002a6fa:	8b 44 24 38          	mov    0x38(%esp),%eax
c002a6fe:	83 f8 03             	cmp    $0x3,%eax
c002a701:	77 89                	ja     c002a68c <start_process+0x244>
c002a703:	83 f8 02             	cmp    $0x2,%eax
c002a706:	0f 83 15 02 00 00    	jae    c002a921 <start_process+0x4d9>
c002a70c:	83 f8 01             	cmp    $0x1,%eax
c002a70f:	75 84                	jne    c002a695 <start_process+0x24d>
  if ((phdr->p_offset & PGMASK) != (phdr->p_vaddr & PGMASK)) 
c002a711:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
c002a715:	89 d8                	mov    %ebx,%eax
c002a717:	33 44 24 40          	xor    0x40(%esp),%eax
c002a71b:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002a720:	74 12                	je     c002a734 <start_process+0x2ec>
c002a722:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a726:	8b 74 24 18          	mov    0x18(%esp),%esi
  bool success = false;
c002a72a:	c6 44 24 0c 00       	movb   $0x0,0xc(%esp)
c002a72f:	e9 78 fe ff ff       	jmp    c002a5ac <start_process+0x164>
  if (phdr->p_offset > (Elf32_Off) file_length (file)) 
c002a734:	83 ec 0c             	sub    $0xc,%esp
c002a737:	ff 74 24 30          	pushl  0x30(%esp)
c002a73b:	e8 0c 23 00 00       	call   c002ca4c <file_length>
c002a740:	83 c4 10             	add    $0x10,%esp
c002a743:	39 c3                	cmp    %eax,%ebx
c002a745:	0f 87 f0 01 00 00    	ja     c002a93b <start_process+0x4f3>
  if (phdr->p_memsz < phdr->p_filesz) 
c002a74b:	8b 54 24 4c          	mov    0x4c(%esp),%edx
c002a74f:	8b 5c 24 48          	mov    0x48(%esp),%ebx
c002a753:	39 da                	cmp    %ebx,%edx
c002a755:	0f 82 ed 01 00 00    	jb     c002a948 <start_process+0x500>
  if (phdr->p_memsz == 0)
c002a75b:	85 d2                	test   %edx,%edx
c002a75d:	0f 84 f2 01 00 00    	je     c002a955 <start_process+0x50d>
  if (!is_user_vaddr ((void *) phdr->p_vaddr))
c002a763:	8b 44 24 40          	mov    0x40(%esp),%eax
c002a767:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002a76c:	0f 87 f0 01 00 00    	ja     c002a962 <start_process+0x51a>
  if (!is_user_vaddr ((void *) (phdr->p_vaddr + phdr->p_memsz)))
c002a772:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c002a775:	81 f9 ff ff ff bf    	cmp    $0xbfffffff,%ecx
c002a77b:	0f 87 ee 01 00 00    	ja     c002a96f <start_process+0x527>
  if (phdr->p_vaddr + phdr->p_memsz < phdr->p_vaddr)
c002a781:	39 c8                	cmp    %ecx,%eax
c002a783:	0f 87 f3 01 00 00    	ja     c002a97c <start_process+0x534>
          if (validate_segment (&phdr, file)) 
c002a789:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002a78e:	0f 86 f5 01 00 00    	jbe    c002a989 <start_process+0x541>
              bool writable = (phdr.p_flags & PF_W) != 0;
c002a794:	8b 74 24 50          	mov    0x50(%esp),%esi
c002a798:	d1 ee                	shr    %esi
c002a79a:	83 e6 01             	and    $0x1,%esi
              uint32_t file_page = phdr.p_offset & ~PGMASK;
c002a79d:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
c002a7a1:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
              uint32_t mem_page = phdr.p_vaddr & ~PGMASK;
c002a7a7:	89 c7                	mov    %eax,%edi
c002a7a9:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
              uint32_t page_offset = phdr.p_vaddr & PGMASK;
c002a7af:	25 ff 0f 00 00       	and    $0xfff,%eax
              if (phdr.p_filesz > 0)
c002a7b4:	85 db                	test   %ebx,%ebx
c002a7b6:	74 43                	je     c002a7fb <start_process+0x3b3>
                  read_bytes = page_offset + phdr.p_filesz;
c002a7b8:	01 c3                	add    %eax,%ebx
                  zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
c002a7ba:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax
c002a7c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002a7c6:	29 d8                	sub    %ebx,%eax
c002a7c8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
              if (!load_segment (file, file_page, (void *) mem_page,
c002a7cc:	89 f0                	mov    %esi,%eax
c002a7ce:	0f b6 c0             	movzbl %al,%eax
c002a7d1:	89 44 24 28          	mov    %eax,0x28(%esp)
c002a7d5:	89 7c 24 20          	mov    %edi,0x20(%esp)
  ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002a7d9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a7dd:	01 d8                	add    %ebx,%eax
c002a7df:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002a7e4:	75 2c                	jne    c002a812 <start_process+0x3ca>
  file_seek (file, ofs);
c002a7e6:	83 ec 08             	sub    $0x8,%esp
c002a7e9:	51                   	push   %ecx
c002a7ea:	ff 74 24 30          	pushl  0x30(%esp)
c002a7ee:	e8 93 22 00 00       	call   c002ca86 <file_seek>
c002a7f3:	83 c4 10             	add    $0x10,%esp
c002a7f6:	e9 a2 00 00 00       	jmp    c002a89d <start_process+0x455>
                  zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
c002a7fb:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax
c002a802:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002a807:	89 44 24 1c          	mov    %eax,0x1c(%esp)
                  read_bytes = 0;
c002a80b:	bb 00 00 00 00       	mov    $0x0,%ebx
c002a810:	eb ba                	jmp    c002a7cc <start_process+0x384>
  ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002a812:	83 ec 0c             	sub    $0xc,%esp
c002a815:	68 38 21 03 c0       	push   $0xc0032138
c002a81a:	68 21 01 03 c0       	push   $0xc0030121
c002a81f:	68 dc fd 02 c0       	push   $0xc002fddc
c002a824:	68 82 04 00 00       	push   $0x482
c002a829:	68 f9 20 03 c0       	push   $0xc00320f9
c002a82e:	e8 f4 dd ff ff       	call   c0028627 <debug_panic>
      size_t page_zero_bytes = PGSIZE - page_read_bytes;
c002a833:	b8 00 10 00 00       	mov    $0x1000,%eax
c002a838:	29 f0                	sub    %esi,%eax
c002a83a:	89 44 24 10          	mov    %eax,0x10(%esp)
      uint8_t *kpage = palloc_get_page (PAL_USER);
c002a83e:	83 ec 0c             	sub    $0xc,%esp
c002a841:	6a 04                	push   $0x4
c002a843:	e8 10 8e ff ff       	call   c0023658 <palloc_get_page>
c002a848:	89 c5                	mov    %eax,%ebp
      if (kpage == NULL)
c002a84a:	83 c4 10             	add    $0x10,%esp
c002a84d:	85 c0                	test   %eax,%eax
c002a84f:	0f 84 41 01 00 00    	je     c002a996 <start_process+0x54e>
      if (file_read (file, kpage, page_read_bytes) != (int) page_read_bytes)
c002a855:	83 ec 04             	sub    $0x4,%esp
c002a858:	56                   	push   %esi
c002a859:	50                   	push   %eax
c002a85a:	ff 74 24 30          	pushl  0x30(%esp)
c002a85e:	e8 9d 20 00 00       	call   c002c900 <file_read>
c002a863:	83 c4 10             	add    $0x10,%esp
c002a866:	39 c6                	cmp    %eax,%esi
c002a868:	75 5a                	jne    c002a8c4 <start_process+0x47c>
      memset (kpage + page_read_bytes, 0, page_zero_bytes);
c002a86a:	8d 54 35 00          	lea    0x0(%ebp,%esi,1),%edx
c002a86e:	89 d7                	mov    %edx,%edi
c002a870:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002a874:	b0 00                	mov    $0x0,%al
c002a876:	f3 aa                	rep stos %al,%es:(%edi)
      if (!install_page (upage, kpage, writable)) 
c002a878:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c002a87c:	89 ea                	mov    %ebp,%edx
c002a87e:	8b 44 24 20          	mov    0x20(%esp),%eax
c002a882:	e8 12 f9 ff ff       	call   c002a199 <install_page>
c002a887:	84 c0                	test   %al,%al
c002a889:	74 54                	je     c002a8df <start_process+0x497>
      read_bytes -= page_read_bytes;
c002a88b:	29 f3                	sub    %esi,%ebx
      zero_bytes -= page_zero_bytes;
c002a88d:	8b 74 24 10          	mov    0x10(%esp),%esi
c002a891:	29 74 24 1c          	sub    %esi,0x1c(%esp)
      upage += PGSIZE;
c002a895:	81 44 24 20 00 10 00 	addl   $0x1000,0x20(%esp)
c002a89c:	00 
  while (read_bytes > 0 || zero_bytes > 0) 
c002a89d:	85 db                	test   %ebx,%ebx
c002a89f:	75 0b                	jne    c002a8ac <start_process+0x464>
c002a8a1:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c002a8a6:	0f 84 e9 fd ff ff    	je     c002a695 <start_process+0x24d>
      size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
c002a8ac:	89 de                	mov    %ebx,%esi
c002a8ae:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
c002a8b4:	0f 86 79 ff ff ff    	jbe    c002a833 <start_process+0x3eb>
c002a8ba:	be 00 10 00 00       	mov    $0x1000,%esi
c002a8bf:	e9 6f ff ff ff       	jmp    c002a833 <start_process+0x3eb>
c002a8c4:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a8c8:	89 e8                	mov    %ebp,%eax
c002a8ca:	8b 6c 24 14          	mov    0x14(%esp),%ebp
          palloc_free_page (kpage);
c002a8ce:	83 ec 0c             	sub    $0xc,%esp
c002a8d1:	50                   	push   %eax
c002a8d2:	e8 ab 8e ff ff       	call   c0023782 <palloc_free_page>
c002a8d7:	83 c4 10             	add    $0x10,%esp
c002a8da:	e9 4b fe ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a8df:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a8e3:	89 e8                	mov    %ebp,%eax
c002a8e5:	8b 6c 24 14          	mov    0x14(%esp),%ebp
          palloc_free_page (kpage);
c002a8e9:	83 ec 0c             	sub    $0xc,%esp
c002a8ec:	50                   	push   %eax
c002a8ed:	e8 90 8e ff ff       	call   c0023782 <palloc_free_page>
c002a8f2:	83 c4 10             	add    $0x10,%esp
c002a8f5:	e9 30 fe ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a8fa:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a8fe:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a902:	e9 23 fe ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a907:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a90b:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a90f:	e9 16 fe ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a914:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a918:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a91c:	e9 09 fe ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a921:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a925:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a929:	e9 fc fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a92e:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a932:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a936:	e9 ef fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a93b:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a93f:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a943:	e9 e2 fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a948:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a94c:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a950:	e9 d5 fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a955:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a959:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a95d:	e9 c8 fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a962:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a966:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a96a:	e9 bb fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a96f:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a973:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a977:	e9 ae fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a97c:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a980:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a984:	e9 a1 fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a989:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a98d:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a991:	e9 94 fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a996:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a99a:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a99e:	e9 87 fd ff ff       	jmp    c002a72a <start_process+0x2e2>
c002a9a3:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002a9a7:	8b 74 24 18          	mov    0x18(%esp),%esi
c002a9ab:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  kpage = palloc_get_page (PAL_USER | PAL_ZERO);
c002a9af:	83 ec 0c             	sub    $0xc,%esp
c002a9b2:	6a 06                	push   $0x6
c002a9b4:	e8 9f 8c ff ff       	call   c0023658 <palloc_get_page>
c002a9b9:	89 c7                	mov    %eax,%edi
  if (kpage != NULL) 
c002a9bb:	83 c4 10             	add    $0x10,%esp
c002a9be:	85 c0                	test   %eax,%eax
c002a9c0:	74 4b                	je     c002aa0d <start_process+0x5c5>
      success = install_page (((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
c002a9c2:	b9 01 00 00 00       	mov    $0x1,%ecx
c002a9c7:	89 c2                	mov    %eax,%edx
c002a9c9:	b8 00 f0 ff bf       	mov    $0xbffff000,%eax
c002a9ce:	e8 c6 f7 ff ff       	call   c002a199 <install_page>
c002a9d3:	88 44 24 0c          	mov    %al,0xc(%esp)
      if (success)
c002a9d7:	84 c0                	test   %al,%al
c002a9d9:	74 26                	je     c002aa01 <start_process+0x5b9>
        *esp = PHYS_BASE;
c002a9db:	c7 84 24 d8 00 00 00 	movl   $0xc0000000,0xd8(%esp)
c002a9e2:	00 00 00 c0 
  *eip = (void (*) (void)) ehdr.e_entry;
c002a9e6:	8b 44 24 70          	mov    0x70(%esp),%eax
c002a9ea:	89 84 24 cc 00 00 00 	mov    %eax,0xcc(%esp)
  thread_current()->self = file;
c002a9f1:	e8 c6 62 ff ff       	call   c0020cbc <thread_current>
c002a9f6:	89 98 b8 00 00 00    	mov    %ebx,0xb8(%eax)
c002a9fc:	e9 ab fb ff ff       	jmp    c002a5ac <start_process+0x164>
        palloc_free_page (kpage);
c002aa01:	83 ec 0c             	sub    $0xc,%esp
c002aa04:	57                   	push   %edi
c002aa05:	e8 78 8d ff ff       	call   c0023782 <palloc_free_page>
c002aa0a:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002aa0d:	c6 44 24 0c 00       	movb   $0x0,0xc(%esp)
c002aa12:	e9 95 fb ff ff       	jmp    c002a5ac <start_process+0x164>
c002aa17:	c6 44 24 0c 00       	movb   $0x0,0xc(%esp)
c002aa1c:	e9 8b fb ff ff       	jmp    c002a5ac <start_process+0x164>
  int argc = 0;
c002aa21:	bb 00 00 00 00       	mov    $0x0,%ebx
c002aa26:	e9 bd fb ff ff       	jmp    c002a5e8 <start_process+0x1a0>
		argv[argc++] = if_.esp;
c002aa2b:	89 fb                	mov    %edi,%ebx
		if_.esp -= strlen(token) + 1;
c002aa2d:	b0 00                	mov    $0x0,%al
c002aa2f:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002aa34:	89 f7                	mov    %esi,%edi
c002aa36:	f2 ae                	repnz scas %es:(%edi),%al
c002aa38:	8b 94 24 d8 00 00 00 	mov    0xd8(%esp),%edx
c002aa3f:	8d 54 0a 01          	lea    0x1(%edx,%ecx,1),%edx
c002aa43:	89 94 24 d8 00 00 00 	mov    %edx,0xd8(%esp)
		memcpy(if_.esp, token, strlen(token) + 1);
c002aa4a:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002aa4f:	89 f7                	mov    %esi,%edi
c002aa51:	f2 ae                	repnz scas %es:(%edi),%al
c002aa53:	f7 d1                	not    %ecx
c002aa55:	89 d7                	mov    %edx,%edi
c002aa57:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		argv[argc++] = if_.esp;
c002aa59:	8d 7b 01             	lea    0x1(%ebx),%edi
c002aa5c:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
c002aa63:	89 44 bd fc          	mov    %eax,-0x4(%ebp,%edi,4)
	for (token = strtok_r(file_name, " ", &save_ptr); token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
c002aa67:	83 ec 04             	sub    $0x4,%esp
c002aa6a:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
c002aa71:	50                   	push   %eax
c002aa72:	68 3a 1b 03 c0       	push   $0xc0031b3a
c002aa77:	6a 00                	push   $0x0
c002aa79:	e8 c9 d0 ff ff       	call   c0027b47 <strtok_r>
c002aa7e:	89 c6                	mov    %eax,%esi
c002aa80:	83 c4 10             	add    $0x10,%esp
c002aa83:	85 c0                	test   %eax,%eax
c002aa85:	75 a4                	jne    c002aa2b <start_process+0x5e3>
	if_.esp -= ((unsigned)if_.esp % WORD_SIZE);
c002aa87:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
c002aa8e:	83 e0 fc             	and    $0xfffffffc,%eax
	if_.esp -= sizeof(int);
c002aa91:	8d 50 fc             	lea    -0x4(%eax),%edx
c002aa94:	89 94 24 d8 00 00 00 	mov    %edx,0xd8(%esp)
	*(int*)if_.esp = 0;
c002aa9b:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	for(int i = argc - 1; i >= 0; i--) {
c002aaa2:	85 db                	test   %ebx,%ebx
c002aaa4:	78 1e                	js     c002aac4 <start_process+0x67c>
		if_.esp -= sizeof(int);
c002aaa6:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
c002aaad:	8d 50 fc             	lea    -0x4(%eax),%edx
c002aab0:	89 94 24 d8 00 00 00 	mov    %edx,0xd8(%esp)
		memcpy(if_.esp, &argv[i], sizeof(int));
c002aab7:	8b 54 9d 00          	mov    0x0(%ebp,%ebx,4),%edx
c002aabb:	89 50 fc             	mov    %edx,-0x4(%eax)
	for(int i = argc - 1; i >= 0; i--) {
c002aabe:	4b                   	dec    %ebx
c002aabf:	83 fb ff             	cmp    $0xffffffff,%ebx
c002aac2:	75 e2                	jne    c002aaa6 <start_process+0x65e>
	int tmp = if_.esp;
c002aac4:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
	if_.esp -= sizeof(int);
c002aacb:	8d 50 fc             	lea    -0x4(%eax),%edx
c002aace:	89 94 24 d8 00 00 00 	mov    %edx,0xd8(%esp)
	memcpy(if_.esp, &tmp, sizeof(int));
c002aad5:	89 40 fc             	mov    %eax,-0x4(%eax)
	if_.esp -= sizeof(int);
c002aad8:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
c002aadf:	8d 50 fc             	lea    -0x4(%eax),%edx
c002aae2:	89 94 24 d8 00 00 00 	mov    %edx,0xd8(%esp)
	memcpy(if_.esp, &argc, sizeof(int));
c002aae9:	89 78 fc             	mov    %edi,-0x4(%eax)
	if_.esp -= sizeof(int);
c002aaec:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
c002aaf3:	8d 50 fc             	lea    -0x4(%eax),%edx
c002aaf6:	89 94 24 d8 00 00 00 	mov    %edx,0xd8(%esp)
	*(int*)if_.esp = 0;
c002aafd:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	palloc_free_page (file_name);
c002ab04:	83 ec 0c             	sub    $0xc,%esp
c002ab07:	ff b4 24 0c 01 00 00 	pushl  0x10c(%esp)
c002ab0e:	e8 6f 8c ff ff       	call   c0023782 <palloc_free_page>
	struct thread * current_thread = thread_current();
c002ab13:	e8 a4 61 ff ff       	call   c0020cbc <thread_current>
	current_thread->parent->load_success = success;
c002ab18:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
c002ab1e:	8a 5c 24 1c          	mov    0x1c(%esp),%bl
c002ab22:	88 9a a0 00 00 00    	mov    %bl,0xa0(%edx)
	if (!success)
c002ab28:	83 c4 10             	add    $0x10,%esp
c002ab2b:	84 db                	test   %bl,%bl
c002ab2d:	75 05                	jne    c002ab34 <start_process+0x6ec>
	  thread_exit();
c002ab2f:	e8 20 6c ff ff       	call   c0021754 <thread_exit>
	sema_up(&current_thread->parent->load_sema);
c002ab34:	83 ec 0c             	sub    $0xc,%esp
c002ab37:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c002ab3d:	83 c0 78             	add    $0x78,%eax
c002ab40:	50                   	push   %eax
c002ab41:	e8 38 80 ff ff       	call   c0022b7e <sema_up>
  asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
c002ab46:	8d 84 24 a0 00 00 00 	lea    0xa0(%esp),%eax
c002ab4d:	89 c4                	mov    %eax,%esp
c002ab4f:	e9 45 73 ff ff       	jmp    c0021e99 <intr_exit>
  NOT_REACHED ();
c002ab54:	68 84 08 03 c0       	push   $0xc0030884
c002ab59:	68 ec fd 02 c0       	push   $0xc002fdec
c002ab5e:	68 1d 03 00 00       	push   $0x31d
c002ab63:	68 f9 20 03 c0       	push   $0xc00320f9
c002ab68:	e8 ba da ff ff       	call   c0028627 <debug_panic>
	if_.esp -= ((unsigned)if_.esp % WORD_SIZE);
c002ab6d:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
c002ab74:	83 e0 fc             	and    $0xfffffffc,%eax
	if_.esp -= sizeof(int);
c002ab77:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ab7a:	89 94 24 d8 00 00 00 	mov    %edx,0xd8(%esp)
	*(int*)if_.esp = 0;
c002ab81:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	argc = 0;
c002ab88:	bf 00 00 00 00       	mov    $0x0,%edi
c002ab8d:	e9 32 ff ff ff       	jmp    c002aac4 <start_process+0x67c>

c002ab92 <lookup_page>:
   on CREATE.  If CREATE is true, then a new page table is
   created and a pointer into it is returned.  Otherwise, a null
   pointer is returned. */
static uint32_t *
lookup_page (uint32_t *pd, const void *vaddr, bool create)
{
c002ab92:	56                   	push   %esi
c002ab93:	53                   	push   %ebx
c002ab94:	83 ec 04             	sub    $0x4,%esp
  uint32_t *pt, *pde;

  ASSERT (pd != NULL);
c002ab97:	85 c0                	test   %eax,%eax
c002ab99:	0f 84 85 00 00 00    	je     c002ac24 <lookup_page+0x92>

  /* Shouldn't create new kernel virtual mappings. */
  ASSERT (!create || is_user_vaddr (vaddr));
c002ab9f:	84 c9                	test   %cl,%cl
c002aba1:	0f 84 31 01 00 00    	je     c002acd8 <lookup_page+0x146>
c002aba7:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002abad:	0f 87 8f 00 00 00    	ja     c002ac42 <lookup_page+0xb0>
  return (uintptr_t) va >> PDSHIFT;
c002abb3:	89 d3                	mov    %edx,%ebx
c002abb5:	c1 ea 16             	shr    $0x16,%edx

  /* Check for a page table for VADDR.
     If one is missing, create one if requested. */
  pde = pd + pd_no (vaddr);
c002abb8:	8d 34 90             	lea    (%eax,%edx,4),%esi
  if (*pde == 0) 
c002abbb:	83 3e 00             	cmpl   $0x0,(%esi)
c002abbe:	75 34                	jne    c002abf4 <lookup_page+0x62>
    {
      if (create)
        {
          pt = palloc_get_page (PAL_ZERO);
c002abc0:	83 ec 0c             	sub    $0xc,%esp
c002abc3:	6a 02                	push   $0x2
c002abc5:	e8 8e 8a ff ff       	call   c0023658 <palloc_get_page>
          if (pt == NULL) 
c002abca:	83 c4 10             	add    $0x10,%esp
c002abcd:	85 c0                	test   %eax,%eax
c002abcf:	74 4d                	je     c002ac1e <lookup_page+0x8c>
c002abd1:	89 c2                	mov    %eax,%edx
  ASSERT (pg_ofs (pt) == 0);
c002abd3:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002abd8:	0f 85 82 00 00 00    	jne    c002ac60 <lookup_page+0xce>
  ASSERT (is_kernel_vaddr (vaddr));
c002abde:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002abe3:	0f 86 95 00 00 00    	jbe    c002ac7e <lookup_page+0xec>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002abe9:	81 c2 00 00 00 40    	add    $0x40000000,%edx
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c002abef:	83 ca 07             	or     $0x7,%edx
c002abf2:	89 16                	mov    %edx,(%esi)
      else
        return NULL;
    }

  /* Return the page table entry. */
  pt = pde_get_pt (*pde);
c002abf4:	8b 06                	mov    (%esi),%eax
  ASSERT (pde & PTE_P);
c002abf6:	a8 01                	test   $0x1,%al
c002abf8:	0f 84 9e 00 00 00    	je     c002ac9c <lookup_page+0x10a>
  return ptov (pde & PTE_ADDR);
c002abfe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c002ac03:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002ac08:	0f 87 ac 00 00 00    	ja     c002acba <lookup_page+0x128>
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002ac0e:	c1 eb 0a             	shr    $0xa,%ebx
  return &pt[pt_no (vaddr)];
c002ac11:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
c002ac17:	8d 84 18 00 00 00 c0 	lea    -0x40000000(%eax,%ebx,1),%eax
}
c002ac1e:	83 c4 04             	add    $0x4,%esp
c002ac21:	5b                   	pop    %ebx
c002ac22:	5e                   	pop    %esi
c002ac23:	c3                   	ret    
  ASSERT (pd != NULL);
c002ac24:	83 ec 0c             	sub    $0xc,%esp
c002ac27:	68 60 21 03 c0       	push   $0xc0032160
c002ac2c:	68 21 01 03 c0       	push   $0xc0030121
c002ac31:	68 30 fe 02 c0       	push   $0xc002fe30
c002ac36:	6a 3d                	push   $0x3d
c002ac38:	68 6b 21 03 c0       	push   $0xc003216b
c002ac3d:	e8 e5 d9 ff ff       	call   c0028627 <debug_panic>
  ASSERT (!create || is_user_vaddr (vaddr));
c002ac42:	83 ec 0c             	sub    $0xc,%esp
c002ac45:	68 0c 22 03 c0       	push   $0xc003220c
c002ac4a:	68 21 01 03 c0       	push   $0xc0030121
c002ac4f:	68 30 fe 02 c0       	push   $0xc002fe30
c002ac54:	6a 40                	push   $0x40
c002ac56:	68 6b 21 03 c0       	push   $0xc003216b
c002ac5b:	e8 c7 d9 ff ff       	call   c0028627 <debug_panic>
  ASSERT (pg_ofs (pt) == 0);
c002ac60:	83 ec 0c             	sub    $0xc,%esp
c002ac63:	68 10 01 03 c0       	push   $0xc0030110
c002ac68:	68 21 01 03 c0       	push   $0xc0030121
c002ac6d:	68 24 fe 02 c0       	push   $0xc002fe24
c002ac72:	6a 48                	push   $0x48
c002ac74:	68 38 01 03 c0       	push   $0xc0030138
c002ac79:	e8 a9 d9 ff ff       	call   c0028627 <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c002ac7e:	83 ec 0c             	sub    $0xc,%esp
c002ac81:	68 4c 01 03 c0       	push   $0xc003014c
c002ac86:	68 21 01 03 c0       	push   $0xc0030121
c002ac8b:	68 3c fe 02 c0       	push   $0xc002fe3c
c002ac90:	6a 54                	push   $0x54
c002ac92:	68 64 01 03 c0       	push   $0xc0030164
c002ac97:	e8 8b d9 ff ff       	call   c0028627 <debug_panic>
  ASSERT (pde & PTE_P);
c002ac9c:	83 ec 0c             	sub    $0xc,%esp
c002ac9f:	68 84 21 03 c0       	push   $0xc0032184
c002aca4:	68 21 01 03 c0       	push   $0xc0030121
c002aca9:	68 60 fe 02 c0       	push   $0xc002fe60
c002acae:	6a 4f                	push   $0x4f
c002acb0:	68 38 01 03 c0       	push   $0xc0030138
c002acb5:	e8 6d d9 ff ff       	call   c0028627 <debug_panic>
  ASSERT ((void *) paddr < PHYS_BASE);
c002acba:	83 ec 0c             	sub    $0xc,%esp
c002acbd:	68 9b 0d 03 c0       	push   $0xc0030d9b
c002acc2:	68 21 01 03 c0       	push   $0xc0030121
c002acc7:	68 58 fe 02 c0       	push   $0xc002fe58
c002accc:	6a 4a                	push   $0x4a
c002acce:	68 64 01 03 c0       	push   $0xc0030164
c002acd3:	e8 4f d9 ff ff       	call   c0028627 <debug_panic>
  return (uintptr_t) va >> PDSHIFT;
c002acd8:	89 d3                	mov    %edx,%ebx
c002acda:	c1 ea 16             	shr    $0x16,%edx
  pde = pd + pd_no (vaddr);
c002acdd:	8d 34 90             	lea    (%eax,%edx,4),%esi
  if (*pde == 0) 
c002ace0:	83 3e 00             	cmpl   $0x0,(%esi)
c002ace3:	0f 85 0b ff ff ff    	jne    c002abf4 <lookup_page+0x62>
        return NULL;
c002ace9:	b8 00 00 00 00       	mov    $0x0,%eax
c002acee:	e9 2b ff ff ff       	jmp    c002ac1e <lookup_page+0x8c>

c002acf3 <pagedir_create>:
{
c002acf3:	57                   	push   %edi
c002acf4:	56                   	push   %esi
c002acf5:	83 ec 10             	sub    $0x10,%esp
  uint32_t *pd = palloc_get_page (0);
c002acf8:	6a 00                	push   $0x0
c002acfa:	e8 59 89 ff ff       	call   c0023658 <palloc_get_page>
  if (pd != NULL)
c002acff:	83 c4 10             	add    $0x10,%esp
c002ad02:	85 c0                	test   %eax,%eax
c002ad04:	74 0f                	je     c002ad15 <pagedir_create+0x22>
    memcpy (pd, init_page_dir, PGSIZE);
c002ad06:	8b 35 94 55 04 c0    	mov    0xc0045594,%esi
c002ad0c:	b9 00 04 00 00       	mov    $0x400,%ecx
c002ad11:	89 c7                	mov    %eax,%edi
c002ad13:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
c002ad15:	83 c4 04             	add    $0x4,%esp
c002ad18:	5e                   	pop    %esi
c002ad19:	5f                   	pop    %edi
c002ad1a:	c3                   	ret    

c002ad1b <pagedir_destroy>:
{
c002ad1b:	55                   	push   %ebp
c002ad1c:	57                   	push   %edi
c002ad1d:	56                   	push   %esi
c002ad1e:	53                   	push   %ebx
c002ad1f:	83 ec 1c             	sub    $0x1c,%esp
  if (pd == NULL)
c002ad22:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c002ad27:	0f 84 05 01 00 00    	je     c002ae32 <pagedir_destroy+0x117>
  ASSERT (pd != init_page_dir);
c002ad2d:	a1 94 55 04 c0       	mov    0xc0045594,%eax
c002ad32:	39 44 24 30          	cmp    %eax,0x30(%esp)
c002ad36:	74 20                	je     c002ad58 <pagedir_destroy+0x3d>
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002ad38:	8b 44 24 30          	mov    0x30(%esp),%eax
c002ad3c:	05 00 0c 00 00       	add    $0xc00,%eax
c002ad41:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002ad45:	39 44 24 30          	cmp    %eax,0x30(%esp)
c002ad49:	0f 83 d4 00 00 00    	jae    c002ae23 <pagedir_destroy+0x108>
c002ad4f:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002ad53:	e9 9b 00 00 00       	jmp    c002adf3 <pagedir_destroy+0xd8>
  ASSERT (pd != init_page_dir);
c002ad58:	83 ec 0c             	sub    $0xc,%esp
c002ad5b:	68 90 21 03 c0       	push   $0xc0032190
c002ad60:	68 21 01 03 c0       	push   $0xc0030121
c002ad65:	68 6c fe 02 c0       	push   $0xc002fe6c
c002ad6a:	6a 23                	push   $0x23
c002ad6c:	68 6b 21 03 c0       	push   $0xc003216b
c002ad71:	e8 b1 d8 ff ff       	call   c0028627 <debug_panic>
c002ad76:	83 ec 0c             	sub    $0xc,%esp
c002ad79:	68 9b 0d 03 c0       	push   $0xc0030d9b
c002ad7e:	68 21 01 03 c0       	push   $0xc0030121
c002ad83:	68 58 fe 02 c0       	push   $0xc002fe58
c002ad88:	6a 4a                	push   $0x4a
c002ad8a:	68 64 01 03 c0       	push   $0xc0030164
c002ad8f:	e8 93 d8 ff ff       	call   c0028627 <debug_panic>
c002ad94:	83 ec 0c             	sub    $0xc,%esp
c002ad97:	68 9b 0d 03 c0       	push   $0xc0030d9b
c002ad9c:	68 21 01 03 c0       	push   $0xc0030121
c002ada1:	68 58 fe 02 c0       	push   $0xc002fe58
c002ada6:	6a 4a                	push   $0x4a
c002ada8:	68 64 01 03 c0       	push   $0xc0030164
c002adad:	e8 75 d8 ff ff       	call   c0028627 <debug_panic>
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002adb2:	83 c3 04             	add    $0x4,%ebx
c002adb5:	39 f3                	cmp    %esi,%ebx
c002adb7:	74 25                	je     c002adde <pagedir_destroy+0xc3>
          if (*pte & PTE_P) 
c002adb9:	8b 03                	mov    (%ebx),%eax
c002adbb:	a8 01                	test   $0x1,%al
c002adbd:	74 f3                	je     c002adb2 <pagedir_destroy+0x97>
}

/* Returns a pointer to the page that page table entry PTE points
   to. */
static inline void *pte_get_page (uint32_t pte) {
  return ptov (pte & PTE_ADDR);
c002adbf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002adc4:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002adc9:	77 c9                	ja     c002ad94 <pagedir_destroy+0x79>
            palloc_free_page (pte_get_page (*pte));
c002adcb:	83 ec 0c             	sub    $0xc,%esp
  return (void *) (paddr + PHYS_BASE);
c002adce:	2d 00 00 00 40       	sub    $0x40000000,%eax
c002add3:	50                   	push   %eax
c002add4:	e8 a9 89 ff ff       	call   c0023782 <palloc_free_page>
c002add9:	83 c4 10             	add    $0x10,%esp
c002addc:	eb d4                	jmp    c002adb2 <pagedir_destroy+0x97>
        palloc_free_page (pt);
c002adde:	83 ec 0c             	sub    $0xc,%esp
c002ade1:	55                   	push   %ebp
c002ade2:	e8 9b 89 ff ff       	call   c0023782 <palloc_free_page>
c002ade7:	83 c4 10             	add    $0x10,%esp
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002adea:	83 c7 04             	add    $0x4,%edi
c002aded:	39 7c 24 0c          	cmp    %edi,0xc(%esp)
c002adf1:	74 30                	je     c002ae23 <pagedir_destroy+0x108>
    if (*pde & PTE_P) 
c002adf3:	8b 37                	mov    (%edi),%esi
c002adf5:	f7 c6 01 00 00 00    	test   $0x1,%esi
c002adfb:	74 ed                	je     c002adea <pagedir_destroy+0xcf>
  return ptov (pde & PTE_ADDR);
c002adfd:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  ASSERT ((void *) paddr < PHYS_BASE);
c002ae03:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002ae09:	0f 87 67 ff ff ff    	ja     c002ad76 <pagedir_destroy+0x5b>
  return (void *) (paddr + PHYS_BASE);
c002ae0f:	8d ae 00 00 00 c0    	lea    -0x40000000(%esi),%ebp
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002ae15:	81 ee 00 f0 ff 3f    	sub    $0x3ffff000,%esi
c002ae1b:	39 f5                	cmp    %esi,%ebp
c002ae1d:	73 bf                	jae    c002adde <pagedir_destroy+0xc3>
c002ae1f:	89 eb                	mov    %ebp,%ebx
c002ae21:	eb 96                	jmp    c002adb9 <pagedir_destroy+0x9e>
  palloc_free_page (pd);
c002ae23:	83 ec 0c             	sub    $0xc,%esp
c002ae26:	ff 74 24 3c          	pushl  0x3c(%esp)
c002ae2a:	e8 53 89 ff ff       	call   c0023782 <palloc_free_page>
c002ae2f:	83 c4 10             	add    $0x10,%esp
}
c002ae32:	83 c4 1c             	add    $0x1c,%esp
c002ae35:	5b                   	pop    %ebx
c002ae36:	5e                   	pop    %esi
c002ae37:	5f                   	pop    %edi
c002ae38:	5d                   	pop    %ebp
c002ae39:	c3                   	ret    

c002ae3a <pagedir_set_page>:
   otherwise it is read-only.
   Returns true if successful, false if memory allocation
   failed. */
bool
pagedir_set_page (uint32_t *pd, void *upage, void *kpage, bool writable)
{
c002ae3a:	56                   	push   %esi
c002ae3b:	53                   	push   %ebx
c002ae3c:	83 ec 04             	sub    $0x4,%esp
c002ae3f:	8b 44 24 10          	mov    0x10(%esp),%eax
c002ae43:	8b 54 24 14          	mov    0x14(%esp),%edx
c002ae47:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c002ae4b:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  uint32_t *pte;

  ASSERT (pg_ofs (upage) == 0);
c002ae4f:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002ae55:	75 7f                	jne    c002aed6 <pagedir_set_page+0x9c>
  ASSERT (pg_ofs (kpage) == 0);
c002ae57:	f7 c1 ff 0f 00 00    	test   $0xfff,%ecx
c002ae5d:	0f 85 91 00 00 00    	jne    c002aef4 <pagedir_set_page+0xba>
  ASSERT (is_user_vaddr (upage));
c002ae63:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002ae69:	0f 87 a3 00 00 00    	ja     c002af12 <pagedir_set_page+0xd8>
  ASSERT (is_kernel_vaddr (vaddr));
c002ae6f:	81 f9 ff ff ff bf    	cmp    $0xbfffffff,%ecx
c002ae75:	0f 86 b5 00 00 00    	jbe    c002af30 <pagedir_set_page+0xf6>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002ae7b:	8d 99 00 00 00 40    	lea    0x40000000(%ecx),%ebx
  ASSERT (vtop (kpage) >> PTSHIFT < init_ram_pages);
c002ae81:	89 d9                	mov    %ebx,%ecx
c002ae83:	c1 e9 0c             	shr    $0xc,%ecx
c002ae86:	3b 0d 5e 01 02 c0    	cmp    0xc002015e,%ecx
c002ae8c:	0f 83 bc 00 00 00    	jae    c002af4e <pagedir_set_page+0x114>
  ASSERT (pd != init_page_dir);
c002ae92:	39 05 94 55 04 c0    	cmp    %eax,0xc0045594
c002ae98:	0f 84 ce 00 00 00    	je     c002af6c <pagedir_set_page+0x132>

  pte = lookup_page (pd, upage, true);
c002ae9e:	b9 01 00 00 00       	mov    $0x1,%ecx
c002aea3:	e8 ea fc ff ff       	call   c002ab92 <lookup_page>

  if (pte != NULL) 
c002aea8:	85 c0                	test   %eax,%eax
c002aeaa:	0f 84 f8 00 00 00    	je     c002afa8 <pagedir_set_page+0x16e>
    {
      ASSERT ((*pte & PTE_P) == 0);
c002aeb0:	f6 00 01             	testb  $0x1,(%eax)
c002aeb3:	0f 85 d1 00 00 00    	jne    c002af8a <pagedir_set_page+0x150>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002aeb9:	89 f2                	mov    %esi,%edx
c002aebb:	84 d2                	test   %dl,%dl
c002aebd:	0f 95 c1             	setne  %cl
c002aec0:	0f b6 c9             	movzbl %cl,%ecx
c002aec3:	d1 e1                	shl    %ecx
  return pte_create_kernel (page, writable) | PTE_U;
c002aec5:	83 cb 05             	or     $0x5,%ebx
c002aec8:	89 da                	mov    %ebx,%edx
c002aeca:	09 ca                	or     %ecx,%edx
c002aecc:	89 10                	mov    %edx,(%eax)
      *pte = pte_create_user (kpage, writable);
      return true;
c002aece:	b0 01                	mov    $0x1,%al
    }
  else
    return false;
}
c002aed0:	83 c4 04             	add    $0x4,%esp
c002aed3:	5b                   	pop    %ebx
c002aed4:	5e                   	pop    %esi
c002aed5:	c3                   	ret    
  ASSERT (pg_ofs (upage) == 0);
c002aed6:	83 ec 0c             	sub    $0xc,%esp
c002aed9:	68 a4 21 03 c0       	push   $0xc00321a4
c002aede:	68 21 01 03 c0       	push   $0xc0030121
c002aee3:	68 44 fe 02 c0       	push   $0xc002fe44
c002aee8:	6a 67                	push   $0x67
c002aeea:	68 6b 21 03 c0       	push   $0xc003216b
c002aeef:	e8 33 d7 ff ff       	call   c0028627 <debug_panic>
  ASSERT (pg_ofs (kpage) == 0);
c002aef4:	83 ec 0c             	sub    $0xc,%esp
c002aef7:	68 b8 21 03 c0       	push   $0xc00321b8
c002aefc:	68 21 01 03 c0       	push   $0xc0030121
c002af01:	68 44 fe 02 c0       	push   $0xc002fe44
c002af06:	6a 68                	push   $0x68
c002af08:	68 6b 21 03 c0       	push   $0xc003216b
c002af0d:	e8 15 d7 ff ff       	call   c0028627 <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002af12:	83 ec 0c             	sub    $0xc,%esp
c002af15:	68 cc 21 03 c0       	push   $0xc00321cc
c002af1a:	68 21 01 03 c0       	push   $0xc0030121
c002af1f:	68 44 fe 02 c0       	push   $0xc002fe44
c002af24:	6a 69                	push   $0x69
c002af26:	68 6b 21 03 c0       	push   $0xc003216b
c002af2b:	e8 f7 d6 ff ff       	call   c0028627 <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c002af30:	83 ec 0c             	sub    $0xc,%esp
c002af33:	68 4c 01 03 c0       	push   $0xc003014c
c002af38:	68 21 01 03 c0       	push   $0xc0030121
c002af3d:	68 3c fe 02 c0       	push   $0xc002fe3c
c002af42:	6a 54                	push   $0x54
c002af44:	68 64 01 03 c0       	push   $0xc0030164
c002af49:	e8 d9 d6 ff ff       	call   c0028627 <debug_panic>
  ASSERT (vtop (kpage) >> PTSHIFT < init_ram_pages);
c002af4e:	83 ec 0c             	sub    $0xc,%esp
c002af51:	68 30 22 03 c0       	push   $0xc0032230
c002af56:	68 21 01 03 c0       	push   $0xc0030121
c002af5b:	68 44 fe 02 c0       	push   $0xc002fe44
c002af60:	6a 6a                	push   $0x6a
c002af62:	68 6b 21 03 c0       	push   $0xc003216b
c002af67:	e8 bb d6 ff ff       	call   c0028627 <debug_panic>
  ASSERT (pd != init_page_dir);
c002af6c:	83 ec 0c             	sub    $0xc,%esp
c002af6f:	68 90 21 03 c0       	push   $0xc0032190
c002af74:	68 21 01 03 c0       	push   $0xc0030121
c002af79:	68 44 fe 02 c0       	push   $0xc002fe44
c002af7e:	6a 6b                	push   $0x6b
c002af80:	68 6b 21 03 c0       	push   $0xc003216b
c002af85:	e8 9d d6 ff ff       	call   c0028627 <debug_panic>
      ASSERT ((*pte & PTE_P) == 0);
c002af8a:	83 ec 0c             	sub    $0xc,%esp
c002af8d:	68 e2 21 03 c0       	push   $0xc00321e2
c002af92:	68 21 01 03 c0       	push   $0xc0030121
c002af97:	68 44 fe 02 c0       	push   $0xc002fe44
c002af9c:	6a 71                	push   $0x71
c002af9e:	68 6b 21 03 c0       	push   $0xc003216b
c002afa3:	e8 7f d6 ff ff       	call   c0028627 <debug_panic>
    return false;
c002afa8:	b0 00                	mov    $0x0,%al
c002afaa:	e9 21 ff ff ff       	jmp    c002aed0 <pagedir_set_page+0x96>

c002afaf <pagedir_get_page>:
   address UADDR in PD.  Returns the kernel virtual address
   corresponding to that physical address, or a null pointer if
   UADDR is unmapped. */
void *
pagedir_get_page (uint32_t *pd, const void *uaddr) 
{
c002afaf:	53                   	push   %ebx
c002afb0:	83 ec 08             	sub    $0x8,%esp
c002afb3:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  uint32_t *pte;

  ASSERT (is_user_vaddr (uaddr));
c002afb7:	81 fb ff ff ff bf    	cmp    $0xbfffffff,%ebx
c002afbd:	77 39                	ja     c002aff8 <pagedir_get_page+0x49>
  
  pte = lookup_page (pd, uaddr, false);
c002afbf:	b9 00 00 00 00       	mov    $0x0,%ecx
c002afc4:	89 da                	mov    %ebx,%edx
c002afc6:	8b 44 24 10          	mov    0x10(%esp),%eax
c002afca:	e8 c3 fb ff ff       	call   c002ab92 <lookup_page>
  if (pte != NULL && (*pte & PTE_P) != 0)
c002afcf:	85 c0                	test   %eax,%eax
c002afd1:	74 64                	je     c002b037 <pagedir_get_page+0x88>
c002afd3:	8b 00                	mov    (%eax),%eax
c002afd5:	a8 01                	test   $0x1,%al
c002afd7:	74 65                	je     c002b03e <pagedir_get_page+0x8f>
  return ptov (pte & PTE_ADDR);
c002afd9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c002afde:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002afe3:	77 34                	ja     c002b019 <pagedir_get_page+0x6a>
  return (uintptr_t) va & PGMASK;
c002afe5:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
    return pte_get_page (*pte) + pg_ofs (uaddr);
c002afeb:	09 c3                	or     %eax,%ebx
c002afed:	8d 83 00 00 00 c0    	lea    -0x40000000(%ebx),%eax
  else
    return NULL;
}
c002aff3:	83 c4 08             	add    $0x8,%esp
c002aff6:	5b                   	pop    %ebx
c002aff7:	c3                   	ret    
  ASSERT (is_user_vaddr (uaddr));
c002aff8:	83 ec 0c             	sub    $0xc,%esp
c002affb:	68 f6 21 03 c0       	push   $0xc00321f6
c002b000:	68 21 01 03 c0       	push   $0xc0030121
c002b005:	68 10 fe 02 c0       	push   $0xc002fe10
c002b00a:	68 82 00 00 00       	push   $0x82
c002b00f:	68 6b 21 03 c0       	push   $0xc003216b
c002b014:	e8 0e d6 ff ff       	call   c0028627 <debug_panic>
  ASSERT ((void *) paddr < PHYS_BASE);
c002b019:	83 ec 0c             	sub    $0xc,%esp
c002b01c:	68 9b 0d 03 c0       	push   $0xc0030d9b
c002b021:	68 21 01 03 c0       	push   $0xc0030121
c002b026:	68 58 fe 02 c0       	push   $0xc002fe58
c002b02b:	6a 4a                	push   $0x4a
c002b02d:	68 64 01 03 c0       	push   $0xc0030164
c002b032:	e8 f0 d5 ff ff       	call   c0028627 <debug_panic>
    return NULL;
c002b037:	b8 00 00 00 00       	mov    $0x0,%eax
c002b03c:	eb b5                	jmp    c002aff3 <pagedir_get_page+0x44>
c002b03e:	b8 00 00 00 00       	mov    $0x0,%eax
c002b043:	eb ae                	jmp    c002aff3 <pagedir_get_page+0x44>

c002b045 <pagedir_is_dirty>:
   that is, if the page has been modified since the PTE was
   installed.
   Returns false if PD contains no PTE for VPAGE. */
bool
pagedir_is_dirty (uint32_t *pd, const void *vpage) 
{
c002b045:	83 ec 0c             	sub    $0xc,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002b048:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b04d:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b051:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b055:	e8 38 fb ff ff       	call   c002ab92 <lookup_page>
  return pte != NULL && (*pte & PTE_D) != 0;
c002b05a:	85 c0                	test   %eax,%eax
c002b05c:	74 0f                	je     c002b06d <pagedir_is_dirty+0x28>
c002b05e:	8b 00                	mov    (%eax),%eax
c002b060:	c1 e8 06             	shr    $0x6,%eax
c002b063:	83 e0 01             	and    $0x1,%eax
c002b066:	83 e0 01             	and    $0x1,%eax
}
c002b069:	83 c4 0c             	add    $0xc,%esp
c002b06c:	c3                   	ret    
c002b06d:	b0 00                	mov    $0x0,%al
c002b06f:	eb f5                	jmp    c002b066 <pagedir_is_dirty+0x21>

c002b071 <pagedir_is_accessed>:
   accessed recently, that is, between the time the PTE was
   installed and the last time it was cleared.  Returns false if
   PD contains no PTE for VPAGE. */
bool
pagedir_is_accessed (uint32_t *pd, const void *vpage) 
{
c002b071:	83 ec 0c             	sub    $0xc,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002b074:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b079:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b07d:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b081:	e8 0c fb ff ff       	call   c002ab92 <lookup_page>
  return pte != NULL && (*pte & PTE_A) != 0;
c002b086:	85 c0                	test   %eax,%eax
c002b088:	74 0f                	je     c002b099 <pagedir_is_accessed+0x28>
c002b08a:	8b 00                	mov    (%eax),%eax
c002b08c:	c1 e8 05             	shr    $0x5,%eax
c002b08f:	83 e0 01             	and    $0x1,%eax
c002b092:	83 e0 01             	and    $0x1,%eax
}
c002b095:	83 c4 0c             	add    $0xc,%esp
c002b098:	c3                   	ret    
c002b099:	b0 00                	mov    $0x0,%al
c002b09b:	eb f5                	jmp    c002b092 <pagedir_is_accessed+0x21>

c002b09d <pagedir_activate>:

/* Loads page directory PD into the CPU's page directory base
   register. */
void
pagedir_activate (uint32_t *pd) 
{
c002b09d:	83 ec 0c             	sub    $0xc,%esp
c002b0a0:	8b 44 24 10          	mov    0x10(%esp),%eax
  if (pd == NULL)
c002b0a4:	85 c0                	test   %eax,%eax
c002b0a6:	74 13                	je     c002b0bb <pagedir_activate+0x1e>
  ASSERT (is_kernel_vaddr (vaddr));
c002b0a8:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002b0ad:	76 13                	jbe    c002b0c2 <pagedir_activate+0x25>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002b0af:	05 00 00 00 40       	add    $0x40000000,%eax
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
     Address of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (pd)) : "memory");
c002b0b4:	0f 22 d8             	mov    %eax,%cr3
}
c002b0b7:	83 c4 0c             	add    $0xc,%esp
c002b0ba:	c3                   	ret    
    pd = init_page_dir;
c002b0bb:	a1 94 55 04 c0       	mov    0xc0045594,%eax
c002b0c0:	eb e6                	jmp    c002b0a8 <pagedir_activate+0xb>
  ASSERT (is_kernel_vaddr (vaddr));
c002b0c2:	83 ec 0c             	sub    $0xc,%esp
c002b0c5:	68 4c 01 03 c0       	push   $0xc003014c
c002b0ca:	68 21 01 03 c0       	push   $0xc0030121
c002b0cf:	68 3c fe 02 c0       	push   $0xc002fe3c
c002b0d4:	6a 54                	push   $0x54
c002b0d6:	68 64 01 03 c0       	push   $0xc0030164
c002b0db:	e8 47 d5 ff ff       	call   c0028627 <debug_panic>

c002b0e0 <invalidate_pagedir>:
   This function invalidates the TLB if PD is the active page
   directory.  (If PD is not active then its entries are not in
   the TLB, so there is no need to invalidate anything.) */
static void
invalidate_pagedir (uint32_t *pd) 
{
c002b0e0:	83 ec 0c             	sub    $0xc,%esp
  asm volatile ("movl %%cr3, %0" : "=r" (pd));
c002b0e3:	0f 20 da             	mov    %cr3,%edx
  ASSERT ((void *) paddr < PHYS_BASE);
c002b0e6:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002b0ec:	77 0e                	ja     c002b0fc <invalidate_pagedir+0x1c>
  return (void *) (paddr + PHYS_BASE);
c002b0ee:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
  if (active_pd () == pd) 
c002b0f4:	39 d0                	cmp    %edx,%eax
c002b0f6:	74 22                	je     c002b11a <invalidate_pagedir+0x3a>
    {
      /* Re-activating PD clears the TLB.  See [IA32-v3a] 3.12
         "Translation Lookaside Buffers (TLBs)". */
      pagedir_activate (pd);
    } 
}
c002b0f8:	83 c4 0c             	add    $0xc,%esp
c002b0fb:	c3                   	ret    
  ASSERT ((void *) paddr < PHYS_BASE);
c002b0fc:	83 ec 0c             	sub    $0xc,%esp
c002b0ff:	68 9b 0d 03 c0       	push   $0xc0030d9b
c002b104:	68 21 01 03 c0       	push   $0xc0030121
c002b109:	68 58 fe 02 c0       	push   $0xc002fe58
c002b10e:	6a 4a                	push   $0x4a
c002b110:	68 64 01 03 c0       	push   $0xc0030164
c002b115:	e8 0d d5 ff ff       	call   c0028627 <debug_panic>
      pagedir_activate (pd);
c002b11a:	83 ec 0c             	sub    $0xc,%esp
c002b11d:	50                   	push   %eax
c002b11e:	e8 7a ff ff ff       	call   c002b09d <pagedir_activate>
c002b123:	83 c4 10             	add    $0x10,%esp
}
c002b126:	eb d0                	jmp    c002b0f8 <invalidate_pagedir+0x18>

c002b128 <pagedir_clear_page>:
{
c002b128:	83 ec 0c             	sub    $0xc,%esp
c002b12b:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (pg_ofs (upage) == 0);
c002b12f:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002b135:	75 25                	jne    c002b15c <pagedir_clear_page+0x34>
  ASSERT (is_user_vaddr (upage));
c002b137:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002b13d:	77 3e                	ja     c002b17d <pagedir_clear_page+0x55>
  pte = lookup_page (pd, upage, false);
c002b13f:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b144:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b148:	e8 45 fa ff ff       	call   c002ab92 <lookup_page>
  if (pte != NULL && (*pte & PTE_P) != 0)
c002b14d:	85 c0                	test   %eax,%eax
c002b14f:	74 07                	je     c002b158 <pagedir_clear_page+0x30>
c002b151:	8b 10                	mov    (%eax),%edx
c002b153:	f6 c2 01             	test   $0x1,%dl
c002b156:	75 46                	jne    c002b19e <pagedir_clear_page+0x76>
}
c002b158:	83 c4 0c             	add    $0xc,%esp
c002b15b:	c3                   	ret    
  ASSERT (pg_ofs (upage) == 0);
c002b15c:	83 ec 0c             	sub    $0xc,%esp
c002b15f:	68 a4 21 03 c0       	push   $0xc00321a4
c002b164:	68 21 01 03 c0       	push   $0xc0030121
c002b169:	68 fc fd 02 c0       	push   $0xc002fdfc
c002b16e:	68 94 00 00 00       	push   $0x94
c002b173:	68 6b 21 03 c0       	push   $0xc003216b
c002b178:	e8 aa d4 ff ff       	call   c0028627 <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002b17d:	83 ec 0c             	sub    $0xc,%esp
c002b180:	68 cc 21 03 c0       	push   $0xc00321cc
c002b185:	68 21 01 03 c0       	push   $0xc0030121
c002b18a:	68 fc fd 02 c0       	push   $0xc002fdfc
c002b18f:	68 95 00 00 00       	push   $0x95
c002b194:	68 6b 21 03 c0       	push   $0xc003216b
c002b199:	e8 89 d4 ff ff       	call   c0028627 <debug_panic>
      *pte &= ~PTE_P;
c002b19e:	83 e2 fe             	and    $0xfffffffe,%edx
c002b1a1:	89 10                	mov    %edx,(%eax)
      invalidate_pagedir (pd);
c002b1a3:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b1a7:	e8 34 ff ff ff       	call   c002b0e0 <invalidate_pagedir>
}
c002b1ac:	eb aa                	jmp    c002b158 <pagedir_clear_page+0x30>

c002b1ae <pagedir_set_dirty>:
{
c002b1ae:	53                   	push   %ebx
c002b1af:	83 ec 08             	sub    $0x8,%esp
c002b1b2:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  uint32_t *pte = lookup_page (pd, vpage, false);
c002b1b6:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b1bb:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b1bf:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b1c3:	e8 ca f9 ff ff       	call   c002ab92 <lookup_page>
  if (pte != NULL) 
c002b1c8:	85 c0                	test   %eax,%eax
c002b1ca:	74 07                	je     c002b1d3 <pagedir_set_dirty+0x25>
      if (dirty)
c002b1cc:	84 db                	test   %bl,%bl
c002b1ce:	74 08                	je     c002b1d8 <pagedir_set_dirty+0x2a>
        *pte |= PTE_D;
c002b1d0:	83 08 40             	orl    $0x40,(%eax)
}
c002b1d3:	83 c4 08             	add    $0x8,%esp
c002b1d6:	5b                   	pop    %ebx
c002b1d7:	c3                   	ret    
          *pte &= ~(uint32_t) PTE_D;
c002b1d8:	83 20 bf             	andl   $0xffffffbf,(%eax)
          invalidate_pagedir (pd);
c002b1db:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b1df:	e8 fc fe ff ff       	call   c002b0e0 <invalidate_pagedir>
}
c002b1e4:	eb ed                	jmp    c002b1d3 <pagedir_set_dirty+0x25>

c002b1e6 <pagedir_set_accessed>:
{
c002b1e6:	53                   	push   %ebx
c002b1e7:	83 ec 08             	sub    $0x8,%esp
c002b1ea:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  uint32_t *pte = lookup_page (pd, vpage, false);
c002b1ee:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b1f3:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b1f7:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b1fb:	e8 92 f9 ff ff       	call   c002ab92 <lookup_page>
  if (pte != NULL) 
c002b200:	85 c0                	test   %eax,%eax
c002b202:	74 07                	je     c002b20b <pagedir_set_accessed+0x25>
      if (accessed)
c002b204:	84 db                	test   %bl,%bl
c002b206:	74 08                	je     c002b210 <pagedir_set_accessed+0x2a>
        *pte |= PTE_A;
c002b208:	83 08 20             	orl    $0x20,(%eax)
}
c002b20b:	83 c4 08             	add    $0x8,%esp
c002b20e:	5b                   	pop    %ebx
c002b20f:	c3                   	ret    
          *pte &= ~(uint32_t) PTE_A; 
c002b210:	83 20 df             	andl   $0xffffffdf,(%eax)
          invalidate_pagedir (pd);
c002b213:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b217:	e8 c4 fe ff ff       	call   c002b0e0 <invalidate_pagedir>
}
c002b21c:	eb ed                	jmp    c002b20b <pagedir_set_accessed+0x25>

c002b21e <kill>:
}

/* Handler for an exception (probably) caused by a user process. */
static void
kill (struct intr_frame *f) 
{
c002b21e:	57                   	push   %edi
c002b21f:	56                   	push   %esi
c002b220:	53                   	push   %ebx
c002b221:	8b 5c 24 10          	mov    0x10(%esp),%ebx
     exceptions back to the process via signals, but we don't
     implement them. */
     
  /* The interrupt frame's code segment value tells us where the
     exception originated. */
  switch (f->cs)
c002b225:	8b 73 40             	mov    0x40(%ebx),%esi
c002b228:	66 83 fe 08          	cmp    $0x8,%si
c002b22c:	74 38                	je     c002b266 <kill+0x48>
c002b22e:	66 83 fe 1b          	cmp    $0x1b,%si
c002b232:	75 51                	jne    c002b285 <kill+0x67>
    {
    case SEL_UCSEG:
      /* User's code segment, so it's a user exception, as we
         expected.  Kill the user process.  */

      printf ("%s: dying due to interrupt %#04x (%s).\n",
c002b234:	83 ec 0c             	sub    $0xc,%esp
c002b237:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
c002b23b:	50                   	push   %eax
c002b23c:	e8 2d 6c ff ff       	call   c0021e6e <intr_name>
c002b241:	89 c7                	mov    %eax,%edi
c002b243:	8b 73 30             	mov    0x30(%ebx),%esi
c002b246:	e8 36 5b ff ff       	call   c0020d81 <thread_name>
c002b24b:	57                   	push   %edi
c002b24c:	56                   	push   %esi
c002b24d:	50                   	push   %eax
c002b24e:	68 5c 22 03 c0       	push   $0xc003225c
c002b253:	e8 21 b9 ff ff       	call   c0026b79 <printf>
              thread_name (), f->vec_no, intr_name (f->vec_no));
      intr_dump_frame (f);
c002b258:	83 c4 14             	add    $0x14,%esp
c002b25b:	53                   	push   %ebx
c002b25c:	e8 80 6b ff ff       	call   c0021de1 <intr_dump_frame>
      thread_exit ();
c002b261:	e8 ee 64 ff ff       	call   c0021754 <thread_exit>
         Kernel code shouldn't throw exceptions.  (Page faults
         may cause kernel exceptions--but they shouldn't arrive
         here.)  Panic the kernel to make the point.  */
	    /* modified */

	    intr_dump_frame (f);
c002b266:	83 ec 0c             	sub    $0xc,%esp
c002b269:	53                   	push   %ebx
c002b26a:	e8 72 6b ff ff       	call   c0021de1 <intr_dump_frame>

      PANIC ("Kernel bug - unexpected interrupt in kernel"); 
c002b26f:	68 84 22 03 c0       	push   $0xc0032284
c002b274:	68 7c fe 02 c0       	push   $0xc002fe7c
c002b279:	6a 69                	push   $0x69
c002b27b:	68 13 23 03 c0       	push   $0xc0032313
c002b280:	e8 a2 d3 ff ff       	call   c0028627 <debug_panic>
      /* Some other code segment?  Shouldn't happen.  Panic the
         kernel. */

	    /* modified */

      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002b285:	83 ec 0c             	sub    $0xc,%esp
c002b288:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
c002b28c:	50                   	push   %eax
c002b28d:	e8 dc 6b ff ff       	call   c0021e6e <intr_name>
  switch (f->cs)
c002b292:	0f b7 f6             	movzwl %si,%esi
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002b295:	56                   	push   %esi
c002b296:	50                   	push   %eax
c002b297:	ff 73 30             	pushl  0x30(%ebx)
c002b29a:	68 b0 22 03 c0       	push   $0xc00322b0
c002b29f:	e8 d5 b8 ff ff       	call   c0026b79 <printf>
             f->vec_no, intr_name (f->vec_no), f->cs);
      thread_exit ();
c002b2a4:	83 c4 20             	add    $0x20,%esp
c002b2a7:	e8 a8 64 ff ff       	call   c0021754 <thread_exit>

c002b2ac <page_fault>:
   can find more information about both of these in the
   description of "Interrupt 14--Page Fault Exception (#PF)" in
   [IA32-v3a] section 5.15 "Exception and Interrupt Reference". */
static void
page_fault (struct intr_frame *f) 
{
c002b2ac:	55                   	push   %ebp
c002b2ad:	57                   	push   %edi
c002b2ae:	56                   	push   %esi
c002b2af:	53                   	push   %ebx
c002b2b0:	83 ec 0c             	sub    $0xc,%esp
     data.  It is not necessarily the address of the instruction
     that caused the fault (that's f->eip).
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (fault_addr));
c002b2b3:	0f 20 d6             	mov    %cr2,%esi

  /* Turn interrupts back on (they were only off so that we could
     be assured of reading CR2 before it changed). */
  intr_enable ();
c002b2b6:	e8 12 67 ff ff       	call   c00219cd <intr_enable>

  /* Count page faults. */
  page_fault_cnt++;
c002b2bb:	83 05 78 ce 03 c0 01 	addl   $0x1,0xc003ce78
c002b2c2:	83 15 7c ce 03 c0 00 	adcl   $0x0,0xc003ce7c

  /* Determine cause. */
  not_present = (f->error_code & PF_P) == 0;
c002b2c9:	8b 44 24 20          	mov    0x20(%esp),%eax
c002b2cd:	8b 58 34             	mov    0x34(%eax),%ebx
c002b2d0:	89 df                	mov    %ebx,%edi
c002b2d2:	83 e7 01             	and    $0x1,%edi
  write = (f->error_code & PF_W) != 0;
c002b2d5:	89 dd                	mov    %ebx,%ebp
c002b2d7:	83 e5 02             	and    $0x2,%ebp
  user = (f->error_code & PF_U) != 0;

  sema_up(&thread_current()->parent->load_sema);
c002b2da:	e8 dd 59 ff ff       	call   c0020cbc <thread_current>
c002b2df:	83 ec 0c             	sub    $0xc,%esp
c002b2e2:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c002b2e8:	83 c0 78             	add    $0x78,%eax
c002b2eb:	50                   	push   %eax
c002b2ec:	e8 8d 78 ff ff       	call   c0022b7e <sema_up>
			syscall_exit_helper(-1);
		}
		return;
	}
#endif
  syscall_exit_helper(-1);
c002b2f1:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002b2f8:	e8 0e 02 00 00       	call   c002b50b <syscall_exit_helper>

  /* To implement virtual memory, delete the rest of the function
     body, and replace it with code that brings in the page to
     which fault_addr refers. */
  printf ("Page fault at %p: %s error %s page in %s context.\n",
c002b2fd:	83 c4 10             	add    $0x10,%esp
c002b300:	f6 c3 04             	test   $0x4,%bl
c002b303:	75 34                	jne    c002b339 <page_fault+0x8d>
c002b305:	b9 fc 12 03 c0       	mov    $0xc00312fc,%ecx
c002b30a:	85 ed                	test   %ebp,%ebp
c002b30c:	75 32                	jne    c002b340 <page_fault+0x94>
c002b30e:	ba 3b 23 03 c0       	mov    $0xc003233b,%edx
c002b313:	85 ff                	test   %edi,%edi
c002b315:	74 30                	je     c002b347 <page_fault+0x9b>
c002b317:	b8 4f 23 03 c0       	mov    $0xc003234f,%eax
c002b31c:	83 ec 0c             	sub    $0xc,%esp
c002b31f:	51                   	push   %ecx
c002b320:	52                   	push   %edx
c002b321:	50                   	push   %eax
c002b322:	56                   	push   %esi
c002b323:	68 e0 22 03 c0       	push   $0xc00322e0
c002b328:	e8 4c b8 ff ff       	call   c0026b79 <printf>
          fault_addr,
          not_present ? "not present" : "rights violation",
          write ? "writing" : "reading",
          user ? "user" : "kernel");
  kill (f);
c002b32d:	83 c4 14             	add    $0x14,%esp
c002b330:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b334:	e8 e5 fe ff ff       	call   c002b21e <kill>
  printf ("Page fault at %p: %s error %s page in %s context.\n",
c002b339:	b9 2e 23 03 c0       	mov    $0xc003232e,%ecx
c002b33e:	eb ca                	jmp    c002b30a <page_fault+0x5e>
c002b340:	ba 33 23 03 c0       	mov    $0xc0032333,%edx
c002b345:	eb cc                	jmp    c002b313 <page_fault+0x67>
c002b347:	b8 43 23 03 c0       	mov    $0xc0032343,%eax
c002b34c:	eb ce                	jmp    c002b31c <page_fault+0x70>

c002b34e <exception_init>:
{
c002b34e:	83 ec 18             	sub    $0x18,%esp
  intr_register_int (3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
c002b351:	68 46 09 03 c0       	push   $0xc0030946
c002b356:	68 1e b2 02 c0       	push   $0xc002b21e
c002b35b:	6a 01                	push   $0x1
c002b35d:	6a 03                	push   $0x3
c002b35f:	6a 03                	push   $0x3
c002b361:	e8 6d 68 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (4, 3, INTR_ON, kill, "#OF Overflow Exception");
c002b366:	83 c4 14             	add    $0x14,%esp
c002b369:	68 5f 09 03 c0       	push   $0xc003095f
c002b36e:	68 1e b2 02 c0       	push   $0xc002b21e
c002b373:	6a 01                	push   $0x1
c002b375:	6a 03                	push   $0x3
c002b377:	6a 04                	push   $0x4
c002b379:	e8 55 68 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (5, 3, INTR_ON, kill,
c002b37e:	83 c4 14             	add    $0x14,%esp
c002b381:	68 9c 0a 03 c0       	push   $0xc0030a9c
c002b386:	68 1e b2 02 c0       	push   $0xc002b21e
c002b38b:	6a 01                	push   $0x1
c002b38d:	6a 03                	push   $0x3
c002b38f:	6a 05                	push   $0x5
c002b391:	e8 3d 68 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (0, 0, INTR_ON, kill, "#DE Divide Error");
c002b396:	83 c4 14             	add    $0x14,%esp
c002b399:	68 13 09 03 c0       	push   $0xc0030913
c002b39e:	68 1e b2 02 c0       	push   $0xc002b21e
c002b3a3:	6a 01                	push   $0x1
c002b3a5:	6a 00                	push   $0x0
c002b3a7:	6a 00                	push   $0x0
c002b3a9:	e8 25 68 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (1, 0, INTR_ON, kill, "#DB Debug Exception");
c002b3ae:	83 c4 14             	add    $0x14,%esp
c002b3b1:	68 24 09 03 c0       	push   $0xc0030924
c002b3b6:	68 1e b2 02 c0       	push   $0xc002b21e
c002b3bb:	6a 01                	push   $0x1
c002b3bd:	6a 00                	push   $0x0
c002b3bf:	6a 01                	push   $0x1
c002b3c1:	e8 0d 68 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
c002b3c6:	83 c4 14             	add    $0x14,%esp
c002b3c9:	68 76 09 03 c0       	push   $0xc0030976
c002b3ce:	68 1e b2 02 c0       	push   $0xc002b21e
c002b3d3:	6a 01                	push   $0x1
c002b3d5:	6a 00                	push   $0x0
c002b3d7:	6a 06                	push   $0x6
c002b3d9:	e8 f5 67 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (7, 0, INTR_ON, kill,
c002b3de:	83 c4 14             	add    $0x14,%esp
c002b3e1:	68 c0 0a 03 c0       	push   $0xc0030ac0
c002b3e6:	68 1e b2 02 c0       	push   $0xc002b21e
c002b3eb:	6a 01                	push   $0x1
c002b3ed:	6a 00                	push   $0x0
c002b3ef:	6a 07                	push   $0x7
c002b3f1:	e8 dd 67 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (11, 0, INTR_ON, kill, "#NP Segment Not Present");
c002b3f6:	83 c4 14             	add    $0x14,%esp
c002b3f9:	68 e4 09 03 c0       	push   $0xc00309e4
c002b3fe:	68 1e b2 02 c0       	push   $0xc002b21e
c002b403:	6a 01                	push   $0x1
c002b405:	6a 00                	push   $0x0
c002b407:	6a 0b                	push   $0xb
c002b409:	e8 c5 67 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
c002b40e:	83 c4 14             	add    $0x14,%esp
c002b411:	68 fc 09 03 c0       	push   $0xc00309fc
c002b416:	68 1e b2 02 c0       	push   $0xc002b21e
c002b41b:	6a 01                	push   $0x1
c002b41d:	6a 00                	push   $0x0
c002b41f:	6a 0c                	push   $0xc
c002b421:	e8 ad 67 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (13, 0, INTR_ON, kill, "#GP General Protection Exception");
c002b426:	83 c4 14             	add    $0x14,%esp
c002b429:	68 e4 0a 03 c0       	push   $0xc0030ae4
c002b42e:	68 1e b2 02 c0       	push   $0xc002b21e
c002b433:	6a 01                	push   $0x1
c002b435:	6a 00                	push   $0x0
c002b437:	6a 0d                	push   $0xd
c002b439:	e8 95 67 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
c002b43e:	83 c4 14             	add    $0x14,%esp
c002b441:	68 08 0b 03 c0       	push   $0xc0030b08
c002b446:	68 1e b2 02 c0       	push   $0xc002b21e
c002b44b:	6a 01                	push   $0x1
c002b44d:	6a 00                	push   $0x0
c002b44f:	6a 10                	push   $0x10
c002b451:	e8 7d 67 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (19, 0, INTR_ON, kill,
c002b456:	83 c4 14             	add    $0x14,%esp
c002b459:	68 2c 0b 03 c0       	push   $0xc0030b2c
c002b45e:	68 1e b2 02 c0       	push   $0xc002b21e
c002b463:	6a 01                	push   $0x1
c002b465:	6a 00                	push   $0x0
c002b467:	6a 13                	push   $0x13
c002b469:	e8 65 67 ff ff       	call   c0021bd3 <intr_register_int>
  intr_register_int (14, 0, INTR_OFF, page_fault, "#PF Page-Fault Exception");
c002b46e:	83 c4 14             	add    $0x14,%esp
c002b471:	68 16 0a 03 c0       	push   $0xc0030a16
c002b476:	68 ac b2 02 c0       	push   $0xc002b2ac
c002b47b:	6a 00                	push   $0x0
c002b47d:	6a 00                	push   $0x0
c002b47f:	6a 0e                	push   $0xe
c002b481:	e8 4d 67 ff ff       	call   c0021bd3 <intr_register_int>
}
c002b486:	83 c4 2c             	add    $0x2c,%esp
c002b489:	c3                   	ret    

c002b48a <exception_print_stats>:
{
c002b48a:	83 ec 10             	sub    $0x10,%esp
  printf ("Exception: %lld page faults\n", page_fault_cnt);
c002b48d:	ff 35 7c ce 03 c0    	pushl  0xc003ce7c
c002b493:	ff 35 78 ce 03 c0    	pushl  0xc003ce78
c002b499:	68 60 23 03 c0       	push   $0xc0032360
c002b49e:	e8 d6 b6 ff ff       	call   c0026b79 <printf>
}
c002b4a3:	83 c4 1c             	add    $0x1c,%esp
c002b4a6:	c3                   	ret    

c002b4a7 <get_file_by_fd>:
    return fd_e->fd;
  }
}

static struct fd_t*
get_file_by_fd(struct list* files, int fd) {
c002b4a7:	57                   	push   %edi
c002b4a8:	56                   	push   %esi
c002b4a9:	53                   	push   %ebx
c002b4aa:	89 c6                	mov    %eax,%esi
c002b4ac:	89 d7                	mov    %edx,%edi
  struct fd_t *entry;
  for (struct list_elem *e = list_begin(files); e != list_end(files); e = list_next(e)) {
c002b4ae:	83 ec 0c             	sub    $0xc,%esp
c002b4b1:	50                   	push   %eax
c002b4b2:	e8 5a d2 ff ff       	call   c0028711 <list_begin>
c002b4b7:	89 c3                	mov    %eax,%ebx
c002b4b9:	83 c4 10             	add    $0x10,%esp
c002b4bc:	83 ec 0c             	sub    $0xc,%esp
c002b4bf:	56                   	push   %esi
c002b4c0:	e8 c4 d2 ff ff       	call   c0028789 <list_end>
c002b4c5:	83 c4 10             	add    $0x10,%esp
c002b4c8:	39 c3                	cmp    %eax,%ebx
c002b4ca:	74 1a                	je     c002b4e6 <get_file_by_fd+0x3f>
    entry = list_entry(e, struct fd_t, elem);
    if (entry->fd == fd)
c002b4cc:	39 7b f8             	cmp    %edi,-0x8(%ebx)
c002b4cf:	74 10                	je     c002b4e1 <get_file_by_fd+0x3a>
  for (struct list_elem *e = list_begin(files); e != list_end(files); e = list_next(e)) {
c002b4d1:	83 ec 0c             	sub    $0xc,%esp
c002b4d4:	53                   	push   %ebx
c002b4d5:	e8 67 d2 ff ff       	call   c0028741 <list_next>
c002b4da:	89 c3                	mov    %eax,%ebx
c002b4dc:	83 c4 10             	add    $0x10,%esp
c002b4df:	eb db                	jmp    c002b4bc <get_file_by_fd+0x15>
    entry = list_entry(e, struct fd_t, elem);
c002b4e1:	8d 43 f4             	lea    -0xc(%ebx),%eax
c002b4e4:	eb 05                	jmp    c002b4eb <get_file_by_fd+0x44>
      return entry;
  }
  return NULL;
c002b4e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b4eb:	5b                   	pop    %ebx
c002b4ec:	5e                   	pop    %esi
c002b4ed:	5f                   	pop    %edi
c002b4ee:	c3                   	ret    

c002b4ef <syscall_init>:
{
c002b4ef:	83 ec 18             	sub    $0x18,%esp
  intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
c002b4f2:	68 7d 23 03 c0       	push   $0xc003237d
c002b4f7:	68 ae b5 02 c0       	push   $0xc002b5ae
c002b4fc:	6a 01                	push   $0x1
c002b4fe:	6a 03                	push   $0x3
c002b500:	6a 30                	push   $0x30
c002b502:	e8 cc 66 ff ff       	call   c0021bd3 <intr_register_int>
}
c002b507:	83 c4 2c             	add    $0x2c,%esp
c002b50a:	c3                   	ret    

c002b50b <syscall_exit_helper>:
syscall_exit_helper(int status) {
c002b50b:	53                   	push   %ebx
c002b50c:	83 ec 08             	sub    $0x8,%esp
c002b50f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  struct thread *t = thread_current();
c002b513:	e8 a4 57 ff ff       	call   c0020cbc <thread_current>
  t->ret_status = status;
c002b518:	89 58 68             	mov    %ebx,0x68(%eax)
  struct child_process *ch = get_child_by_tid(&t->parent->children, t->tid);
c002b51b:	83 ec 08             	sub    $0x8,%esp
c002b51e:	ff 70 04             	pushl  0x4(%eax)
c002b521:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c002b527:	05 a8 00 00 00       	add    $0xa8,%eax
c002b52c:	50                   	push   %eax
c002b52d:	e8 d6 61 ff ff       	call   c0021708 <get_child_by_tid>
  ch->ret_status = status;
c002b532:	89 58 04             	mov    %ebx,0x4(%eax)
  thread_exit();
c002b535:	e8 1a 62 ff ff       	call   c0021754 <thread_exit>

c002b53a <is_valid_addr>:
is_valid_addr(void *addr) {
c002b53a:	53                   	push   %ebx
c002b53b:	83 ec 08             	sub    $0x8,%esp
	if (!is_user_vaddr(addr) || !pagedir_get_page(thread_current()->pagedir, addr)) {
c002b53e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002b543:	77 21                	ja     c002b566 <is_valid_addr+0x2c>
c002b545:	89 c3                	mov    %eax,%ebx
c002b547:	e8 70 57 ff ff       	call   c0020cbc <thread_current>
c002b54c:	83 ec 08             	sub    $0x8,%esp
c002b54f:	53                   	push   %ebx
c002b550:	ff 70 64             	pushl  0x64(%eax)
c002b553:	e8 57 fa ff ff       	call   c002afaf <pagedir_get_page>
c002b558:	83 c4 10             	add    $0x10,%esp
c002b55b:	85 c0                	test   %eax,%eax
c002b55d:	74 07                	je     c002b566 <is_valid_addr+0x2c>
}
c002b55f:	b0 01                	mov    $0x1,%al
c002b561:	83 c4 08             	add    $0x8,%esp
c002b564:	5b                   	pop    %ebx
c002b565:	c3                   	ret    
		syscall_exit_helper(-1);
c002b566:	83 ec 0c             	sub    $0xc,%esp
c002b569:	6a ff                	push   $0xffffffff
c002b56b:	e8 9b ff ff ff       	call   c002b50b <syscall_exit_helper>

c002b570 <pop_stack>:
pop_stack(int *esp, void *dst, int offset) {
c002b570:	56                   	push   %esi
c002b571:	53                   	push   %ebx
c002b572:	83 ec 04             	sub    $0x4,%esp
  *((int *)dst) = *((int *)get_paddr(esp + offset));
c002b575:	8d 1c 88             	lea    (%eax,%ecx,4),%ebx
	if (!is_user_vaddr(vaddr) || !(ret = pagedir_get_page(thread_current()->pagedir, vaddr))) {
c002b578:	81 fb ff ff ff bf    	cmp    $0xbfffffff,%ebx
c002b57e:	77 24                	ja     c002b5a4 <pop_stack+0x34>
c002b580:	89 d6                	mov    %edx,%esi
c002b582:	e8 35 57 ff ff       	call   c0020cbc <thread_current>
c002b587:	83 ec 08             	sub    $0x8,%esp
c002b58a:	53                   	push   %ebx
c002b58b:	ff 70 64             	pushl  0x64(%eax)
c002b58e:	e8 1c fa ff ff       	call   c002afaf <pagedir_get_page>
c002b593:	83 c4 10             	add    $0x10,%esp
c002b596:	85 c0                	test   %eax,%eax
c002b598:	74 0a                	je     c002b5a4 <pop_stack+0x34>
  *((int *)dst) = *((int *)get_paddr(esp + offset));
c002b59a:	8b 00                	mov    (%eax),%eax
c002b59c:	89 06                	mov    %eax,(%esi)
}
c002b59e:	83 c4 04             	add    $0x4,%esp
c002b5a1:	5b                   	pop    %ebx
c002b5a2:	5e                   	pop    %esi
c002b5a3:	c3                   	ret    
		syscall_exit_helper(-1);
c002b5a4:	83 ec 0c             	sub    $0xc,%esp
c002b5a7:	6a ff                	push   $0xffffffff
c002b5a9:	e8 5d ff ff ff       	call   c002b50b <syscall_exit_helper>

c002b5ae <syscall_handler>:
{
c002b5ae:	55                   	push   %ebp
c002b5af:	57                   	push   %edi
c002b5b0:	56                   	push   %esi
c002b5b1:	53                   	push   %ebx
c002b5b2:	83 ec 2c             	sub    $0x2c,%esp
c002b5b5:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  is_valid_addr(f->esp);
c002b5b9:	8b 45 48             	mov    0x48(%ebp),%eax
c002b5bc:	e8 79 ff ff ff       	call   c002b53a <is_valid_addr>
  int sysnum = *(int*)f->esp;
c002b5c1:	8b 45 48             	mov    0x48(%ebp),%eax
c002b5c4:	8b 10                	mov    (%eax),%edx
  switch (sysnum) {
c002b5c6:	83 fa 13             	cmp    $0x13,%edx
c002b5c9:	0f 87 c7 09 00 00    	ja     c002bf96 <syscall_handler+0x9e8>
c002b5cf:	ff 24 95 84 fe 02 c0 	jmp    *-0x3ffd017c(,%edx,4)
  shutdown_power_off();
c002b5d6:	e8 52 ae ff ff       	call   c002642d <shutdown_power_off>
	pop_stack(f->esp, &status, 1);
c002b5db:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b5e0:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b5e4:	e8 87 ff ff ff       	call   c002b570 <pop_stack>
	syscall_exit_helper(status);
c002b5e9:	83 ec 0c             	sub    $0xc,%esp
c002b5ec:	ff 74 24 28          	pushl  0x28(%esp)
c002b5f0:	e8 16 ff ff ff       	call   c002b50b <syscall_exit_helper>
  pop_stack(f->esp, &file_name, 1);
c002b5f5:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b5fa:	8d 54 24 18          	lea    0x18(%esp),%edx
c002b5fe:	e8 6d ff ff ff       	call   c002b570 <pop_stack>
  if (!is_valid_addr(file_name)) {
c002b603:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b607:	e8 2e ff ff ff       	call   c002b53a <is_valid_addr>
c002b60c:	84 c0                	test   %al,%al
c002b60e:	0f 84 a8 00 00 00    	je     c002b6bc <syscall_handler+0x10e>
  lock_acquire(&filesys_lock);
c002b614:	83 ec 0c             	sub    $0xc,%esp
c002b617:	68 60 55 04 c0       	push   $0xc0045560
c002b61c:	e8 5c 78 ff ff       	call   c0022e7d <lock_acquire>
  char *fn_cp = malloc(strlen(file_name) + 1);
c002b621:	8b 5c 24 28          	mov    0x28(%esp),%ebx
c002b625:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b62a:	89 df                	mov    %ebx,%edi
c002b62c:	b0 00                	mov    $0x0,%al
c002b62e:	f2 ae                	repnz scas %es:(%edi),%al
c002b630:	f7 d1                	not    %ecx
c002b632:	89 0c 24             	mov    %ecx,(%esp)
c002b635:	e8 94 83 ff ff       	call   c00239ce <malloc>
c002b63a:	89 c6                	mov    %eax,%esi
  strlcpy(fn_cp, file_name, strlen(file_name) + 1);
c002b63c:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b641:	89 df                	mov    %ebx,%edi
c002b643:	b0 00                	mov    $0x0,%al
c002b645:	f2 ae                	repnz scas %es:(%edi),%al
c002b647:	f7 d1                	not    %ecx
c002b649:	83 c4 0c             	add    $0xc,%esp
c002b64c:	51                   	push   %ecx
c002b64d:	53                   	push   %ebx
c002b64e:	56                   	push   %esi
c002b64f:	e8 cd c6 ff ff       	call   c0027d21 <strlcpy>
  token = strtok_r(fn_cp, " ", &save_ptr);
c002b654:	83 c4 0c             	add    $0xc,%esp
c002b657:	8d 44 24 20          	lea    0x20(%esp),%eax
c002b65b:	50                   	push   %eax
c002b65c:	68 3a 1b 03 c0       	push   $0xc0031b3a
c002b661:	56                   	push   %esi
c002b662:	e8 e0 c4 ff ff       	call   c0027b47 <strtok_r>
  struct file *fi = filesys_open(token);
c002b667:	89 04 24             	mov    %eax,(%esp)
c002b66a:	e8 b3 0d 00 00       	call   c002c422 <filesys_open>
  if (fi == NULL) {
c002b66f:	83 c4 10             	add    $0x10,%esp
c002b672:	85 c0                	test   %eax,%eax
c002b674:	74 2f                	je     c002b6a5 <syscall_handler+0xf7>
    file_close(fi);
c002b676:	83 ec 0c             	sub    $0xc,%esp
c002b679:	50                   	push   %eax
c002b67a:	e8 93 13 00 00       	call   c002ca12 <file_close>
    lock_release(&filesys_lock);
c002b67f:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002b686:	e8 8f 79 ff ff       	call   c002301a <lock_release>
    return process_execute(file_name);
c002b68b:	83 c4 04             	add    $0x4,%esp
c002b68e:	ff 74 24 24          	pushl  0x24(%esp)
c002b692:	e8 51 eb ff ff       	call   c002a1e8 <process_execute>
c002b697:	83 c4 10             	add    $0x10,%esp
	  case SYS_EXEC: f->eax = syscall_exec(f); break;
c002b69a:	89 45 1c             	mov    %eax,0x1c(%ebp)
}
c002b69d:	83 c4 2c             	add    $0x2c,%esp
c002b6a0:	5b                   	pop    %ebx
c002b6a1:	5e                   	pop    %esi
c002b6a2:	5f                   	pop    %edi
c002b6a3:	5d                   	pop    %ebp
c002b6a4:	c3                   	ret    
    lock_release(&filesys_lock);
c002b6a5:	83 ec 0c             	sub    $0xc,%esp
c002b6a8:	68 60 55 04 c0       	push   $0xc0045560
c002b6ad:	e8 68 79 ff ff       	call   c002301a <lock_release>
c002b6b2:	83 c4 10             	add    $0x10,%esp
    return -1;
c002b6b5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b6ba:	eb de                	jmp    c002b69a <syscall_handler+0xec>
    return -1;
c002b6bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b6c1:	eb d7                	jmp    c002b69a <syscall_handler+0xec>
  pop_stack(f->esp, &tid, 1);
c002b6c3:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b6c8:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b6cc:	e8 9f fe ff ff       	call   c002b570 <pop_stack>
  return process_wait(tid);
c002b6d1:	83 ec 0c             	sub    $0xc,%esp
c002b6d4:	ff 74 24 28          	pushl  0x28(%esp)
c002b6d8:	e8 da eb ff ff       	call   c002a2b7 <process_wait>
	  case SYS_WAIT: f->eax = syscall_wait(f); break;
c002b6dd:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002b6e0:	83 c4 10             	add    $0x10,%esp
c002b6e3:	eb b8                	jmp    c002b69d <syscall_handler+0xef>
  pop_stack(f->esp, &size, 2);
c002b6e5:	b9 02 00 00 00       	mov    $0x2,%ecx
c002b6ea:	8d 54 24 18          	lea    0x18(%esp),%edx
c002b6ee:	e8 7d fe ff ff       	call   c002b570 <pop_stack>
  pop_stack(f->esp, &file_name, 1);
c002b6f3:	8b 45 48             	mov    0x48(%ebp),%eax
c002b6f6:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b6fb:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b6ff:	e8 6c fe ff ff       	call   c002b570 <pop_stack>
  if (!is_valid_addr(file_name))
c002b704:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b708:	e8 2d fe ff ff       	call   c002b53a <is_valid_addr>
c002b70d:	88 c3                	mov    %al,%bl
c002b70f:	84 c0                	test   %al,%al
c002b711:	75 08                	jne    c002b71b <syscall_handler+0x16d>
	  case SYS_CREATE: f->eax = syscall_create(f); break;
c002b713:	0f b6 db             	movzbl %bl,%ebx
c002b716:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002b719:	eb 82                	jmp    c002b69d <syscall_handler+0xef>
  lock_acquire(&filesys_lock);
c002b71b:	83 ec 0c             	sub    $0xc,%esp
c002b71e:	68 60 55 04 c0       	push   $0xc0045560
c002b723:	e8 55 77 ff ff       	call   c0022e7d <lock_acquire>
  ret = filesys_create(file_name, size);
c002b728:	83 c4 08             	add    $0x8,%esp
c002b72b:	ff 74 24 20          	pushl  0x20(%esp)
c002b72f:	ff 74 24 28          	pushl  0x28(%esp)
c002b733:	e8 42 0c 00 00       	call   c002c37a <filesys_create>
c002b738:	88 c3                	mov    %al,%bl
  lock_release(&filesys_lock);
c002b73a:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002b741:	e8 d4 78 ff ff       	call   c002301a <lock_release>
c002b746:	83 c4 10             	add    $0x10,%esp
c002b749:	eb c8                	jmp    c002b713 <syscall_handler+0x165>
  pop_stack(f->esp, &file_name, 1);
c002b74b:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b750:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b754:	e8 17 fe ff ff       	call   c002b570 <pop_stack>
  if (!is_valid_addr(file_name))
c002b759:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b75d:	e8 d8 fd ff ff       	call   c002b53a <is_valid_addr>
c002b762:	88 c3                	mov    %al,%bl
c002b764:	84 c0                	test   %al,%al
c002b766:	75 0b                	jne    c002b773 <syscall_handler+0x1c5>
	  case SYS_REMOVE: f->eax = syscall_remove(f); break;
c002b768:	0f b6 db             	movzbl %bl,%ebx
c002b76b:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002b76e:	e9 2a ff ff ff       	jmp    c002b69d <syscall_handler+0xef>
  lock_acquire(&filesys_lock);
c002b773:	83 ec 0c             	sub    $0xc,%esp
c002b776:	68 60 55 04 c0       	push   $0xc0045560
c002b77b:	e8 fd 76 ff ff       	call   c0022e7d <lock_acquire>
  ret = filesys_remove(file_name);
c002b780:	83 c4 04             	add    $0x4,%esp
c002b783:	ff 74 24 28          	pushl  0x28(%esp)
c002b787:	e8 e8 0d 00 00       	call   c002c574 <filesys_remove>
c002b78c:	88 c3                	mov    %al,%bl
  lock_release(&filesys_lock);
c002b78e:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002b795:	e8 80 78 ff ff       	call   c002301a <lock_release>
c002b79a:	83 c4 10             	add    $0x10,%esp
c002b79d:	eb c9                	jmp    c002b768 <syscall_handler+0x1ba>
	pop_stack(f->esp, &file_name, 1);
c002b79f:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b7a4:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b7a8:	e8 c3 fd ff ff       	call   c002b570 <pop_stack>
	if (!is_valid_addr(file_name)) {
c002b7ad:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b7b1:	e8 84 fd ff ff       	call   c002b53a <is_valid_addr>
c002b7b6:	84 c0                	test   %al,%al
c002b7b8:	0f 84 ac 00 00 00    	je     c002b86a <syscall_handler+0x2bc>
	lock_acquire(&filesys_lock);
c002b7be:	83 ec 0c             	sub    $0xc,%esp
c002b7c1:	68 60 55 04 c0       	push   $0xc0045560
c002b7c6:	e8 b2 76 ff ff       	call   c0022e7d <lock_acquire>
	struct file *fi = filesys_open(file_name);
c002b7cb:	83 c4 04             	add    $0x4,%esp
c002b7ce:	ff 74 24 28          	pushl  0x28(%esp)
c002b7d2:	e8 4b 0c 00 00       	call   c002c422 <filesys_open>
c002b7d7:	89 c7                	mov    %eax,%edi
	lock_release(&filesys_lock);
c002b7d9:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002b7e0:	e8 35 78 ff ff       	call   c002301a <lock_release>
	if (fi == NULL) {
c002b7e5:	83 c4 10             	add    $0x10,%esp
c002b7e8:	85 ff                	test   %edi,%edi
c002b7ea:	0f 84 81 00 00 00    	je     c002b871 <syscall_handler+0x2c3>
    struct fd_t *fd_e = malloc(sizeof(*fd_e));
c002b7f0:	83 ec 0c             	sub    $0xc,%esp
c002b7f3:	6a 14                	push   $0x14
c002b7f5:	e8 d4 81 ff ff       	call   c00239ce <malloc>
c002b7fa:	89 c6                	mov    %eax,%esi
    fd_e->ptr = fi;
c002b7fc:	89 38                	mov    %edi,(%eax)
    struct thread *t = thread_current();
c002b7fe:	e8 b9 54 ff ff       	call   c0020cbc <thread_current>
c002b803:	89 c3                	mov    %eax,%ebx
    fd_e->fd = t->file_cnt++;
c002b805:	8b 40 6c             	mov    0x6c(%eax),%eax
c002b808:	8d 50 01             	lea    0x1(%eax),%edx
c002b80b:	89 53 6c             	mov    %edx,0x6c(%ebx)
c002b80e:	89 46 04             	mov    %eax,0x4(%esi)
    if (inode_is_dir(file_get_inode(fi))) {
c002b811:	89 3c 24             	mov    %edi,(%esp)
c002b814:	e8 e0 10 00 00       	call   c002c8f9 <file_get_inode>
c002b819:	89 04 24             	mov    %eax,(%esp)
c002b81c:	e8 ad 27 00 00       	call   c002dfce <inode_is_dir>
c002b821:	83 c4 10             	add    $0x10,%esp
c002b824:	84 c0                	test   %al,%al
c002b826:	75 21                	jne    c002b849 <syscall_handler+0x29b>
    list_push_back(&t->files, &fd_e->elem);
c002b828:	83 ec 08             	sub    $0x8,%esp
c002b82b:	8d 46 0c             	lea    0xc(%esi),%eax
c002b82e:	50                   	push   %eax
c002b82f:	81 c3 bc 00 00 00    	add    $0xbc,%ebx
c002b835:	53                   	push   %ebx
c002b836:	e8 df d2 ff ff       	call   c0028b1a <list_push_back>
    return fd_e->fd;
c002b83b:	8b 46 04             	mov    0x4(%esi),%eax
c002b83e:	83 c4 10             	add    $0x10,%esp
	  case SYS_OPEN: f->eax = syscall_open(f); break;
c002b841:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002b844:	e9 54 fe ff ff       	jmp    c002b69d <syscall_handler+0xef>
      fd_e->opened_dir = dir_open(inode_reopen(file_get_inode(fi)));
c002b849:	83 ec 0c             	sub    $0xc,%esp
c002b84c:	57                   	push   %edi
c002b84d:	e8 a7 10 00 00       	call   c002c8f9 <file_get_inode>
c002b852:	89 04 24             	mov    %eax,(%esp)
c002b855:	e8 f0 21 00 00       	call   c002da4a <inode_reopen>
c002b85a:	89 04 24             	mov    %eax,(%esp)
c002b85d:	e8 95 13 00 00       	call   c002cbf7 <dir_open>
c002b862:	89 46 08             	mov    %eax,0x8(%esi)
c002b865:	83 c4 10             	add    $0x10,%esp
c002b868:	eb be                	jmp    c002b828 <syscall_handler+0x27a>
		return -1;
c002b86a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b86f:	eb d0                	jmp    c002b841 <syscall_handler+0x293>
		return -1;
c002b871:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b876:	eb c9                	jmp    c002b841 <syscall_handler+0x293>

static int
syscall_filesize(struct intr_frame *f) {
  int fd;
  pop_stack(f->esp, &fd, 1);
c002b878:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b87d:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b881:	e8 ea fc ff ff       	call   c002b570 <pop_stack>
  lock_acquire(&filesys_lock);
c002b886:	83 ec 0c             	sub    $0xc,%esp
c002b889:	68 60 55 04 c0       	push   $0xc0045560
c002b88e:	e8 ea 75 ff ff       	call   c0022e7d <lock_acquire>
  int ret = file_length(get_file_by_fd(&thread_current()->files, fd)->ptr);
c002b893:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c002b897:	e8 20 54 ff ff       	call   c0020cbc <thread_current>
c002b89c:	05 bc 00 00 00       	add    $0xbc,%eax
c002b8a1:	89 da                	mov    %ebx,%edx
c002b8a3:	e8 ff fb ff ff       	call   c002b4a7 <get_file_by_fd>
c002b8a8:	83 c4 04             	add    $0x4,%esp
c002b8ab:	ff 30                	pushl  (%eax)
c002b8ad:	e8 9a 11 00 00       	call   c002ca4c <file_length>
c002b8b2:	89 c3                	mov    %eax,%ebx
  lock_release(&filesys_lock);
c002b8b4:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002b8bb:	e8 5a 77 ff ff       	call   c002301a <lock_release>
	  case SYS_FILESIZE: f->eax = syscall_filesize(f); break;
c002b8c0:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002b8c3:	83 c4 10             	add    $0x10,%esp
c002b8c6:	e9 d2 fd ff ff       	jmp    c002b69d <syscall_handler+0xef>
syscall_read(struct intr_frame *f) {
	int size;
	char *buffer;
	int fd;

	pop_stack(f->esp, &size, 3);
c002b8cb:	b9 03 00 00 00       	mov    $0x3,%ecx
c002b8d0:	8d 54 24 14          	lea    0x14(%esp),%edx
c002b8d4:	e8 97 fc ff ff       	call   c002b570 <pop_stack>
	pop_stack(f->esp, &buffer, 2);
c002b8d9:	8b 45 48             	mov    0x48(%ebp),%eax
c002b8dc:	b9 02 00 00 00       	mov    $0x2,%ecx
c002b8e1:	8d 54 24 18          	lea    0x18(%esp),%edx
c002b8e5:	e8 86 fc ff ff       	call   c002b570 <pop_stack>
	pop_stack(f->esp, &fd, 1);
c002b8ea:	8b 45 48             	mov    0x48(%ebp),%eax
c002b8ed:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b8f2:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b8f6:	e8 75 fc ff ff       	call   c002b570 <pop_stack>

	int ret = 0;

	struct fd_t* fd_e;
	if (fd != 0) {
c002b8fb:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002b8ff:	85 db                	test   %ebx,%ebx
c002b901:	75 18                	jne    c002b91b <syscall_handler+0x36d>
		fd_e = get_file_by_fd(&thread_current()->files, fd);
		if (fd_e == NULL)
			return -1;
	}

	while (size > 0) {
c002b903:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c002b908:	0f 8e d6 00 00 00    	jle    c002b9e4 <syscall_handler+0x436>
c002b90e:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!is_valid_addr(buffer))
			return -1;

		int page_left = PGSIZE - pg_ofs(buffer);
c002b913:	89 6c 24 40          	mov    %ebp,0x40(%esp)
c002b917:	89 c5                	mov    %eax,%ebp
c002b919:	eb 59                	jmp    c002b974 <syscall_handler+0x3c6>
		fd_e = get_file_by_fd(&thread_current()->files, fd);
c002b91b:	e8 9c 53 ff ff       	call   c0020cbc <thread_current>
c002b920:	05 bc 00 00 00       	add    $0xbc,%eax
c002b925:	89 da                	mov    %ebx,%edx
c002b927:	e8 7b fb ff ff       	call   c002b4a7 <get_file_by_fd>
c002b92c:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (fd_e == NULL)
c002b930:	85 c0                	test   %eax,%eax
c002b932:	75 cf                	jne    c002b903 <syscall_handler+0x355>
			return -1;
c002b934:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b939:	e9 b6 00 00 00       	jmp    c002b9f4 <syscall_handler+0x446>
		int read_size = size < page_left ? size : page_left;
		off_t ofs;

		if (fd == 0) {
c002b93e:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002b942:	85 db                	test   %ebx,%ebx
c002b944:	75 59                	jne    c002b99f <syscall_handler+0x3f1>
			for (int i = 0; i < read_size; ++i) {
c002b946:	85 ff                	test   %edi,%edi
c002b948:	0f 8e 82 00 00 00    	jle    c002b9d0 <syscall_handler+0x422>
				buffer[i] = input_getc();
c002b94e:	89 de                	mov    %ebx,%esi
c002b950:	03 74 24 18          	add    0x18(%esp),%esi
c002b954:	e8 51 a4 ff ff       	call   c0025daa <input_getc>
c002b959:	88 06                	mov    %al,(%esi)
			for (int i = 0; i < read_size; ++i) {
c002b95b:	43                   	inc    %ebx
c002b95c:	39 df                	cmp    %ebx,%edi
c002b95e:	75 ee                	jne    c002b94e <syscall_handler+0x3a0>
			lock_release(&filesys_lock);
		}
//		printf("ofs = %x\n", size);
		if (ofs == 0)
			break;
		ret += ofs;
c002b960:	01 fd                	add    %edi,%ebp
		buffer += ofs;
c002b962:	01 7c 24 18          	add    %edi,0x18(%esp)
		size -= ofs;
c002b966:	8b 44 24 14          	mov    0x14(%esp),%eax
c002b96a:	29 f8                	sub    %edi,%eax
c002b96c:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (size > 0) {
c002b970:	85 c0                	test   %eax,%eax
c002b972:	7e 68                	jle    c002b9dc <syscall_handler+0x42e>
		if (!is_valid_addr(buffer))
c002b974:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b978:	e8 bd fb ff ff       	call   c002b53a <is_valid_addr>
c002b97d:	84 c0                	test   %al,%al
c002b97f:	74 6a                	je     c002b9eb <syscall_handler+0x43d>
  return (uintptr_t) va & PGMASK;
c002b981:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b985:	25 ff 0f 00 00       	and    $0xfff,%eax
		int page_left = PGSIZE - pg_ofs(buffer);
c002b98a:	b9 00 10 00 00       	mov    $0x1000,%ecx
c002b98f:	29 c1                	sub    %eax,%ecx
		int read_size = size < page_left ? size : page_left;
c002b991:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b995:	89 cf                	mov    %ecx,%edi
c002b997:	39 d1                	cmp    %edx,%ecx
c002b999:	7e a3                	jle    c002b93e <syscall_handler+0x390>
c002b99b:	89 d7                	mov    %edx,%edi
c002b99d:	eb 9f                	jmp    c002b93e <syscall_handler+0x390>
			lock_acquire(&filesys_lock);
c002b99f:	83 ec 0c             	sub    $0xc,%esp
c002b9a2:	68 60 55 04 c0       	push   $0xc0045560
c002b9a7:	e8 d1 74 ff ff       	call   c0022e7d <lock_acquire>
			ofs = file_read(fd_e->ptr, buffer, read_size);
c002b9ac:	83 c4 0c             	add    $0xc,%esp
c002b9af:	57                   	push   %edi
c002b9b0:	ff 74 24 20          	pushl  0x20(%esp)
c002b9b4:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b9b8:	ff 30                	pushl  (%eax)
c002b9ba:	e8 41 0f 00 00       	call   c002c900 <file_read>
c002b9bf:	89 c7                	mov    %eax,%edi
			lock_release(&filesys_lock);
c002b9c1:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002b9c8:	e8 4d 76 ff ff       	call   c002301a <lock_release>
c002b9cd:	83 c4 10             	add    $0x10,%esp
		if (ofs == 0)
c002b9d0:	85 ff                	test   %edi,%edi
c002b9d2:	75 8c                	jne    c002b960 <syscall_handler+0x3b2>
c002b9d4:	89 e8                	mov    %ebp,%eax
c002b9d6:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c002b9da:	eb 18                	jmp    c002b9f4 <syscall_handler+0x446>
c002b9dc:	89 e8                	mov    %ebp,%eax
c002b9de:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c002b9e2:	eb 10                	jmp    c002b9f4 <syscall_handler+0x446>
	while (size > 0) {
c002b9e4:	b8 00 00 00 00       	mov    $0x0,%eax
c002b9e9:	eb 09                	jmp    c002b9f4 <syscall_handler+0x446>
c002b9eb:	8b 6c 24 40          	mov    0x40(%esp),%ebp
			return -1;
c002b9ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	  case SYS_READ: f->eax = syscall_read(f); break;
c002b9f4:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002b9f7:	e9 a1 fc ff ff       	jmp    c002b69d <syscall_handler+0xef>
syscall_write(struct intr_frame *f) {
  int size;
  char *buffer;
  int fd;

  pop_stack(f->esp, &size, 3);
c002b9fc:	b9 03 00 00 00       	mov    $0x3,%ecx
c002ba01:	8d 54 24 14          	lea    0x14(%esp),%edx
c002ba05:	e8 66 fb ff ff       	call   c002b570 <pop_stack>
  pop_stack(f->esp, &buffer, 2);
c002ba0a:	8b 45 48             	mov    0x48(%ebp),%eax
c002ba0d:	b9 02 00 00 00       	mov    $0x2,%ecx
c002ba12:	8d 54 24 18          	lea    0x18(%esp),%edx
c002ba16:	e8 55 fb ff ff       	call   c002b570 <pop_stack>
  pop_stack(f->esp, &fd, 1);
c002ba1b:	8b 45 48             	mov    0x48(%ebp),%eax
c002ba1e:	b9 01 00 00 00       	mov    $0x1,%ecx
c002ba23:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002ba27:	e8 44 fb ff ff       	call   c002b570 <pop_stack>

  if (!is_valid_addr(buffer)) {
c002ba2c:	8b 44 24 18          	mov    0x18(%esp),%eax
c002ba30:	e8 05 fb ff ff       	call   c002b53a <is_valid_addr>
c002ba35:	84 c0                	test   %al,%al
c002ba37:	0f 84 dd 00 00 00    	je     c002bb1a <syscall_handler+0x56c>
  }

	int ret = 0;

	struct fd_t* fd_e;
	if (fd != 1) {
c002ba3d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002ba41:	83 fb 01             	cmp    $0x1,%ebx
c002ba44:	74 38                	je     c002ba7e <syscall_handler+0x4d0>
		fd_e = get_file_by_fd(&thread_current()->files, fd);
c002ba46:	e8 71 52 ff ff       	call   c0020cbc <thread_current>
c002ba4b:	05 bc 00 00 00       	add    $0xbc,%eax
c002ba50:	89 da                	mov    %ebx,%edx
c002ba52:	e8 50 fa ff ff       	call   c002b4a7 <get_file_by_fd>
c002ba57:	89 c7                	mov    %eax,%edi
		if (fd_e == NULL || inode_is_dir (file_get_inode(fd_e->ptr)))
c002ba59:	85 c0                	test   %eax,%eax
c002ba5b:	0f 84 c0 00 00 00    	je     c002bb21 <syscall_handler+0x573>
c002ba61:	83 ec 0c             	sub    $0xc,%esp
c002ba64:	ff 30                	pushl  (%eax)
c002ba66:	e8 8e 0e 00 00       	call   c002c8f9 <file_get_inode>
c002ba6b:	89 04 24             	mov    %eax,(%esp)
c002ba6e:	e8 5b 25 00 00       	call   c002dfce <inode_is_dir>
c002ba73:	83 c4 10             	add    $0x10,%esp
c002ba76:	84 c0                	test   %al,%al
c002ba78:	0f 85 aa 00 00 00    	jne    c002bb28 <syscall_handler+0x57a>
			return -1;
	}

	while (size > 0) {
c002ba7e:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c002ba83:	0f 8e a6 00 00 00    	jle    c002bb2f <syscall_handler+0x581>
c002ba89:	be 00 00 00 00       	mov    $0x0,%esi
c002ba8e:	eb 4c                	jmp    c002badc <syscall_handler+0x52e>
			return -1;
		int page_left = PGSIZE - pg_ofs(buffer);
		int write_size = size < page_left ? size : page_left;
		off_t ofs;

		if (fd == 1) {
c002ba90:	83 7c 24 1c 01       	cmpl   $0x1,0x1c(%esp)
c002ba95:	74 74                	je     c002bb0b <syscall_handler+0x55d>
			putbuf(buffer, write_size);
			ofs = write_size;
		}
		else {
			lock_acquire(&filesys_lock);
c002ba97:	83 ec 0c             	sub    $0xc,%esp
c002ba9a:	68 60 55 04 c0       	push   $0xc0045560
c002ba9f:	e8 d9 73 ff ff       	call   c0022e7d <lock_acquire>
			ofs = file_write(fd_e->ptr, buffer, write_size);
c002baa4:	83 c4 0c             	add    $0xc,%esp
c002baa7:	53                   	push   %ebx
c002baa8:	ff 74 24 20          	pushl  0x20(%esp)
c002baac:	ff 37                	pushl  (%edi)
c002baae:	e8 8d 0e 00 00       	call   c002c940 <file_write>
c002bab3:	89 c3                	mov    %eax,%ebx
			lock_release(&filesys_lock);
c002bab5:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002babc:	e8 59 75 ff ff       	call   c002301a <lock_release>
c002bac1:	83 c4 10             	add    $0x10,%esp
		}
//		printf("ofs = %x\n", size);

		if (ofs == 0)
c002bac4:	85 db                	test   %ebx,%ebx
c002bac6:	74 73                	je     c002bb3b <syscall_handler+0x58d>
			break;
		ret += ofs;
c002bac8:	01 de                	add    %ebx,%esi
		buffer += ofs;
c002baca:	01 5c 24 18          	add    %ebx,0x18(%esp)
		size -= ofs;
c002bace:	8b 44 24 14          	mov    0x14(%esp),%eax
c002bad2:	29 d8                	sub    %ebx,%eax
c002bad4:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (size > 0) {
c002bad8:	85 c0                	test   %eax,%eax
c002bada:	7e 5f                	jle    c002bb3b <syscall_handler+0x58d>
		if (!is_valid_addr(buffer))
c002badc:	8b 44 24 18          	mov    0x18(%esp),%eax
c002bae0:	e8 55 fa ff ff       	call   c002b53a <is_valid_addr>
c002bae5:	84 c0                	test   %al,%al
c002bae7:	74 4d                	je     c002bb36 <syscall_handler+0x588>
		int page_left = PGSIZE - pg_ofs(buffer);
c002bae9:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c002baed:	89 c8                	mov    %ecx,%eax
c002baef:	25 ff 0f 00 00       	and    $0xfff,%eax
c002baf4:	ba 00 10 00 00       	mov    $0x1000,%edx
c002baf9:	29 c2                	sub    %eax,%edx
c002bafb:	89 d0                	mov    %edx,%eax
		int write_size = size < page_left ? size : page_left;
c002bafd:	8b 54 24 14          	mov    0x14(%esp),%edx
c002bb01:	89 c3                	mov    %eax,%ebx
c002bb03:	39 d0                	cmp    %edx,%eax
c002bb05:	7e 89                	jle    c002ba90 <syscall_handler+0x4e2>
c002bb07:	89 d3                	mov    %edx,%ebx
c002bb09:	eb 85                	jmp    c002ba90 <syscall_handler+0x4e2>
			putbuf(buffer, write_size);
c002bb0b:	83 ec 08             	sub    $0x8,%esp
c002bb0e:	53                   	push   %ebx
c002bb0f:	51                   	push   %ecx
c002bb10:	e8 34 e6 ff ff       	call   c002a149 <putbuf>
c002bb15:	83 c4 10             	add    $0x10,%esp
c002bb18:	eb aa                	jmp    c002bac4 <syscall_handler+0x516>
    return -1;
c002bb1a:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002bb1f:	eb 1a                	jmp    c002bb3b <syscall_handler+0x58d>
			return -1;
c002bb21:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002bb26:	eb 13                	jmp    c002bb3b <syscall_handler+0x58d>
c002bb28:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002bb2d:	eb 0c                	jmp    c002bb3b <syscall_handler+0x58d>
	while (size > 0) {
c002bb2f:	be 00 00 00 00       	mov    $0x0,%esi
c002bb34:	eb 05                	jmp    c002bb3b <syscall_handler+0x58d>
			return -1;
c002bb36:	be ff ff ff ff       	mov    $0xffffffff,%esi
	  case SYS_WRITE: f->eax = syscall_write(f); break;
c002bb3b:	89 75 1c             	mov    %esi,0x1c(%ebp)
c002bb3e:	e9 5a fb ff ff       	jmp    c002b69d <syscall_handler+0xef>
}

static void
syscall_seek(struct intr_frame *f) {
	int fd, pos;
	pop_stack(f->esp, &pos, 2);
c002bb43:	b9 02 00 00 00       	mov    $0x2,%ecx
c002bb48:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bb4c:	e8 1f fa ff ff       	call   c002b570 <pop_stack>
	pop_stack(f->esp, &fd, 1);
c002bb51:	8b 45 48             	mov    0x48(%ebp),%eax
c002bb54:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bb59:	8d 54 24 18          	lea    0x18(%esp),%edx
c002bb5d:	e8 0e fa ff ff       	call   c002b570 <pop_stack>

  lock_acquire(&filesys_lock);
c002bb62:	83 ec 0c             	sub    $0xc,%esp
c002bb65:	68 60 55 04 c0       	push   $0xc0045560
c002bb6a:	e8 0e 73 ff ff       	call   c0022e7d <lock_acquire>
  file_seek(get_file_by_fd(&thread_current()->files, fd)->ptr, pos);
c002bb6f:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c002bb73:	8b 74 24 28          	mov    0x28(%esp),%esi
c002bb77:	e8 40 51 ff ff       	call   c0020cbc <thread_current>
c002bb7c:	05 bc 00 00 00       	add    $0xbc,%eax
c002bb81:	89 f2                	mov    %esi,%edx
c002bb83:	e8 1f f9 ff ff       	call   c002b4a7 <get_file_by_fd>
c002bb88:	83 c4 08             	add    $0x8,%esp
c002bb8b:	53                   	push   %ebx
c002bb8c:	ff 30                	pushl  (%eax)
c002bb8e:	e8 f3 0e 00 00       	call   c002ca86 <file_seek>
  lock_release(&filesys_lock);
c002bb93:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002bb9a:	e8 7b 74 ff ff       	call   c002301a <lock_release>
c002bb9f:	83 c4 10             	add    $0x10,%esp
c002bba2:	e9 f6 fa ff ff       	jmp    c002b69d <syscall_handler+0xef>
}

static int
syscall_tell(struct intr_frame *f) {
  int fd;
  pop_stack(f->esp, &fd, 1);
c002bba7:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bbac:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bbb0:	e8 bb f9 ff ff       	call   c002b570 <pop_stack>

  lock_acquire(&filesys_lock);
c002bbb5:	83 ec 0c             	sub    $0xc,%esp
c002bbb8:	68 60 55 04 c0       	push   $0xc0045560
c002bbbd:	e8 bb 72 ff ff       	call   c0022e7d <lock_acquire>
  struct fd_t* fd_e = get_file_by_fd(&thread_current()->files, fd);
c002bbc2:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c002bbc6:	e8 f1 50 ff ff       	call   c0020cbc <thread_current>
c002bbcb:	05 bc 00 00 00       	add    $0xbc,%eax
c002bbd0:	89 da                	mov    %ebx,%edx
c002bbd2:	e8 d0 f8 ff ff       	call   c002b4a7 <get_file_by_fd>
c002bbd7:	89 c3                	mov    %eax,%ebx
  int ret;
  if (fd_e == NULL || inode_is_dir (file_get_inode(fd_e->ptr))) {
c002bbd9:	83 c4 10             	add    $0x10,%esp
c002bbdc:	85 c0                	test   %eax,%eax
c002bbde:	74 40                	je     c002bc20 <syscall_handler+0x672>
c002bbe0:	83 ec 0c             	sub    $0xc,%esp
c002bbe3:	ff 30                	pushl  (%eax)
c002bbe5:	e8 0f 0d 00 00       	call   c002c8f9 <file_get_inode>
c002bbea:	89 04 24             	mov    %eax,(%esp)
c002bbed:	e8 dc 23 00 00       	call   c002dfce <inode_is_dir>
c002bbf2:	83 c4 10             	add    $0x10,%esp
c002bbf5:	84 c0                	test   %al,%al
c002bbf7:	75 2e                	jne    c002bc27 <syscall_handler+0x679>
    ret = -1;
  } else {
    ret = file_tell(fd_e->ptr);
c002bbf9:	83 ec 0c             	sub    $0xc,%esp
c002bbfc:	ff 33                	pushl  (%ebx)
c002bbfe:	e8 df 0e 00 00       	call   c002cae2 <file_tell>
c002bc03:	89 c3                	mov    %eax,%ebx
c002bc05:	83 c4 10             	add    $0x10,%esp
  }
  lock_release(&filesys_lock);
c002bc08:	83 ec 0c             	sub    $0xc,%esp
c002bc0b:	68 60 55 04 c0       	push   $0xc0045560
c002bc10:	e8 05 74 ff ff       	call   c002301a <lock_release>
	  case SYS_TELL: f->eax = syscall_tell(f); break;
c002bc15:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002bc18:	83 c4 10             	add    $0x10,%esp
c002bc1b:	e9 7d fa ff ff       	jmp    c002b69d <syscall_handler+0xef>
    ret = -1;
c002bc20:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002bc25:	eb e1                	jmp    c002bc08 <syscall_handler+0x65a>
c002bc27:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002bc2c:	eb da                	jmp    c002bc08 <syscall_handler+0x65a>
}

static void
syscall_close(struct intr_frame *f) {
  int fd;
  pop_stack(f->esp, &fd, 1);
c002bc2e:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bc33:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bc37:	e8 34 f9 ff ff       	call   c002b570 <pop_stack>
  struct fd_t *entry = get_file_by_fd(&thread_current()->files, fd);
c002bc3c:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002bc40:	e8 77 50 ff ff       	call   c0020cbc <thread_current>
c002bc45:	05 bc 00 00 00       	add    $0xbc,%eax
c002bc4a:	89 da                	mov    %ebx,%edx
c002bc4c:	e8 56 f8 ff ff       	call   c002b4a7 <get_file_by_fd>
c002bc51:	89 c3                	mov    %eax,%ebx
  if (entry != NULL) {
c002bc53:	85 c0                	test   %eax,%eax
c002bc55:	0f 84 42 fa ff ff    	je     c002b69d <syscall_handler+0xef>
    lock_acquire(&filesys_lock);
c002bc5b:	83 ec 0c             	sub    $0xc,%esp
c002bc5e:	68 60 55 04 c0       	push   $0xc0045560
c002bc63:	e8 15 72 ff ff       	call   c0022e7d <lock_acquire>
#ifdef FILESYS
    if (inode_is_dir (file_get_inode(entry->ptr)))
c002bc68:	83 c4 04             	add    $0x4,%esp
c002bc6b:	ff 33                	pushl  (%ebx)
c002bc6d:	e8 87 0c 00 00       	call   c002c8f9 <file_get_inode>
c002bc72:	89 04 24             	mov    %eax,(%esp)
c002bc75:	e8 54 23 00 00       	call   c002dfce <inode_is_dir>
c002bc7a:	83 c4 10             	add    $0x10,%esp
c002bc7d:	84 c0                	test   %al,%al
c002bc7f:	75 31                	jne    c002bcb2 <syscall_handler+0x704>
      dir_close (entry->opened_dir);
#endif
    file_close(entry->ptr);
c002bc81:	83 ec 0c             	sub    $0xc,%esp
c002bc84:	ff 33                	pushl  (%ebx)
c002bc86:	e8 87 0d 00 00       	call   c002ca12 <file_close>
    list_remove(&entry->elem);
c002bc8b:	8d 43 0c             	lea    0xc(%ebx),%eax
c002bc8e:	89 04 24             	mov    %eax,(%esp)
c002bc91:	e8 a1 ce ff ff       	call   c0028b37 <list_remove>
    free(entry);
c002bc96:	89 1c 24             	mov    %ebx,(%esp)
c002bc99:	e8 d3 7e ff ff       	call   c0023b71 <free>
    lock_release(&filesys_lock);
c002bc9e:	c7 04 24 60 55 04 c0 	movl   $0xc0045560,(%esp)
c002bca5:	e8 70 73 ff ff       	call   c002301a <lock_release>
c002bcaa:	83 c4 10             	add    $0x10,%esp
c002bcad:	e9 eb f9 ff ff       	jmp    c002b69d <syscall_handler+0xef>
      dir_close (entry->opened_dir);
c002bcb2:	83 ec 0c             	sub    $0xc,%esp
c002bcb5:	ff 73 08             	pushl  0x8(%ebx)
c002bcb8:	e8 b5 0f 00 00       	call   c002cc72 <dir_close>
c002bcbd:	83 c4 10             	add    $0x10,%esp
c002bcc0:	eb bf                	jmp    c002bc81 <syscall_handler+0x6d3>
#ifdef FILESYS

static bool 
syscall_chdir (struct intr_frame *f) {
  char * path_name;
  pop_stack (f->esp, &path_name, 1);
c002bcc2:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bcc7:	8d 54 24 14          	lea    0x14(%esp),%edx
c002bccb:	e8 a0 f8 ff ff       	call   c002b570 <pop_stack>
  if (path_name == NULL || strlen (path_name) == 0) {
c002bcd0:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002bcd4:	85 db                	test   %ebx,%ebx
c002bcd6:	0f 84 de 00 00 00    	je     c002bdba <syscall_handler+0x80c>
c002bcdc:	80 3b 00             	cmpb   $0x0,(%ebx)
c002bcdf:	75 0d                	jne    c002bcee <syscall_handler+0x740>
    return false;
c002bce1:	b3 00                	mov    $0x0,%bl
    case SYS_CHDIR: f->eax = syscall_chdir(f); break;
c002bce3:	0f b6 db             	movzbl %bl,%ebx
c002bce6:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002bce9:	e9 af f9 ff ff       	jmp    c002b69d <syscall_handler+0xef>
  }
  char * pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002bcee:	83 ec 08             	sub    $0x8,%esp
c002bcf1:	6a 01                	push   $0x1
c002bcf3:	6a 0f                	push   $0xf
c002bcf5:	e8 2d 7e ff ff       	call   c0023b27 <calloc>
c002bcfa:	89 44 24 28          	mov    %eax,0x28(%esp)
  bool is_dir;
  struct dir* dir;
  bool success = false;
  if (filesys_is_root_dir (path_name)) {
c002bcfe:	89 1c 24             	mov    %ebx,(%esp)
c002bd01:	e8 a6 04 00 00       	call   c002c1ac <filesys_is_root_dir>
c002bd06:	89 c6                	mov    %eax,%esi
c002bd08:	83 c4 10             	add    $0x10,%esp
c002bd0b:	84 c0                	test   %al,%al
c002bd0d:	74 3b                	je     c002bd4a <syscall_handler+0x79c>
    dir_close ( thread_current () -> dir);
c002bd0f:	e8 a8 4f ff ff       	call   c0020cbc <thread_current>
c002bd14:	83 ec 0c             	sub    $0xc,%esp
c002bd17:	ff b0 dc 00 00 00    	pushl  0xdc(%eax)
c002bd1d:	e8 50 0f 00 00       	call   c002cc72 <dir_close>
    thread_current () -> dir = dir_open_root ();
c002bd22:	e8 95 4f ff ff       	call   c0020cbc <thread_current>
c002bd27:	89 c3                	mov    %eax,%ebx
c002bd29:	e8 14 0f 00 00       	call   c002cc42 <dir_open_root>
c002bd2e:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
c002bd34:	83 c4 10             	add    $0x10,%esp
    success = true;
c002bd37:	89 f3                	mov    %esi,%ebx
        success = true;
      }
      dir_close (dir);
    }
  }
  free (pure_name);
c002bd39:	83 ec 0c             	sub    $0xc,%esp
c002bd3c:	ff 74 24 24          	pushl  0x24(%esp)
c002bd40:	e8 2c 7e ff ff       	call   c0023b71 <free>
c002bd45:	83 c4 10             	add    $0x10,%esp
c002bd48:	eb 99                	jmp    c002bce3 <syscall_handler+0x735>
    if (filesys_path_parse (path_name, &dir, &pure_name, &is_dir)) {
c002bd4a:	8d 44 24 13          	lea    0x13(%esp),%eax
c002bd4e:	50                   	push   %eax
c002bd4f:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002bd53:	50                   	push   %eax
c002bd54:	8d 44 24 24          	lea    0x24(%esp),%eax
c002bd58:	50                   	push   %eax
c002bd59:	ff 74 24 20          	pushl  0x20(%esp)
c002bd5d:	e8 73 04 00 00       	call   c002c1d5 <filesys_path_parse>
c002bd62:	88 c3                	mov    %al,%bl
c002bd64:	83 c4 10             	add    $0x10,%esp
c002bd67:	84 c0                	test   %al,%al
c002bd69:	74 ce                	je     c002bd39 <syscall_handler+0x78b>
      struct dir * subdir = dir_subdir_lookup (dir, pure_name);
c002bd6b:	83 ec 08             	sub    $0x8,%esp
c002bd6e:	ff 74 24 20          	pushl  0x20(%esp)
c002bd72:	ff 74 24 28          	pushl  0x28(%esp)
c002bd76:	e8 2d 14 00 00       	call   c002d1a8 <dir_subdir_lookup>
c002bd7b:	89 c7                	mov    %eax,%edi
      if (subdir != NULL) {
c002bd7d:	83 c4 10             	add    $0x10,%esp
c002bd80:	85 c0                	test   %eax,%eax
c002bd82:	74 32                	je     c002bdb6 <syscall_handler+0x808>
        dir_close (thread_current () -> dir);
c002bd84:	e8 33 4f ff ff       	call   c0020cbc <thread_current>
c002bd89:	83 ec 0c             	sub    $0xc,%esp
c002bd8c:	ff b0 dc 00 00 00    	pushl  0xdc(%eax)
c002bd92:	e8 db 0e 00 00       	call   c002cc72 <dir_close>
        thread_current () -> dir = subdir;
c002bd97:	e8 20 4f ff ff       	call   c0020cbc <thread_current>
c002bd9c:	89 b8 dc 00 00 00    	mov    %edi,0xdc(%eax)
c002bda2:	83 c4 10             	add    $0x10,%esp
      dir_close (dir);
c002bda5:	83 ec 0c             	sub    $0xc,%esp
c002bda8:	ff 74 24 28          	pushl  0x28(%esp)
c002bdac:	e8 c1 0e 00 00       	call   c002cc72 <dir_close>
c002bdb1:	83 c4 10             	add    $0x10,%esp
c002bdb4:	eb 83                	jmp    c002bd39 <syscall_handler+0x78b>
  bool success = false;
c002bdb6:	89 f3                	mov    %esi,%ebx
c002bdb8:	eb eb                	jmp    c002bda5 <syscall_handler+0x7f7>
    return false;
c002bdba:	b3 00                	mov    $0x0,%bl
c002bdbc:	e9 22 ff ff ff       	jmp    c002bce3 <syscall_handler+0x735>
}

static bool
syscall_mkdir (struct intr_frame *f) {
  char * path_name;
  pop_stack (f->esp, &path_name, 1);
c002bdc1:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bdc6:	8d 54 24 14          	lea    0x14(%esp),%edx
c002bdca:	e8 a1 f7 ff ff       	call   c002b570 <pop_stack>
  if (path_name == NULL || strlen (path_name) == 0) {
c002bdcf:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002bdd3:	85 db                	test   %ebx,%ebx
c002bdd5:	0f 84 88 00 00 00    	je     c002be63 <syscall_handler+0x8b5>
c002bddb:	80 3b 00             	cmpb   $0x0,(%ebx)
c002bdde:	75 0d                	jne    c002bded <syscall_handler+0x83f>
    return false;
c002bde0:	b3 00                	mov    $0x0,%bl
    case SYS_MKDIR: f->eax = syscall_mkdir(f); break;
c002bde2:	0f b6 db             	movzbl %bl,%ebx
c002bde5:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002bde8:	e9 b0 f8 ff ff       	jmp    c002b69d <syscall_handler+0xef>
  }
  char * pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002bded:	83 ec 08             	sub    $0x8,%esp
c002bdf0:	6a 01                	push   $0x1
c002bdf2:	6a 0f                	push   $0xf
c002bdf4:	e8 2e 7d ff ff       	call   c0023b27 <calloc>
c002bdf9:	89 44 24 28          	mov    %eax,0x28(%esp)
  bool is_dir;
  struct dir* dir;
  bool success = false;
  if (! filesys_is_root_dir (path_name) && filesys_path_parse (path_name, &dir, &pure_name, &is_dir)) {
c002bdfd:	89 1c 24             	mov    %ebx,(%esp)
c002be00:	e8 a7 03 00 00       	call   c002c1ac <filesys_is_root_dir>
c002be05:	83 c4 10             	add    $0x10,%esp
c002be08:	84 c0                	test   %al,%al
c002be0a:	74 13                	je     c002be1f <syscall_handler+0x871>
  bool success = false;
c002be0c:	b3 00                	mov    $0x0,%bl
    success = dir_subdir_create (dir, pure_name);
    dir_close (dir);
  }
  free (pure_name);
c002be0e:	83 ec 0c             	sub    $0xc,%esp
c002be11:	ff 74 24 24          	pushl  0x24(%esp)
c002be15:	e8 57 7d ff ff       	call   c0023b71 <free>
c002be1a:	83 c4 10             	add    $0x10,%esp
c002be1d:	eb c3                	jmp    c002bde2 <syscall_handler+0x834>
  if (! filesys_is_root_dir (path_name) && filesys_path_parse (path_name, &dir, &pure_name, &is_dir)) {
c002be1f:	8d 44 24 13          	lea    0x13(%esp),%eax
c002be23:	50                   	push   %eax
c002be24:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002be28:	50                   	push   %eax
c002be29:	8d 44 24 24          	lea    0x24(%esp),%eax
c002be2d:	50                   	push   %eax
c002be2e:	ff 74 24 20          	pushl  0x20(%esp)
c002be32:	e8 9e 03 00 00       	call   c002c1d5 <filesys_path_parse>
c002be37:	88 c3                	mov    %al,%bl
c002be39:	83 c4 10             	add    $0x10,%esp
c002be3c:	84 c0                	test   %al,%al
c002be3e:	74 ce                	je     c002be0e <syscall_handler+0x860>
    success = dir_subdir_create (dir, pure_name);
c002be40:	83 ec 08             	sub    $0x8,%esp
c002be43:	ff 74 24 20          	pushl  0x20(%esp)
c002be47:	ff 74 24 28          	pushl  0x28(%esp)
c002be4b:	e8 c5 12 00 00       	call   c002d115 <dir_subdir_create>
c002be50:	88 c3                	mov    %al,%bl
    dir_close (dir);
c002be52:	83 c4 04             	add    $0x4,%esp
c002be55:	ff 74 24 28          	pushl  0x28(%esp)
c002be59:	e8 14 0e 00 00       	call   c002cc72 <dir_close>
c002be5e:	83 c4 10             	add    $0x10,%esp
c002be61:	eb ab                	jmp    c002be0e <syscall_handler+0x860>
    return false;
c002be63:	b3 00                	mov    $0x0,%bl
c002be65:	e9 78 ff ff ff       	jmp    c002bde2 <syscall_handler+0x834>

static bool
syscall_readdir (struct intr_frame *f) {
  int fd;
  char * name;
  pop_stack (f->esp, &fd, 1);
c002be6a:	b9 01 00 00 00       	mov    $0x1,%ecx
c002be6f:	8d 54 24 18          	lea    0x18(%esp),%edx
c002be73:	e8 f8 f6 ff ff       	call   c002b570 <pop_stack>
  pop_stack (f->esp, &name, 2);
c002be78:	8b 45 48             	mov    0x48(%ebp),%eax
c002be7b:	b9 02 00 00 00       	mov    $0x2,%ecx
c002be80:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002be84:	e8 e7 f6 ff ff       	call   c002b570 <pop_stack>
  if (fd <= 1 || name == NULL)
c002be89:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002be8d:	83 fb 01             	cmp    $0x1,%ebx
c002be90:	7e 4d                	jle    c002bedf <syscall_handler+0x931>
c002be92:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c002be97:	74 4a                	je     c002bee3 <syscall_handler+0x935>
    return false;
  struct fd_t * fd_e = get_file_by_fd(&thread_current()->files, fd);
c002be99:	e8 1e 4e ff ff       	call   c0020cbc <thread_current>
c002be9e:	05 bc 00 00 00       	add    $0xbc,%eax
c002bea3:	89 da                	mov    %ebx,%edx
c002bea5:	e8 fd f5 ff ff       	call   c002b4a7 <get_file_by_fd>
c002beaa:	89 c3                	mov    %eax,%ebx
  bool success = false;
  if (fd_e != NULL && dir_is_dirfile (fd_e)) {
c002beac:	85 c0                	test   %eax,%eax
c002beae:	74 37                	je     c002bee7 <syscall_handler+0x939>
c002beb0:	83 ec 0c             	sub    $0xc,%esp
c002beb3:	50                   	push   %eax
c002beb4:	e8 8b 16 00 00       	call   c002d544 <dir_is_dirfile>
c002beb9:	83 c4 10             	add    $0x10,%esp
c002bebc:	84 c0                	test   %al,%al
c002bebe:	75 0b                	jne    c002becb <syscall_handler+0x91d>
    case SYS_READDIR: f->eax = syscall_readdir(f); break;
c002bec0:	0f b6 c0             	movzbl %al,%eax
c002bec3:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002bec6:	e9 d2 f7 ff ff       	jmp    c002b69d <syscall_handler+0xef>
    success = dir_readdir (fd_e->opened_dir, name);
c002becb:	83 ec 08             	sub    $0x8,%esp
c002bece:	ff 74 24 24          	pushl  0x24(%esp)
c002bed2:	ff 73 08             	pushl  0x8(%ebx)
c002bed5:	e8 69 11 00 00       	call   c002d043 <dir_readdir>
c002beda:	83 c4 10             	add    $0x10,%esp
c002bedd:	eb e1                	jmp    c002bec0 <syscall_handler+0x912>
    return false;
c002bedf:	b0 00                	mov    $0x0,%al
c002bee1:	eb dd                	jmp    c002bec0 <syscall_handler+0x912>
c002bee3:	b0 00                	mov    $0x0,%al
c002bee5:	eb d9                	jmp    c002bec0 <syscall_handler+0x912>
  bool success = false;
c002bee7:	b0 00                	mov    $0x0,%al
c002bee9:	eb d5                	jmp    c002bec0 <syscall_handler+0x912>
}

static bool
syscall_isdir (struct intr_frame *f) {
  int fd;
  pop_stack (f->esp, &fd, 1);
c002beeb:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bef0:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bef4:	e8 77 f6 ff ff       	call   c002b570 <pop_stack>
  if (fd <= 1) return false;
c002bef9:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002befd:	83 fb 01             	cmp    $0x1,%ebx
c002bf00:	7e 39                	jle    c002bf3b <syscall_handler+0x98d>
  struct fd_t * fd_e = get_file_by_fd(&thread_current()->files, fd);
c002bf02:	e8 b5 4d ff ff       	call   c0020cbc <thread_current>
c002bf07:	05 bc 00 00 00       	add    $0xbc,%eax
c002bf0c:	89 da                	mov    %ebx,%edx
c002bf0e:	e8 94 f5 ff ff       	call   c002b4a7 <get_file_by_fd>
  return fd_e != NULL && dir_is_dirfile (fd_e);
c002bf13:	85 c0                	test   %eax,%eax
c002bf15:	74 1d                	je     c002bf34 <syscall_handler+0x986>
c002bf17:	83 ec 0c             	sub    $0xc,%esp
c002bf1a:	50                   	push   %eax
c002bf1b:	e8 24 16 00 00       	call   c002d544 <dir_is_dirfile>
c002bf20:	0f b6 c0             	movzbl %al,%eax
c002bf23:	83 c4 10             	add    $0x10,%esp
c002bf26:	83 e0 01             	and    $0x1,%eax
    case SYS_ISDIR: f->eax = syscall_isdir(f); break;
c002bf29:	0f b6 c0             	movzbl %al,%eax
c002bf2c:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002bf2f:	e9 69 f7 ff ff       	jmp    c002b69d <syscall_handler+0xef>
  return fd_e != NULL && dir_is_dirfile (fd_e);
c002bf34:	b8 00 00 00 00       	mov    $0x0,%eax
c002bf39:	eb eb                	jmp    c002bf26 <syscall_handler+0x978>
  if (fd <= 1) return false;
c002bf3b:	b0 00                	mov    $0x0,%al
c002bf3d:	eb ea                	jmp    c002bf29 <syscall_handler+0x97b>
}

static int
syscall_inumber (struct intr_frame *f) {
  int fd;
  pop_stack (f->esp, &fd, 1);
c002bf3f:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bf44:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bf48:	e8 23 f6 ff ff       	call   c002b570 <pop_stack>
  if (fd <= 1) return -1;
c002bf4d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002bf51:	83 fb 01             	cmp    $0x1,%ebx
c002bf54:	7e 32                	jle    c002bf88 <syscall_handler+0x9da>
  struct fd_t * fd_e = get_file_by_fd (&thread_current()->files, fd);
c002bf56:	e8 61 4d ff ff       	call   c0020cbc <thread_current>
c002bf5b:	05 bc 00 00 00       	add    $0xbc,%eax
c002bf60:	89 da                	mov    %ebx,%edx
c002bf62:	e8 40 f5 ff ff       	call   c002b4a7 <get_file_by_fd>
  if (fd_e != NULL) 
c002bf67:	85 c0                	test   %eax,%eax
c002bf69:	74 24                	je     c002bf8f <syscall_handler+0x9e1>
    return inode_get_inumber (file_get_inode (fd_e->ptr));
c002bf6b:	83 ec 0c             	sub    $0xc,%esp
c002bf6e:	ff 30                	pushl  (%eax)
c002bf70:	e8 84 09 00 00       	call   c002c8f9 <file_get_inode>
c002bf75:	89 04 24             	mov    %eax,(%esp)
c002bf78:	e8 79 1b 00 00       	call   c002daf6 <inode_get_inumber>
c002bf7d:	83 c4 10             	add    $0x10,%esp
    case SYS_INUMBER: f->eax = syscall_inumber(f); break;
c002bf80:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002bf83:	e9 15 f7 ff ff       	jmp    c002b69d <syscall_handler+0xef>
  if (fd <= 1) return -1;
c002bf88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002bf8d:	eb f1                	jmp    c002bf80 <syscall_handler+0x9d2>
  return -1;
c002bf8f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002bf94:	eb ea                	jmp    c002bf80 <syscall_handler+0x9d2>
      printf("Not implemented system call %d!\n", sysnum);
c002bf96:	83 ec 08             	sub    $0x8,%esp
c002bf99:	52                   	push   %edx
c002bf9a:	68 88 23 03 c0       	push   $0xc0032388
c002bf9f:	e8 d5 ab ff ff       	call   c0026b79 <printf>
c002bfa4:	83 c4 10             	add    $0x10,%esp
}
c002bfa7:	e9 f1 f6 ff ff       	jmp    c002b69d <syscall_handler+0xef>

c002bfac <gdt_init>:

/* Sets up a proper GDT.  The bootstrap loader's GDT didn't
   include user-mode selectors or a TSS, but we need both now. */
void
gdt_init (void)
{
c002bfac:	83 ec 1c             	sub    $0x1c,%esp
  uint64_t gdtr_operand;

  /* Initialize GDT. */
  gdt[SEL_NULL / sizeof *gdt] = 0;
c002bfaf:	c7 05 80 ce 03 c0 00 	movl   $0x0,0xc003ce80
c002bfb6:	00 00 00 
c002bfb9:	c7 05 84 ce 03 c0 00 	movl   $0x0,0xc003ce84
c002bfc0:	00 00 00 
  gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc (0);
c002bfc3:	c7 05 88 ce 03 c0 ff 	movl   $0xffff,0xc003ce88
c002bfca:	ff 00 00 
c002bfcd:	c7 05 8c ce 03 c0 00 	movl   $0xcf9a00,0xc003ce8c
c002bfd4:	9a cf 00 
  gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc (0);
c002bfd7:	c7 05 90 ce 03 c0 ff 	movl   $0xffff,0xc003ce90
c002bfde:	ff 00 00 
c002bfe1:	c7 05 94 ce 03 c0 00 	movl   $0xcf9200,0xc003ce94
c002bfe8:	92 cf 00 
  gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc (3);
c002bfeb:	c7 05 98 ce 03 c0 ff 	movl   $0xffff,0xc003ce98
c002bff2:	ff 00 00 
c002bff5:	c7 05 9c ce 03 c0 00 	movl   $0xcffa00,0xc003ce9c
c002bffc:	fa cf 00 
  gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc (3);
c002bfff:	c7 05 a0 ce 03 c0 ff 	movl   $0xffff,0xc003cea0
c002c006:	ff 00 00 
c002c009:	c7 05 a4 ce 03 c0 00 	movl   $0xcff200,0xc003cea4
c002c010:	f2 cf 00 
  gdt[SEL_TSS / sizeof *gdt] = make_tss_desc (tss_get ());
c002c013:	e8 56 00 00 00       	call   c002c06e <tss_get>
  ASSERT (granularity == GRAN_BYTE || granularity == GRAN_PAGE);

  e0 = ((limit & 0xffff)             /* Limit 15:0. */
        | (base << 16));             /* Base 15:0. */

  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002c018:	89 c2                	mov    %eax,%edx
c002c01a:	c1 ea 10             	shr    $0x10,%edx
c002c01d:	0f b6 d2             	movzbl %dl,%edx
        | (dpl << 13)                /* Descriptor privilege. */
        | (1 << 15)                  /* Present. */
        | (limit & 0xf0000)          /* Limit 16:19. */
        | (1 << 22)                  /* 32-bit segment. */
        | (granularity << 23)        /* Byte/page granularity. */
        | (base & 0xff000000));      /* Base 31:24. */
c002c020:	89 c1                	mov    %eax,%ecx
c002c022:	81 e1 00 00 00 ff    	and    $0xff000000,%ecx
  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002c028:	81 c9 00 89 40 00    	or     $0x408900,%ecx
c002c02e:	09 ca                	or     %ecx,%edx
        | (base << 16));             /* Base 15:0. */
c002c030:	c1 e0 10             	shl    $0x10,%eax
  e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002c033:	83 c8 67             	or     $0x67,%eax

  return e0 | ((uint64_t) e1 << 32);
c002c036:	a3 a8 ce 03 c0       	mov    %eax,0xc003cea8
c002c03b:	89 15 ac ce 03 c0    	mov    %edx,0xc003ceac
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LGDT instruction. */
static uint64_t
make_gdtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
c002c041:	b8 80 ce 03 c0       	mov    $0xc003ce80,%eax
c002c046:	ba 00 00 00 00       	mov    $0x0,%edx
c002c04b:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002c04f:	c1 e0 10             	shl    $0x10,%eax
c002c052:	83 c8 2f             	or     $0x2f,%eax
c002c055:	89 44 24 08          	mov    %eax,0x8(%esp)
c002c059:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lgdt %0" : : "m" (gdtr_operand));
c002c05d:	0f 01 54 24 08       	lgdtl  0x8(%esp)
  asm volatile ("ltr %w0" : : "q" (SEL_TSS));
c002c062:	b8 28 00 00 00       	mov    $0x28,%eax
c002c067:	0f 00 d8             	ltr    %ax
}
c002c06a:	83 c4 1c             	add    $0x1c,%esp
c002c06d:	c3                   	ret    

c002c06e <tss_get>:

/* Returns the kernel TSS. */
struct tss *
tss_get (void) 
{
  ASSERT (tss != NULL);
c002c06e:	a1 b0 ce 03 c0       	mov    0xc003ceb0,%eax
c002c073:	85 c0                	test   %eax,%eax
c002c075:	74 01                	je     c002c078 <tss_get+0xa>
  return tss;
}
c002c077:	c3                   	ret    
{
c002c078:	83 ec 18             	sub    $0x18,%esp
  ASSERT (tss != NULL);
c002c07b:	68 a9 23 03 c0       	push   $0xc00323a9
c002c080:	68 21 01 03 c0       	push   $0xc0030121
c002c085:	68 e0 fe 02 c0       	push   $0xc002fee0
c002c08a:	6a 5f                	push   $0x5f
c002c08c:	68 b5 23 03 c0       	push   $0xc00323b5
c002c091:	e8 91 c5 ff ff       	call   c0028627 <debug_panic>

c002c096 <tss_update>:

/* Sets the ring 0 stack pointer in the TSS to point to the end
   of the thread stack. */
void
tss_update (void) 
{
c002c096:	53                   	push   %ebx
c002c097:	83 ec 08             	sub    $0x8,%esp
  ASSERT (tss != NULL);
c002c09a:	8b 1d b0 ce 03 c0    	mov    0xc003ceb0,%ebx
c002c0a0:	85 db                	test   %ebx,%ebx
c002c0a2:	74 12                	je     c002c0b6 <tss_update+0x20>
  tss->esp0 = (uint8_t *) thread_current () + PGSIZE;
c002c0a4:	e8 13 4c ff ff       	call   c0020cbc <thread_current>
c002c0a9:	05 00 10 00 00       	add    $0x1000,%eax
c002c0ae:	89 43 04             	mov    %eax,0x4(%ebx)
}
c002c0b1:	83 c4 08             	add    $0x8,%esp
c002c0b4:	5b                   	pop    %ebx
c002c0b5:	c3                   	ret    
  ASSERT (tss != NULL);
c002c0b6:	83 ec 0c             	sub    $0xc,%esp
c002c0b9:	68 a9 23 03 c0       	push   $0xc00323a9
c002c0be:	68 21 01 03 c0       	push   $0xc0030121
c002c0c3:	68 d4 fe 02 c0       	push   $0xc002fed4
c002c0c8:	6a 68                	push   $0x68
c002c0ca:	68 b5 23 03 c0       	push   $0xc00323b5
c002c0cf:	e8 53 c5 ff ff       	call   c0028627 <debug_panic>

c002c0d4 <tss_init>:
{
c002c0d4:	83 ec 18             	sub    $0x18,%esp
  tss = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002c0d7:	6a 03                	push   $0x3
c002c0d9:	e8 7a 75 ff ff       	call   c0023658 <palloc_get_page>
c002c0de:	a3 b0 ce 03 c0       	mov    %eax,0xc003ceb0
  tss->ss0 = SEL_KDSEG;
c002c0e3:	66 c7 40 08 10 00    	movw   $0x10,0x8(%eax)
  tss->bitmap = 0xdfff;
c002c0e9:	66 c7 40 66 ff df    	movw   $0xdfff,0x66(%eax)
  tss_update ();
c002c0ef:	e8 a2 ff ff ff       	call   c002c096 <tss_update>
}
c002c0f4:	83 c4 1c             	add    $0x1c,%esp
c002c0f7:	c3                   	ret    

c002c0f8 <filesys_init>:

/* Initializes the file system module.
   If FORMAT is true, reformats the file system. */
void
filesys_init (bool format) 
{
c002c0f8:	53                   	push   %ebx
c002c0f9:	83 ec 14             	sub    $0x14,%esp
c002c0fc:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  fs_device = block_get_role (BLOCK_FILESYS);
c002c100:	6a 01                	push   $0x1
c002c102:	e8 5d 8a ff ff       	call   c0024b64 <block_get_role>
c002c107:	a3 98 55 04 c0       	mov    %eax,0xc0045598
  if (fs_device == NULL)
c002c10c:	83 c4 10             	add    $0x10,%esp
c002c10f:	85 c0                	test   %eax,%eax
c002c111:	74 1d                	je     c002c130 <filesys_init+0x38>
    PANIC ("No file system device found, can't initialize file system.");

  inode_init ();
c002c113:	e8 c1 16 00 00       	call   c002d7d9 <inode_init>
  free_map_init ();
c002c118:	e8 21 05 00 00       	call   c002c63e <free_map_init>
  cache_init ();
c002c11d:	e8 c3 25 00 00       	call   c002e6e5 <cache_init>

  if (format) 
c002c122:	84 db                	test   %bl,%bl
c002c124:	75 20                	jne    c002c146 <filesys_init+0x4e>
    do_format ();

  free_map_open ();
c002c126:	e8 3f 06 00 00       	call   c002c76a <free_map_open>
}
c002c12b:	83 c4 08             	add    $0x8,%esp
c002c12e:	5b                   	pop    %ebx
c002c12f:	c3                   	ret    
    PANIC ("No file system device found, can't initialize file system.");
c002c130:	68 cc 23 03 c0       	push   $0xc00323cc
c002c135:	68 08 ff 02 c0       	push   $0xc002ff08
c002c13a:	6a 1a                	push   $0x1a
c002c13c:	68 49 24 03 c0       	push   $0xc0032449
c002c141:	e8 e1 c4 ff ff       	call   c0028627 <debug_panic>

/* Formats the file system. */
static void
do_format (void)
{
  printf ("Formatting file system...");
c002c146:	83 ec 0c             	sub    $0xc,%esp
c002c149:	68 61 24 03 c0       	push   $0xc0032461
c002c14e:	e8 26 aa ff ff       	call   c0026b79 <printf>
  free_map_create ();
c002c153:	e8 88 06 00 00       	call   c002c7e0 <free_map_create>
  if (!dir_create (ROOT_DIR_SECTOR, 16))
c002c158:	83 c4 08             	add    $0x8,%esp
c002c15b:	6a 10                	push   $0x10
c002c15d:	6a 01                	push   $0x1
c002c15f:	e8 8f 0d 00 00       	call   c002cef3 <dir_create>
c002c164:	83 c4 10             	add    $0x10,%esp
c002c167:	84 c0                	test   %al,%al
c002c169:	74 17                	je     c002c182 <filesys_init+0x8a>
    PANIC ("root directory creation failed");
  free_map_close ();
c002c16b:	e8 5e 06 00 00       	call   c002c7ce <free_map_close>
  printf ("done.\n");
c002c170:	83 ec 0c             	sub    $0xc,%esp
c002c173:	68 ac 0c 03 c0       	push   $0xc0030cac
c002c178:	e8 91 df ff ff       	call   c002a10e <puts>
c002c17d:	83 c4 10             	add    $0x10,%esp
c002c180:	eb a4                	jmp    c002c126 <filesys_init+0x2e>
    PANIC ("root directory creation failed");
c002c182:	68 08 24 03 c0       	push   $0xc0032408
c002c187:	68 fc fe 02 c0       	push   $0xc002fefc
c002c18c:	68 a2 00 00 00       	push   $0xa2
c002c191:	68 49 24 03 c0       	push   $0xc0032449
c002c196:	e8 8c c4 ff ff       	call   c0028627 <debug_panic>

c002c19b <filesys_done>:
{
c002c19b:	83 ec 0c             	sub    $0xc,%esp
  free_map_close ();
c002c19e:	e8 2b 06 00 00       	call   c002c7ce <free_map_close>
  cache_done ();
c002c1a3:	e8 cb 26 00 00       	call   c002e873 <cache_done>
}
c002c1a8:	83 c4 0c             	add    $0xc,%esp
c002c1ab:	c3                   	ret    

c002c1ac <filesys_is_root_dir>:
  return false;
}

/* name == "/" ? */
bool
filesys_is_root_dir (const char * name) {
c002c1ac:	8b 44 24 04          	mov    0x4(%esp),%eax
  return name != NULL && name[0] == '/' && name[1] == '\0';
c002c1b0:	85 c0                	test   %eax,%eax
c002c1b2:	74 1a                	je     c002c1ce <filesys_is_root_dir+0x22>
c002c1b4:	80 38 2f             	cmpb   $0x2f,(%eax)
c002c1b7:	74 09                	je     c002c1c2 <filesys_is_root_dir+0x16>
c002c1b9:	b8 00 00 00 00       	mov    $0x0,%eax
c002c1be:	83 e0 01             	and    $0x1,%eax
}
c002c1c1:	c3                   	ret    
  return name != NULL && name[0] == '/' && name[1] == '\0';
c002c1c2:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
c002c1c6:	0f 94 c0             	sete   %al
c002c1c9:	0f b6 c0             	movzbl %al,%eax
c002c1cc:	eb f0                	jmp    c002c1be <filesys_is_root_dir+0x12>
c002c1ce:	b8 00 00 00 00       	mov    $0x0,%eax
c002c1d3:	eb e9                	jmp    c002c1be <filesys_is_root_dir+0x12>

c002c1d5 <filesys_path_parse>:
dir       : On success, return the directory the file belong to. Should be closed by caller.
pure_name : On success, copy the name of file into *pure_name.
is_dir    : On success, indicate if path name is ended with slash.
*/
bool
filesys_path_parse (const char *name, struct dir **dir, char **pure_name, bool *is_dir) {
c002c1d5:	55                   	push   %ebp
c002c1d6:	57                   	push   %edi
c002c1d7:	56                   	push   %esi
c002c1d8:	53                   	push   %ebx
c002c1d9:	83 ec 2c             	sub    $0x2c,%esp
c002c1dc:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c002c1e0:	8b 74 24 44          	mov    0x44(%esp),%esi
  int len;
  if (name == NULL || (len = strlen (name)) == 0 || (len == 1 && name[0] == '/'))
c002c1e4:	85 ed                	test   %ebp,%ebp
c002c1e6:	0f 84 86 01 00 00    	je     c002c372 <filesys_path_parse+0x19d>
c002c1ec:	b0 00                	mov    $0x0,%al
c002c1ee:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002c1f3:	89 ef                	mov    %ebp,%edi
c002c1f5:	f2 ae                	repnz scas %es:(%edi),%al
c002c1f7:	f7 d1                	not    %ecx
c002c1f9:	49                   	dec    %ecx
c002c1fa:	89 cb                	mov    %ecx,%ebx
c002c1fc:	0f 84 74 01 00 00    	je     c002c376 <filesys_path_parse+0x1a1>
c002c202:	83 f9 01             	cmp    $0x1,%ecx
c002c205:	0f 84 83 00 00 00    	je     c002c28e <filesys_path_parse+0xb9>
    return false;
  char *path = calloc (len + 1, 1);
c002c20b:	8d 7b 01             	lea    0x1(%ebx),%edi
c002c20e:	83 ec 08             	sub    $0x8,%esp
c002c211:	6a 01                	push   $0x1
c002c213:	57                   	push   %edi
c002c214:	e8 0e 79 ff ff       	call   c0023b27 <calloc>
c002c219:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  strlcpy (path, name, len + 1);
c002c21d:	83 c4 0c             	add    $0xc,%esp
c002c220:	57                   	push   %edi
c002c221:	55                   	push   %ebp
c002c222:	89 c7                	mov    %eax,%edi
c002c224:	50                   	push   %eax
c002c225:	e8 f7 ba ff ff       	call   c0027d21 <strlcpy>
  if (path[len - 1] == '/') {
c002c22a:	83 c4 10             	add    $0x10,%esp
c002c22d:	80 7c 1f ff 2f       	cmpb   $0x2f,-0x1(%edi,%ebx,1)
c002c232:	74 6b                	je     c002c29f <filesys_path_parse+0xca>
    *is_dir = true;
    path[len--] = 0;
  } else {
    *is_dir = false;
c002c234:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002c238:	c6 00 00             	movb   $0x0,(%eax)
  }
  if (path[0] == '/') {
c002c23b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002c23f:	80 38 2f             	cmpb   $0x2f,(%eax)
c002c242:	74 6c                	je     c002c2b0 <filesys_path_parse+0xdb>
    *dir = dir_open_root ();
  } else {
    ASSERT (thread_current () -> dir != NULL);
c002c244:	e8 73 4a ff ff       	call   c0020cbc <thread_current>
c002c249:	83 b8 dc 00 00 00 00 	cmpl   $0x0,0xdc(%eax)
c002c250:	74 67                	je     c002c2b9 <filesys_path_parse+0xe4>
    *dir = dir_reopen (thread_current ()->dir); // NPE for start up
c002c252:	e8 65 4a ff ff       	call   c0020cbc <thread_current>
c002c257:	83 ec 0c             	sub    $0xc,%esp
c002c25a:	ff b0 dc 00 00 00    	pushl  0xdc(%eax)
c002c260:	e8 f3 09 00 00       	call   c002cc58 <dir_reopen>
c002c265:	89 06                	mov    %eax,(%esi)
c002c267:	83 c4 10             	add    $0x10,%esp
  }
  char *token, *saveptr, *next;
  bool success = false;
  token = strtok_r (path, DELIM, &saveptr);
c002c26a:	83 ec 04             	sub    $0x4,%esp
c002c26d:	8d 44 24 20          	lea    0x20(%esp),%eax
c002c271:	50                   	push   %eax
c002c272:	68 57 10 03 c0       	push   $0xc0031057
c002c277:	ff 74 24 18          	pushl  0x18(%esp)
c002c27b:	e8 c7 b8 ff ff       	call   c0027b47 <strtok_r>
c002c280:	89 c3                	mov    %eax,%ebx
c002c282:	83 c4 10             	add    $0x10,%esp
  for ( ; ; ) {
    if (!check_name (token)) {
      dir_close (*dir);
      break;
    }
    next = strtok_r (NULL, DELIM, &saveptr);
c002c285:	8d 6c 24 1c          	lea    0x1c(%esp),%ebp
c002c289:	e9 87 00 00 00       	jmp    c002c315 <filesys_path_parse+0x140>
  if (name == NULL || (len = strlen (name)) == 0 || (len == 1 && name[0] == '/'))
c002c28e:	80 7d 00 2f          	cmpb   $0x2f,0x0(%ebp)
c002c292:	0f 85 73 ff ff ff    	jne    c002c20b <filesys_path_parse+0x36>
    return false;
c002c298:	b3 00                	mov    $0x0,%bl
c002c29a:	e9 ad 00 00 00       	jmp    c002c34c <filesys_path_parse+0x177>
    *is_dir = true;
c002c29f:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002c2a3:	c6 00 01             	movb   $0x1,(%eax)
    path[len--] = 0;
c002c2a6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002c2aa:	c6 04 18 00          	movb   $0x0,(%eax,%ebx,1)
c002c2ae:	eb 8b                	jmp    c002c23b <filesys_path_parse+0x66>
    *dir = dir_open_root ();
c002c2b0:	e8 8d 09 00 00       	call   c002cc42 <dir_open_root>
c002c2b5:	89 06                	mov    %eax,(%esi)
c002c2b7:	eb b1                	jmp    c002c26a <filesys_path_parse+0x95>
    ASSERT (thread_current () -> dir != NULL);
c002c2b9:	83 ec 0c             	sub    $0xc,%esp
c002c2bc:	68 28 24 03 c0       	push   $0xc0032428
c002c2c1:	68 21 01 03 c0       	push   $0xc0030121
c002c2c6:	68 e8 fe 02 c0       	push   $0xc002fee8
c002c2cb:	68 d8 00 00 00       	push   $0xd8
c002c2d0:	68 49 24 03 c0       	push   $0xc0032449
c002c2d5:	e8 4d c3 ff ff       	call   c0028627 <debug_panic>
    next = strtok_r (NULL, DELIM, &saveptr);
c002c2da:	83 ec 04             	sub    $0x4,%esp
c002c2dd:	55                   	push   %ebp
c002c2de:	68 57 10 03 c0       	push   $0xc0031057
c002c2e3:	6a 00                	push   $0x0
c002c2e5:	e8 5d b8 ff ff       	call   c0027b47 <strtok_r>
c002c2ea:	89 c7                	mov    %eax,%edi
    if (next == NULL) {
c002c2ec:	83 c4 10             	add    $0x10,%esp
c002c2ef:	85 c0                	test   %eax,%eax
c002c2f1:	74 63                	je     c002c356 <filesys_path_parse+0x181>
      strlcpy (*pure_name, token, READDIR_MAX_LEN + 1);
      success = true;
      break;
    }
    struct dir *nxt = dir_subdir_lookup (*dir, token);
c002c2f3:	83 ec 08             	sub    $0x8,%esp
c002c2f6:	53                   	push   %ebx
c002c2f7:	ff 36                	pushl  (%esi)
c002c2f9:	e8 aa 0e 00 00       	call   c002d1a8 <dir_subdir_lookup>
c002c2fe:	89 c3                	mov    %eax,%ebx
    dir_close (*dir);
c002c300:	83 c4 04             	add    $0x4,%esp
c002c303:	ff 36                	pushl  (%esi)
c002c305:	e8 68 09 00 00       	call   c002cc72 <dir_close>
    if (nxt == NULL) {
c002c30a:	83 c4 10             	add    $0x10,%esp
c002c30d:	85 db                	test   %ebx,%ebx
c002c30f:	74 5d                	je     c002c36e <filesys_path_parse+0x199>
      break;
    }
    *dir = nxt;
c002c311:	89 1e                	mov    %ebx,(%esi)
    token = next;
c002c313:	89 fb                	mov    %edi,%ebx
  if (name == NULL)
c002c315:	85 db                	test   %ebx,%ebx
c002c317:	74 15                	je     c002c32e <filesys_path_parse+0x159>
c002c319:	89 d8                	mov    %ebx,%eax
c002c31b:	8d 4b 0f             	lea    0xf(%ebx),%ecx
    switch (name[i]) {
c002c31e:	8a 10                	mov    (%eax),%dl
c002c320:	84 d2                	test   %dl,%dl
c002c322:	74 b6                	je     c002c2da <filesys_path_parse+0x105>
c002c324:	80 fa 2f             	cmp    $0x2f,%dl
c002c327:	74 05                	je     c002c32e <filesys_path_parse+0x159>
c002c329:	40                   	inc    %eax
  for (int i = 0; i < READDIR_MAX_LEN + 1; i++) {
c002c32a:	39 c8                	cmp    %ecx,%eax
c002c32c:	75 f0                	jne    c002c31e <filesys_path_parse+0x149>
      dir_close (*dir);
c002c32e:	83 ec 0c             	sub    $0xc,%esp
c002c331:	ff 36                	pushl  (%esi)
c002c333:	e8 3a 09 00 00       	call   c002cc72 <dir_close>
      break;
c002c338:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002c33b:	b3 00                	mov    $0x0,%bl
  }
  free (path);
c002c33d:	83 ec 0c             	sub    $0xc,%esp
c002c340:	ff 74 24 18          	pushl  0x18(%esp)
c002c344:	e8 28 78 ff ff       	call   c0023b71 <free>
  return success;
c002c349:	83 c4 10             	add    $0x10,%esp
}
c002c34c:	88 d8                	mov    %bl,%al
c002c34e:	83 c4 2c             	add    $0x2c,%esp
c002c351:	5b                   	pop    %ebx
c002c352:	5e                   	pop    %esi
c002c353:	5f                   	pop    %edi
c002c354:	5d                   	pop    %ebp
c002c355:	c3                   	ret    
      strlcpy (*pure_name, token, READDIR_MAX_LEN + 1);
c002c356:	83 ec 04             	sub    $0x4,%esp
c002c359:	6a 0f                	push   $0xf
c002c35b:	53                   	push   %ebx
c002c35c:	8b 44 24 54          	mov    0x54(%esp),%eax
c002c360:	ff 30                	pushl  (%eax)
c002c362:	e8 ba b9 ff ff       	call   c0027d21 <strlcpy>
      break;
c002c367:	83 c4 10             	add    $0x10,%esp
      success = true;
c002c36a:	b3 01                	mov    $0x1,%bl
      break;
c002c36c:	eb cf                	jmp    c002c33d <filesys_path_parse+0x168>
  bool success = false;
c002c36e:	b3 00                	mov    $0x0,%bl
c002c370:	eb cb                	jmp    c002c33d <filesys_path_parse+0x168>
    return false;
c002c372:	b3 00                	mov    $0x0,%bl
c002c374:	eb d6                	jmp    c002c34c <filesys_path_parse+0x177>
c002c376:	b3 00                	mov    $0x0,%bl
c002c378:	eb d2                	jmp    c002c34c <filesys_path_parse+0x177>

c002c37a <filesys_create>:
{
c002c37a:	53                   	push   %ebx
c002c37b:	83 ec 20             	sub    $0x20,%esp
c002c37e:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  char *pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002c382:	6a 01                	push   $0x1
c002c384:	6a 0f                	push   $0xf
c002c386:	e8 9c 77 ff ff       	call   c0023b27 <calloc>
c002c38b:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (name != NULL && strlen(name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c38f:	83 c4 10             	add    $0x10,%esp
c002c392:	85 db                	test   %ebx,%ebx
c002c394:	74 73                	je     c002c409 <filesys_create+0x8f>
c002c396:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c399:	74 72                	je     c002c40d <filesys_create+0x93>
c002c39b:	83 ec 0c             	sub    $0xc,%esp
c002c39e:	53                   	push   %ebx
c002c39f:	e8 08 fe ff ff       	call   c002c1ac <filesys_is_root_dir>
c002c3a4:	83 c4 10             	add    $0x10,%esp
c002c3a7:	84 c0                	test   %al,%al
c002c3a9:	74 04                	je     c002c3af <filesys_create+0x35>
  bool success = false;
c002c3ab:	b3 00                	mov    $0x0,%bl
c002c3ad:	eb 60                	jmp    c002c40f <filesys_create+0x95>
  if (name != NULL && strlen(name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c3af:	8d 44 24 07          	lea    0x7(%esp),%eax
c002c3b3:	50                   	push   %eax
c002c3b4:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002c3b8:	50                   	push   %eax
c002c3b9:	8d 44 24 14          	lea    0x14(%esp),%eax
c002c3bd:	50                   	push   %eax
c002c3be:	53                   	push   %ebx
c002c3bf:	e8 11 fe ff ff       	call   c002c1d5 <filesys_path_parse>
c002c3c4:	88 c3                	mov    %al,%bl
c002c3c6:	83 c4 10             	add    $0x10,%esp
c002c3c9:	84 c0                	test   %al,%al
c002c3cb:	74 42                	je     c002c40f <filesys_create+0x95>
    success = !is_dir && dir_subfile_create (dir, pure_name, initial_size);
c002c3cd:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c002c3d2:	74 19                	je     c002c3ed <filesys_create+0x73>
c002c3d4:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c3d9:	83 e3 01             	and    $0x1,%ebx
    dir_close (dir);
c002c3dc:	83 ec 0c             	sub    $0xc,%esp
c002c3df:	ff 74 24 18          	pushl  0x18(%esp)
c002c3e3:	e8 8a 08 00 00       	call   c002cc72 <dir_close>
c002c3e8:	83 c4 10             	add    $0x10,%esp
c002c3eb:	eb 22                	jmp    c002c40f <filesys_create+0x95>
    success = !is_dir && dir_subfile_create (dir, pure_name, initial_size);
c002c3ed:	83 ec 04             	sub    $0x4,%esp
c002c3f0:	ff 74 24 28          	pushl  0x28(%esp)
c002c3f4:	ff 74 24 10          	pushl  0x10(%esp)
c002c3f8:	ff 74 24 18          	pushl  0x18(%esp)
c002c3fc:	e8 68 0f 00 00       	call   c002d369 <dir_subfile_create>
c002c401:	0f b6 d8             	movzbl %al,%ebx
c002c404:	83 c4 10             	add    $0x10,%esp
c002c407:	eb d0                	jmp    c002c3d9 <filesys_create+0x5f>
  bool success = false;
c002c409:	b3 00                	mov    $0x0,%bl
c002c40b:	eb 02                	jmp    c002c40f <filesys_create+0x95>
c002c40d:	b3 00                	mov    $0x0,%bl
  free (pure_name);
c002c40f:	83 ec 0c             	sub    $0xc,%esp
c002c412:	ff 74 24 14          	pushl  0x14(%esp)
c002c416:	e8 56 77 ff ff       	call   c0023b71 <free>
}
c002c41b:	88 d8                	mov    %bl,%al
c002c41d:	83 c4 28             	add    $0x28,%esp
c002c420:	5b                   	pop    %ebx
c002c421:	c3                   	ret    

c002c422 <filesys_open>:
{
c002c422:	56                   	push   %esi
c002c423:	53                   	push   %ebx
c002c424:	83 ec 1c             	sub    $0x1c,%esp
c002c427:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  char *pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002c42b:	6a 01                	push   $0x1
c002c42d:	6a 0f                	push   $0xf
c002c42f:	e8 f3 76 ff ff       	call   c0023b27 <calloc>
c002c434:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (name != NULL && strlen (name) > 0 && filesys_is_root_dir(name)) {
c002c438:	83 c4 10             	add    $0x10,%esp
c002c43b:	85 db                	test   %ebx,%ebx
c002c43d:	0f 84 15 01 00 00    	je     c002c558 <filesys_open+0x136>
c002c443:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c446:	0f 84 13 01 00 00    	je     c002c55f <filesys_open+0x13d>
c002c44c:	83 ec 0c             	sub    $0xc,%esp
c002c44f:	53                   	push   %ebx
c002c450:	e8 57 fd ff ff       	call   c002c1ac <filesys_is_root_dir>
c002c455:	83 c4 10             	add    $0x10,%esp
c002c458:	84 c0                	test   %al,%al
c002c45a:	0f 85 c2 00 00 00    	jne    c002c522 <filesys_open+0x100>
  else if (name != NULL  && strlen (name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c460:	83 ec 0c             	sub    $0xc,%esp
c002c463:	53                   	push   %ebx
c002c464:	e8 43 fd ff ff       	call   c002c1ac <filesys_is_root_dir>
c002c469:	83 c4 10             	add    $0x10,%esp
c002c46c:	84 c0                	test   %al,%al
c002c46e:	0f 85 f9 00 00 00    	jne    c002c56d <filesys_open+0x14b>
c002c474:	8d 44 24 07          	lea    0x7(%esp),%eax
c002c478:	50                   	push   %eax
c002c479:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002c47d:	50                   	push   %eax
c002c47e:	8d 44 24 14          	lea    0x14(%esp),%eax
c002c482:	50                   	push   %eax
c002c483:	53                   	push   %ebx
c002c484:	e8 4c fd ff ff       	call   c002c1d5 <filesys_path_parse>
c002c489:	83 c4 10             	add    $0x10,%esp
c002c48c:	84 c0                	test   %al,%al
c002c48e:	0f 84 d2 00 00 00    	je     c002c566 <filesys_open+0x144>
    retdir = dir_subdir_lookup (dir, pure_name);
c002c494:	83 ec 08             	sub    $0x8,%esp
c002c497:	ff 74 24 10          	pushl  0x10(%esp)
c002c49b:	ff 74 24 18          	pushl  0x18(%esp)
c002c49f:	e8 04 0d 00 00       	call   c002d1a8 <dir_subdir_lookup>
c002c4a4:	89 c6                	mov    %eax,%esi
    retfile = dir_subfile_lookup (dir, pure_name);
c002c4a6:	83 c4 08             	add    $0x8,%esp
c002c4a9:	ff 74 24 10          	pushl  0x10(%esp)
c002c4ad:	ff 74 24 18          	pushl  0x18(%esp)
c002c4b1:	e8 48 0f 00 00       	call   c002d3fe <dir_subfile_lookup>
c002c4b6:	89 c3                	mov    %eax,%ebx
    if (retdir != NULL) {
c002c4b8:	83 c4 10             	add    $0x10,%esp
c002c4bb:	85 f6                	test   %esi,%esi
c002c4bd:	0f 84 87 00 00 00    	je     c002c54a <filesys_open+0x128>
      file = file_open (inode_reopen (dir_get_inode (retdir)));
c002c4c3:	83 ec 0c             	sub    $0xc,%esp
c002c4c6:	56                   	push   %esi
c002c4c7:	e8 cc 07 00 00       	call   c002cc98 <dir_get_inode>
c002c4cc:	89 04 24             	mov    %eax,(%esp)
c002c4cf:	e8 76 15 00 00       	call   c002da4a <inode_reopen>
c002c4d4:	89 04 24             	mov    %eax,(%esp)
c002c4d7:	e8 9e 03 00 00       	call   c002c87a <file_open>
c002c4dc:	89 c3                	mov    %eax,%ebx
      file_set_dir (file, dir_reopen (dir));
c002c4de:	83 c4 04             	add    $0x4,%esp
c002c4e1:	ff 74 24 18          	pushl  0x18(%esp)
c002c4e5:	e8 6e 07 00 00       	call   c002cc58 <dir_reopen>
c002c4ea:	83 c4 08             	add    $0x8,%esp
c002c4ed:	50                   	push   %eax
c002c4ee:	53                   	push   %ebx
c002c4ef:	e8 21 06 00 00       	call   c002cb15 <file_set_dir>
      dir_close (retdir);
c002c4f4:	89 34 24             	mov    %esi,(%esp)
c002c4f7:	e8 76 07 00 00       	call   c002cc72 <dir_close>
c002c4fc:	83 c4 10             	add    $0x10,%esp
    dir_close (dir);
c002c4ff:	83 ec 0c             	sub    $0xc,%esp
c002c502:	ff 74 24 18          	pushl  0x18(%esp)
c002c506:	e8 67 07 00 00       	call   c002cc72 <dir_close>
c002c50b:	83 c4 10             	add    $0x10,%esp
  free (pure_name);
c002c50e:	83 ec 0c             	sub    $0xc,%esp
c002c511:	ff 74 24 14          	pushl  0x14(%esp)
c002c515:	e8 57 76 ff ff       	call   c0023b71 <free>
}
c002c51a:	89 d8                	mov    %ebx,%eax
c002c51c:	83 c4 24             	add    $0x24,%esp
c002c51f:	5b                   	pop    %ebx
c002c520:	5e                   	pop    %esi
c002c521:	c3                   	ret    
    file = file_open(inode_open(ROOT_DIR_SECTOR));
c002c522:	83 ec 0c             	sub    $0xc,%esp
c002c525:	6a 01                	push   $0x1
c002c527:	e8 2a 15 00 00       	call   c002da56 <inode_open>
c002c52c:	89 04 24             	mov    %eax,(%esp)
c002c52f:	e8 46 03 00 00       	call   c002c87a <file_open>
c002c534:	89 c3                	mov    %eax,%ebx
    file_set_dir(file, dir_open_root());
c002c536:	e8 07 07 00 00       	call   c002cc42 <dir_open_root>
c002c53b:	83 c4 08             	add    $0x8,%esp
c002c53e:	50                   	push   %eax
c002c53f:	53                   	push   %ebx
c002c540:	e8 d0 05 00 00       	call   c002cb15 <file_set_dir>
c002c545:	83 c4 10             	add    $0x10,%esp
c002c548:	eb c4                	jmp    c002c50e <filesys_open+0xec>
      if (!is_dir) {
c002c54a:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c002c54f:	74 ae                	je     c002c4ff <filesys_open+0xdd>
  struct file * file = NULL;
c002c551:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c556:	eb a7                	jmp    c002c4ff <filesys_open+0xdd>
c002c558:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c55d:	eb af                	jmp    c002c50e <filesys_open+0xec>
c002c55f:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c564:	eb a8                	jmp    c002c50e <filesys_open+0xec>
c002c566:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c56b:	eb a1                	jmp    c002c50e <filesys_open+0xec>
c002c56d:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c572:	eb 9a                	jmp    c002c50e <filesys_open+0xec>

c002c574 <filesys_remove>:
{
c002c574:	53                   	push   %ebx
c002c575:	83 ec 20             	sub    $0x20,%esp
c002c578:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  char *pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002c57c:	6a 01                	push   $0x1
c002c57e:	6a 0f                	push   $0xf
c002c580:	e8 a2 75 ff ff       	call   c0023b27 <calloc>
c002c585:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (name != NULL  && strlen (name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c589:	83 c4 10             	add    $0x10,%esp
c002c58c:	85 db                	test   %ebx,%ebx
c002c58e:	0f 84 91 00 00 00    	je     c002c625 <filesys_remove+0xb1>
c002c594:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c597:	0f 84 8c 00 00 00    	je     c002c629 <filesys_remove+0xb5>
c002c59d:	83 ec 0c             	sub    $0xc,%esp
c002c5a0:	53                   	push   %ebx
c002c5a1:	e8 06 fc ff ff       	call   c002c1ac <filesys_is_root_dir>
c002c5a6:	83 c4 10             	add    $0x10,%esp
c002c5a9:	84 c0                	test   %al,%al
c002c5ab:	74 04                	je     c002c5b1 <filesys_remove+0x3d>
  bool success = false;
c002c5ad:	b3 00                	mov    $0x0,%bl
c002c5af:	eb 7a                	jmp    c002c62b <filesys_remove+0xb7>
  if (name != NULL  && strlen (name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c5b1:	8d 44 24 07          	lea    0x7(%esp),%eax
c002c5b5:	50                   	push   %eax
c002c5b6:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002c5ba:	50                   	push   %eax
c002c5bb:	8d 44 24 14          	lea    0x14(%esp),%eax
c002c5bf:	50                   	push   %eax
c002c5c0:	53                   	push   %ebx
c002c5c1:	e8 0f fc ff ff       	call   c002c1d5 <filesys_path_parse>
c002c5c6:	88 c3                	mov    %al,%bl
c002c5c8:	83 c4 10             	add    $0x10,%esp
c002c5cb:	84 c0                	test   %al,%al
c002c5cd:	74 5c                	je     c002c62b <filesys_remove+0xb7>
    success = dir_subdir_delete (dir, pure_name) || (!is_dir && dir_subfile_delete (dir, pure_name));
c002c5cf:	83 ec 08             	sub    $0x8,%esp
c002c5d2:	ff 74 24 10          	pushl  0x10(%esp)
c002c5d6:	ff 74 24 18          	pushl  0x18(%esp)
c002c5da:	e8 5c 0c 00 00       	call   c002d23b <dir_subdir_delete>
c002c5df:	83 c4 10             	add    $0x10,%esp
c002c5e2:	84 c0                	test   %al,%al
c002c5e4:	75 26                	jne    c002c60c <filesys_remove+0x98>
c002c5e6:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c002c5eb:	74 07                	je     c002c5f4 <filesys_remove+0x80>
c002c5ed:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c5f2:	eb 1d                	jmp    c002c611 <filesys_remove+0x9d>
c002c5f4:	83 ec 08             	sub    $0x8,%esp
c002c5f7:	ff 74 24 10          	pushl  0x10(%esp)
c002c5fb:	ff 74 24 18          	pushl  0x18(%esp)
c002c5ff:	e8 ae 0e 00 00       	call   c002d4b2 <dir_subfile_delete>
c002c604:	0f b6 d8             	movzbl %al,%ebx
c002c607:	83 c4 10             	add    $0x10,%esp
c002c60a:	eb 05                	jmp    c002c611 <filesys_remove+0x9d>
c002c60c:	bb 01 00 00 00       	mov    $0x1,%ebx
c002c611:	83 e3 01             	and    $0x1,%ebx
    dir_close (dir);
c002c614:	83 ec 0c             	sub    $0xc,%esp
c002c617:	ff 74 24 18          	pushl  0x18(%esp)
c002c61b:	e8 52 06 00 00       	call   c002cc72 <dir_close>
c002c620:	83 c4 10             	add    $0x10,%esp
c002c623:	eb 06                	jmp    c002c62b <filesys_remove+0xb7>
  bool success = false;
c002c625:	b3 00                	mov    $0x0,%bl
c002c627:	eb 02                	jmp    c002c62b <filesys_remove+0xb7>
c002c629:	b3 00                	mov    $0x0,%bl
  free (pure_name);
c002c62b:	83 ec 0c             	sub    $0xc,%esp
c002c62e:	ff 74 24 14          	pushl  0x14(%esp)
c002c632:	e8 3a 75 ff ff       	call   c0023b71 <free>
}
c002c637:	88 d8                	mov    %bl,%al
c002c639:	83 c4 28             	add    $0x28,%esp
c002c63c:	5b                   	pop    %ebx
c002c63d:	c3                   	ret    

c002c63e <free_map_init>:
static struct bitmap *free_map;      /* Free map, one bit per sector. */

/* Initializes the free map. */
void
free_map_init (void) 
{
c002c63e:	83 ec 18             	sub    $0x18,%esp
  free_map = bitmap_create (block_size (fs_device));
c002c641:	ff 35 98 55 04 c0    	pushl  0xc0045598
c002c647:	e8 d6 86 ff ff       	call   c0024d22 <block_size>
c002c64c:	89 04 24             	mov    %eax,(%esp)
c002c64f:	e8 a4 ce ff ff       	call   c00294f8 <bitmap_create>
c002c654:	a3 b4 ce 03 c0       	mov    %eax,0xc003ceb4
  if (free_map == NULL)
c002c659:	83 c4 10             	add    $0x10,%esp
c002c65c:	85 c0                	test   %eax,%eax
c002c65e:	74 1f                	je     c002c67f <free_map_init+0x41>
    PANIC ("bitmap creation failed--file system device is too large");
  bitmap_mark (free_map, FREE_MAP_SECTOR);
c002c660:	83 ec 08             	sub    $0x8,%esp
c002c663:	6a 00                	push   $0x0
c002c665:	50                   	push   %eax
c002c666:	e8 58 cc ff ff       	call   c00292c3 <bitmap_mark>
  bitmap_mark (free_map, ROOT_DIR_SECTOR);
c002c66b:	83 c4 08             	add    $0x8,%esp
c002c66e:	6a 01                	push   $0x1
c002c670:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c676:	e8 48 cc ff ff       	call   c00292c3 <bitmap_mark>
}
c002c67b:	83 c4 1c             	add    $0x1c,%esp
c002c67e:	c3                   	ret    
    PANIC ("bitmap creation failed--file system device is too large");
c002c67f:	68 7c 24 03 c0       	push   $0xc003247c
c002c684:	68 4c ff 02 c0       	push   $0xc002ff4c
c002c689:	6a 11                	push   $0x11
c002c68b:	68 d7 24 03 c0       	push   $0xc00324d7
c002c690:	e8 92 bf ff ff       	call   c0028627 <debug_panic>

c002c695 <free_map_allocate>:
   Returns true if successful, false if not enough consecutive
   sectors were available or if the free_map file could not be
   written. */
bool
free_map_allocate (size_t cnt, block_sector_t *sectorp)
{
c002c695:	56                   	push   %esi
c002c696:	53                   	push   %ebx
c002c697:	83 ec 04             	sub    $0x4,%esp
c002c69a:	8b 74 24 10          	mov    0x10(%esp),%esi
  block_sector_t sector = bitmap_scan_and_flip (free_map, 0, cnt, false);
c002c69e:	6a 00                	push   $0x0
c002c6a0:	56                   	push   %esi
c002c6a1:	6a 00                	push   $0x0
c002c6a3:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c6a9:	e8 7d d1 ff ff       	call   c002982b <bitmap_scan_and_flip>
  if (sector != BITMAP_ERROR
c002c6ae:	83 c4 10             	add    $0x10,%esp
c002c6b1:	83 f8 ff             	cmp    $0xffffffff,%eax
c002c6b4:	74 45                	je     c002c6fb <free_map_allocate+0x66>
c002c6b6:	89 c3                	mov    %eax,%ebx
      && free_map_file != NULL
c002c6b8:	a1 b8 ce 03 c0       	mov    0xc003ceb8,%eax
c002c6bd:	85 c0                	test   %eax,%eax
c002c6bf:	74 16                	je     c002c6d7 <free_map_allocate+0x42>
      && !bitmap_write (free_map, free_map_file))
c002c6c1:	83 ec 08             	sub    $0x8,%esp
c002c6c4:	50                   	push   %eax
c002c6c5:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c6cb:	e8 17 d2 ff ff       	call   c00298e7 <bitmap_write>
c002c6d0:	83 c4 10             	add    $0x10,%esp
c002c6d3:	84 c0                	test   %al,%al
c002c6d5:	74 12                	je     c002c6e9 <free_map_allocate+0x54>
    {
      bitmap_set_multiple (free_map, sector, cnt, false); 
      sector = BITMAP_ERROR;
    }
  if (sector != BITMAP_ERROR)
    *sectorp = sector;
c002c6d7:	8b 44 24 14          	mov    0x14(%esp),%eax
c002c6db:	89 18                	mov    %ebx,(%eax)
  return sector != BITMAP_ERROR;
c002c6dd:	83 fb ff             	cmp    $0xffffffff,%ebx
c002c6e0:	0f 95 c0             	setne  %al
}
c002c6e3:	83 c4 04             	add    $0x4,%esp
c002c6e6:	5b                   	pop    %ebx
c002c6e7:	5e                   	pop    %esi
c002c6e8:	c3                   	ret    
      bitmap_set_multiple (free_map, sector, cnt, false); 
c002c6e9:	6a 00                	push   $0x0
c002c6eb:	56                   	push   %esi
c002c6ec:	53                   	push   %ebx
c002c6ed:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c6f3:	e8 11 cd ff ff       	call   c0029409 <bitmap_set_multiple>
c002c6f8:	83 c4 10             	add    $0x10,%esp
{
c002c6fb:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002c700:	eb db                	jmp    c002c6dd <free_map_allocate+0x48>

c002c702 <free_map_release>:

/* Makes CNT sectors starting at SECTOR available for use. */
void
free_map_release (block_sector_t sector, size_t cnt)
{
c002c702:	56                   	push   %esi
c002c703:	53                   	push   %ebx
c002c704:	83 ec 08             	sub    $0x8,%esp
c002c707:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002c70b:	8b 74 24 18          	mov    0x18(%esp),%esi
  ASSERT (bitmap_all (free_map, sector, cnt));
c002c70f:	56                   	push   %esi
c002c710:	53                   	push   %ebx
c002c711:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c717:	e8 42 d0 ff ff       	call   c002975e <bitmap_all>
c002c71c:	83 c4 10             	add    $0x10,%esp
c002c71f:	84 c0                	test   %al,%al
c002c721:	74 29                	je     c002c74c <free_map_release+0x4a>
  bitmap_set_multiple (free_map, sector, cnt, false);
c002c723:	6a 00                	push   $0x0
c002c725:	56                   	push   %esi
c002c726:	53                   	push   %ebx
c002c727:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c72d:	e8 d7 cc ff ff       	call   c0029409 <bitmap_set_multiple>
  bitmap_write (free_map, free_map_file);
c002c732:	83 c4 08             	add    $0x8,%esp
c002c735:	ff 35 b8 ce 03 c0    	pushl  0xc003ceb8
c002c73b:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c741:	e8 a1 d1 ff ff       	call   c00298e7 <bitmap_write>
}
c002c746:	83 c4 14             	add    $0x14,%esp
c002c749:	5b                   	pop    %ebx
c002c74a:	5e                   	pop    %esi
c002c74b:	c3                   	ret    
  ASSERT (bitmap_all (free_map, sector, cnt));
c002c74c:	83 ec 0c             	sub    $0xc,%esp
c002c74f:	68 b4 24 03 c0       	push   $0xc00324b4
c002c754:	68 21 01 03 c0       	push   $0xc0030121
c002c759:	68 38 ff 02 c0       	push   $0xc002ff38
c002c75e:	6a 2f                	push   $0x2f
c002c760:	68 d7 24 03 c0       	push   $0xc00324d7
c002c765:	e8 bd be ff ff       	call   c0028627 <debug_panic>

c002c76a <free_map_open>:

/* Opens the free map file and reads it from disk. */
void
free_map_open (void) 
{
c002c76a:	83 ec 18             	sub    $0x18,%esp
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002c76d:	6a 00                	push   $0x0
c002c76f:	e8 e2 12 00 00       	call   c002da56 <inode_open>
c002c774:	89 04 24             	mov    %eax,(%esp)
c002c777:	e8 fe 00 00 00       	call   c002c87a <file_open>
c002c77c:	a3 b8 ce 03 c0       	mov    %eax,0xc003ceb8
  if (free_map_file == NULL)
c002c781:	83 c4 10             	add    $0x10,%esp
c002c784:	85 c0                	test   %eax,%eax
c002c786:	74 1a                	je     c002c7a2 <free_map_open+0x38>
    PANIC ("can't open free map");
  if (!bitmap_read (free_map, free_map_file))
c002c788:	83 ec 08             	sub    $0x8,%esp
c002c78b:	50                   	push   %eax
c002c78c:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c792:	e8 ec d0 ff ff       	call   c0029883 <bitmap_read>
c002c797:	83 c4 10             	add    $0x10,%esp
c002c79a:	84 c0                	test   %al,%al
c002c79c:	74 1a                	je     c002c7b8 <free_map_open+0x4e>
    PANIC ("can't read free map");
}
c002c79e:	83 c4 0c             	add    $0xc,%esp
c002c7a1:	c3                   	ret    
    PANIC ("can't open free map");
c002c7a2:	68 f0 24 03 c0       	push   $0xc00324f0
c002c7a7:	68 28 ff 02 c0       	push   $0xc002ff28
c002c7ac:	6a 3a                	push   $0x3a
c002c7ae:	68 d7 24 03 c0       	push   $0xc00324d7
c002c7b3:	e8 6f be ff ff       	call   c0028627 <debug_panic>
    PANIC ("can't read free map");
c002c7b8:	68 04 25 03 c0       	push   $0xc0032504
c002c7bd:	68 28 ff 02 c0       	push   $0xc002ff28
c002c7c2:	6a 3c                	push   $0x3c
c002c7c4:	68 d7 24 03 c0       	push   $0xc00324d7
c002c7c9:	e8 59 be ff ff       	call   c0028627 <debug_panic>

c002c7ce <free_map_close>:

/* Writes the free map to disk and closes the free map file. */
void
free_map_close (void) 
{
c002c7ce:	83 ec 18             	sub    $0x18,%esp
  file_close (free_map_file);
c002c7d1:	ff 35 b8 ce 03 c0    	pushl  0xc003ceb8
c002c7d7:	e8 36 02 00 00       	call   c002ca12 <file_close>
}
c002c7dc:	83 c4 1c             	add    $0x1c,%esp
c002c7df:	c3                   	ret    

c002c7e0 <free_map_create>:

/* Creates a new free map file on disk and writes the free map to
   it. */
void
free_map_create (void) 
{
c002c7e0:	83 ec 18             	sub    $0x18,%esp
  /* Create inode. */
  if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map)))
c002c7e3:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c7e9:	e8 85 d0 ff ff       	call   c0029873 <bitmap_file_size>
c002c7ee:	83 c4 08             	add    $0x8,%esp
c002c7f1:	50                   	push   %eax
c002c7f2:	6a 00                	push   $0x0
c002c7f4:	e8 03 10 00 00       	call   c002d7fc <inode_create>
c002c7f9:	83 c4 10             	add    $0x10,%esp
c002c7fc:	84 c0                	test   %al,%al
c002c7fe:	74 38                	je     c002c838 <free_map_create+0x58>
    PANIC ("free map creation failed");

  /* Write bitmap to file. */
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002c800:	83 ec 0c             	sub    $0xc,%esp
c002c803:	6a 00                	push   $0x0
c002c805:	e8 4c 12 00 00       	call   c002da56 <inode_open>
c002c80a:	89 04 24             	mov    %eax,(%esp)
c002c80d:	e8 68 00 00 00       	call   c002c87a <file_open>
c002c812:	a3 b8 ce 03 c0       	mov    %eax,0xc003ceb8
  if (free_map_file == NULL)
c002c817:	83 c4 10             	add    $0x10,%esp
c002c81a:	85 c0                	test   %eax,%eax
c002c81c:	74 30                	je     c002c84e <free_map_create+0x6e>
    PANIC ("can't open free map");
  if (!bitmap_write (free_map, free_map_file))
c002c81e:	83 ec 08             	sub    $0x8,%esp
c002c821:	50                   	push   %eax
c002c822:	ff 35 b4 ce 03 c0    	pushl  0xc003ceb4
c002c828:	e8 ba d0 ff ff       	call   c00298e7 <bitmap_write>
c002c82d:	83 c4 10             	add    $0x10,%esp
c002c830:	84 c0                	test   %al,%al
c002c832:	74 30                	je     c002c864 <free_map_create+0x84>
    PANIC ("can't write free map");
}
c002c834:	83 c4 0c             	add    $0xc,%esp
c002c837:	c3                   	ret    
    PANIC ("free map creation failed");
c002c838:	68 18 25 03 c0       	push   $0xc0032518
c002c83d:	68 18 ff 02 c0       	push   $0xc002ff18
c002c842:	6a 4d                	push   $0x4d
c002c844:	68 d7 24 03 c0       	push   $0xc00324d7
c002c849:	e8 d9 bd ff ff       	call   c0028627 <debug_panic>
    PANIC ("can't open free map");
c002c84e:	68 f0 24 03 c0       	push   $0xc00324f0
c002c853:	68 18 ff 02 c0       	push   $0xc002ff18
c002c858:	6a 52                	push   $0x52
c002c85a:	68 d7 24 03 c0       	push   $0xc00324d7
c002c85f:	e8 c3 bd ff ff       	call   c0028627 <debug_panic>
    PANIC ("can't write free map");
c002c864:	68 31 25 03 c0       	push   $0xc0032531
c002c869:	68 18 ff 02 c0       	push   $0xc002ff18
c002c86e:	6a 54                	push   $0x54
c002c870:	68 d7 24 03 c0       	push   $0xc00324d7
c002c875:	e8 ad bd ff ff       	call   c0028627 <debug_panic>

c002c87a <file_open>:
/* Opens a file for the given INODE, of which it takes ownership,
   and returns the new file.  Returns a null pointer if an
   allocation fails or if INODE is null. */
struct file *
file_open (struct inode *inode) 
{
c002c87a:	56                   	push   %esi
c002c87b:	53                   	push   %ebx
c002c87c:	83 ec 0c             	sub    $0xc,%esp
c002c87f:	8b 74 24 18          	mov    0x18(%esp),%esi
  struct file *file = calloc (1, sizeof *file);
c002c883:	6a 10                	push   $0x10
c002c885:	6a 01                	push   $0x1
c002c887:	e8 9b 72 ff ff       	call   c0023b27 <calloc>
c002c88c:	89 c3                	mov    %eax,%ebx
  if (inode != NULL && file != NULL)
c002c88e:	83 c4 10             	add    $0x10,%esp
c002c891:	85 f6                	test   %esi,%esi
c002c893:	74 19                	je     c002c8ae <file_open+0x34>
c002c895:	85 c0                	test   %eax,%eax
c002c897:	74 15                	je     c002c8ae <file_open+0x34>
    {
      file->inode = inode;
c002c899:	89 30                	mov    %esi,(%eax)
      file->pos = 0;
c002c89b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      file->deny_write = false;
c002c8a2:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    {
      inode_close (inode);
      free (file);
      return NULL; 
    }
}
c002c8a6:	89 d8                	mov    %ebx,%eax
c002c8a8:	83 c4 04             	add    $0x4,%esp
c002c8ab:	5b                   	pop    %ebx
c002c8ac:	5e                   	pop    %esi
c002c8ad:	c3                   	ret    
      inode_close (inode);
c002c8ae:	83 ec 0c             	sub    $0xc,%esp
c002c8b1:	56                   	push   %esi
c002c8b2:	e8 47 12 00 00       	call   c002dafe <inode_close>
      free (file);
c002c8b7:	89 1c 24             	mov    %ebx,(%esp)
c002c8ba:	e8 b2 72 ff ff       	call   c0023b71 <free>
      return NULL; 
c002c8bf:	83 c4 10             	add    $0x10,%esp
c002c8c2:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c8c7:	eb dd                	jmp    c002c8a6 <file_open+0x2c>

c002c8c9 <file_reopen>:

/* Opens and returns a new file for the same inode as FILE.
   Returns a null pointer if unsuccessful. */
struct file *
file_reopen (struct file *file) 
{
c002c8c9:	56                   	push   %esi
c002c8ca:	53                   	push   %ebx
c002c8cb:	83 ec 10             	sub    $0x10,%esp
c002c8ce:	8b 74 24 1c          	mov    0x1c(%esp),%esi
#ifdef FILESYS
  struct file* f = file_open (inode_reopen (file->inode));
c002c8d2:	ff 36                	pushl  (%esi)
c002c8d4:	e8 71 11 00 00       	call   c002da4a <inode_reopen>
c002c8d9:	89 04 24             	mov    %eax,(%esp)
c002c8dc:	e8 99 ff ff ff       	call   c002c87a <file_open>
c002c8e1:	89 c3                	mov    %eax,%ebx
  file_set_dir(f, dir_reopen(file->dir));
c002c8e3:	83 c4 04             	add    $0x4,%esp
c002c8e6:	ff 76 0c             	pushl  0xc(%esi)
c002c8e9:	e8 6a 03 00 00       	call   c002cc58 <dir_reopen>
}

#ifdef FILESYS
void
file_set_dir(struct file* file, struct dir* dir) {
    file->dir = dir;
c002c8ee:	89 43 0c             	mov    %eax,0xc(%ebx)
}
c002c8f1:	89 d8                	mov    %ebx,%eax
c002c8f3:	83 c4 14             	add    $0x14,%esp
c002c8f6:	5b                   	pop    %ebx
c002c8f7:	5e                   	pop    %esi
c002c8f8:	c3                   	ret    

c002c8f9 <file_get_inode>:
  return file->inode;
c002c8f9:	8b 44 24 04          	mov    0x4(%esp),%eax
c002c8fd:	8b 00                	mov    (%eax),%eax
}
c002c8ff:	c3                   	ret    

c002c900 <file_read>:
{
c002c900:	53                   	push   %ebx
c002c901:	83 ec 08             	sub    $0x8,%esp
c002c904:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  off_t bytes_read = inode_read_at (file->inode, buffer, size, file->pos);
c002c908:	ff 73 04             	pushl  0x4(%ebx)
c002c90b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c90f:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c913:	ff 33                	pushl  (%ebx)
c002c915:	e8 58 13 00 00       	call   c002dc72 <inode_read_at>
  file->pos += bytes_read;
c002c91a:	01 43 04             	add    %eax,0x4(%ebx)
}
c002c91d:	83 c4 18             	add    $0x18,%esp
c002c920:	5b                   	pop    %ebx
c002c921:	c3                   	ret    

c002c922 <file_read_at>:
{
c002c922:	83 ec 0c             	sub    $0xc,%esp
  return inode_read_at (file->inode, buffer, size, file_ofs);
c002c925:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c929:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c92d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c931:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002c935:	ff 30                	pushl  (%eax)
c002c937:	e8 36 13 00 00       	call   c002dc72 <inode_read_at>
}
c002c93c:	83 c4 1c             	add    $0x1c,%esp
c002c93f:	c3                   	ret    

c002c940 <file_write>:
{
c002c940:	53                   	push   %ebx
c002c941:	83 ec 08             	sub    $0x8,%esp
c002c944:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  off_t bytes_written = inode_write_at (file->inode, buffer, size, file->pos);
c002c948:	ff 73 04             	pushl  0x4(%ebx)
c002c94b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c94f:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c953:	ff 33                	pushl  (%ebx)
c002c955:	e8 44 14 00 00       	call   c002dd9e <inode_write_at>
  file->pos += bytes_written;
c002c95a:	01 43 04             	add    %eax,0x4(%ebx)
}
c002c95d:	83 c4 18             	add    $0x18,%esp
c002c960:	5b                   	pop    %ebx
c002c961:	c3                   	ret    

c002c962 <file_write_at>:
{
c002c962:	83 ec 0c             	sub    $0xc,%esp
  return inode_write_at (file->inode, buffer, size, file_ofs);
c002c965:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c969:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c96d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c971:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002c975:	ff 30                	pushl  (%eax)
c002c977:	e8 22 14 00 00       	call   c002dd9e <inode_write_at>
}
c002c97c:	83 c4 1c             	add    $0x1c,%esp
c002c97f:	c3                   	ret    

c002c980 <file_deny_write>:
{
c002c980:	83 ec 0c             	sub    $0xc,%esp
c002c983:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002c987:	85 c0                	test   %eax,%eax
c002c989:	74 0a                	je     c002c995 <file_deny_write+0x15>
  if (!file->deny_write) 
c002c98b:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002c98f:	74 25                	je     c002c9b6 <file_deny_write+0x36>
}
c002c991:	83 c4 0c             	add    $0xc,%esp
c002c994:	c3                   	ret    
  ASSERT (file != NULL);
c002c995:	83 ec 0c             	sub    $0xc,%esp
c002c998:	68 46 25 03 c0       	push   $0xc0032546
c002c99d:	68 21 01 03 c0       	push   $0xc0030121
c002c9a2:	68 94 ff 02 c0       	push   $0xc002ff94
c002c9a7:	68 87 00 00 00       	push   $0x87
c002c9ac:	68 53 25 03 c0       	push   $0xc0032553
c002c9b1:	e8 71 bc ff ff       	call   c0028627 <debug_panic>
      file->deny_write = true;
c002c9b6:	c6 40 08 01          	movb   $0x1,0x8(%eax)
      inode_deny_write (file->inode);
c002c9ba:	83 ec 0c             	sub    $0xc,%esp
c002c9bd:	ff 30                	pushl  (%eax)
c002c9bf:	e8 6d 15 00 00       	call   c002df31 <inode_deny_write>
c002c9c4:	83 c4 10             	add    $0x10,%esp
}
c002c9c7:	eb c8                	jmp    c002c991 <file_deny_write+0x11>

c002c9c9 <file_allow_write>:
{
c002c9c9:	83 ec 0c             	sub    $0xc,%esp
c002c9cc:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002c9d0:	85 c0                	test   %eax,%eax
c002c9d2:	74 0a                	je     c002c9de <file_allow_write+0x15>
  if (file->deny_write) 
c002c9d4:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002c9d8:	75 25                	jne    c002c9ff <file_allow_write+0x36>
}
c002c9da:	83 c4 0c             	add    $0xc,%esp
c002c9dd:	c3                   	ret    
  ASSERT (file != NULL);
c002c9de:	83 ec 0c             	sub    $0xc,%esp
c002c9e1:	68 46 25 03 c0       	push   $0xc0032546
c002c9e6:	68 21 01 03 c0       	push   $0xc0030121
c002c9eb:	68 80 ff 02 c0       	push   $0xc002ff80
c002c9f0:	68 95 00 00 00       	push   $0x95
c002c9f5:	68 53 25 03 c0       	push   $0xc0032553
c002c9fa:	e8 28 bc ff ff       	call   c0028627 <debug_panic>
      file->deny_write = false;
c002c9ff:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      inode_allow_write (file->inode);
c002ca03:	83 ec 0c             	sub    $0xc,%esp
c002ca06:	ff 30                	pushl  (%eax)
c002ca08:	e8 5c 15 00 00       	call   c002df69 <inode_allow_write>
c002ca0d:	83 c4 10             	add    $0x10,%esp
}
c002ca10:	eb c8                	jmp    c002c9da <file_allow_write+0x11>

c002ca12 <file_close>:
{
c002ca12:	53                   	push   %ebx
c002ca13:	83 ec 08             	sub    $0x8,%esp
c002ca16:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (file != NULL)
c002ca1a:	85 db                	test   %ebx,%ebx
c002ca1c:	74 29                	je     c002ca47 <file_close+0x35>
      file_allow_write (file);
c002ca1e:	83 ec 0c             	sub    $0xc,%esp
c002ca21:	53                   	push   %ebx
c002ca22:	e8 a2 ff ff ff       	call   c002c9c9 <file_allow_write>
      dir_close (file->dir);
c002ca27:	83 c4 04             	add    $0x4,%esp
c002ca2a:	ff 73 0c             	pushl  0xc(%ebx)
c002ca2d:	e8 40 02 00 00       	call   c002cc72 <dir_close>
      inode_close (file->inode);
c002ca32:	83 c4 04             	add    $0x4,%esp
c002ca35:	ff 33                	pushl  (%ebx)
c002ca37:	e8 c2 10 00 00       	call   c002dafe <inode_close>
      free (file); 
c002ca3c:	89 1c 24             	mov    %ebx,(%esp)
c002ca3f:	e8 2d 71 ff ff       	call   c0023b71 <free>
c002ca44:	83 c4 10             	add    $0x10,%esp
}
c002ca47:	83 c4 08             	add    $0x8,%esp
c002ca4a:	5b                   	pop    %ebx
c002ca4b:	c3                   	ret    

c002ca4c <file_length>:
{
c002ca4c:	83 ec 0c             	sub    $0xc,%esp
c002ca4f:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002ca53:	85 c0                	test   %eax,%eax
c002ca55:	74 0e                	je     c002ca65 <file_length+0x19>
  return inode_length (file->inode);
c002ca57:	83 ec 0c             	sub    $0xc,%esp
c002ca5a:	ff 30                	pushl  (%eax)
c002ca5c:	e8 65 15 00 00       	call   c002dfc6 <inode_length>
}
c002ca61:	83 c4 1c             	add    $0x1c,%esp
c002ca64:	c3                   	ret    
  ASSERT (file != NULL);
c002ca65:	83 ec 0c             	sub    $0xc,%esp
c002ca68:	68 46 25 03 c0       	push   $0xc0032546
c002ca6d:	68 21 01 03 c0       	push   $0xc0030121
c002ca72:	68 74 ff 02 c0       	push   $0xc002ff74
c002ca77:	68 a1 00 00 00       	push   $0xa1
c002ca7c:	68 53 25 03 c0       	push   $0xc0032553
c002ca81:	e8 a1 bb ff ff       	call   c0028627 <debug_panic>

c002ca86 <file_seek>:
{
c002ca86:	83 ec 0c             	sub    $0xc,%esp
c002ca89:	8b 44 24 10          	mov    0x10(%esp),%eax
c002ca8d:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (file != NULL);
c002ca91:	85 c0                	test   %eax,%eax
c002ca93:	74 0b                	je     c002caa0 <file_seek+0x1a>
  ASSERT (new_pos >= 0);
c002ca95:	85 d2                	test   %edx,%edx
c002ca97:	78 28                	js     c002cac1 <file_seek+0x3b>
  file->pos = new_pos;
c002ca99:	89 50 04             	mov    %edx,0x4(%eax)
}
c002ca9c:	83 c4 0c             	add    $0xc,%esp
c002ca9f:	c3                   	ret    
  ASSERT (file != NULL);
c002caa0:	83 ec 0c             	sub    $0xc,%esp
c002caa3:	68 46 25 03 c0       	push   $0xc0032546
c002caa8:	68 21 01 03 c0       	push   $0xc0030121
c002caad:	68 68 ff 02 c0       	push   $0xc002ff68
c002cab2:	68 aa 00 00 00       	push   $0xaa
c002cab7:	68 53 25 03 c0       	push   $0xc0032553
c002cabc:	e8 66 bb ff ff       	call   c0028627 <debug_panic>
  ASSERT (new_pos >= 0);
c002cac1:	83 ec 0c             	sub    $0xc,%esp
c002cac4:	68 68 25 03 c0       	push   $0xc0032568
c002cac9:	68 21 01 03 c0       	push   $0xc0030121
c002cace:	68 68 ff 02 c0       	push   $0xc002ff68
c002cad3:	68 ab 00 00 00       	push   $0xab
c002cad8:	68 53 25 03 c0       	push   $0xc0032553
c002cadd:	e8 45 bb ff ff       	call   c0028627 <debug_panic>

c002cae2 <file_tell>:
{
c002cae2:	83 ec 0c             	sub    $0xc,%esp
c002cae5:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002cae9:	85 c0                	test   %eax,%eax
c002caeb:	74 07                	je     c002caf4 <file_tell+0x12>
  return file->pos;
c002caed:	8b 40 04             	mov    0x4(%eax),%eax
}
c002caf0:	83 c4 0c             	add    $0xc,%esp
c002caf3:	c3                   	ret    
  ASSERT (file != NULL);
c002caf4:	83 ec 0c             	sub    $0xc,%esp
c002caf7:	68 46 25 03 c0       	push   $0xc0032546
c002cafc:	68 21 01 03 c0       	push   $0xc0030121
c002cb01:	68 5c ff 02 c0       	push   $0xc002ff5c
c002cb06:	68 b4 00 00 00       	push   $0xb4
c002cb0b:	68 53 25 03 c0       	push   $0xc0032553
c002cb10:	e8 12 bb ff ff       	call   c0028627 <debug_panic>

c002cb15 <file_set_dir>:
    file->dir = dir;
c002cb15:	8b 54 24 08          	mov    0x8(%esp),%edx
c002cb19:	8b 44 24 04          	mov    0x4(%esp),%eax
c002cb1d:	89 50 0c             	mov    %edx,0xc(%eax)
c002cb20:	c3                   	ret    

c002cb21 <file_get_dir>:
}

struct dir*
file_get_dir(struct file* file) {
  return file->dir;
c002cb21:	8b 44 24 04          	mov    0x4(%esp),%eax
c002cb25:	8b 40 0c             	mov    0xc(%eax),%eax
}
c002cb28:	c3                   	ret    

c002cb29 <lookup>:
   directory entry if OFSP is non-null.
   otherwise, returns false and ignores EP and OFSP. */
static bool
lookup (const struct dir *dir, const char *name,
        struct dir_entry *ep, off_t *ofsp) 
{
c002cb29:	55                   	push   %ebp
c002cb2a:	57                   	push   %edi
c002cb2b:	56                   	push   %esi
c002cb2c:	53                   	push   %ebx
c002cb2d:	83 ec 3c             	sub    $0x3c,%esp
c002cb30:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  struct dir_entry e;
  size_t ofs;
  
  ASSERT (dir != NULL);
c002cb34:	85 c0                	test   %eax,%eax
c002cb36:	74 17                	je     c002cb4f <lookup+0x26>
c002cb38:	89 c6                	mov    %eax,%esi
  ASSERT (name != NULL);
c002cb3a:	85 d2                	test   %edx,%edx
c002cb3c:	74 2f                	je     c002cb6d <lookup+0x44>
c002cb3e:	bb 00 00 00 00       	mov    $0x0,%ebx

  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002cb43:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
       ofs += sizeof e) 
    if (e.in_use && !strcmp (name, e.name)) 
c002cb47:	89 54 24 08          	mov    %edx,0x8(%esp)
c002cb4b:	89 dd                	mov    %ebx,%ebp
c002cb4d:	eb 3f                	jmp    c002cb8e <lookup+0x65>
  ASSERT (dir != NULL);
c002cb4f:	83 ec 0c             	sub    $0xc,%esp
c002cb52:	68 75 25 03 c0       	push   $0xc0032575
c002cb57:	68 21 01 03 c0       	push   $0xc0030121
c002cb5c:	68 c4 ff 02 c0       	push   $0xc002ffc4
c002cb61:	6a 68                	push   $0x68
c002cb63:	68 81 25 03 c0       	push   $0xc0032581
c002cb68:	e8 ba ba ff ff       	call   c0028627 <debug_panic>
  ASSERT (name != NULL);
c002cb6d:	83 ec 0c             	sub    $0xc,%esp
c002cb70:	68 d7 06 03 c0       	push   $0xc00306d7
c002cb75:	68 21 01 03 c0       	push   $0xc0030121
c002cb7a:	68 c4 ff 02 c0       	push   $0xc002ffc4
c002cb7f:	6a 69                	push   $0x69
c002cb81:	68 81 25 03 c0       	push   $0xc0032581
c002cb86:	e8 9c ba ff ff       	call   c0028627 <debug_panic>
       ofs += sizeof e) 
c002cb8b:	83 c5 14             	add    $0x14,%ebp
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002cb8e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002cb92:	55                   	push   %ebp
c002cb93:	6a 14                	push   $0x14
c002cb95:	57                   	push   %edi
c002cb96:	ff 36                	pushl  (%esi)
c002cb98:	e8 d5 10 00 00       	call   c002dc72 <inode_read_at>
c002cb9d:	83 c4 10             	add    $0x10,%esp
c002cba0:	83 f8 14             	cmp    $0x14,%eax
c002cba3:	75 46                	jne    c002cbeb <lookup+0xc2>
    if (e.in_use && !strcmp (name, e.name)) 
c002cba5:	8a 5c 24 2f          	mov    0x2f(%esp),%bl
c002cba9:	84 db                	test   %bl,%bl
c002cbab:	74 de                	je     c002cb8b <lookup+0x62>
c002cbad:	83 ec 08             	sub    $0x8,%esp
c002cbb0:	8d 44 24 28          	lea    0x28(%esp),%eax
c002cbb4:	50                   	push   %eax
c002cbb5:	ff 74 24 14          	pushl  0x14(%esp)
c002cbb9:	e8 1e ae ff ff       	call   c00279dc <strcmp>
c002cbbe:	83 c4 10             	add    $0x10,%esp
c002cbc1:	85 c0                	test   %eax,%eax
c002cbc3:	75 c6                	jne    c002cb8b <lookup+0x62>
      {
        if (ep != NULL)
c002cbc5:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002cbc9:	85 ff                	test   %edi,%edi
c002cbcb:	74 0b                	je     c002cbd8 <lookup+0xaf>
          *ep = e;
c002cbcd:	8d 74 24 1c          	lea    0x1c(%esp),%esi
c002cbd1:	b9 05 00 00 00       	mov    $0x5,%ecx
c002cbd6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        if (ofsp != NULL)
c002cbd8:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c002cbdd:	74 0e                	je     c002cbed <lookup+0xc4>
          *ofsp = ofs;
c002cbdf:	8b 44 24 50          	mov    0x50(%esp),%eax
c002cbe3:	8b 54 24 04          	mov    0x4(%esp),%edx
c002cbe7:	89 10                	mov    %edx,(%eax)
c002cbe9:	eb 02                	jmp    c002cbed <lookup+0xc4>
        return true;
      }
  return false;
c002cbeb:	b3 00                	mov    $0x0,%bl
}
c002cbed:	88 d8                	mov    %bl,%al
c002cbef:	83 c4 3c             	add    $0x3c,%esp
c002cbf2:	5b                   	pop    %ebx
c002cbf3:	5e                   	pop    %esi
c002cbf4:	5f                   	pop    %edi
c002cbf5:	5d                   	pop    %ebp
c002cbf6:	c3                   	ret    

c002cbf7 <dir_open>:
{
c002cbf7:	56                   	push   %esi
c002cbf8:	53                   	push   %ebx
c002cbf9:	83 ec 0c             	sub    $0xc,%esp
c002cbfc:	8b 74 24 18          	mov    0x18(%esp),%esi
  struct dir *dir = calloc (1, sizeof *dir);
c002cc00:	6a 08                	push   $0x8
c002cc02:	6a 01                	push   $0x1
c002cc04:	e8 1e 6f ff ff       	call   c0023b27 <calloc>
c002cc09:	89 c3                	mov    %eax,%ebx
  if (inode != NULL && dir != NULL)
c002cc0b:	83 c4 10             	add    $0x10,%esp
c002cc0e:	85 f6                	test   %esi,%esi
c002cc10:	74 15                	je     c002cc27 <dir_open+0x30>
c002cc12:	85 c0                	test   %eax,%eax
c002cc14:	74 11                	je     c002cc27 <dir_open+0x30>
      dir->inode = inode;
c002cc16:	89 30                	mov    %esi,(%eax)
      dir->pos = 2 * sizeof (struct dir_entry); // jump '.' and '..' for readdir
c002cc18:	c7 40 04 28 00 00 00 	movl   $0x28,0x4(%eax)
}
c002cc1f:	89 d8                	mov    %ebx,%eax
c002cc21:	83 c4 04             	add    $0x4,%esp
c002cc24:	5b                   	pop    %ebx
c002cc25:	5e                   	pop    %esi
c002cc26:	c3                   	ret    
      inode_close (inode);
c002cc27:	83 ec 0c             	sub    $0xc,%esp
c002cc2a:	56                   	push   %esi
c002cc2b:	e8 ce 0e 00 00       	call   c002dafe <inode_close>
      free (dir);
c002cc30:	89 1c 24             	mov    %ebx,(%esp)
c002cc33:	e8 39 6f ff ff       	call   c0023b71 <free>
      return NULL; 
c002cc38:	83 c4 10             	add    $0x10,%esp
c002cc3b:	bb 00 00 00 00       	mov    $0x0,%ebx
c002cc40:	eb dd                	jmp    c002cc1f <dir_open+0x28>

c002cc42 <dir_open_root>:
{
c002cc42:	83 ec 18             	sub    $0x18,%esp
  return dir_open (inode_open (ROOT_DIR_SECTOR));
c002cc45:	6a 01                	push   $0x1
c002cc47:	e8 0a 0e 00 00       	call   c002da56 <inode_open>
c002cc4c:	89 04 24             	mov    %eax,(%esp)
c002cc4f:	e8 a3 ff ff ff       	call   c002cbf7 <dir_open>
}
c002cc54:	83 c4 1c             	add    $0x1c,%esp
c002cc57:	c3                   	ret    

c002cc58 <dir_reopen>:
{
c002cc58:	83 ec 18             	sub    $0x18,%esp
  return dir_open (inode_reopen (dir->inode));
c002cc5b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002cc5f:	ff 30                	pushl  (%eax)
c002cc61:	e8 e4 0d 00 00       	call   c002da4a <inode_reopen>
c002cc66:	89 04 24             	mov    %eax,(%esp)
c002cc69:	e8 89 ff ff ff       	call   c002cbf7 <dir_open>
}
c002cc6e:	83 c4 1c             	add    $0x1c,%esp
c002cc71:	c3                   	ret    

c002cc72 <dir_close>:
{
c002cc72:	53                   	push   %ebx
c002cc73:	83 ec 08             	sub    $0x8,%esp
c002cc76:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (dir != NULL)
c002cc7a:	85 db                	test   %ebx,%ebx
c002cc7c:	74 15                	je     c002cc93 <dir_close+0x21>
      inode_close (dir->inode);
c002cc7e:	83 ec 0c             	sub    $0xc,%esp
c002cc81:	ff 33                	pushl  (%ebx)
c002cc83:	e8 76 0e 00 00       	call   c002dafe <inode_close>
      free (dir);
c002cc88:	89 1c 24             	mov    %ebx,(%esp)
c002cc8b:	e8 e1 6e ff ff       	call   c0023b71 <free>
c002cc90:	83 c4 10             	add    $0x10,%esp
}
c002cc93:	83 c4 08             	add    $0x8,%esp
c002cc96:	5b                   	pop    %ebx
c002cc97:	c3                   	ret    

c002cc98 <dir_get_inode>:
  return dir->inode;
c002cc98:	8b 44 24 04          	mov    0x4(%esp),%eax
c002cc9c:	8b 00                	mov    (%eax),%eax
}
c002cc9e:	c3                   	ret    

c002cc9f <dir_lookup>:
   On success, sets *INODE to an inode for the file, otherwise to
   a null pointer.  The caller must close *INODE. */
bool
dir_lookup (const struct dir *dir, const char *name,
            struct inode **inode) 
{
c002cc9f:	53                   	push   %ebx
c002cca0:	83 ec 28             	sub    $0x28,%esp
c002cca3:	8b 44 24 30          	mov    0x30(%esp),%eax
c002cca7:	8b 54 24 34          	mov    0x34(%esp),%edx
c002ccab:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  struct dir_entry e;

  ASSERT (dir != NULL);
c002ccaf:	85 c0                	test   %eax,%eax
c002ccb1:	74 2a                	je     c002ccdd <dir_lookup+0x3e>
  ASSERT (name != NULL);
c002ccb3:	85 d2                	test   %edx,%edx
c002ccb5:	74 47                	je     c002ccfe <dir_lookup+0x5f>

  if (lookup (dir, name, &e, NULL))
c002ccb7:	83 ec 0c             	sub    $0xc,%esp
c002ccba:	6a 00                	push   $0x0
c002ccbc:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c002ccc0:	e8 64 fe ff ff       	call   c002cb29 <lookup>
c002ccc5:	83 c4 10             	add    $0x10,%esp
c002ccc8:	84 c0                	test   %al,%al
c002ccca:	75 53                	jne    c002cd1f <dir_lookup+0x80>
    *inode = inode_open (e.inode_sector);
  else
    *inode = NULL;
c002cccc:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

  return *inode != NULL;
c002ccd2:	83 3b 00             	cmpl   $0x0,(%ebx)
c002ccd5:	0f 95 c0             	setne  %al
}
c002ccd8:	83 c4 28             	add    $0x28,%esp
c002ccdb:	5b                   	pop    %ebx
c002ccdc:	c3                   	ret    
  ASSERT (dir != NULL);
c002ccdd:	83 ec 0c             	sub    $0xc,%esp
c002cce0:	68 75 25 03 c0       	push   $0xc0032575
c002cce5:	68 21 01 03 c0       	push   $0xc0030121
c002ccea:	68 cc ff 02 c0       	push   $0xc002ffcc
c002ccef:	68 82 00 00 00       	push   $0x82
c002ccf4:	68 81 25 03 c0       	push   $0xc0032581
c002ccf9:	e8 29 b9 ff ff       	call   c0028627 <debug_panic>
  ASSERT (name != NULL);
c002ccfe:	83 ec 0c             	sub    $0xc,%esp
c002cd01:	68 d7 06 03 c0       	push   $0xc00306d7
c002cd06:	68 21 01 03 c0       	push   $0xc0030121
c002cd0b:	68 cc ff 02 c0       	push   $0xc002ffcc
c002cd10:	68 83 00 00 00       	push   $0x83
c002cd15:	68 81 25 03 c0       	push   $0xc0032581
c002cd1a:	e8 08 b9 ff ff       	call   c0028627 <debug_panic>
    *inode = inode_open (e.inode_sector);
c002cd1f:	83 ec 0c             	sub    $0xc,%esp
c002cd22:	ff 74 24 18          	pushl  0x18(%esp)
c002cd26:	e8 2b 0d 00 00       	call   c002da56 <inode_open>
c002cd2b:	89 03                	mov    %eax,(%ebx)
c002cd2d:	83 c4 10             	add    $0x10,%esp
c002cd30:	eb a0                	jmp    c002ccd2 <dir_lookup+0x33>

c002cd32 <dir_add>:
   Returns true if successful, false on failure.
   Fails if NAME is invalid (i.e. too long) or a disk or memory
   error occurs. */
bool
dir_add (struct dir *dir, const char *name, block_sector_t inode_sector)
{
c002cd32:	55                   	push   %ebp
c002cd33:	57                   	push   %edi
c002cd34:	56                   	push   %esi
c002cd35:	53                   	push   %ebx
c002cd36:	83 ec 2c             	sub    $0x2c,%esp
c002cd39:	8b 5c 24 40          	mov    0x40(%esp),%ebx
c002cd3d:	8b 74 24 44          	mov    0x44(%esp),%esi
  struct dir_entry e;
  off_t ofs;
  bool success = false;

  ASSERT (dir != NULL);
c002cd41:	85 db                	test   %ebx,%ebx
c002cd43:	74 2c                	je     c002cd71 <dir_add+0x3f>
  ASSERT (name != NULL);
c002cd45:	85 f6                	test   %esi,%esi
c002cd47:	74 49                	je     c002cd92 <dir_add+0x60>

  /* Check NAME for validity. */
  if (*name == '\0' || strlen (name) > NAME_MAX)
c002cd49:	80 3e 00             	cmpb   $0x0,(%esi)
c002cd4c:	0f 84 84 01 00 00    	je     c002ced6 <dir_add+0x1a4>
c002cd52:	b0 00                	mov    $0x0,%al
c002cd54:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002cd59:	89 f7                	mov    %esi,%edi
c002cd5b:	f2 ae                	repnz scas %es:(%edi),%al
c002cd5d:	89 c8                	mov    %ecx,%eax
c002cd5f:	f7 d0                	not    %eax
c002cd61:	48                   	dec    %eax
c002cd62:	83 f8 0e             	cmp    $0xe,%eax
c002cd65:	76 4c                	jbe    c002cdb3 <dir_add+0x81>
    return false;
c002cd67:	bf 00 00 00 00       	mov    $0x0,%edi
c002cd6c:	e9 6a 01 00 00       	jmp    c002cedb <dir_add+0x1a9>
  ASSERT (dir != NULL);
c002cd71:	83 ec 0c             	sub    $0xc,%esp
c002cd74:	68 75 25 03 c0       	push   $0xc0032575
c002cd79:	68 21 01 03 c0       	push   $0xc0030121
c002cd7e:	68 bc ff 02 c0       	push   $0xc002ffbc
c002cd83:	68 9a 00 00 00       	push   $0x9a
c002cd88:	68 81 25 03 c0       	push   $0xc0032581
c002cd8d:	e8 95 b8 ff ff       	call   c0028627 <debug_panic>
  ASSERT (name != NULL);
c002cd92:	83 ec 0c             	sub    $0xc,%esp
c002cd95:	68 d7 06 03 c0       	push   $0xc00306d7
c002cd9a:	68 21 01 03 c0       	push   $0xc0030121
c002cd9f:	68 bc ff 02 c0       	push   $0xc002ffbc
c002cda4:	68 9b 00 00 00       	push   $0x9b
c002cda9:	68 81 25 03 c0       	push   $0xc0032581
c002cdae:	e8 74 b8 ff ff       	call   c0028627 <debug_panic>

  /* Check that NAME is not in use. */
  if (lookup (dir, name, NULL, NULL))
c002cdb3:	83 ec 0c             	sub    $0xc,%esp
c002cdb6:	6a 00                	push   $0x0
c002cdb8:	b9 00 00 00 00       	mov    $0x0,%ecx
c002cdbd:	89 f2                	mov    %esi,%edx
c002cdbf:	89 d8                	mov    %ebx,%eax
c002cdc1:	e8 63 fd ff ff       	call   c002cb29 <lookup>
c002cdc6:	89 c7                	mov    %eax,%edi
c002cdc8:	83 c4 10             	add    $0x10,%esp
c002cdcb:	84 c0                	test   %al,%al
c002cdcd:	0f 85 12 01 00 00    	jne    c002cee5 <dir_add+0x1b3>
     current end-of-file.
     
     inode_read_at() will only return a short read at end of file.
     Otherwise, we'd need to verify that we didn't get a short
     read due to something intermittent such as low memory. */
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002cdd3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002cdda:	00 
c002cddb:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c002cddf:	ff 74 24 08          	pushl  0x8(%esp)
c002cde3:	6a 14                	push   $0x14
c002cde5:	55                   	push   %ebp
c002cde6:	ff 33                	pushl  (%ebx)
c002cde8:	e8 85 0e 00 00       	call   c002dc72 <inode_read_at>
c002cded:	83 c4 10             	add    $0x10,%esp
c002cdf0:	83 f8 14             	cmp    $0x14,%eax
c002cdf3:	75 0e                	jne    c002ce03 <dir_add+0xd1>
       ofs += sizeof e) 
    if (!e.in_use)
c002cdf5:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c002cdfa:	74 07                	je     c002ce03 <dir_add+0xd1>
       ofs += sizeof e) 
c002cdfc:	83 44 24 08 14       	addl   $0x14,0x8(%esp)
c002ce01:	eb dc                	jmp    c002cddf <dir_add+0xad>
      break;

  /* Write slot. */
  e.in_use = true;
c002ce03:	c6 44 24 1f 01       	movb   $0x1,0x1f(%esp)
  strlcpy (e.name, name, sizeof e.name);
c002ce08:	83 ec 04             	sub    $0x4,%esp
c002ce0b:	6a 0f                	push   $0xf
c002ce0d:	56                   	push   %esi
c002ce0e:	8d 74 24 18          	lea    0x18(%esp),%esi
c002ce12:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002ce16:	50                   	push   %eax
c002ce17:	e8 05 af ff ff       	call   c0027d21 <strlcpy>
  e.inode_sector = inode_sector;
c002ce1c:	8b 44 24 58          	mov    0x58(%esp),%eax
c002ce20:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002ce24:	ff 74 24 18          	pushl  0x18(%esp)
c002ce28:	6a 14                	push   $0x14
c002ce2a:	56                   	push   %esi
c002ce2b:	ff 33                	pushl  (%ebx)
c002ce2d:	e8 6c 0f 00 00       	call   c002dd9e <inode_write_at>

  /* Write .. infomation for true subdir */
  if (success && inode_sector != inode_get_inumber (dir->inode)) {
c002ce32:	83 c4 20             	add    $0x20,%esp
c002ce35:	83 f8 14             	cmp    $0x14,%eax
c002ce38:	0f 85 9d 00 00 00    	jne    c002cedb <dir_add+0x1a9>
c002ce3e:	83 ec 0c             	sub    $0xc,%esp
c002ce41:	ff 33                	pushl  (%ebx)
c002ce43:	e8 ae 0c 00 00       	call   c002daf6 <inode_get_inumber>
c002ce48:	83 c4 10             	add    $0x10,%esp
c002ce4b:	39 44 24 48          	cmp    %eax,0x48(%esp)
c002ce4f:	0f 84 97 00 00 00    	je     c002ceec <dir_add+0x1ba>
    struct inode* inode = inode_open (inode_sector);
c002ce55:	83 ec 0c             	sub    $0xc,%esp
c002ce58:	ff 74 24 54          	pushl  0x54(%esp)
c002ce5c:	e8 f5 0b 00 00       	call   c002da56 <inode_open>
c002ce61:	89 c6                	mov    %eax,%esi
    if(inode_is_dir (inode) || (inode_close (inode), 0)) {
c002ce63:	89 04 24             	mov    %eax,(%esp)
c002ce66:	e8 63 11 00 00       	call   c002dfce <inode_is_dir>
c002ce6b:	89 c7                	mov    %eax,%edi
c002ce6d:	83 c4 10             	add    $0x10,%esp
c002ce70:	84 c0                	test   %al,%al
c002ce72:	74 4f                	je     c002cec3 <dir_add+0x191>
      struct dir *subdir = dir_open (inode);
c002ce74:	83 ec 0c             	sub    $0xc,%esp
c002ce77:	56                   	push   %esi
c002ce78:	e8 7a fd ff ff       	call   c002cbf7 <dir_open>
c002ce7d:	89 c6                	mov    %eax,%esi
      lookup (subdir, "..", &e, &ofs);
c002ce7f:	8d 6c 24 1c          	lea    0x1c(%esp),%ebp
c002ce83:	83 c4 04             	add    $0x4,%esp
c002ce86:	8d 44 24 14          	lea    0x14(%esp),%eax
c002ce8a:	50                   	push   %eax
c002ce8b:	89 e9                	mov    %ebp,%ecx
c002ce8d:	ba d2 15 03 c0       	mov    $0xc00315d2,%edx
c002ce92:	89 f0                	mov    %esi,%eax
c002ce94:	e8 90 fc ff ff       	call   c002cb29 <lookup>
      e.inode_sector = inode_get_inumber(dir->inode);
c002ce99:	83 c4 04             	add    $0x4,%esp
c002ce9c:	ff 33                	pushl  (%ebx)
c002ce9e:	e8 53 0c 00 00       	call   c002daf6 <inode_get_inumber>
c002cea3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
      inode_write_at(subdir->inode, &e, sizeof e, ofs);
c002cea7:	ff 74 24 18          	pushl  0x18(%esp)
c002ceab:	6a 14                	push   $0x14
c002cead:	55                   	push   %ebp
c002ceae:	ff 36                	pushl  (%esi)
c002ceb0:	e8 e9 0e 00 00       	call   c002dd9e <inode_write_at>
      dir_close (subdir);
c002ceb5:	83 c4 14             	add    $0x14,%esp
c002ceb8:	56                   	push   %esi
c002ceb9:	e8 b4 fd ff ff       	call   c002cc72 <dir_close>
c002cebe:	83 c4 10             	add    $0x10,%esp
c002cec1:	eb 18                	jmp    c002cedb <dir_add+0x1a9>
    if(inode_is_dir (inode) || (inode_close (inode), 0)) {
c002cec3:	83 ec 0c             	sub    $0xc,%esp
c002cec6:	56                   	push   %esi
c002cec7:	e8 32 0c 00 00       	call   c002dafe <inode_close>
c002cecc:	83 c4 10             	add    $0x10,%esp
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002cecf:	bf 01 00 00 00       	mov    $0x1,%edi
c002ced4:	eb 05                	jmp    c002cedb <dir_add+0x1a9>
    return false;
c002ced6:	bf 00 00 00 00       	mov    $0x0,%edi
    }
  }
 done:
  return success;
}
c002cedb:	89 f8                	mov    %edi,%eax
c002cedd:	83 c4 2c             	add    $0x2c,%esp
c002cee0:	5b                   	pop    %ebx
c002cee1:	5e                   	pop    %esi
c002cee2:	5f                   	pop    %edi
c002cee3:	5d                   	pop    %ebp
c002cee4:	c3                   	ret    
  bool success = false;
c002cee5:	bf 00 00 00 00       	mov    $0x0,%edi
c002ceea:	eb ef                	jmp    c002cedb <dir_add+0x1a9>
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002ceec:	bf 01 00 00 00       	mov    $0x1,%edi
c002cef1:	eb e8                	jmp    c002cedb <dir_add+0x1a9>

c002cef3 <dir_create>:
{
c002cef3:	57                   	push   %edi
c002cef4:	56                   	push   %esi
c002cef5:	53                   	push   %ebx
c002cef6:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002cefa:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (inode_create (sector, entry_cnt * sizeof (struct dir_entry))) {
c002cefe:	83 ec 08             	sub    $0x8,%esp
c002cf01:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002cf04:	c1 e0 02             	shl    $0x2,%eax
c002cf07:	50                   	push   %eax
c002cf08:	53                   	push   %ebx
c002cf09:	e8 ee 08 00 00       	call   c002d7fc <inode_create>
c002cf0e:	89 c6                	mov    %eax,%esi
c002cf10:	83 c4 10             	add    $0x10,%esp
c002cf13:	84 c0                	test   %al,%al
c002cf15:	75 06                	jne    c002cf1d <dir_create+0x2a>
}
c002cf17:	89 f0                	mov    %esi,%eax
c002cf19:	5b                   	pop    %ebx
c002cf1a:	5e                   	pop    %esi
c002cf1b:	5f                   	pop    %edi
c002cf1c:	c3                   	ret    
    struct inode * inode = inode_open (sector);
c002cf1d:	83 ec 0c             	sub    $0xc,%esp
c002cf20:	53                   	push   %ebx
c002cf21:	e8 30 0b 00 00       	call   c002da56 <inode_open>
c002cf26:	89 c7                	mov    %eax,%edi
    inode_set_dir (inode);
c002cf28:	89 04 24             	mov    %eax,(%esp)
c002cf2b:	e8 a6 10 00 00       	call   c002dfd6 <inode_set_dir>
    struct dir * dir = dir_open (inode);
c002cf30:	89 3c 24             	mov    %edi,(%esp)
c002cf33:	e8 bf fc ff ff       	call   c002cbf7 <dir_open>
c002cf38:	89 c7                	mov    %eax,%edi
    dir_add(dir, ".", sector);
c002cf3a:	83 c4 0c             	add    $0xc,%esp
c002cf3d:	53                   	push   %ebx
c002cf3e:	68 d3 15 03 c0       	push   $0xc00315d3
c002cf43:	50                   	push   %eax
c002cf44:	e8 e9 fd ff ff       	call   c002cd32 <dir_add>
    dir_add(dir, "..", sector);
c002cf49:	83 c4 0c             	add    $0xc,%esp
c002cf4c:	53                   	push   %ebx
c002cf4d:	68 d2 15 03 c0       	push   $0xc00315d2
c002cf52:	57                   	push   %edi
c002cf53:	e8 da fd ff ff       	call   c002cd32 <dir_add>
    dir_close(dir);
c002cf58:	89 3c 24             	mov    %edi,(%esp)
c002cf5b:	e8 12 fd ff ff       	call   c002cc72 <dir_close>
    return true;
c002cf60:	83 c4 10             	add    $0x10,%esp
c002cf63:	eb b2                	jmp    c002cf17 <dir_create+0x24>

c002cf65 <dir_remove>:
/* Removes any entry for NAME in DIR.
   Returns true if successful, false on failure,
   which occurs only if there is no file with the given NAME. */
bool
dir_remove (struct dir *dir, const char *name) 
{
c002cf65:	57                   	push   %edi
c002cf66:	56                   	push   %esi
c002cf67:	53                   	push   %ebx
c002cf68:	83 ec 20             	sub    $0x20,%esp
c002cf6b:	8b 74 24 30          	mov    0x30(%esp),%esi
c002cf6f:	8b 54 24 34          	mov    0x34(%esp),%edx
  struct dir_entry e;
  struct inode *inode = NULL;
  bool success = false;
  off_t ofs;

  ASSERT (dir != NULL);
c002cf73:	85 f6                	test   %esi,%esi
c002cf75:	74 37                	je     c002cfae <dir_remove+0x49>
  ASSERT (name != NULL);
c002cf77:	85 d2                	test   %edx,%edx
c002cf79:	74 54                	je     c002cfcf <dir_remove+0x6a>

  /* Find directory entry. */
  if (!lookup (dir, name, &e, &ofs))
c002cf7b:	83 ec 0c             	sub    $0xc,%esp
c002cf7e:	8d 44 24 14          	lea    0x14(%esp),%eax
c002cf82:	50                   	push   %eax
c002cf83:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c002cf87:	89 f0                	mov    %esi,%eax
c002cf89:	e8 9b fb ff ff       	call   c002cb29 <lookup>
c002cf8e:	88 c3                	mov    %al,%bl
c002cf90:	83 c4 10             	add    $0x10,%esp
c002cf93:	84 c0                	test   %al,%al
c002cf95:	75 59                	jne    c002cff0 <dir_remove+0x8b>
  struct inode *inode = NULL;
c002cf97:	bf 00 00 00 00       	mov    $0x0,%edi
  /* Remove inode. */
  inode_remove (inode);
  success = true;

 done:
  inode_close (inode);
c002cf9c:	83 ec 0c             	sub    $0xc,%esp
c002cf9f:	57                   	push   %edi
c002cfa0:	e8 59 0b 00 00       	call   c002dafe <inode_close>
  return success;
}
c002cfa5:	88 d8                	mov    %bl,%al
c002cfa7:	83 c4 30             	add    $0x30,%esp
c002cfaa:	5b                   	pop    %ebx
c002cfab:	5e                   	pop    %esi
c002cfac:	5f                   	pop    %edi
c002cfad:	c3                   	ret    
  ASSERT (dir != NULL);
c002cfae:	83 ec 0c             	sub    $0xc,%esp
c002cfb1:	68 75 25 03 c0       	push   $0xc0032575
c002cfb6:	68 21 01 03 c0       	push   $0xc0030121
c002cfbb:	68 b0 ff 02 c0       	push   $0xc002ffb0
c002cfc0:	68 d1 00 00 00       	push   $0xd1
c002cfc5:	68 81 25 03 c0       	push   $0xc0032581
c002cfca:	e8 58 b6 ff ff       	call   c0028627 <debug_panic>
  ASSERT (name != NULL);
c002cfcf:	83 ec 0c             	sub    $0xc,%esp
c002cfd2:	68 d7 06 03 c0       	push   $0xc00306d7
c002cfd7:	68 21 01 03 c0       	push   $0xc0030121
c002cfdc:	68 b0 ff 02 c0       	push   $0xc002ffb0
c002cfe1:	68 d2 00 00 00       	push   $0xd2
c002cfe6:	68 81 25 03 c0       	push   $0xc0032581
c002cfeb:	e8 37 b6 ff ff       	call   c0028627 <debug_panic>
  inode = inode_open (e.inode_sector);
c002cff0:	83 ec 0c             	sub    $0xc,%esp
c002cff3:	ff 74 24 18          	pushl  0x18(%esp)
c002cff7:	e8 5a 0a 00 00       	call   c002da56 <inode_open>
c002cffc:	89 c7                	mov    %eax,%edi
  if (inode == NULL)
c002cffe:	83 c4 10             	add    $0x10,%esp
c002d001:	85 c0                	test   %eax,%eax
c002d003:	74 37                	je     c002d03c <dir_remove+0xd7>
  e.in_use = false;
c002d005:	c6 44 24 1f 00       	movb   $0x0,0x1f(%esp)
  if (inode_write_at (dir->inode, &e, sizeof e, ofs) != sizeof e) 
c002d00a:	ff 74 24 08          	pushl  0x8(%esp)
c002d00e:	6a 14                	push   $0x14
c002d010:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d014:	50                   	push   %eax
c002d015:	ff 36                	pushl  (%esi)
c002d017:	e8 82 0d 00 00       	call   c002dd9e <inode_write_at>
c002d01c:	83 c4 10             	add    $0x10,%esp
c002d01f:	83 f8 14             	cmp    $0x14,%eax
c002d022:	74 07                	je     c002d02b <dir_remove+0xc6>
  bool success = false;
c002d024:	b3 00                	mov    $0x0,%bl
c002d026:	e9 71 ff ff ff       	jmp    c002cf9c <dir_remove+0x37>
  inode_remove (inode);
c002d02b:	83 ec 0c             	sub    $0xc,%esp
c002d02e:	57                   	push   %edi
c002d02f:	e8 0a 0c 00 00       	call   c002dc3e <inode_remove>
c002d034:	83 c4 10             	add    $0x10,%esp
c002d037:	e9 60 ff ff ff       	jmp    c002cf9c <dir_remove+0x37>
  bool success = false;
c002d03c:	b3 00                	mov    $0x0,%bl
c002d03e:	e9 59 ff ff ff       	jmp    c002cf9c <dir_remove+0x37>

c002d043 <dir_readdir>:
/* Reads the next directory entry in DIR and stores the name in
   NAME.  Returns true if successful, false if the directory
   contains no more entries. */
bool
dir_readdir (struct dir *dir, char name[NAME_MAX + 1])
{
c002d043:	57                   	push   %edi
c002d044:	56                   	push   %esi
c002d045:	53                   	push   %ebx
c002d046:	83 ec 20             	sub    $0x20,%esp
c002d049:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  struct dir_entry e;

  ASSERT (dir != NULL);
c002d04d:	85 db                	test   %ebx,%ebx
c002d04f:	74 53                	je     c002d0a4 <dir_readdir+0x61>
  ASSERT (dir->inode != NULL);
c002d051:	83 3b 00             	cmpl   $0x0,(%ebx)
c002d054:	74 6f                	je     c002d0c5 <dir_readdir+0x82>
  ASSERT (dir->pos > 0);
c002d056:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c002d05a:	0f 8e 86 00 00 00    	jle    c002d0e6 <dir_readdir+0xa3>

  while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e) 
c002d060:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002d064:	ff 73 04             	pushl  0x4(%ebx)
c002d067:	6a 14                	push   $0x14
c002d069:	57                   	push   %edi
c002d06a:	ff 33                	pushl  (%ebx)
c002d06c:	e8 01 0c 00 00       	call   c002dc72 <inode_read_at>
c002d071:	83 c4 10             	add    $0x10,%esp
c002d074:	83 f8 14             	cmp    $0x14,%eax
c002d077:	0f 85 8a 00 00 00    	jne    c002d107 <dir_readdir+0xc4>
    {
      dir->pos += sizeof e;
c002d07d:	83 43 04 14          	addl   $0x14,0x4(%ebx)
      if (e.in_use)
c002d081:	0f b6 74 24 1f       	movzbl 0x1f(%esp),%esi
c002d086:	89 f0                	mov    %esi,%eax
c002d088:	84 c0                	test   %al,%al
c002d08a:	74 d8                	je     c002d064 <dir_readdir+0x21>
        {
          strlcpy (name, e.name, NAME_MAX + 1);
c002d08c:	83 ec 04             	sub    $0x4,%esp
c002d08f:	6a 0f                	push   $0xf
c002d091:	8d 44 24 18          	lea    0x18(%esp),%eax
c002d095:	50                   	push   %eax
c002d096:	ff 74 24 40          	pushl  0x40(%esp)
c002d09a:	e8 82 ac ff ff       	call   c0027d21 <strlcpy>
          return true;
c002d09f:	83 c4 10             	add    $0x10,%esp
c002d0a2:	eb 68                	jmp    c002d10c <dir_readdir+0xc9>
  ASSERT (dir != NULL);
c002d0a4:	83 ec 0c             	sub    $0xc,%esp
c002d0a7:	68 75 25 03 c0       	push   $0xc0032575
c002d0ac:	68 21 01 03 c0       	push   $0xc0030121
c002d0b1:	68 a4 ff 02 c0       	push   $0xc002ffa4
c002d0b6:	68 f3 00 00 00       	push   $0xf3
c002d0bb:	68 81 25 03 c0       	push   $0xc0032581
c002d0c0:	e8 62 b5 ff ff       	call   c0028627 <debug_panic>
  ASSERT (dir->inode != NULL);
c002d0c5:	83 ec 0c             	sub    $0xc,%esp
c002d0c8:	68 9b 25 03 c0       	push   $0xc003259b
c002d0cd:	68 21 01 03 c0       	push   $0xc0030121
c002d0d2:	68 a4 ff 02 c0       	push   $0xc002ffa4
c002d0d7:	68 f4 00 00 00       	push   $0xf4
c002d0dc:	68 81 25 03 c0       	push   $0xc0032581
c002d0e1:	e8 41 b5 ff ff       	call   c0028627 <debug_panic>
  ASSERT (dir->pos > 0);
c002d0e6:	83 ec 0c             	sub    $0xc,%esp
c002d0e9:	68 ae 25 03 c0       	push   $0xc00325ae
c002d0ee:	68 21 01 03 c0       	push   $0xc0030121
c002d0f3:	68 a4 ff 02 c0       	push   $0xc002ffa4
c002d0f8:	68 f5 00 00 00       	push   $0xf5
c002d0fd:	68 81 25 03 c0       	push   $0xc0032581
c002d102:	e8 20 b5 ff ff       	call   c0028627 <debug_panic>
        } 
    }
  return false;
c002d107:	be 00 00 00 00       	mov    $0x0,%esi
}
c002d10c:	89 f0                	mov    %esi,%eax
c002d10e:	83 c4 20             	add    $0x20,%esp
c002d111:	5b                   	pop    %ebx
c002d112:	5e                   	pop    %esi
c002d113:	5f                   	pop    %edi
c002d114:	c3                   	ret    

c002d115 <dir_subdir_create>:


bool
dir_subdir_create (struct dir* dir, const char* name) {
c002d115:	56                   	push   %esi
c002d116:	53                   	push   %ebx
c002d117:	83 ec 14             	sub    $0x14,%esp
c002d11a:	8b 74 24 20          	mov    0x20(%esp),%esi
c002d11e:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  block_sector_t sector = -1u;
c002d122:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c002d129:	ff 
  if (  dir != NULL
c002d12a:	85 f6                	test   %esi,%esi
c002d12c:	74 6e                	je     c002d19c <dir_subdir_create+0x87>
    &&  name != NULL
c002d12e:	85 db                	test   %ebx,%ebx
c002d130:	74 6e                	je     c002d1a0 <dir_subdir_create+0x8b>
    &&  strlen(name) > 0
c002d132:	80 3b 00             	cmpb   $0x0,(%ebx)
c002d135:	75 04                	jne    c002d13b <dir_subdir_create+0x26>
    return true;
  }
  if (sector != -1u) {
    free_map_release(sector, 1);
  }
  return false;
c002d137:	b0 00                	mov    $0x0,%al
c002d139:	eb 2f                	jmp    c002d16a <dir_subdir_create+0x55>
    &&  free_map_allocate(1, &sector)
c002d13b:	83 ec 08             	sub    $0x8,%esp
c002d13e:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d142:	50                   	push   %eax
c002d143:	6a 01                	push   $0x1
c002d145:	e8 4b f5 ff ff       	call   c002c695 <free_map_allocate>
c002d14a:	83 c4 10             	add    $0x10,%esp
c002d14d:	84 c0                	test   %al,%al
c002d14f:	75 1f                	jne    c002d170 <dir_subdir_create+0x5b>
  if (sector != -1u) {
c002d151:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d155:	83 f8 ff             	cmp    $0xffffffff,%eax
c002d158:	74 4a                	je     c002d1a4 <dir_subdir_create+0x8f>
    free_map_release(sector, 1);
c002d15a:	83 ec 08             	sub    $0x8,%esp
c002d15d:	6a 01                	push   $0x1
c002d15f:	50                   	push   %eax
c002d160:	e8 9d f5 ff ff       	call   c002c702 <free_map_release>
c002d165:	83 c4 10             	add    $0x10,%esp
  return false;
c002d168:	b0 00                	mov    $0x0,%al
}
c002d16a:	83 c4 14             	add    $0x14,%esp
c002d16d:	5b                   	pop    %ebx
c002d16e:	5e                   	pop    %esi
c002d16f:	c3                   	ret    
    &&  dir_create(sector, 0)
c002d170:	83 ec 08             	sub    $0x8,%esp
c002d173:	6a 00                	push   $0x0
c002d175:	ff 74 24 18          	pushl  0x18(%esp)
c002d179:	e8 75 fd ff ff       	call   c002cef3 <dir_create>
c002d17e:	83 c4 10             	add    $0x10,%esp
c002d181:	84 c0                	test   %al,%al
c002d183:	74 cc                	je     c002d151 <dir_subdir_create+0x3c>
    &&  dir_add(dir, name, sector)
c002d185:	83 ec 04             	sub    $0x4,%esp
c002d188:	ff 74 24 10          	pushl  0x10(%esp)
c002d18c:	53                   	push   %ebx
c002d18d:	56                   	push   %esi
c002d18e:	e8 9f fb ff ff       	call   c002cd32 <dir_add>
c002d193:	83 c4 10             	add    $0x10,%esp
c002d196:	84 c0                	test   %al,%al
c002d198:	74 b7                	je     c002d151 <dir_subdir_create+0x3c>
c002d19a:	eb ce                	jmp    c002d16a <dir_subdir_create+0x55>
  return false;
c002d19c:	b0 00                	mov    $0x0,%al
c002d19e:	eb ca                	jmp    c002d16a <dir_subdir_create+0x55>
c002d1a0:	b0 00                	mov    $0x0,%al
c002d1a2:	eb c6                	jmp    c002d16a <dir_subdir_create+0x55>
c002d1a4:	b0 00                	mov    $0x0,%al
c002d1a6:	eb c2                	jmp    c002d16a <dir_subdir_create+0x55>

c002d1a8 <dir_subdir_lookup>:

struct dir*
dir_subdir_lookup (struct dir* dir, const char* name) {
c002d1a8:	83 ec 1c             	sub    $0x1c,%esp
c002d1ab:	8b 44 24 20          	mov    0x20(%esp),%eax
c002d1af:	8b 54 24 24          	mov    0x24(%esp),%edx
  struct inode* inode = NULL;
c002d1b3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d1ba:	00 
  if (  dir != NULL
c002d1bb:	85 c0                	test   %eax,%eax
c002d1bd:	74 46                	je     c002d205 <dir_subdir_lookup+0x5d>
    &&  name != NULL
c002d1bf:	85 d2                	test   %edx,%edx
c002d1c1:	74 5c                	je     c002d21f <dir_subdir_lookup+0x77>
    &&  strlen(name) > 0
c002d1c3:	80 3a 00             	cmpb   $0x0,(%edx)
c002d1c6:	74 5e                	je     c002d226 <dir_subdir_lookup+0x7e>
    &&  dir_lookup(dir, name, &inode)
c002d1c8:	83 ec 04             	sub    $0x4,%esp
c002d1cb:	8d 4c 24 10          	lea    0x10(%esp),%ecx
c002d1cf:	51                   	push   %ecx
c002d1d0:	52                   	push   %edx
c002d1d1:	50                   	push   %eax
c002d1d2:	e8 c8 fa ff ff       	call   c002cc9f <dir_lookup>
c002d1d7:	83 c4 10             	add    $0x10,%esp
c002d1da:	84 c0                	test   %al,%al
c002d1dc:	74 4f                	je     c002d22d <dir_subdir_lookup+0x85>
    &&  inode != NULL
c002d1de:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d1e2:	85 c0                	test   %eax,%eax
c002d1e4:	74 4e                	je     c002d234 <dir_subdir_lookup+0x8c>
    &&  (inode_is_dir(inode) || (inode_close(inode), 0))
c002d1e6:	83 ec 0c             	sub    $0xc,%esp
c002d1e9:	50                   	push   %eax
c002d1ea:	e8 df 0d 00 00       	call   c002dfce <inode_is_dir>
c002d1ef:	83 c4 10             	add    $0x10,%esp
c002d1f2:	84 c0                	test   %al,%al
c002d1f4:	74 13                	je     c002d209 <dir_subdir_lookup+0x61>
    ) {
    return dir_open(inode);
c002d1f6:	83 ec 0c             	sub    $0xc,%esp
c002d1f9:	ff 74 24 18          	pushl  0x18(%esp)
c002d1fd:	e8 f5 f9 ff ff       	call   c002cbf7 <dir_open>
c002d202:	83 c4 10             	add    $0x10,%esp
  }
  return NULL;
}
c002d205:	83 c4 1c             	add    $0x1c,%esp
c002d208:	c3                   	ret    
    &&  (inode_is_dir(inode) || (inode_close(inode), 0))
c002d209:	83 ec 0c             	sub    $0xc,%esp
c002d20c:	ff 74 24 18          	pushl  0x18(%esp)
c002d210:	e8 e9 08 00 00       	call   c002dafe <inode_close>
c002d215:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002d218:	b8 00 00 00 00       	mov    $0x0,%eax
c002d21d:	eb e6                	jmp    c002d205 <dir_subdir_lookup+0x5d>
c002d21f:	b8 00 00 00 00       	mov    $0x0,%eax
c002d224:	eb df                	jmp    c002d205 <dir_subdir_lookup+0x5d>
c002d226:	b8 00 00 00 00       	mov    $0x0,%eax
c002d22b:	eb d8                	jmp    c002d205 <dir_subdir_lookup+0x5d>
c002d22d:	b8 00 00 00 00       	mov    $0x0,%eax
c002d232:	eb d1                	jmp    c002d205 <dir_subdir_lookup+0x5d>
c002d234:	b8 00 00 00 00       	mov    $0x0,%eax
c002d239:	eb ca                	jmp    c002d205 <dir_subdir_lookup+0x5d>

c002d23b <dir_subdir_delete>:

bool
dir_subdir_delete (struct dir* dir, const char* name) {
c002d23b:	55                   	push   %ebp
c002d23c:	57                   	push   %edi
c002d23d:	56                   	push   %esi
c002d23e:	53                   	push   %ebx
c002d23f:	83 ec 2c             	sub    $0x2c,%esp
c002d242:	8b 74 24 40          	mov    0x40(%esp),%esi
c002d246:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  struct inode* inode = NULL;
c002d24a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c002d251:	00 
  if (  dir != NULL
c002d252:	85 f6                	test   %esi,%esi
c002d254:	0f 84 fa 00 00 00    	je     c002d354 <dir_subdir_delete+0x119>
    &&  name != NULL
c002d25a:	85 db                	test   %ebx,%ebx
c002d25c:	0f 84 f9 00 00 00    	je     c002d35b <dir_subdir_delete+0x120>
    &&  strlen(name) > 0
c002d262:	80 3b 00             	cmpb   $0x0,(%ebx)
c002d265:	75 0a                	jne    c002d271 <dir_subdir_delete+0x36>
      free (buffer);
      if (!not_empty) {
        return dir_remove (dir, name);
      }
  }
  return false;
c002d267:	b0 00                	mov    $0x0,%al
}
c002d269:	83 c4 2c             	add    $0x2c,%esp
c002d26c:	5b                   	pop    %ebx
c002d26d:	5e                   	pop    %esi
c002d26e:	5f                   	pop    %edi
c002d26f:	5d                   	pop    %ebp
c002d270:	c3                   	ret    
    &&  dir_lookup(dir, name, &inode)
c002d271:	83 ec 04             	sub    $0x4,%esp
c002d274:	8d 44 24 20          	lea    0x20(%esp),%eax
c002d278:	50                   	push   %eax
c002d279:	53                   	push   %ebx
c002d27a:	56                   	push   %esi
c002d27b:	e8 1f fa ff ff       	call   c002cc9f <dir_lookup>
c002d280:	83 c4 10             	add    $0x10,%esp
c002d283:	84 c0                	test   %al,%al
c002d285:	74 e2                	je     c002d269 <dir_subdir_delete+0x2e>
    &&  inode != NULL
c002d287:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d28b:	85 c0                	test   %eax,%eax
c002d28d:	0f 84 cf 00 00 00    	je     c002d362 <dir_subdir_delete+0x127>
              inode_is_dir(inode)
c002d293:	83 ec 0c             	sub    $0xc,%esp
c002d296:	50                   	push   %eax
c002d297:	e8 32 0d 00 00       	call   c002dfce <inode_is_dir>
    &&  ( (
c002d29c:	83 c4 10             	add    $0x10,%esp
c002d29f:	84 c0                	test   %al,%al
c002d2a1:	74 3e                	je     c002d2e1 <dir_subdir_delete+0xa6>
          &&  inode_get_inumber(inode) != inode_get_inumber(dir_get_inode(thread_current()->dir))
c002d2a3:	83 ec 0c             	sub    $0xc,%esp
c002d2a6:	ff 74 24 28          	pushl  0x28(%esp)
c002d2aa:	e8 47 08 00 00       	call   c002daf6 <inode_get_inumber>
c002d2af:	89 c7                	mov    %eax,%edi
c002d2b1:	e8 06 3a ff ff       	call   c0020cbc <thread_current>
c002d2b6:	83 c4 04             	add    $0x4,%esp
  return dir->inode;
c002d2b9:	8b 80 dc 00 00 00    	mov    0xdc(%eax),%eax
          &&  inode_get_inumber(inode) != inode_get_inumber(dir_get_inode(thread_current()->dir))
c002d2bf:	ff 30                	pushl  (%eax)
c002d2c1:	e8 30 08 00 00       	call   c002daf6 <inode_get_inumber>
c002d2c6:	83 c4 10             	add    $0x10,%esp
c002d2c9:	39 c7                	cmp    %eax,%edi
c002d2cb:	74 14                	je     c002d2e1 <dir_subdir_delete+0xa6>
          &&  inode_get_open_cnt(inode) <= 1
c002d2cd:	83 ec 0c             	sub    $0xc,%esp
c002d2d0:	ff 74 24 28          	pushl  0x28(%esp)
c002d2d4:	e8 18 0d 00 00       	call   c002dff1 <inode_get_open_cnt>
c002d2d9:	83 c4 10             	add    $0x10,%esp
c002d2dc:	83 f8 01             	cmp    $0x1,%eax
c002d2df:	7e 16                	jle    c002d2f7 <dir_subdir_delete+0xbc>
        || (inode_close(inode), 0)
c002d2e1:	83 ec 0c             	sub    $0xc,%esp
c002d2e4:	ff 74 24 28          	pushl  0x28(%esp)
c002d2e8:	e8 11 08 00 00       	call   c002dafe <inode_close>
c002d2ed:	83 c4 10             	add    $0x10,%esp
  return false;
c002d2f0:	b0 00                	mov    $0x0,%al
c002d2f2:	e9 72 ff ff ff       	jmp    c002d269 <dir_subdir_delete+0x2e>
      struct dir* checker = dir_open(inode);
c002d2f7:	83 ec 0c             	sub    $0xc,%esp
c002d2fa:	ff 74 24 28          	pushl  0x28(%esp)
c002d2fe:	e8 f4 f8 ff ff       	call   c002cbf7 <dir_open>
c002d303:	89 c5                	mov    %eax,%ebp
      char* buffer = calloc(NAME_MAX + 1, 1);
c002d305:	83 c4 08             	add    $0x8,%esp
c002d308:	6a 01                	push   $0x1
c002d30a:	6a 0f                	push   $0xf
c002d30c:	e8 16 68 ff ff       	call   c0023b27 <calloc>
c002d311:	89 c7                	mov    %eax,%edi
      bool not_empty = dir_readdir (checker, buffer);
c002d313:	83 c4 08             	add    $0x8,%esp
c002d316:	50                   	push   %eax
c002d317:	55                   	push   %ebp
c002d318:	e8 26 fd ff ff       	call   c002d043 <dir_readdir>
c002d31d:	88 44 24 1f          	mov    %al,0x1f(%esp)
      dir_close (checker);
c002d321:	89 2c 24             	mov    %ebp,(%esp)
c002d324:	e8 49 f9 ff ff       	call   c002cc72 <dir_close>
      free (buffer);
c002d329:	89 3c 24             	mov    %edi,(%esp)
c002d32c:	e8 40 68 ff ff       	call   c0023b71 <free>
      if (!not_empty) {
c002d331:	83 c4 10             	add    $0x10,%esp
c002d334:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c002d339:	74 07                	je     c002d342 <dir_subdir_delete+0x107>
  return false;
c002d33b:	b0 00                	mov    $0x0,%al
c002d33d:	e9 27 ff ff ff       	jmp    c002d269 <dir_subdir_delete+0x2e>
        return dir_remove (dir, name);
c002d342:	83 ec 08             	sub    $0x8,%esp
c002d345:	53                   	push   %ebx
c002d346:	56                   	push   %esi
c002d347:	e8 19 fc ff ff       	call   c002cf65 <dir_remove>
c002d34c:	83 c4 10             	add    $0x10,%esp
c002d34f:	e9 15 ff ff ff       	jmp    c002d269 <dir_subdir_delete+0x2e>
  return false;
c002d354:	b0 00                	mov    $0x0,%al
c002d356:	e9 0e ff ff ff       	jmp    c002d269 <dir_subdir_delete+0x2e>
c002d35b:	b0 00                	mov    $0x0,%al
c002d35d:	e9 07 ff ff ff       	jmp    c002d269 <dir_subdir_delete+0x2e>
c002d362:	b0 00                	mov    $0x0,%al
c002d364:	e9 00 ff ff ff       	jmp    c002d269 <dir_subdir_delete+0x2e>

c002d369 <dir_subfile_create>:

bool
dir_subfile_create(struct dir* dir, const char* name, off_t initial_size) {
c002d369:	56                   	push   %esi
c002d36a:	53                   	push   %ebx
c002d36b:	83 ec 14             	sub    $0x14,%esp
c002d36e:	8b 74 24 20          	mov    0x20(%esp),%esi
c002d372:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  block_sector_t sector = -1u;
c002d376:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c002d37d:	ff 
  if (  dir != NULL
c002d37e:	85 f6                	test   %esi,%esi
c002d380:	74 70                	je     c002d3f2 <dir_subfile_create+0x89>
    &&  name != NULL
c002d382:	85 db                	test   %ebx,%ebx
c002d384:	74 70                	je     c002d3f6 <dir_subfile_create+0x8d>
    &&  strlen(name) > 0
c002d386:	80 3b 00             	cmpb   $0x0,(%ebx)
c002d389:	75 04                	jne    c002d38f <dir_subfile_create+0x26>
    return true;
  }
  if (sector != -1u) {
    free_map_release(sector, 1);
  }
  return false;
c002d38b:	b0 00                	mov    $0x0,%al
c002d38d:	eb 2f                	jmp    c002d3be <dir_subfile_create+0x55>
    &&  free_map_allocate(1, &sector)
c002d38f:	83 ec 08             	sub    $0x8,%esp
c002d392:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d396:	50                   	push   %eax
c002d397:	6a 01                	push   $0x1
c002d399:	e8 f7 f2 ff ff       	call   c002c695 <free_map_allocate>
c002d39e:	83 c4 10             	add    $0x10,%esp
c002d3a1:	84 c0                	test   %al,%al
c002d3a3:	75 1f                	jne    c002d3c4 <dir_subfile_create+0x5b>
  if (sector != -1u) {
c002d3a5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d3a9:	83 f8 ff             	cmp    $0xffffffff,%eax
c002d3ac:	74 4c                	je     c002d3fa <dir_subfile_create+0x91>
    free_map_release(sector, 1);
c002d3ae:	83 ec 08             	sub    $0x8,%esp
c002d3b1:	6a 01                	push   $0x1
c002d3b3:	50                   	push   %eax
c002d3b4:	e8 49 f3 ff ff       	call   c002c702 <free_map_release>
c002d3b9:	83 c4 10             	add    $0x10,%esp
  return false;
c002d3bc:	b0 00                	mov    $0x0,%al
}
c002d3be:	83 c4 14             	add    $0x14,%esp
c002d3c1:	5b                   	pop    %ebx
c002d3c2:	5e                   	pop    %esi
c002d3c3:	c3                   	ret    
    &&  inode_create(sector, initial_size)
c002d3c4:	83 ec 08             	sub    $0x8,%esp
c002d3c7:	ff 74 24 30          	pushl  0x30(%esp)
c002d3cb:	ff 74 24 18          	pushl  0x18(%esp)
c002d3cf:	e8 28 04 00 00       	call   c002d7fc <inode_create>
c002d3d4:	83 c4 10             	add    $0x10,%esp
c002d3d7:	84 c0                	test   %al,%al
c002d3d9:	74 ca                	je     c002d3a5 <dir_subfile_create+0x3c>
    &&  dir_add(dir, name, sector)
c002d3db:	83 ec 04             	sub    $0x4,%esp
c002d3de:	ff 74 24 10          	pushl  0x10(%esp)
c002d3e2:	53                   	push   %ebx
c002d3e3:	56                   	push   %esi
c002d3e4:	e8 49 f9 ff ff       	call   c002cd32 <dir_add>
c002d3e9:	83 c4 10             	add    $0x10,%esp
c002d3ec:	84 c0                	test   %al,%al
c002d3ee:	74 b5                	je     c002d3a5 <dir_subfile_create+0x3c>
c002d3f0:	eb cc                	jmp    c002d3be <dir_subfile_create+0x55>
  return false;
c002d3f2:	b0 00                	mov    $0x0,%al
c002d3f4:	eb c8                	jmp    c002d3be <dir_subfile_create+0x55>
c002d3f6:	b0 00                	mov    $0x0,%al
c002d3f8:	eb c4                	jmp    c002d3be <dir_subfile_create+0x55>
c002d3fa:	b0 00                	mov    $0x0,%al
c002d3fc:	eb c0                	jmp    c002d3be <dir_subfile_create+0x55>

c002d3fe <dir_subfile_lookup>:

struct file*
dir_subfile_lookup(struct dir* dir, const char* name) {
c002d3fe:	56                   	push   %esi
c002d3ff:	53                   	push   %ebx
c002d400:	83 ec 14             	sub    $0x14,%esp
c002d403:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c002d407:	8b 44 24 24          	mov    0x24(%esp),%eax
  struct inode* inode = NULL;
c002d40b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d412:	00 
  if (  dir != NULL
c002d413:	85 db                	test   %ebx,%ebx
c002d415:	74 78                	je     c002d48f <dir_subfile_lookup+0x91>
    &&  name != NULL
c002d417:	85 c0                	test   %eax,%eax
c002d419:	74 7b                	je     c002d496 <dir_subfile_lookup+0x98>
    &&  strlen(name) > 0
c002d41b:	80 38 00             	cmpb   $0x0,(%eax)
c002d41e:	74 7d                	je     c002d49d <dir_subfile_lookup+0x9f>
    &&  dir_lookup(dir, name, &inode)
c002d420:	83 ec 04             	sub    $0x4,%esp
c002d423:	8d 54 24 10          	lea    0x10(%esp),%edx
c002d427:	52                   	push   %edx
c002d428:	50                   	push   %eax
c002d429:	53                   	push   %ebx
c002d42a:	e8 70 f8 ff ff       	call   c002cc9f <dir_lookup>
c002d42f:	83 c4 10             	add    $0x10,%esp
c002d432:	84 c0                	test   %al,%al
c002d434:	74 6e                	je     c002d4a4 <dir_subfile_lookup+0xa6>
    &&  inode != NULL
c002d436:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d43a:	85 c0                	test   %eax,%eax
c002d43c:	74 6d                	je     c002d4ab <dir_subfile_lookup+0xad>
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
c002d43e:	83 ec 0c             	sub    $0xc,%esp
c002d441:	50                   	push   %eax
c002d442:	e8 87 0b 00 00       	call   c002dfce <inode_is_dir>
c002d447:	83 c4 10             	add    $0x10,%esp
c002d44a:	84 c0                	test   %al,%al
c002d44c:	75 2b                	jne    c002d479 <dir_subfile_lookup+0x7b>
    ) {
    struct file* file = file_open(inode);
c002d44e:	83 ec 0c             	sub    $0xc,%esp
c002d451:	ff 74 24 18          	pushl  0x18(%esp)
c002d455:	e8 20 f4 ff ff       	call   c002c87a <file_open>
c002d45a:	89 c6                	mov    %eax,%esi
    file_set_dir(file, dir_reopen(dir));
c002d45c:	89 1c 24             	mov    %ebx,(%esp)
c002d45f:	e8 f4 f7 ff ff       	call   c002cc58 <dir_reopen>
c002d464:	83 c4 08             	add    $0x8,%esp
c002d467:	50                   	push   %eax
c002d468:	56                   	push   %esi
c002d469:	e8 a7 f6 ff ff       	call   c002cb15 <file_set_dir>
    return file;
c002d46e:	83 c4 10             	add    $0x10,%esp
  }
  return NULL;
}
c002d471:	89 f0                	mov    %esi,%eax
c002d473:	83 c4 14             	add    $0x14,%esp
c002d476:	5b                   	pop    %ebx
c002d477:	5e                   	pop    %esi
c002d478:	c3                   	ret    
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
c002d479:	83 ec 0c             	sub    $0xc,%esp
c002d47c:	ff 74 24 18          	pushl  0x18(%esp)
c002d480:	e8 79 06 00 00       	call   c002dafe <inode_close>
c002d485:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002d488:	be 00 00 00 00       	mov    $0x0,%esi
c002d48d:	eb e2                	jmp    c002d471 <dir_subfile_lookup+0x73>
c002d48f:	be 00 00 00 00       	mov    $0x0,%esi
c002d494:	eb db                	jmp    c002d471 <dir_subfile_lookup+0x73>
c002d496:	be 00 00 00 00       	mov    $0x0,%esi
c002d49b:	eb d4                	jmp    c002d471 <dir_subfile_lookup+0x73>
c002d49d:	be 00 00 00 00       	mov    $0x0,%esi
c002d4a2:	eb cd                	jmp    c002d471 <dir_subfile_lookup+0x73>
c002d4a4:	be 00 00 00 00       	mov    $0x0,%esi
c002d4a9:	eb c6                	jmp    c002d471 <dir_subfile_lookup+0x73>
c002d4ab:	be 00 00 00 00       	mov    $0x0,%esi
c002d4b0:	eb bf                	jmp    c002d471 <dir_subfile_lookup+0x73>

c002d4b2 <dir_subfile_delete>:

bool
dir_subfile_delete(struct dir* dir, const char* name) {
c002d4b2:	56                   	push   %esi
c002d4b3:	53                   	push   %ebx
c002d4b4:	83 ec 14             	sub    $0x14,%esp
c002d4b7:	8b 74 24 20          	mov    0x20(%esp),%esi
c002d4bb:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  struct inode* inode = NULL;
c002d4bf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d4c6:	00 
  if (  dir != NULL
c002d4c7:	85 f6                	test   %esi,%esi
c002d4c9:	74 6d                	je     c002d538 <dir_subfile_delete+0x86>
    &&  name != NULL
c002d4cb:	85 db                	test   %ebx,%ebx
c002d4cd:	74 6d                	je     c002d53c <dir_subfile_delete+0x8a>
    &&  strlen(name) > 0
c002d4cf:	80 3b 00             	cmpb   $0x0,(%ebx)
c002d4d2:	75 08                	jne    c002d4dc <dir_subfile_delete+0x2a>
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
    ) {
    inode_close(inode);
    return dir_remove(dir, name);
  }
  return false;
c002d4d4:	b0 00                	mov    $0x0,%al
}
c002d4d6:	83 c4 14             	add    $0x14,%esp
c002d4d9:	5b                   	pop    %ebx
c002d4da:	5e                   	pop    %esi
c002d4db:	c3                   	ret    
    &&  dir_lookup(dir, name, &inode)
c002d4dc:	83 ec 04             	sub    $0x4,%esp
c002d4df:	8d 44 24 10          	lea    0x10(%esp),%eax
c002d4e3:	50                   	push   %eax
c002d4e4:	53                   	push   %ebx
c002d4e5:	56                   	push   %esi
c002d4e6:	e8 b4 f7 ff ff       	call   c002cc9f <dir_lookup>
c002d4eb:	83 c4 10             	add    $0x10,%esp
c002d4ee:	84 c0                	test   %al,%al
c002d4f0:	74 e4                	je     c002d4d6 <dir_subfile_delete+0x24>
    &&  inode != NULL
c002d4f2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d4f6:	85 c0                	test   %eax,%eax
c002d4f8:	74 46                	je     c002d540 <dir_subfile_delete+0x8e>
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
c002d4fa:	83 ec 0c             	sub    $0xc,%esp
c002d4fd:	50                   	push   %eax
c002d4fe:	e8 cb 0a 00 00       	call   c002dfce <inode_is_dir>
c002d503:	83 c4 10             	add    $0x10,%esp
c002d506:	84 c0                	test   %al,%al
c002d508:	75 1b                	jne    c002d525 <dir_subfile_delete+0x73>
    inode_close(inode);
c002d50a:	83 ec 0c             	sub    $0xc,%esp
c002d50d:	ff 74 24 18          	pushl  0x18(%esp)
c002d511:	e8 e8 05 00 00       	call   c002dafe <inode_close>
    return dir_remove(dir, name);
c002d516:	83 c4 08             	add    $0x8,%esp
c002d519:	53                   	push   %ebx
c002d51a:	56                   	push   %esi
c002d51b:	e8 45 fa ff ff       	call   c002cf65 <dir_remove>
c002d520:	83 c4 10             	add    $0x10,%esp
c002d523:	eb b1                	jmp    c002d4d6 <dir_subfile_delete+0x24>
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
c002d525:	83 ec 0c             	sub    $0xc,%esp
c002d528:	ff 74 24 18          	pushl  0x18(%esp)
c002d52c:	e8 cd 05 00 00       	call   c002dafe <inode_close>
c002d531:	83 c4 10             	add    $0x10,%esp
  return false;
c002d534:	b0 00                	mov    $0x0,%al
c002d536:	eb 9e                	jmp    c002d4d6 <dir_subfile_delete+0x24>
c002d538:	b0 00                	mov    $0x0,%al
c002d53a:	eb 9a                	jmp    c002d4d6 <dir_subfile_delete+0x24>
c002d53c:	b0 00                	mov    $0x0,%al
c002d53e:	eb 96                	jmp    c002d4d6 <dir_subfile_delete+0x24>
c002d540:	b0 00                	mov    $0x0,%al
c002d542:	eb 92                	jmp    c002d4d6 <dir_subfile_delete+0x24>

c002d544 <dir_is_dirfile>:

bool
dir_is_dirfile(struct fd_t* h) {
c002d544:	83 ec 18             	sub    $0x18,%esp
  return inode_is_dir(file_get_inode(h->ptr));
c002d547:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d54b:	ff 30                	pushl  (%eax)
c002d54d:	e8 a7 f3 ff ff       	call   c002c8f9 <file_get_inode>
c002d552:	89 04 24             	mov    %eax,(%esp)
c002d555:	e8 74 0a 00 00       	call   c002dfce <inode_is_dir>
c002d55a:	83 c4 1c             	add    $0x1c,%esp
c002d55d:	c3                   	ret    

c002d55e <byte_to_sector>:
   within INODE.
   Returns -1 if INODE does not contain data for a byte at offset
   POS. */
static block_sector_t
byte_to_sector (struct inode *inode, off_t pos, bool write) 
{
c002d55e:	55                   	push   %ebp
c002d55f:	57                   	push   %edi
c002d560:	56                   	push   %esi
c002d561:	53                   	push   %ebx
c002d562:	83 ec 3c             	sub    $0x3c,%esp
c002d565:	89 44 24 14          	mov    %eax,0x14(%esp)
c002d569:	89 54 24 18          	mov    %edx,0x18(%esp)
  ASSERT (inode != NULL);
c002d56d:	85 c0                	test   %eax,%eax
c002d56f:	74 67                	je     c002d5d8 <byte_to_sector+0x7a>
c002d571:	89 cb                	mov    %ecx,%ebx
  if (pos < inode->data.length)
    return inode->data.table + pos / BLOCK_SECTOR_SIZE;
  else
    return -1;
*/
  block_sector_t *l1 = calloc(TABLE_SIZE, sizeof *l1);
c002d573:	83 ec 08             	sub    $0x8,%esp
c002d576:	6a 04                	push   $0x4
c002d578:	68 80 00 00 00       	push   $0x80
c002d57d:	e8 a5 65 ff ff       	call   c0023b27 <calloc>
c002d582:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  block_sector_t *l2 = calloc(TABLE_SIZE, sizeof *l2);
c002d586:	83 c4 08             	add    $0x8,%esp
c002d589:	6a 04                	push   $0x4
c002d58b:	68 80 00 00 00       	push   $0x80
c002d590:	e8 92 65 ff ff       	call   c0023b27 <calloc>
c002d595:	89 44 24 14          	mov    %eax,0x14(%esp)
  block_sector_t ret = -1;
  if (pos >= inode->data.length) {
c002d599:	8b 44 24 24          	mov    0x24(%esp),%eax
c002d59d:	8b 40 1c             	mov    0x1c(%eax),%eax
c002d5a0:	83 c4 10             	add    $0x10,%esp
c002d5a3:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002d5a7:	0f 8f e9 01 00 00    	jg     c002d796 <byte_to_sector+0x238>
    if (!write)
c002d5ad:	84 db                	test   %bl,%bl
c002d5af:	75 45                	jne    c002d5f6 <byte_to_sector+0x98>
  block_sector_t ret = -1;
c002d5b1:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
  cache_read (inode->data.table, l1);
  cache_read (l1[byte_to_l1_table (pos)], l2);
  ret = l2[byte_to_l2_table (pos)];

done:
  free(l1);
c002d5b6:	83 ec 0c             	sub    $0xc,%esp
c002d5b9:	ff 74 24 18          	pushl  0x18(%esp)
c002d5bd:	e8 af 65 ff ff       	call   c0023b71 <free>
  free(l2);
c002d5c2:	83 c4 04             	add    $0x4,%esp
c002d5c5:	ff 74 24 10          	pushl  0x10(%esp)
c002d5c9:	e8 a3 65 ff ff       	call   c0023b71 <free>
  return ret;
}
c002d5ce:	89 e8                	mov    %ebp,%eax
c002d5d0:	83 c4 4c             	add    $0x4c,%esp
c002d5d3:	5b                   	pop    %ebx
c002d5d4:	5e                   	pop    %esi
c002d5d5:	5f                   	pop    %edi
c002d5d6:	5d                   	pop    %ebp
c002d5d7:	c3                   	ret    
  ASSERT (inode != NULL);
c002d5d8:	83 ec 0c             	sub    $0xc,%esp
c002d5db:	68 a0 25 03 c0       	push   $0xc00325a0
c002d5e0:	68 21 01 03 c0       	push   $0xc0030121
c002d5e5:	68 00 00 03 c0       	push   $0xc0030000
c002d5ea:	6a 49                	push   $0x49
c002d5ec:	68 bb 25 03 c0       	push   $0xc00325bb
c002d5f1:	e8 31 b0 ff ff       	call   c0028627 <debug_panic>
    l1_st = byte_to_l1_table(inode->data.length);
c002d5f6:	89 c2                	mov    %eax,%edx
c002d5f8:	c1 fa 10             	sar    $0x10,%edx
c002d5fb:	83 e2 7f             	and    $0x7f,%edx
c002d5fe:	89 d6                	mov    %edx,%esi
c002d600:	89 54 24 24          	mov    %edx,0x24(%esp)
    l2_st = byte_to_l2_table(inode->data.length);
c002d604:	c1 f8 09             	sar    $0x9,%eax
c002d607:	83 e0 7f             	and    $0x7f,%eax
c002d60a:	89 c7                	mov    %eax,%edi
c002d60c:	89 44 24 28          	mov    %eax,0x28(%esp)
    l1_ed = byte_to_l1_table(pos);
c002d610:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002d614:	89 d8                	mov    %ebx,%eax
c002d616:	c1 f8 10             	sar    $0x10,%eax
c002d619:	83 e0 7f             	and    $0x7f,%eax
c002d61c:	89 c5                	mov    %eax,%ebp
c002d61e:	89 44 24 20          	mov    %eax,0x20(%esp)
    l2_ed = byte_to_l2_table(pos);
c002d622:	c1 fb 09             	sar    $0x9,%ebx
c002d625:	83 e3 7f             	and    $0x7f,%ebx
    cache_read (inode->data.table, l1);
c002d628:	83 ec 08             	sub    $0x8,%esp
c002d62b:	ff 74 24 14          	pushl  0x14(%esp)
c002d62f:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c002d633:	ff 71 18             	pushl  0x18(%ecx)
c002d636:	e8 e4 10 00 00       	call   c002e71f <cache_read>
    for (i = l1_st; i <= l1_ed; i++) {
c002d63b:	83 c4 10             	add    $0x10,%esp
c002d63e:	39 ee                	cmp    %ebp,%esi
c002d640:	0f 8f 21 01 00 00    	jg     c002d767 <byte_to_sector+0x209>
c002d646:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d64a:	8d 04 b0             	lea    (%eax,%esi,4),%eax
c002d64d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002d651:	89 74 24 08          	mov    %esi,0x8(%esp)
      r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002d655:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
c002d659:	e9 be 00 00 00       	jmp    c002d71c <byte_to_sector+0x1be>
      l = (i == l1_st ? l2_st : 0);
c002d65e:	8b 7c 24 28          	mov    0x28(%esp),%edi
c002d662:	e9 b5 00 00 00       	jmp    c002d71c <byte_to_sector+0x1be>
      r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002d667:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002d66b:	89 04 24             	mov    %eax,(%esp)
c002d66e:	e9 be 00 00 00       	jmp    c002d731 <byte_to_sector+0x1d3>
        if (!free_map_allocate (1, &l1[i]))
c002d673:	83 ec 08             	sub    $0x8,%esp
c002d676:	ff 74 24 24          	pushl  0x24(%esp)
c002d67a:	6a 01                	push   $0x1
c002d67c:	e8 14 f0 ff ff       	call   c002c695 <free_map_allocate>
c002d681:	83 c4 10             	add    $0x10,%esp
c002d684:	84 c0                	test   %al,%al
c002d686:	0f 84 2a ff ff ff    	je     c002d5b6 <byte_to_sector+0x58>
        cache_write (l1[i], ones); // table init to -1
c002d68c:	83 ec 08             	sub    $0x8,%esp
c002d68f:	68 e0 ce 03 c0       	push   $0xc003cee0
c002d694:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d698:	ff 30                	pushl  (%eax)
c002d69a:	e8 2e 11 00 00       	call   c002e7cd <cache_write>
c002d69f:	83 c4 10             	add    $0x10,%esp
c002d6a2:	e9 9d 00 00 00       	jmp    c002d744 <byte_to_sector+0x1e6>
      for (j = l; j <= r; j++) {
c002d6a7:	47                   	inc    %edi
c002d6a8:	83 c3 04             	add    $0x4,%ebx
c002d6ab:	39 3c 24             	cmp    %edi,(%esp)
c002d6ae:	7c 31                	jl     c002d6e1 <byte_to_sector+0x183>
        if (l2[j] == -1) {
c002d6b0:	8b 2b                	mov    (%ebx),%ebp
c002d6b2:	83 fd ff             	cmp    $0xffffffff,%ebp
c002d6b5:	75 f0                	jne    c002d6a7 <byte_to_sector+0x149>
          if (!free_map_allocate (1, &l2[j]))
c002d6b7:	83 ec 08             	sub    $0x8,%esp
c002d6ba:	53                   	push   %ebx
c002d6bb:	6a 01                	push   $0x1
c002d6bd:	e8 d3 ef ff ff       	call   c002c695 <free_map_allocate>
c002d6c2:	83 c4 10             	add    $0x10,%esp
c002d6c5:	84 c0                	test   %al,%al
c002d6c7:	0f 84 e9 fe ff ff    	je     c002d5b6 <byte_to_sector+0x58>
          cache_write (l2[j], zeros);
c002d6cd:	83 ec 08             	sub    $0x8,%esp
c002d6d0:	68 e0 d0 03 c0       	push   $0xc003d0e0
c002d6d5:	ff 33                	pushl  (%ebx)
c002d6d7:	e8 f1 10 00 00       	call   c002e7cd <cache_write>
c002d6dc:	83 c4 10             	add    $0x10,%esp
c002d6df:	eb c6                	jmp    c002d6a7 <byte_to_sector+0x149>
      cache_write (l1[i], l2);
c002d6e1:	83 ec 08             	sub    $0x8,%esp
c002d6e4:	ff 74 24 0c          	pushl  0xc(%esp)
c002d6e8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d6ec:	ff 30                	pushl  (%eax)
c002d6ee:	e8 da 10 00 00       	call   c002e7cd <cache_write>
    for (i = l1_st; i <= l1_ed; i++) {
c002d6f3:	ff 44 24 18          	incl   0x18(%esp)
c002d6f7:	8b 44 24 18          	mov    0x18(%esp),%eax
c002d6fb:	83 44 24 2c 04       	addl   $0x4,0x2c(%esp)
c002d700:	83 c4 10             	add    $0x10,%esp
c002d703:	39 44 24 20          	cmp    %eax,0x20(%esp)
c002d707:	7c 5e                	jl     c002d767 <byte_to_sector+0x209>
      l = (i == l1_st ? l2_st : 0);
c002d709:	8b 54 24 08          	mov    0x8(%esp),%edx
c002d70d:	39 54 24 24          	cmp    %edx,0x24(%esp)
c002d711:	0f 84 47 ff ff ff    	je     c002d65e <byte_to_sector+0x100>
c002d717:	bf 00 00 00 00       	mov    $0x0,%edi
      r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002d71c:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002d720:	39 4c 24 20          	cmp    %ecx,0x20(%esp)
c002d724:	0f 84 3d ff ff ff    	je     c002d667 <byte_to_sector+0x109>
c002d72a:	c7 04 24 7f 00 00 00 	movl   $0x7f,(%esp)
      if (l1[i] == -1){
c002d731:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d735:	89 44 24 10          	mov    %eax,0x10(%esp)
c002d739:	8b 28                	mov    (%eax),%ebp
c002d73b:	83 fd ff             	cmp    $0xffffffff,%ebp
c002d73e:	0f 84 2f ff ff ff    	je     c002d673 <byte_to_sector+0x115>
      cache_read (l1[i], l2);
c002d744:	83 ec 08             	sub    $0x8,%esp
c002d747:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002d74b:	56                   	push   %esi
c002d74c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d750:	ff 30                	pushl  (%eax)
c002d752:	e8 c8 0f 00 00       	call   c002e71f <cache_read>
      for (j = l; j <= r; j++) {
c002d757:	83 c4 10             	add    $0x10,%esp
c002d75a:	3b 3c 24             	cmp    (%esp),%edi
c002d75d:	7f 82                	jg     c002d6e1 <byte_to_sector+0x183>
c002d75f:	8d 1c be             	lea    (%esi,%edi,4),%ebx
c002d762:	e9 49 ff ff ff       	jmp    c002d6b0 <byte_to_sector+0x152>
    cache_write (inode->data.table, l1);
c002d767:	83 ec 08             	sub    $0x8,%esp
c002d76a:	ff 74 24 14          	pushl  0x14(%esp)
c002d76e:	8b 74 24 20          	mov    0x20(%esp),%esi
c002d772:	ff 76 18             	pushl  0x18(%esi)
c002d775:	e8 53 10 00 00       	call   c002e7cd <cache_write>
    inode->data.length = pos + 1;
c002d77a:	8b 44 24 28          	mov    0x28(%esp),%eax
c002d77e:	40                   	inc    %eax
c002d77f:	89 46 1c             	mov    %eax,0x1c(%esi)
    cache_write (inode->sector, &inode->data);
c002d782:	83 c4 08             	add    $0x8,%esp
c002d785:	89 f0                	mov    %esi,%eax
c002d787:	83 c0 18             	add    $0x18,%eax
c002d78a:	50                   	push   %eax
c002d78b:	ff 76 08             	pushl  0x8(%esi)
c002d78e:	e8 3a 10 00 00       	call   c002e7cd <cache_write>
c002d793:	83 c4 10             	add    $0x10,%esp
  cache_read (inode->data.table, l1);
c002d796:	83 ec 08             	sub    $0x8,%esp
c002d799:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002d79d:	57                   	push   %edi
c002d79e:	8b 44 24 20          	mov    0x20(%esp),%eax
c002d7a2:	ff 70 18             	pushl  0x18(%eax)
c002d7a5:	e8 75 0f 00 00       	call   c002e71f <cache_read>
  cache_read (l1[byte_to_l1_table (pos)], l2);
c002d7aa:	83 c4 08             	add    $0x8,%esp
c002d7ad:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002d7b1:	53                   	push   %ebx
c002d7b2:	8b 74 24 24          	mov    0x24(%esp),%esi
c002d7b6:	89 f0                	mov    %esi,%eax
c002d7b8:	c1 f8 10             	sar    $0x10,%eax
c002d7bb:	83 e0 7f             	and    $0x7f,%eax
c002d7be:	ff 34 87             	pushl  (%edi,%eax,4)
c002d7c1:	e8 59 0f 00 00       	call   c002e71f <cache_read>
  ret = l2[byte_to_l2_table (pos)];
c002d7c6:	89 f0                	mov    %esi,%eax
c002d7c8:	c1 f8 09             	sar    $0x9,%eax
c002d7cb:	83 e0 7f             	and    $0x7f,%eax
c002d7ce:	8b 2c 83             	mov    (%ebx,%eax,4),%ebp
c002d7d1:	83 c4 10             	add    $0x10,%esp
c002d7d4:	e9 dd fd ff ff       	jmp    c002d5b6 <byte_to_sector+0x58>

c002d7d9 <inode_init>:
static struct list open_inodes;

/* Initializes the inode module. */
void
inode_init (void) 
{
c002d7d9:	57                   	push   %edi
c002d7da:	83 ec 14             	sub    $0x14,%esp
  list_init (&open_inodes);
c002d7dd:	68 c0 ce 03 c0       	push   $0xc003cec0
c002d7e2:	e8 e7 ae ff ff       	call   c00286ce <list_init>
  memset (ones, -1, sizeof ones);
c002d7e7:	ba e0 ce 03 c0       	mov    $0xc003cee0,%edx
c002d7ec:	b9 00 02 00 00       	mov    $0x200,%ecx
c002d7f1:	b0 ff                	mov    $0xff,%al
c002d7f3:	89 d7                	mov    %edx,%edi
c002d7f5:	f3 aa                	rep stos %al,%es:(%edi)
}
c002d7f7:	83 c4 18             	add    $0x18,%esp
c002d7fa:	5f                   	pop    %edi
c002d7fb:	c3                   	ret    

c002d7fc <inode_create>:
   device.
   Returns true if successful.
   Returns false if memory or disk allocation fails. */
bool
inode_create (block_sector_t sector, off_t length)
{
c002d7fc:	55                   	push   %ebp
c002d7fd:	57                   	push   %edi
c002d7fe:	56                   	push   %esi
c002d7ff:	53                   	push   %ebx
c002d800:	83 ec 3c             	sub    $0x3c,%esp
c002d803:	8b 5c 24 54          	mov    0x54(%esp),%ebx
  struct inode_disk *disk_inode = NULL;
  bool success = false;

  ASSERT (length >= 0);
c002d807:	85 db                	test   %ebx,%ebx
c002d809:	78 5b                	js     c002d866 <inode_create+0x6a>

  /* If this assertion fails, the inode structure is not exactly
     one sector in size, and you should fix that. */
  ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);

  disk_inode = calloc (1, sizeof *disk_inode);
c002d80b:	83 ec 08             	sub    $0x8,%esp
c002d80e:	68 00 02 00 00       	push   $0x200
c002d813:	6a 01                	push   $0x1
c002d815:	e8 0d 63 ff ff       	call   c0023b27 <calloc>
c002d81a:	89 c5                	mov    %eax,%ebp
  if (disk_inode != NULL)
c002d81c:	83 c4 10             	add    $0x10,%esp
c002d81f:	85 c0                	test   %eax,%eax
c002d821:	0f 84 19 02 00 00    	je     c002da40 <inode_create+0x244>
    {
      disk_inode->length = length;
c002d827:	89 58 04             	mov    %ebx,0x4(%eax)
      disk_inode->magic = INODE_MAGIC;
c002d82a:	c7 80 fc 01 00 00 44 	movl   $0x494e4f44,0x1fc(%eax)
c002d831:	4f 4e 49 
      disk_inode->is_dir = false;
c002d834:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      if (free_map_allocate (1, &disk_inode->table)) 
c002d838:	83 ec 08             	sub    $0x8,%esp
c002d83b:	50                   	push   %eax
c002d83c:	6a 01                	push   $0x1
c002d83e:	e8 52 ee ff ff       	call   c002c695 <free_map_allocate>
c002d843:	88 44 24 1f          	mov    %al,0x1f(%esp)
c002d847:	83 c4 10             	add    $0x10,%esp
c002d84a:	84 c0                	test   %al,%al
c002d84c:	75 39                	jne    c002d887 <inode_create+0x8b>
            free(l2);
          } else {
            success = true; 
          }
        } 
      free (disk_inode);
c002d84e:	83 ec 0c             	sub    $0xc,%esp
c002d851:	55                   	push   %ebp
c002d852:	e8 1a 63 ff ff       	call   c0023b71 <free>
c002d857:	83 c4 10             	add    $0x10,%esp
    }
  return success;
}
c002d85a:	8a 44 24 0f          	mov    0xf(%esp),%al
c002d85e:	83 c4 3c             	add    $0x3c,%esp
c002d861:	5b                   	pop    %ebx
c002d862:	5e                   	pop    %esi
c002d863:	5f                   	pop    %edi
c002d864:	5d                   	pop    %ebp
c002d865:	c3                   	ret    
  ASSERT (length >= 0);
c002d866:	83 ec 0c             	sub    $0xc,%esp
c002d869:	68 d1 25 03 c0       	push   $0xc00325d1
c002d86e:	68 21 01 03 c0       	push   $0xc0030121
c002d873:	68 20 00 03 c0       	push   $0xc0030020
c002d878:	68 97 00 00 00       	push   $0x97
c002d87d:	68 bb 25 03 c0       	push   $0xc00325bb
c002d882:	e8 a0 ad ff ff       	call   c0028627 <debug_panic>
          cache_write (sector, disk_inode);
c002d887:	83 ec 08             	sub    $0x8,%esp
c002d88a:	55                   	push   %ebp
c002d88b:	ff 74 24 5c          	pushl  0x5c(%esp)
c002d88f:	e8 39 0f 00 00       	call   c002e7cd <cache_write>
          cache_write (disk_inode->table, ones);
c002d894:	83 c4 08             	add    $0x8,%esp
c002d897:	68 e0 ce 03 c0       	push   $0xc003cee0
c002d89c:	ff 75 00             	pushl  0x0(%ebp)
c002d89f:	e8 29 0f 00 00       	call   c002e7cd <cache_write>
          if (length) {
c002d8a4:	83 c4 10             	add    $0x10,%esp
c002d8a7:	85 db                	test   %ebx,%ebx
c002d8a9:	74 a3                	je     c002d84e <inode_create+0x52>
            block_sector_t *l1 = calloc(TABLE_SIZE, sizeof *l1);
c002d8ab:	83 ec 08             	sub    $0x8,%esp
c002d8ae:	6a 04                	push   $0x4
c002d8b0:	68 80 00 00 00       	push   $0x80
c002d8b5:	e8 6d 62 ff ff       	call   c0023b27 <calloc>
c002d8ba:	89 c7                	mov    %eax,%edi
c002d8bc:	89 44 24 34          	mov    %eax,0x34(%esp)
            block_sector_t *l2 = calloc(TABLE_SIZE, sizeof *l2);
c002d8c0:	83 c4 08             	add    $0x8,%esp
c002d8c3:	6a 04                	push   $0x4
c002d8c5:	68 80 00 00 00       	push   $0x80
c002d8ca:	e8 58 62 ff ff       	call   c0023b27 <calloc>
c002d8cf:	89 44 24 2c          	mov    %eax,0x2c(%esp)
            l1_ed = byte_to_l1_table(length - 1);
c002d8d3:	4b                   	dec    %ebx
c002d8d4:	89 d8                	mov    %ebx,%eax
c002d8d6:	c1 f8 10             	sar    $0x10,%eax
c002d8d9:	83 e0 7f             	and    $0x7f,%eax
c002d8dc:	89 44 24 30          	mov    %eax,0x30(%esp)
            l2_ed = byte_to_l2_table(length - 1);
c002d8e0:	c1 fb 09             	sar    $0x9,%ebx
c002d8e3:	83 e3 7f             	and    $0x7f,%ebx
            cache_read (disk_inode->table, l1);
c002d8e6:	83 c4 08             	add    $0x8,%esp
c002d8e9:	57                   	push   %edi
c002d8ea:	ff 75 00             	pushl  0x0(%ebp)
c002d8ed:	e8 2d 0e 00 00       	call   c002e71f <cache_read>
c002d8f2:	89 7c 24 28          	mov    %edi,0x28(%esp)
c002d8f6:	83 c4 10             	add    $0x10,%esp
c002d8f9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c002d900:	00 
              r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002d901:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
c002d905:	89 6c 24 28          	mov    %ebp,0x28(%esp)
c002d909:	e9 9c 00 00 00       	jmp    c002d9aa <inode_create+0x1ae>
c002d90e:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002d912:	e9 a6 00 00 00       	jmp    c002d9bd <inode_create+0x1c1>
                if (!free_map_allocate (1, &l1[i]))
c002d917:	83 ec 08             	sub    $0x8,%esp
c002d91a:	ff 74 24 20          	pushl  0x20(%esp)
c002d91e:	6a 01                	push   $0x1
c002d920:	e8 70 ed ff ff       	call   c002c695 <free_map_allocate>
c002d925:	83 c4 10             	add    $0x10,%esp
c002d928:	84 c0                	test   %al,%al
c002d92a:	0f 84 dc 00 00 00    	je     c002da0c <inode_create+0x210>
                cache_write (l1[i], ones); // table init to -1
c002d930:	83 ec 08             	sub    $0x8,%esp
c002d933:	68 e0 ce 03 c0       	push   $0xc003cee0
c002d938:	8b 44 24 20          	mov    0x20(%esp),%eax
c002d93c:	ff 30                	pushl  (%eax)
c002d93e:	e8 8a 0e 00 00       	call   c002e7cd <cache_write>
c002d943:	83 c4 10             	add    $0x10,%esp
c002d946:	e9 83 00 00 00       	jmp    c002d9ce <inode_create+0x1d2>
              for (j = l; j <= r; j++) {
c002d94b:	46                   	inc    %esi
c002d94c:	83 c3 04             	add    $0x4,%ebx
c002d94f:	39 f5                	cmp    %esi,%ebp
c002d951:	7c 2f                	jl     c002d982 <inode_create+0x186>
                if (l2[j] == -1) {
c002d953:	83 3b ff             	cmpl   $0xffffffff,(%ebx)
c002d956:	75 f3                	jne    c002d94b <inode_create+0x14f>
                  if (!free_map_allocate (1, &l2[j]))
c002d958:	83 ec 08             	sub    $0x8,%esp
c002d95b:	53                   	push   %ebx
c002d95c:	6a 01                	push   $0x1
c002d95e:	e8 32 ed ff ff       	call   c002c695 <free_map_allocate>
c002d963:	83 c4 10             	add    $0x10,%esp
c002d966:	84 c0                	test   %al,%al
c002d968:	0f 84 a6 00 00 00    	je     c002da14 <inode_create+0x218>
                  cache_write (l2[j], zeros);
c002d96e:	83 ec 08             	sub    $0x8,%esp
c002d971:	68 e0 d0 03 c0       	push   $0xc003d0e0
c002d976:	ff 33                	pushl  (%ebx)
c002d978:	e8 50 0e 00 00       	call   c002e7cd <cache_write>
c002d97d:	83 c4 10             	add    $0x10,%esp
c002d980:	eb c9                	jmp    c002d94b <inode_create+0x14f>
              cache_write (l1[i], l2);
c002d982:	83 ec 08             	sub    $0x8,%esp
c002d985:	ff 74 24 24          	pushl  0x24(%esp)
c002d989:	8b 44 24 20          	mov    0x20(%esp),%eax
c002d98d:	ff 30                	pushl  (%eax)
c002d98f:	e8 39 0e 00 00       	call   c002e7cd <cache_write>
            for (i = 0; i <= l1_ed; i++) {
c002d994:	ff 44 24 20          	incl   0x20(%esp)
c002d998:	8b 44 24 20          	mov    0x20(%esp),%eax
c002d99c:	83 44 24 28 04       	addl   $0x4,0x28(%esp)
c002d9a1:	83 c4 10             	add    $0x10,%esp
c002d9a4:	39 44 24 20          	cmp    %eax,0x20(%esp)
c002d9a8:	7c 44                	jl     c002d9ee <inode_create+0x1f2>
              r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002d9aa:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002d9ae:	39 4c 24 20          	cmp    %ecx,0x20(%esp)
c002d9b2:	0f 84 56 ff ff ff    	je     c002d90e <inode_create+0x112>
c002d9b8:	bd 7f 00 00 00       	mov    $0x7f,%ebp
              if (l1[i] == -1){
c002d9bd:	8b 44 24 18          	mov    0x18(%esp),%eax
c002d9c1:	89 44 24 14          	mov    %eax,0x14(%esp)
c002d9c5:	83 38 ff             	cmpl   $0xffffffff,(%eax)
c002d9c8:	0f 84 49 ff ff ff    	je     c002d917 <inode_create+0x11b>
              cache_read (l1[i], l2);
c002d9ce:	83 ec 08             	sub    $0x8,%esp
c002d9d1:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c002d9d5:	53                   	push   %ebx
c002d9d6:	8b 44 24 20          	mov    0x20(%esp),%eax
c002d9da:	ff 30                	pushl  (%eax)
c002d9dc:	e8 3e 0d 00 00       	call   c002e71f <cache_read>
c002d9e1:	83 c4 10             	add    $0x10,%esp
c002d9e4:	be 00 00 00 00       	mov    $0x0,%esi
c002d9e9:	e9 65 ff ff ff       	jmp    c002d953 <inode_create+0x157>
c002d9ee:	8b 6c 24 28          	mov    0x28(%esp),%ebp
            cache_write (disk_inode->table, l1);
c002d9f2:	83 ec 08             	sub    $0x8,%esp
c002d9f5:	ff 74 24 2c          	pushl  0x2c(%esp)
c002d9f9:	ff 75 00             	pushl  0x0(%ebp)
c002d9fc:	e8 cc 0d 00 00       	call   c002e7cd <cache_write>
c002da01:	83 c4 10             	add    $0x10,%esp
            success = true;
c002da04:	8a 44 24 0f          	mov    0xf(%esp),%al
c002da08:	89 c7                	mov    %eax,%edi
c002da0a:	eb 0e                	jmp    c002da1a <inode_create+0x21e>
c002da0c:	89 c7                	mov    %eax,%edi
c002da0e:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002da12:	eb 06                	jmp    c002da1a <inode_create+0x21e>
c002da14:	89 c7                	mov    %eax,%edi
c002da16:	8b 6c 24 28          	mov    0x28(%esp),%ebp
            free(l1);
c002da1a:	83 ec 0c             	sub    $0xc,%esp
c002da1d:	ff 74 24 30          	pushl  0x30(%esp)
c002da21:	e8 4b 61 ff ff       	call   c0023b71 <free>
            free(l2);
c002da26:	83 c4 04             	add    $0x4,%esp
c002da29:	ff 74 24 28          	pushl  0x28(%esp)
c002da2d:	e8 3f 61 ff ff       	call   c0023b71 <free>
c002da32:	83 c4 10             	add    $0x10,%esp
c002da35:	89 f8                	mov    %edi,%eax
c002da37:	88 44 24 0f          	mov    %al,0xf(%esp)
c002da3b:	e9 0e fe ff ff       	jmp    c002d84e <inode_create+0x52>
  bool success = false;
c002da40:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
  return success;
c002da45:	e9 10 fe ff ff       	jmp    c002d85a <inode_create+0x5e>

c002da4a <inode_reopen>:
}

/* Reopens and returns INODE. */
struct inode *
inode_reopen (struct inode *inode)
{
c002da4a:	8b 44 24 04          	mov    0x4(%esp),%eax
  if (inode != NULL)
c002da4e:	85 c0                	test   %eax,%eax
c002da50:	74 03                	je     c002da55 <inode_reopen+0xb>
    inode->open_cnt++;
c002da52:	ff 40 0c             	incl   0xc(%eax)
  return inode;
}
c002da55:	c3                   	ret    

c002da56 <inode_open>:
{
c002da56:	56                   	push   %esi
c002da57:	53                   	push   %ebx
c002da58:	83 ec 10             	sub    $0x10,%esp
c002da5b:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
c002da5f:	68 c0 ce 03 c0       	push   $0xc003cec0
c002da64:	e8 a8 ac ff ff       	call   c0028711 <list_begin>
c002da69:	89 c3                	mov    %eax,%ebx
c002da6b:	83 c4 10             	add    $0x10,%esp
c002da6e:	83 ec 0c             	sub    $0xc,%esp
c002da71:	68 c0 ce 03 c0       	push   $0xc003cec0
c002da76:	e8 0e ad ff ff       	call   c0028789 <list_end>
c002da7b:	83 c4 10             	add    $0x10,%esp
c002da7e:	39 c3                	cmp    %eax,%ebx
c002da80:	74 29                	je     c002daab <inode_open+0x55>
      if (inode->sector == sector) 
c002da82:	39 73 08             	cmp    %esi,0x8(%ebx)
c002da85:	74 10                	je     c002da97 <inode_open+0x41>
       e = list_next (e)) 
c002da87:	83 ec 0c             	sub    $0xc,%esp
c002da8a:	53                   	push   %ebx
c002da8b:	e8 b1 ac ff ff       	call   c0028741 <list_next>
c002da90:	89 c3                	mov    %eax,%ebx
c002da92:	83 c4 10             	add    $0x10,%esp
c002da95:	eb d7                	jmp    c002da6e <inode_open+0x18>
          inode_reopen (inode);
c002da97:	83 ec 0c             	sub    $0xc,%esp
c002da9a:	53                   	push   %ebx
c002da9b:	e8 aa ff ff ff       	call   c002da4a <inode_reopen>
          return inode; 
c002daa0:	83 c4 10             	add    $0x10,%esp
}
c002daa3:	89 d8                	mov    %ebx,%eax
c002daa5:	83 c4 04             	add    $0x4,%esp
c002daa8:	5b                   	pop    %ebx
c002daa9:	5e                   	pop    %esi
c002daaa:	c3                   	ret    
  inode = malloc (sizeof *inode);
c002daab:	83 ec 0c             	sub    $0xc,%esp
c002daae:	68 18 02 00 00       	push   $0x218
c002dab3:	e8 16 5f ff ff       	call   c00239ce <malloc>
c002dab8:	89 c3                	mov    %eax,%ebx
  if (inode == NULL)
c002daba:	83 c4 10             	add    $0x10,%esp
c002dabd:	85 c0                	test   %eax,%eax
c002dabf:	74 e2                	je     c002daa3 <inode_open+0x4d>
  list_push_front (&open_inodes, &inode->elem);
c002dac1:	83 ec 08             	sub    $0x8,%esp
c002dac4:	50                   	push   %eax
c002dac5:	68 c0 ce 03 c0       	push   $0xc003cec0
c002daca:	e8 2e b0 ff ff       	call   c0028afd <list_push_front>
  inode->sector = sector;
c002dacf:	89 73 08             	mov    %esi,0x8(%ebx)
  inode->open_cnt = 1;
c002dad2:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
  inode->deny_write_cnt = 0;
c002dad9:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
  inode->removed = false;
c002dae0:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
  cache_read (inode->sector, &inode->data);
c002dae4:	83 c4 08             	add    $0x8,%esp
c002dae7:	8d 43 18             	lea    0x18(%ebx),%eax
c002daea:	50                   	push   %eax
c002daeb:	56                   	push   %esi
c002daec:	e8 2e 0c 00 00       	call   c002e71f <cache_read>
  return inode;
c002daf1:	83 c4 10             	add    $0x10,%esp
c002daf4:	eb ad                	jmp    c002daa3 <inode_open+0x4d>

c002daf6 <inode_get_inumber>:

/* Returns INODE's inode number. */
block_sector_t
inode_get_inumber (const struct inode *inode)
{
  return inode->sector;
c002daf6:	8b 44 24 04          	mov    0x4(%esp),%eax
c002dafa:	8b 40 08             	mov    0x8(%eax),%eax
}
c002dafd:	c3                   	ret    

c002dafe <inode_close>:
/* Closes INODE and writes it to disk.
   If this was the last reference to INODE, frees its memory.
   If INODE was also a removed inode, frees its blocks. */
void
inode_close (struct inode* inode) 
{
c002dafe:	55                   	push   %ebp
c002daff:	57                   	push   %edi
c002db00:	56                   	push   %esi
c002db01:	53                   	push   %ebx
c002db02:	83 ec 2c             	sub    $0x2c,%esp
c002db05:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  /* Ignore null pointer. */
  if (inode == NULL)
c002db09:	85 ed                	test   %ebp,%ebp
c002db0b:	74 0f                	je     c002db1c <inode_close+0x1e>
    return;

  /* Release resources if this was the last opener. */
  if (--inode->open_cnt == 0)
c002db0d:	8b 45 0c             	mov    0xc(%ebp),%eax
c002db10:	48                   	dec    %eax
c002db11:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002db15:	89 45 0c             	mov    %eax,0xc(%ebp)
c002db18:	85 c0                	test   %eax,%eax
c002db1a:	74 08                	je     c002db24 <inode_close+0x26>
        free_map_release (inode->data.table, 1);
      }

      free (inode); 
    }
}
c002db1c:	83 c4 2c             	add    $0x2c,%esp
c002db1f:	5b                   	pop    %ebx
c002db20:	5e                   	pop    %esi
c002db21:	5f                   	pop    %edi
c002db22:	5d                   	pop    %ebp
c002db23:	c3                   	ret    
      list_remove (&inode->elem);
c002db24:	83 ec 0c             	sub    $0xc,%esp
c002db27:	55                   	push   %ebp
c002db28:	e8 0a b0 ff ff       	call   c0028b37 <list_remove>
      if (inode->removed) {
c002db2d:	83 c4 10             	add    $0x10,%esp
c002db30:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
c002db34:	74 24                	je     c002db5a <inode_close+0x5c>
        if (inode->data.length) {
c002db36:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
c002db39:	85 db                	test   %ebx,%ebx
c002db3b:	75 2b                	jne    c002db68 <inode_close+0x6a>
        free_map_release (inode->sector, 1);
c002db3d:	83 ec 08             	sub    $0x8,%esp
c002db40:	6a 01                	push   $0x1
c002db42:	ff 75 08             	pushl  0x8(%ebp)
c002db45:	e8 b8 eb ff ff       	call   c002c702 <free_map_release>
        free_map_release (inode->data.table, 1);
c002db4a:	83 c4 08             	add    $0x8,%esp
c002db4d:	6a 01                	push   $0x1
c002db4f:	ff 75 18             	pushl  0x18(%ebp)
c002db52:	e8 ab eb ff ff       	call   c002c702 <free_map_release>
c002db57:	83 c4 10             	add    $0x10,%esp
      free (inode); 
c002db5a:	83 ec 0c             	sub    $0xc,%esp
c002db5d:	55                   	push   %ebp
c002db5e:	e8 0e 60 ff ff       	call   c0023b71 <free>
c002db63:	83 c4 10             	add    $0x10,%esp
c002db66:	eb b4                	jmp    c002db1c <inode_close+0x1e>
          block_sector_t *l1 = calloc(TABLE_SIZE, sizeof *l1);
c002db68:	83 ec 08             	sub    $0x8,%esp
c002db6b:	6a 04                	push   $0x4
c002db6d:	68 80 00 00 00       	push   $0x80
c002db72:	e8 b0 5f ff ff       	call   c0023b27 <calloc>
c002db77:	89 c7                	mov    %eax,%edi
c002db79:	89 44 24 20          	mov    %eax,0x20(%esp)
          block_sector_t *l2 = calloc(TABLE_SIZE, sizeof *l2);
c002db7d:	83 c4 08             	add    $0x8,%esp
c002db80:	6a 04                	push   $0x4
c002db82:	68 80 00 00 00       	push   $0x80
c002db87:	e8 9b 5f ff ff       	call   c0023b27 <calloc>
c002db8c:	89 c6                	mov    %eax,%esi
          l1_ed = byte_to_l1_table(inode->data.length - 1);
c002db8e:	4b                   	dec    %ebx
c002db8f:	89 d8                	mov    %ebx,%eax
c002db91:	c1 f8 10             	sar    $0x10,%eax
c002db94:	83 e0 7f             	and    $0x7f,%eax
c002db97:	89 44 24 24          	mov    %eax,0x24(%esp)
          l2_ed = byte_to_l2_table(inode->data.length - 1);
c002db9b:	c1 fb 09             	sar    $0x9,%ebx
c002db9e:	83 e3 7f             	and    $0x7f,%ebx
          cache_read (inode->data.table, l1);
c002dba1:	83 c4 08             	add    $0x8,%esp
c002dba4:	57                   	push   %edi
c002dba5:	ff 75 18             	pushl  0x18(%ebp)
c002dba8:	e8 72 0b 00 00       	call   c002e71f <cache_read>
c002dbad:	83 c4 10             	add    $0x10,%esp
c002dbb0:	8b 44 24 0c          	mov    0xc(%esp),%eax
            r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002dbb4:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
c002dbb8:	89 6c 24 40          	mov    %ebp,0x40(%esp)
c002dbbc:	89 c5                	mov    %eax,%ebp
c002dbbe:	39 6c 24 14          	cmp    %ebp,0x14(%esp)
c002dbc2:	74 74                	je     c002dc38 <inode_close+0x13a>
c002dbc4:	bf 7f 00 00 00       	mov    $0x7f,%edi
c002dbc9:	89 6c 24 18          	mov    %ebp,0x18(%esp)
            cache_read (l1[i], l2);
c002dbcd:	83 ec 08             	sub    $0x8,%esp
c002dbd0:	56                   	push   %esi
c002dbd1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002dbd5:	ff 34 a8             	pushl  (%eax,%ebp,4)
c002dbd8:	e8 42 0b 00 00       	call   c002e71f <cache_read>
c002dbdd:	83 c4 10             	add    $0x10,%esp
c002dbe0:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
              free_map_release (l2[j], 1);
c002dbe4:	83 ec 08             	sub    $0x8,%esp
c002dbe7:	6a 01                	push   $0x1
c002dbe9:	ff 34 9e             	pushl  (%esi,%ebx,4)
c002dbec:	e8 11 eb ff ff       	call   c002c702 <free_map_release>
            for (j = l; j <= r; j++) {
c002dbf1:	43                   	inc    %ebx
c002dbf2:	83 c4 10             	add    $0x10,%esp
c002dbf5:	39 fb                	cmp    %edi,%ebx
c002dbf7:	7e eb                	jle    c002dbe4 <inode_close+0xe6>
            free_map_release(l1[i], 1);
c002dbf9:	83 ec 08             	sub    $0x8,%esp
c002dbfc:	6a 01                	push   $0x1
c002dbfe:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002dc02:	8b 54 24 24          	mov    0x24(%esp),%edx
c002dc06:	ff 34 90             	pushl  (%eax,%edx,4)
c002dc09:	e8 f4 ea ff ff       	call   c002c702 <free_map_release>
          for (i = 0; i <= l1_ed; i++) {
c002dc0e:	45                   	inc    %ebp
c002dc0f:	83 c4 10             	add    $0x10,%esp
c002dc12:	39 6c 24 14          	cmp    %ebp,0x14(%esp)
c002dc16:	7d a6                	jge    c002dbbe <inode_close+0xc0>
c002dc18:	8b 6c 24 40          	mov    0x40(%esp),%ebp
          free(l1);
c002dc1c:	83 ec 0c             	sub    $0xc,%esp
c002dc1f:	ff 74 24 1c          	pushl  0x1c(%esp)
c002dc23:	e8 49 5f ff ff       	call   c0023b71 <free>
          free(l2);
c002dc28:	89 34 24             	mov    %esi,(%esp)
c002dc2b:	e8 41 5f ff ff       	call   c0023b71 <free>
c002dc30:	83 c4 10             	add    $0x10,%esp
c002dc33:	e9 05 ff ff ff       	jmp    c002db3d <inode_close+0x3f>
            r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002dc38:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
c002dc3c:	eb 8b                	jmp    c002dbc9 <inode_close+0xcb>

c002dc3e <inode_remove>:

/* Marks INODE to be deleted when it is closed by the last caller who
   has it open. */
void
inode_remove (struct inode *inode) 
{
c002dc3e:	83 ec 0c             	sub    $0xc,%esp
c002dc41:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (inode != NULL);
c002dc45:	85 c0                	test   %eax,%eax
c002dc47:	74 08                	je     c002dc51 <inode_remove+0x13>
  inode->removed = true;
c002dc49:	c6 40 10 01          	movb   $0x1,0x10(%eax)
}
c002dc4d:	83 c4 0c             	add    $0xc,%esp
c002dc50:	c3                   	ret    
  ASSERT (inode != NULL);
c002dc51:	83 ec 0c             	sub    $0xc,%esp
c002dc54:	68 a0 25 03 c0       	push   $0xc00325a0
c002dc59:	68 21 01 03 c0       	push   $0xc0030121
c002dc5e:	68 10 00 03 c0       	push   $0xc0030010
c002dc63:	68 3a 01 00 00       	push   $0x13a
c002dc68:	68 bb 25 03 c0       	push   $0xc00325bb
c002dc6d:	e8 b5 a9 ff ff       	call   c0028627 <debug_panic>

c002dc72 <inode_read_at>:
/* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
   Returns the number of bytes actually read, which may be less
   than SIZE if an error occurs or end of file is reached. */
off_t
inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset) 
{
c002dc72:	55                   	push   %ebp
c002dc73:	57                   	push   %edi
c002dc74:	56                   	push   %esi
c002dc75:	53                   	push   %ebx
c002dc76:	83 ec 1c             	sub    $0x1c,%esp
c002dc79:	8b 6c 24 38          	mov    0x38(%esp),%ebp
  uint8_t *buffer = buffer_;
  off_t bytes_read = 0;
  uint8_t *bounce = NULL;

  while (size > 0) 
c002dc7d:	85 ed                	test   %ebp,%ebp
c002dc7f:	0f 8e 07 01 00 00    	jle    c002dd8c <inode_read_at+0x11a>
c002dc85:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002dc8c:	00 
c002dc8d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002dc94:	00 
c002dc95:	eb 49                	jmp    c002dce0 <inode_read_at+0x6e>
    {
      /* Disk sector to read, starting byte offset within sector. */
      block_sector_t sector_idx = byte_to_sector (inode, offset, false);
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002dc97:	4e                   	dec    %esi
c002dc98:	81 ce 00 fe ff ff    	or     $0xfffffe00,%esi
c002dc9e:	46                   	inc    %esi
c002dc9f:	eb 5f                	jmp    c002dd00 <inode_read_at+0x8e>
        }
      else 
        {
          /* Read sector into bounce buffer, then partially copy
             into caller's buffer. */
          if (bounce == NULL) 
c002dca1:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c002dca6:	0f 84 ac 00 00 00    	je     c002dd58 <inode_read_at+0xe6>
            {
              bounce = malloc (BLOCK_SECTOR_SIZE);
              if (bounce == NULL)
                break;
            }
          cache_read (sector_idx, bounce);
c002dcac:	83 ec 08             	sub    $0x8,%esp
c002dcaf:	ff 74 24 0c          	pushl  0xc(%esp)
c002dcb3:	57                   	push   %edi
c002dcb4:	e8 66 0a 00 00       	call   c002e71f <cache_read>
          memcpy (buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002dcb9:	8b 44 24 18          	mov    0x18(%esp),%eax
c002dcbd:	03 44 24 44          	add    0x44(%esp),%eax
c002dcc1:	03 74 24 14          	add    0x14(%esp),%esi
c002dcc5:	89 c7                	mov    %eax,%edi
c002dcc7:	89 d9                	mov    %ebx,%ecx
c002dcc9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
c002dccb:	83 c4 10             	add    $0x10,%esp
        }
      
      /* Advance. */
      size -= chunk_size;
c002dcce:	29 dd                	sub    %ebx,%ebp
      offset += chunk_size;
c002dcd0:	01 5c 24 3c          	add    %ebx,0x3c(%esp)
      bytes_read += chunk_size;
c002dcd4:	01 5c 24 08          	add    %ebx,0x8(%esp)
  while (size > 0) 
c002dcd8:	85 ed                	test   %ebp,%ebp
c002dcda:	0f 8e 94 00 00 00    	jle    c002dd74 <inode_read_at+0x102>
      block_sector_t sector_idx = byte_to_sector (inode, offset, false);
c002dce0:	b9 00 00 00 00       	mov    $0x0,%ecx
c002dce5:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c002dce9:	8b 44 24 30          	mov    0x30(%esp),%eax
c002dced:	e8 6c f8 ff ff       	call   c002d55e <byte_to_sector>
c002dcf2:	89 c7                	mov    %eax,%edi
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002dcf4:	8b 74 24 3c          	mov    0x3c(%esp),%esi
c002dcf8:	81 e6 ff 01 00 80    	and    $0x800001ff,%esi
c002dcfe:	78 97                	js     c002dc97 <inode_read_at+0x25>
      off_t inode_left = inode_length (inode) - offset;
c002dd00:	8b 44 24 30          	mov    0x30(%esp),%eax
c002dd04:	8b 40 1c             	mov    0x1c(%eax),%eax
c002dd07:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002dd0b:	2b 44 24 3c          	sub    0x3c(%esp),%eax
      int chunk_size = size < min_left ? size : min_left;
c002dd0f:	89 c2                	mov    %eax,%edx
c002dd11:	39 e8                	cmp    %ebp,%eax
c002dd13:	7e 02                	jle    c002dd17 <inode_read_at+0xa5>
c002dd15:	89 ea                	mov    %ebp,%edx
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002dd17:	b8 00 02 00 00       	mov    $0x200,%eax
c002dd1c:	29 f0                	sub    %esi,%eax
      int chunk_size = size < min_left ? size : min_left;
c002dd1e:	89 d3                	mov    %edx,%ebx
c002dd20:	39 c2                	cmp    %eax,%edx
c002dd22:	7e 02                	jle    c002dd26 <inode_read_at+0xb4>
c002dd24:	89 c3                	mov    %eax,%ebx
      if (chunk_size <= 0)
c002dd26:	85 db                	test   %ebx,%ebx
c002dd28:	7e 4a                	jle    c002dd74 <inode_read_at+0x102>
      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002dd2a:	85 f6                	test   %esi,%esi
c002dd2c:	0f 85 6f ff ff ff    	jne    c002dca1 <inode_read_at+0x2f>
c002dd32:	81 fb 00 02 00 00    	cmp    $0x200,%ebx
c002dd38:	0f 85 63 ff ff ff    	jne    c002dca1 <inode_read_at+0x2f>
          cache_read (sector_idx, buffer + bytes_read);
c002dd3e:	83 ec 08             	sub    $0x8,%esp
c002dd41:	8b 44 24 10          	mov    0x10(%esp),%eax
c002dd45:	03 44 24 3c          	add    0x3c(%esp),%eax
c002dd49:	50                   	push   %eax
c002dd4a:	57                   	push   %edi
c002dd4b:	e8 cf 09 00 00       	call   c002e71f <cache_read>
c002dd50:	83 c4 10             	add    $0x10,%esp
c002dd53:	e9 76 ff ff ff       	jmp    c002dcce <inode_read_at+0x5c>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002dd58:	83 ec 0c             	sub    $0xc,%esp
c002dd5b:	68 00 02 00 00       	push   $0x200
c002dd60:	e8 69 5c ff ff       	call   c00239ce <malloc>
c002dd65:	89 44 24 14          	mov    %eax,0x14(%esp)
              if (bounce == NULL)
c002dd69:	83 c4 10             	add    $0x10,%esp
c002dd6c:	85 c0                	test   %eax,%eax
c002dd6e:	0f 85 38 ff ff ff    	jne    c002dcac <inode_read_at+0x3a>
    }
  free (bounce);
c002dd74:	83 ec 0c             	sub    $0xc,%esp
c002dd77:	ff 74 24 10          	pushl  0x10(%esp)
c002dd7b:	e8 f1 5d ff ff       	call   c0023b71 <free>

  return bytes_read;
}
c002dd80:	8b 44 24 18          	mov    0x18(%esp),%eax
c002dd84:	83 c4 2c             	add    $0x2c,%esp
c002dd87:	5b                   	pop    %ebx
c002dd88:	5e                   	pop    %esi
c002dd89:	5f                   	pop    %edi
c002dd8a:	5d                   	pop    %ebp
c002dd8b:	c3                   	ret    
  off_t bytes_read = 0;
c002dd8c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002dd93:	00 
  uint8_t *bounce = NULL;
c002dd94:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002dd9b:	00 
c002dd9c:	eb d6                	jmp    c002dd74 <inode_read_at+0x102>

c002dd9e <inode_write_at>:
   (Normally a write at end of file would extend the inode, but
   growth is not yet implemented.) */
off_t
inode_write_at (struct inode *inode, const void *buffer_, off_t size,
                off_t offset) 
{
c002dd9e:	55                   	push   %ebp
c002dd9f:	57                   	push   %edi
c002dda0:	56                   	push   %esi
c002dda1:	53                   	push   %ebx
c002dda2:	83 ec 1c             	sub    $0x1c,%esp
  const uint8_t *buffer = buffer_;
  off_t bytes_written = 0;
  uint8_t *bounce = NULL;

  if (inode->deny_write_cnt)
c002dda5:	8b 44 24 30          	mov    0x30(%esp),%eax
c002dda9:	8b 40 14             	mov    0x14(%eax),%eax
c002ddac:	89 44 24 08          	mov    %eax,0x8(%esp)
c002ddb0:	85 c0                	test   %eax,%eax
c002ddb2:	0f 85 57 01 00 00    	jne    c002df0f <inode_write_at+0x171>
    return 0;

  while (size > 0) 
c002ddb8:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002ddbd:	0f 8e 45 01 00 00    	jle    c002df08 <inode_write_at+0x16a>
c002ddc3:	bd 00 00 00 00       	mov    $0x0,%ebp
c002ddc8:	eb 7f                	jmp    c002de49 <inode_write_at+0xab>
    {
      /* Sector to write, starting byte offset within sector. */
      block_sector_t sector_idx = byte_to_sector (inode, offset, true);
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002ddca:	48                   	dec    %eax
c002ddcb:	0d 00 fe ff ff       	or     $0xfffffe00,%eax
c002ddd0:	40                   	inc    %eax
c002ddd1:	e9 98 00 00 00       	jmp    c002de6e <inode_write_at+0xd0>
        break;

      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
        {
          /* Write full sector directly to disk. */
          cache_write (sector_idx, buffer + bytes_written);
c002ddd6:	83 ec 08             	sub    $0x8,%esp
c002ddd9:	8b 44 24 10          	mov    0x10(%esp),%eax
c002dddd:	03 44 24 3c          	add    0x3c(%esp),%eax
c002dde1:	50                   	push   %eax
c002dde2:	ff 74 24 10          	pushl  0x10(%esp)
c002dde6:	e8 e2 09 00 00       	call   c002e7cd <cache_write>
c002ddeb:	83 c4 10             	add    $0x10,%esp
c002ddee:	eb 42                	jmp    c002de32 <inode_write_at+0x94>
        }
      else 
        {
          /* We need a bounce buffer. */
          if (bounce == NULL) 
c002ddf0:	85 ed                	test   %ebp,%ebp
c002ddf2:	0f 84 d9 00 00 00    	je     c002ded1 <inode_write_at+0x133>
            }

          /* If the sector contains data before or after the chunk
             we're writing, then we need to read in the sector
             first.  Otherwise we start with a sector of all zeros. */
          if (sector_ofs > 0 || chunk_size < sector_left) 
c002ddf8:	85 f6                	test   %esi,%esi
c002ddfa:	0f 8e b6 00 00 00    	jle    c002deb6 <inode_write_at+0x118>
            cache_read (sector_idx, bounce);
c002de00:	83 ec 08             	sub    $0x8,%esp
c002de03:	55                   	push   %ebp
c002de04:	ff 74 24 10          	pushl  0x10(%esp)
c002de08:	e8 12 09 00 00       	call   c002e71f <cache_read>
c002de0d:	83 c4 10             	add    $0x10,%esp
          else
            memset (bounce, 0, BLOCK_SECTOR_SIZE);
          memcpy (bounce + sector_ofs, buffer + bytes_written, chunk_size);
c002de10:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
c002de14:	8b 74 24 08          	mov    0x8(%esp),%esi
c002de18:	03 74 24 34          	add    0x34(%esp),%esi
c002de1c:	89 c7                	mov    %eax,%edi
c002de1e:	89 d9                	mov    %ebx,%ecx
c002de20:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
          cache_write ( sector_idx, bounce);
c002de22:	83 ec 08             	sub    $0x8,%esp
c002de25:	55                   	push   %ebp
c002de26:	ff 74 24 10          	pushl  0x10(%esp)
c002de2a:	e8 9e 09 00 00       	call   c002e7cd <cache_write>
c002de2f:	83 c4 10             	add    $0x10,%esp
        }

      /* Advance. */
      size -= chunk_size;
c002de32:	29 5c 24 38          	sub    %ebx,0x38(%esp)
      offset += chunk_size;
c002de36:	01 5c 24 3c          	add    %ebx,0x3c(%esp)
      bytes_written += chunk_size;
c002de3a:	01 5c 24 08          	add    %ebx,0x8(%esp)
  while (size > 0) 
c002de3e:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002de43:	0f 8e a7 00 00 00    	jle    c002def0 <inode_write_at+0x152>
      block_sector_t sector_idx = byte_to_sector (inode, offset, true);
c002de49:	b9 01 00 00 00       	mov    $0x1,%ecx
c002de4e:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c002de52:	8b 44 24 30          	mov    0x30(%esp),%eax
c002de56:	e8 03 f7 ff ff       	call   c002d55e <byte_to_sector>
c002de5b:	89 44 24 04          	mov    %eax,0x4(%esp)
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002de5f:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002de63:	25 ff 01 00 80       	and    $0x800001ff,%eax
c002de68:	0f 88 5c ff ff ff    	js     c002ddca <inode_write_at+0x2c>
c002de6e:	89 c6                	mov    %eax,%esi
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002de70:	bf 00 02 00 00       	mov    $0x200,%edi
c002de75:	29 c7                	sub    %eax,%edi
      off_t inode_left = inode_length (inode) - offset;
c002de77:	8b 44 24 30          	mov    0x30(%esp),%eax
c002de7b:	8b 40 1c             	mov    0x1c(%eax),%eax
c002de7e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002de82:	2b 44 24 3c          	sub    0x3c(%esp),%eax
      int chunk_size = size < min_left ? size : min_left;
c002de86:	89 c2                	mov    %eax,%edx
c002de88:	3b 44 24 38          	cmp    0x38(%esp),%eax
c002de8c:	7e 04                	jle    c002de92 <inode_write_at+0xf4>
c002de8e:	8b 54 24 38          	mov    0x38(%esp),%edx
c002de92:	89 d3                	mov    %edx,%ebx
c002de94:	39 fa                	cmp    %edi,%edx
c002de96:	7e 02                	jle    c002de9a <inode_write_at+0xfc>
c002de98:	89 fb                	mov    %edi,%ebx
      if (chunk_size <= 0)
c002de9a:	85 db                	test   %ebx,%ebx
c002de9c:	7e 52                	jle    c002def0 <inode_write_at+0x152>
      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002de9e:	85 f6                	test   %esi,%esi
c002dea0:	0f 85 4a ff ff ff    	jne    c002ddf0 <inode_write_at+0x52>
c002dea6:	81 fb 00 02 00 00    	cmp    $0x200,%ebx
c002deac:	0f 84 24 ff ff ff    	je     c002ddd6 <inode_write_at+0x38>
          if (bounce == NULL) 
c002deb2:	85 ed                	test   %ebp,%ebp
c002deb4:	74 63                	je     c002df19 <inode_write_at+0x17b>
          if (sector_ofs > 0 || chunk_size < sector_left) 
c002deb6:	39 df                	cmp    %ebx,%edi
c002deb8:	0f 8f 42 ff ff ff    	jg     c002de00 <inode_write_at+0x62>
            memset (bounce, 0, BLOCK_SECTOR_SIZE);
c002debe:	b9 80 00 00 00       	mov    $0x80,%ecx
c002dec3:	89 ef                	mov    %ebp,%edi
c002dec5:	b8 00 00 00 00       	mov    $0x0,%eax
c002deca:	f3 ab                	rep stos %eax,%es:(%edi)
c002decc:	e9 3f ff ff ff       	jmp    c002de10 <inode_write_at+0x72>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002ded1:	83 ec 0c             	sub    $0xc,%esp
c002ded4:	68 00 02 00 00       	push   $0x200
c002ded9:	e8 f0 5a ff ff       	call   c00239ce <malloc>
c002dede:	89 c5                	mov    %eax,%ebp
              if (bounce == NULL)
c002dee0:	83 c4 10             	add    $0x10,%esp
c002dee3:	85 c0                	test   %eax,%eax
c002dee5:	0f 85 0d ff ff ff    	jne    c002ddf8 <inode_write_at+0x5a>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002deeb:	bd 00 00 00 00       	mov    $0x0,%ebp
    }
  free (bounce);
c002def0:	83 ec 0c             	sub    $0xc,%esp
c002def3:	55                   	push   %ebp
c002def4:	e8 78 5c ff ff       	call   c0023b71 <free>

  return bytes_written;
c002def9:	83 c4 10             	add    $0x10,%esp
}
c002defc:	8b 44 24 08          	mov    0x8(%esp),%eax
c002df00:	83 c4 1c             	add    $0x1c,%esp
c002df03:	5b                   	pop    %ebx
c002df04:	5e                   	pop    %esi
c002df05:	5f                   	pop    %edi
c002df06:	5d                   	pop    %ebp
c002df07:	c3                   	ret    
  while (size > 0) 
c002df08:	bd 00 00 00 00       	mov    $0x0,%ebp
c002df0d:	eb e1                	jmp    c002def0 <inode_write_at+0x152>
    return 0;
c002df0f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002df16:	00 
c002df17:	eb e3                	jmp    c002defc <inode_write_at+0x15e>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002df19:	83 ec 0c             	sub    $0xc,%esp
c002df1c:	68 00 02 00 00       	push   $0x200
c002df21:	e8 a8 5a ff ff       	call   c00239ce <malloc>
c002df26:	89 c5                	mov    %eax,%ebp
              if (bounce == NULL)
c002df28:	83 c4 10             	add    $0x10,%esp
c002df2b:	85 c0                	test   %eax,%eax
c002df2d:	75 87                	jne    c002deb6 <inode_write_at+0x118>
c002df2f:	eb ba                	jmp    c002deeb <inode_write_at+0x14d>

c002df31 <inode_deny_write>:

/* Disables writes to INODE.
   May be called at most once per inode opener. */
void
inode_deny_write (struct inode *inode) 
{
c002df31:	83 ec 0c             	sub    $0xc,%esp
c002df34:	8b 54 24 10          	mov    0x10(%esp),%edx
  inode->deny_write_cnt++;
c002df38:	8b 42 14             	mov    0x14(%edx),%eax
c002df3b:	40                   	inc    %eax
c002df3c:	89 42 14             	mov    %eax,0x14(%edx)
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002df3f:	3b 42 0c             	cmp    0xc(%edx),%eax
c002df42:	7f 04                	jg     c002df48 <inode_deny_write+0x17>
}
c002df44:	83 c4 0c             	add    $0xc,%esp
c002df47:	c3                   	ret    
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002df48:	83 ec 0c             	sub    $0xc,%esp
c002df4b:	68 f8 25 03 c0       	push   $0xc00325f8
c002df50:	68 21 01 03 c0       	push   $0xc0030121
c002df55:	68 ec ff 02 c0       	push   $0xc002ffec
c002df5a:	68 bf 01 00 00       	push   $0x1bf
c002df5f:	68 bb 25 03 c0       	push   $0xc00325bb
c002df64:	e8 be a6 ff ff       	call   c0028627 <debug_panic>

c002df69 <inode_allow_write>:
/* Re-enables writes to INODE.
   Must be called once by each inode opener who has called
   inode_deny_write() on the inode, before closing the inode. */
void
inode_allow_write (struct inode *inode) 
{
c002df69:	83 ec 0c             	sub    $0xc,%esp
c002df6c:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (inode->deny_write_cnt > 0);
c002df70:	8b 42 14             	mov    0x14(%edx),%eax
c002df73:	85 c0                	test   %eax,%eax
c002df75:	7e 0d                	jle    c002df84 <inode_allow_write+0x1b>
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002df77:	3b 42 0c             	cmp    0xc(%edx),%eax
c002df7a:	7f 29                	jg     c002dfa5 <inode_allow_write+0x3c>
  inode->deny_write_cnt--;
c002df7c:	48                   	dec    %eax
c002df7d:	89 42 14             	mov    %eax,0x14(%edx)
}
c002df80:	83 c4 0c             	add    $0xc,%esp
c002df83:	c3                   	ret    
  ASSERT (inode->deny_write_cnt > 0);
c002df84:	83 ec 0c             	sub    $0xc,%esp
c002df87:	68 dd 25 03 c0       	push   $0xc00325dd
c002df8c:	68 21 01 03 c0       	push   $0xc0030121
c002df91:	68 d8 ff 02 c0       	push   $0xc002ffd8
c002df96:	68 c8 01 00 00       	push   $0x1c8
c002df9b:	68 bb 25 03 c0       	push   $0xc00325bb
c002dfa0:	e8 82 a6 ff ff       	call   c0028627 <debug_panic>
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002dfa5:	83 ec 0c             	sub    $0xc,%esp
c002dfa8:	68 f8 25 03 c0       	push   $0xc00325f8
c002dfad:	68 21 01 03 c0       	push   $0xc0030121
c002dfb2:	68 d8 ff 02 c0       	push   $0xc002ffd8
c002dfb7:	68 c9 01 00 00       	push   $0x1c9
c002dfbc:	68 bb 25 03 c0       	push   $0xc00325bb
c002dfc1:	e8 61 a6 ff ff       	call   c0028627 <debug_panic>

c002dfc6 <inode_length>:

/* Returns the length, in bytes, of INODE's data. */
off_t
inode_length (const struct inode *inode)
{
  return inode->data.length;
c002dfc6:	8b 44 24 04          	mov    0x4(%esp),%eax
c002dfca:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002dfcd:	c3                   	ret    

c002dfce <inode_is_dir>:

bool 
inode_is_dir (const struct inode *inode) {
  return inode->data.is_dir;
c002dfce:	8b 44 24 04          	mov    0x4(%esp),%eax
c002dfd2:	8a 40 20             	mov    0x20(%eax),%al
}
c002dfd5:	c3                   	ret    

c002dfd6 <inode_set_dir>:

void
inode_set_dir (struct inode* inode) {
c002dfd6:	83 ec 14             	sub    $0x14,%esp
c002dfd9:	8b 44 24 18          	mov    0x18(%esp),%eax
  inode->data.is_dir = true;
c002dfdd:	c6 40 20 01          	movb   $0x1,0x20(%eax)
  cache_write (inode->sector, &inode->data);
c002dfe1:	8d 50 18             	lea    0x18(%eax),%edx
c002dfe4:	52                   	push   %edx
c002dfe5:	ff 70 08             	pushl  0x8(%eax)
c002dfe8:	e8 e0 07 00 00       	call   c002e7cd <cache_write>
}
c002dfed:	83 c4 1c             	add    $0x1c,%esp
c002dff0:	c3                   	ret    

c002dff1 <inode_get_open_cnt>:

int
inode_get_open_cnt (struct inode* inode) {
  return inode->open_cnt;
c002dff1:	8b 44 24 04          	mov    0x4(%esp),%eax
c002dff5:	8b 40 0c             	mov    0xc(%eax),%eax
c002dff8:	c3                   	ret    

c002dff9 <fsutil_ls>:
#include "threads/vaddr.h"

/* List files in the root directory. */
void
fsutil_ls (char **argv UNUSED) 
{
c002dff9:	56                   	push   %esi
c002dffa:	53                   	push   %ebx
c002dffb:	83 ec 20             	sub    $0x20,%esp
  struct dir *dir;
  char name[NAME_MAX + 1];
  
  printf ("Files in the root directory:\n");
c002dffe:	68 21 26 03 c0       	push   $0xc0032621
c002e003:	e8 06 c1 ff ff       	call   c002a10e <puts>
  dir = dir_open_root ();
c002e008:	e8 35 ec ff ff       	call   c002cc42 <dir_open_root>
  if (dir == NULL)
c002e00d:	83 c4 10             	add    $0x10,%esp
c002e010:	85 c0                	test   %eax,%eax
c002e012:	74 08                	je     c002e01c <fsutil_ls+0x23>
c002e014:	89 c6                	mov    %eax,%esi
    PANIC ("root dir open failed");
  while (dir_readdir (dir, name))
c002e016:	8d 5c 24 01          	lea    0x1(%esp),%ebx
c002e01a:	eb 22                	jmp    c002e03e <fsutil_ls+0x45>
    PANIC ("root dir open failed");
c002e01c:	68 3e 26 03 c0       	push   $0xc003263e
c002e021:	68 68 00 03 c0       	push   $0xc0030068
c002e026:	6a 18                	push   $0x18
c002e028:	68 53 26 03 c0       	push   $0xc0032653
c002e02d:	e8 f5 a5 ff ff       	call   c0028627 <debug_panic>
    printf ("%s\n", name);
c002e032:	83 ec 0c             	sub    $0xc,%esp
c002e035:	53                   	push   %ebx
c002e036:	e8 d3 c0 ff ff       	call   c002a10e <puts>
c002e03b:	83 c4 10             	add    $0x10,%esp
  while (dir_readdir (dir, name))
c002e03e:	83 ec 08             	sub    $0x8,%esp
c002e041:	53                   	push   %ebx
c002e042:	56                   	push   %esi
c002e043:	e8 fb ef ff ff       	call   c002d043 <dir_readdir>
c002e048:	83 c4 10             	add    $0x10,%esp
c002e04b:	84 c0                	test   %al,%al
c002e04d:	75 e3                	jne    c002e032 <fsutil_ls+0x39>
  dir_close (dir);
c002e04f:	83 ec 0c             	sub    $0xc,%esp
c002e052:	56                   	push   %esi
c002e053:	e8 1a ec ff ff       	call   c002cc72 <dir_close>
  printf ("End of listing.\n");
c002e058:	c7 04 24 6a 26 03 c0 	movl   $0xc003266a,(%esp)
c002e05f:	e8 aa c0 ff ff       	call   c002a10e <puts>
}
c002e064:	83 c4 24             	add    $0x24,%esp
c002e067:	5b                   	pop    %ebx
c002e068:	5e                   	pop    %esi
c002e069:	c3                   	ret    

c002e06a <fsutil_cat>:

/* Prints the contents of file ARGV[1] to the system console as
   hex and ASCII. */
void
fsutil_cat (char **argv)
{
c002e06a:	57                   	push   %edi
c002e06b:	56                   	push   %esi
c002e06c:	53                   	push   %ebx
  const char *file_name = argv[1];
c002e06d:	8b 44 24 10          	mov    0x10(%esp),%eax
c002e071:	8b 70 04             	mov    0x4(%eax),%esi
  
  struct file *file;
  char *buffer;

  printf ("Printing '%s' to the console...\n", file_name);
c002e074:	83 ec 08             	sub    $0x8,%esp
c002e077:	56                   	push   %esi
c002e078:	68 44 27 03 c0       	push   $0xc0032744
c002e07d:	e8 f7 8a ff ff       	call   c0026b79 <printf>
  file = filesys_open (file_name);
c002e082:	89 34 24             	mov    %esi,(%esp)
c002e085:	e8 98 e3 ff ff       	call   c002c422 <filesys_open>
  if (file == NULL)
c002e08a:	83 c4 10             	add    $0x10,%esp
c002e08d:	85 c0                	test   %eax,%eax
c002e08f:	74 41                	je     c002e0d2 <fsutil_cat+0x68>
c002e091:	89 c3                	mov    %eax,%ebx
    PANIC ("%s: open failed", file_name);
  buffer = palloc_get_page (PAL_ASSERT);
c002e093:	83 ec 0c             	sub    $0xc,%esp
c002e096:	6a 01                	push   $0x1
c002e098:	e8 bb 55 ff ff       	call   c0023658 <palloc_get_page>
c002e09d:	89 c6                	mov    %eax,%esi
c002e09f:	83 c4 10             	add    $0x10,%esp
  for (;;) 
    {
      off_t pos = file_tell (file);
c002e0a2:	83 ec 0c             	sub    $0xc,%esp
c002e0a5:	53                   	push   %ebx
c002e0a6:	e8 37 ea ff ff       	call   c002cae2 <file_tell>
c002e0ab:	89 c7                	mov    %eax,%edi
      off_t n = file_read (file, buffer, PGSIZE);
c002e0ad:	83 c4 0c             	add    $0xc,%esp
c002e0b0:	68 00 10 00 00       	push   $0x1000
c002e0b5:	56                   	push   %esi
c002e0b6:	53                   	push   %ebx
c002e0b7:	e8 44 e8 ff ff       	call   c002c900 <file_read>
      if (n == 0)
c002e0bc:	83 c4 10             	add    $0x10,%esp
c002e0bf:	85 c0                	test   %eax,%eax
c002e0c1:	74 29                	je     c002e0ec <fsutil_cat+0x82>
        break;

      hex_dump (pos, buffer, n, true); 
c002e0c3:	6a 01                	push   $0x1
c002e0c5:	50                   	push   %eax
c002e0c6:	56                   	push   %esi
c002e0c7:	57                   	push   %edi
c002e0c8:	e8 55 92 ff ff       	call   c0027322 <hex_dump>
    {
c002e0cd:	83 c4 10             	add    $0x10,%esp
c002e0d0:	eb d0                	jmp    c002e0a2 <fsutil_cat+0x38>
    PANIC ("%s: open failed", file_name);
c002e0d2:	83 ec 0c             	sub    $0xc,%esp
c002e0d5:	56                   	push   %esi
c002e0d6:	68 7a 26 03 c0       	push   $0xc003267a
c002e0db:	68 5c 00 03 c0       	push   $0xc003005c
c002e0e0:	6a 2c                	push   $0x2c
c002e0e2:	68 53 26 03 c0       	push   $0xc0032653
c002e0e7:	e8 3b a5 ff ff       	call   c0028627 <debug_panic>
    }
  palloc_free_page (buffer);
c002e0ec:	83 ec 0c             	sub    $0xc,%esp
c002e0ef:	56                   	push   %esi
c002e0f0:	e8 8d 56 ff ff       	call   c0023782 <palloc_free_page>
  file_close (file);
c002e0f5:	89 1c 24             	mov    %ebx,(%esp)
c002e0f8:	e8 15 e9 ff ff       	call   c002ca12 <file_close>
}
c002e0fd:	83 c4 10             	add    $0x10,%esp
c002e100:	5b                   	pop    %ebx
c002e101:	5e                   	pop    %esi
c002e102:	5f                   	pop    %edi
c002e103:	c3                   	ret    

c002e104 <fsutil_rm>:

/* Deletes file ARGV[1]. */
void
fsutil_rm (char **argv) 
{
c002e104:	53                   	push   %ebx
c002e105:	83 ec 10             	sub    $0x10,%esp
  const char *file_name = argv[1];
c002e108:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e10c:	8b 58 04             	mov    0x4(%eax),%ebx
  
  printf ("Deleting '%s'...\n", file_name);
c002e10f:	53                   	push   %ebx
c002e110:	68 8a 26 03 c0       	push   $0xc003268a
c002e115:	e8 5f 8a ff ff       	call   c0026b79 <printf>
  if (!filesys_remove (file_name))
c002e11a:	89 1c 24             	mov    %ebx,(%esp)
c002e11d:	e8 52 e4 ff ff       	call   c002c574 <filesys_remove>
c002e122:	83 c4 10             	add    $0x10,%esp
c002e125:	84 c0                	test   %al,%al
c002e127:	74 05                	je     c002e12e <fsutil_rm+0x2a>
    PANIC ("%s: delete failed\n", file_name);
}
c002e129:	83 c4 08             	add    $0x8,%esp
c002e12c:	5b                   	pop    %ebx
c002e12d:	c3                   	ret    
    PANIC ("%s: delete failed\n", file_name);
c002e12e:	83 ec 0c             	sub    $0xc,%esp
c002e131:	53                   	push   %ebx
c002e132:	68 9c 26 03 c0       	push   $0xc003269c
c002e137:	68 50 00 03 c0       	push   $0xc0030050
c002e13c:	6a 43                	push   $0x43
c002e13e:	68 53 26 03 c0       	push   $0xc0032653
c002e143:	e8 df a4 ff ff       	call   c0028627 <debug_panic>

c002e148 <fsutil_extract>:

/* Extracts a ustar-format tar archive from the scratch block
   device into the Pintos file system. */
void
fsutil_extract (char **argv UNUSED) 
{
c002e148:	55                   	push   %ebp
c002e149:	57                   	push   %edi
c002e14a:	56                   	push   %esi
c002e14b:	53                   	push   %ebx
c002e14c:	83 ec 38             	sub    $0x38,%esp

  struct block *src;
  void *header, *data;

  /* Allocate buffers. */
  header = malloc (BLOCK_SECTOR_SIZE);
c002e14f:	68 00 02 00 00       	push   $0x200
c002e154:	e8 75 58 ff ff       	call   c00239ce <malloc>
c002e159:	89 c7                	mov    %eax,%edi
c002e15b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  data = malloc (BLOCK_SECTOR_SIZE);
c002e15f:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002e166:	e8 63 58 ff ff       	call   c00239ce <malloc>
c002e16b:	89 c6                	mov    %eax,%esi
  if (header == NULL || data == NULL)
c002e16d:	83 c4 10             	add    $0x10,%esp
c002e170:	85 ff                	test   %edi,%edi
c002e172:	74 29                	je     c002e19d <fsutil_extract+0x55>
c002e174:	85 c0                	test   %eax,%eax
c002e176:	74 25                	je     c002e19d <fsutil_extract+0x55>
    PANIC ("couldn't allocate buffers");

  /* Open source block device. */
  src = block_get_role (BLOCK_SCRATCH);
c002e178:	83 ec 0c             	sub    $0xc,%esp
c002e17b:	6a 02                	push   $0x2
c002e17d:	e8 e2 69 ff ff       	call   c0024b64 <block_get_role>
c002e182:	89 c5                	mov    %eax,%ebp
  if (src == NULL)
c002e184:	83 c4 10             	add    $0x10,%esp
c002e187:	85 c0                	test   %eax,%eax
c002e189:	74 28                	je     c002e1b3 <fsutil_extract+0x6b>
    PANIC ("couldn't open scratch device");

  printf ("Extracting ustar archive from scratch device "
c002e18b:	83 ec 0c             	sub    $0xc,%esp
c002e18e:	68 68 27 03 c0       	push   $0xc0032768
c002e193:	e8 76 bf ff ff       	call   c002a10e <puts>
c002e198:	83 c4 10             	add    $0x10,%esp
c002e19b:	eb 61                	jmp    c002e1fe <fsutil_extract+0xb6>
    PANIC ("couldn't allocate buffers");
c002e19d:	68 af 26 03 c0       	push   $0xc00326af
c002e1a2:	68 40 00 03 c0       	push   $0xc0030040
c002e1a7:	6a 54                	push   $0x54
c002e1a9:	68 53 26 03 c0       	push   $0xc0032653
c002e1ae:	e8 74 a4 ff ff       	call   c0028627 <debug_panic>
    PANIC ("couldn't open scratch device");
c002e1b3:	68 c9 26 03 c0       	push   $0xc00326c9
c002e1b8:	68 40 00 03 c0       	push   $0xc0030040
c002e1bd:	6a 59                	push   $0x59
c002e1bf:	68 53 26 03 c0       	push   $0xc0032653
c002e1c4:	e8 5e a4 ff ff       	call   c0028627 <debug_panic>

      /* Read and parse ustar header. */
      block_read (src, sector++, header);
      error = ustar_parse_header (header, &file_name, &type, &size);
      if (error != NULL)
        PANIC ("bad ustar header in sector %"PRDSNu" (%s)", sector - 1, error);
c002e1c9:	83 ec 08             	sub    $0x8,%esp
c002e1cc:	50                   	push   %eax
c002e1cd:	a1 e4 d2 03 c0       	mov    0xc003d2e4,%eax
c002e1d2:	48                   	dec    %eax
c002e1d3:	50                   	push   %eax
c002e1d4:	68 ac 27 03 c0       	push   $0xc00327ac
c002e1d9:	68 40 00 03 c0       	push   $0xc0030040
c002e1de:	6a 69                	push   $0x69
c002e1e0:	68 53 26 03 c0       	push   $0xc0032653
c002e1e5:	e8 3d a4 ff ff       	call   c0028627 <debug_panic>
        {
          /* End of archive. */
          break;
        }
      else if (type == USTAR_DIRECTORY)
        printf ("ignoring directory %s\n", file_name);
c002e1ea:	83 ec 08             	sub    $0x8,%esp
c002e1ed:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e1f1:	68 e6 26 03 c0       	push   $0xc00326e6
c002e1f6:	e8 7e 89 ff ff       	call   c0026b79 <printf>
c002e1fb:	83 c4 10             	add    $0x10,%esp
      block_read (src, sector++, header);
c002e1fe:	a1 e4 d2 03 c0       	mov    0xc003d2e4,%eax
c002e203:	8d 50 01             	lea    0x1(%eax),%edx
c002e206:	89 15 e4 d2 03 c0    	mov    %edx,0xc003d2e4
c002e20c:	83 ec 04             	sub    $0x4,%esp
c002e20f:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002e213:	57                   	push   %edi
c002e214:	50                   	push   %eax
c002e215:	55                   	push   %ebp
c002e216:	e8 77 6a ff ff       	call   c0024c92 <block_read>
      error = ustar_parse_header (header, &file_name, &type, &size);
c002e21b:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002e21f:	50                   	push   %eax
c002e220:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002e224:	50                   	push   %eax
c002e225:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002e229:	50                   	push   %eax
c002e22a:	57                   	push   %edi
c002e22b:	e8 71 a1 ff ff       	call   c00283a1 <ustar_parse_header>
      if (error != NULL)
c002e230:	83 c4 20             	add    $0x20,%esp
c002e233:	85 c0                	test   %eax,%eax
c002e235:	75 92                	jne    c002e1c9 <fsutil_extract+0x81>
      if (type == USTAR_EOF)
c002e237:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e23b:	83 f8 ff             	cmp    $0xffffffff,%eax
c002e23e:	0f 84 0f 01 00 00    	je     c002e353 <fsutil_extract+0x20b>
      else if (type == USTAR_DIRECTORY)
c002e244:	83 f8 35             	cmp    $0x35,%eax
c002e247:	74 a1                	je     c002e1ea <fsutil_extract+0xa2>
      else if (type == USTAR_REGULAR)
c002e249:	83 f8 30             	cmp    $0x30,%eax
c002e24c:	75 b0                	jne    c002e1fe <fsutil_extract+0xb6>
        {
          struct file *dst;

          printf ("Putting '%s' into the file system...\n", file_name);
c002e24e:	83 ec 08             	sub    $0x8,%esp
c002e251:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e255:	68 d0 27 03 c0       	push   $0xc00327d0
c002e25a:	e8 1a 89 ff ff       	call   c0026b79 <printf>

          /* Create destination file. */
          if (!filesys_create (file_name, size))
c002e25f:	83 c4 08             	add    $0x8,%esp
c002e262:	ff 74 24 24          	pushl  0x24(%esp)
c002e266:	ff 74 24 20          	pushl  0x20(%esp)
c002e26a:	e8 0b e1 ff ff       	call   c002c37a <filesys_create>
c002e26f:	83 c4 10             	add    $0x10,%esp
c002e272:	84 c0                	test   %al,%al
c002e274:	74 32                	je     c002e2a8 <fsutil_extract+0x160>
            PANIC ("%s: create failed", file_name);
          dst = filesys_open (file_name);
c002e276:	83 ec 0c             	sub    $0xc,%esp
c002e279:	ff 74 24 20          	pushl  0x20(%esp)
c002e27d:	e8 a0 e1 ff ff       	call   c002c422 <filesys_open>
c002e282:	89 c7                	mov    %eax,%edi
          if (dst == NULL)
c002e284:	83 c4 10             	add    $0x10,%esp
c002e287:	85 c0                	test   %eax,%eax
c002e289:	74 3a                	je     c002e2c5 <fsutil_extract+0x17d>
            PANIC ("%s: open failed", file_name);
          /* Do copy. */
          while (size > 0)
c002e28b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e28f:	85 c0                	test   %eax,%eax
c002e291:	0f 8f 88 00 00 00    	jg     c002e31f <fsutil_extract+0x1d7>
                       file_name, size);
              size -= chunk_size;
            }

          /* Finish up. */
          file_close (dst);
c002e297:	83 ec 0c             	sub    $0xc,%esp
c002e29a:	57                   	push   %edi
c002e29b:	e8 72 e7 ff ff       	call   c002ca12 <file_close>
c002e2a0:	83 c4 10             	add    $0x10,%esp
    {
c002e2a3:	e9 56 ff ff ff       	jmp    c002e1fe <fsutil_extract+0xb6>
            PANIC ("%s: create failed", file_name);
c002e2a8:	83 ec 0c             	sub    $0xc,%esp
c002e2ab:	ff 74 24 20          	pushl  0x20(%esp)
c002e2af:	68 fd 26 03 c0       	push   $0xc00326fd
c002e2b4:	68 40 00 03 c0       	push   $0xc0030040
c002e2b9:	6a 7a                	push   $0x7a
c002e2bb:	68 53 26 03 c0       	push   $0xc0032653
c002e2c0:	e8 62 a3 ff ff       	call   c0028627 <debug_panic>
            PANIC ("%s: open failed", file_name);
c002e2c5:	83 ec 0c             	sub    $0xc,%esp
c002e2c8:	ff 74 24 20          	pushl  0x20(%esp)
c002e2cc:	68 7a 26 03 c0       	push   $0xc003267a
c002e2d1:	68 40 00 03 c0       	push   $0xc0030040
c002e2d6:	6a 7d                	push   $0x7d
c002e2d8:	68 53 26 03 c0       	push   $0xc0032653
c002e2dd:	e8 45 a3 ff ff       	call   c0028627 <debug_panic>
              block_read (src, sector++, data);
c002e2e2:	a1 e4 d2 03 c0       	mov    0xc003d2e4,%eax
c002e2e7:	8d 50 01             	lea    0x1(%eax),%edx
c002e2ea:	89 15 e4 d2 03 c0    	mov    %edx,0xc003d2e4
c002e2f0:	83 ec 04             	sub    $0x4,%esp
c002e2f3:	56                   	push   %esi
c002e2f4:	50                   	push   %eax
c002e2f5:	55                   	push   %ebp
c002e2f6:	e8 97 69 ff ff       	call   c0024c92 <block_read>
              if (file_write (dst, data, chunk_size) != chunk_size)
c002e2fb:	83 c4 0c             	add    $0xc,%esp
c002e2fe:	53                   	push   %ebx
c002e2ff:	56                   	push   %esi
c002e300:	57                   	push   %edi
c002e301:	e8 3a e6 ff ff       	call   c002c940 <file_write>
c002e306:	83 c4 10             	add    $0x10,%esp
c002e309:	39 c3                	cmp    %eax,%ebx
c002e30b:	75 22                	jne    c002e32f <fsutil_extract+0x1e7>
              size -= chunk_size;
c002e30d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e311:	29 d8                	sub    %ebx,%eax
c002e313:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          while (size > 0)
c002e317:	85 c0                	test   %eax,%eax
c002e319:	0f 8e 78 ff ff ff    	jle    c002e297 <fsutil_extract+0x14f>
              int chunk_size = (size > BLOCK_SECTOR_SIZE
c002e31f:	89 c3                	mov    %eax,%ebx
c002e321:	3d 00 02 00 00       	cmp    $0x200,%eax
c002e326:	7e ba                	jle    c002e2e2 <fsutil_extract+0x19a>
c002e328:	bb 00 02 00 00       	mov    $0x200,%ebx
c002e32d:	eb b3                	jmp    c002e2e2 <fsutil_extract+0x19a>
                PANIC ("%s: write failed with %d bytes unwritten",
c002e32f:	83 ec 08             	sub    $0x8,%esp
c002e332:	ff 74 24 24          	pushl  0x24(%esp)
c002e336:	ff 74 24 20          	pushl  0x20(%esp)
c002e33a:	68 f8 27 03 c0       	push   $0xc00327f8
c002e33f:	68 40 00 03 c0       	push   $0xc0030040
c002e344:	68 87 00 00 00       	push   $0x87
c002e349:	68 53 26 03 c0       	push   $0xc0032653
c002e34e:	e8 d4 a2 ff ff       	call   c0028627 <debug_panic>

  /* Erase the ustar header from the start of the block device,
     so that the extraction operation is idempotent.  We erase
     two blocks because two blocks of zeros are the ustar
     end-of-archive marker. */
  printf ("Erasing ustar archive...\n");
c002e353:	83 ec 0c             	sub    $0xc,%esp
c002e356:	68 0f 27 03 c0       	push   $0xc003270f
c002e35b:	e8 ae bd ff ff       	call   c002a10e <puts>
  memset (header, 0, BLOCK_SECTOR_SIZE);
c002e360:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e365:	b8 00 00 00 00       	mov    $0x0,%eax
c002e36a:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
c002e36e:	f3 ab                	rep stos %eax,%es:(%edi)
  block_write (src, 0, header);
c002e370:	83 c4 0c             	add    $0xc,%esp
c002e373:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002e377:	57                   	push   %edi
c002e378:	6a 00                	push   $0x0
c002e37a:	55                   	push   %ebp
c002e37b:	e8 46 69 ff ff       	call   c0024cc6 <block_write>
  block_write (src, 1, header);
c002e380:	83 c4 0c             	add    $0xc,%esp
c002e383:	57                   	push   %edi
c002e384:	6a 01                	push   $0x1
c002e386:	55                   	push   %ebp
c002e387:	e8 3a 69 ff ff       	call   c0024cc6 <block_write>

  free (data);
c002e38c:	89 34 24             	mov    %esi,(%esp)
c002e38f:	e8 dd 57 ff ff       	call   c0023b71 <free>
  free (header);
c002e394:	89 3c 24             	mov    %edi,(%esp)
c002e397:	e8 d5 57 ff ff       	call   c0023b71 <free>
}
c002e39c:	83 c4 3c             	add    $0x3c,%esp
c002e39f:	5b                   	pop    %ebx
c002e3a0:	5e                   	pop    %esi
c002e3a1:	5f                   	pop    %edi
c002e3a2:	5d                   	pop    %ebp
c002e3a3:	c3                   	ret    

c002e3a4 <fsutil_append>:
   the device.  This position is independent of that used for
   fsutil_extract(), so `extract' should precede all
   `append's. */
void
fsutil_append (char **argv)
{
c002e3a4:	55                   	push   %ebp
c002e3a5:	57                   	push   %edi
c002e3a6:	56                   	push   %esi
c002e3a7:	53                   	push   %ebx
c002e3a8:	83 ec 24             	sub    $0x24,%esp
  static block_sector_t sector = 0;

  const char *file_name = argv[1];
c002e3ab:	8b 44 24 38          	mov    0x38(%esp),%eax
c002e3af:	8b 40 04             	mov    0x4(%eax),%eax
c002e3b2:	89 44 24 14          	mov    %eax,0x14(%esp)
  void *buffer;
  struct file *src;
  struct block *dst;
  off_t size;

  printf ("Appending '%s' to ustar archive on scratch device...\n", file_name);
c002e3b6:	50                   	push   %eax
c002e3b7:	68 24 28 03 c0       	push   $0xc0032824
c002e3bc:	e8 b8 87 ff ff       	call   c0026b79 <printf>

  /* Allocate buffer. */
  buffer = malloc (BLOCK_SECTOR_SIZE);
c002e3c1:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002e3c8:	e8 01 56 ff ff       	call   c00239ce <malloc>
  if (buffer == NULL)
c002e3cd:	83 c4 10             	add    $0x10,%esp
c002e3d0:	85 c0                	test   %eax,%eax
c002e3d2:	0f 84 d6 00 00 00    	je     c002e4ae <fsutil_append+0x10a>
c002e3d8:	89 c5                	mov    %eax,%ebp
    PANIC ("couldn't allocate buffer");

  /* Open source file. */
  src = filesys_open (file_name);
c002e3da:	83 ec 0c             	sub    $0xc,%esp
c002e3dd:	ff 74 24 18          	pushl  0x18(%esp)
c002e3e1:	e8 3c e0 ff ff       	call   c002c422 <filesys_open>
c002e3e6:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (src == NULL)
c002e3ea:	83 c4 10             	add    $0x10,%esp
c002e3ed:	85 c0                	test   %eax,%eax
c002e3ef:	0f 84 d2 00 00 00    	je     c002e4c7 <fsutil_append+0x123>
    PANIC ("%s: open failed", file_name);
  size = file_length (src);
c002e3f5:	83 ec 0c             	sub    $0xc,%esp
c002e3f8:	ff 74 24 14          	pushl  0x14(%esp)
c002e3fc:	e8 4b e6 ff ff       	call   c002ca4c <file_length>
c002e401:	89 c6                	mov    %eax,%esi

  /* Open target block device. */
  dst = block_get_role (BLOCK_SCRATCH);
c002e403:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c002e40a:	e8 55 67 ff ff       	call   c0024b64 <block_get_role>
c002e40f:	89 44 24 14          	mov    %eax,0x14(%esp)
  if (dst == NULL)
c002e413:	83 c4 10             	add    $0x10,%esp
c002e416:	85 c0                	test   %eax,%eax
c002e418:	0f 84 c9 00 00 00    	je     c002e4e7 <fsutil_append+0x143>
    PANIC ("couldn't open scratch device");
  
  /* Write ustar header to first sector. */
  if (!ustar_make_header (file_name, USTAR_REGULAR, size, buffer))
c002e41e:	55                   	push   %ebp
c002e41f:	56                   	push   %esi
c002e420:	6a 30                	push   $0x30
c002e422:	ff 74 24 18          	pushl  0x18(%esp)
c002e426:	e8 98 9d ff ff       	call   c00281c3 <ustar_make_header>
c002e42b:	83 c4 10             	add    $0x10,%esp
c002e42e:	84 c0                	test   %al,%al
c002e430:	0f 84 ca 00 00 00    	je     c002e500 <fsutil_append+0x15c>
    PANIC ("%s: name too long for ustar format", file_name);
  block_write (dst, sector++, buffer);
c002e436:	a1 e0 d2 03 c0       	mov    0xc003d2e0,%eax
c002e43b:	8d 50 01             	lea    0x1(%eax),%edx
c002e43e:	89 15 e0 d2 03 c0    	mov    %edx,0xc003d2e0
c002e444:	83 ec 04             	sub    $0x4,%esp
c002e447:	55                   	push   %ebp
c002e448:	50                   	push   %eax
c002e449:	ff 74 24 10          	pushl  0x10(%esp)
c002e44d:	e8 74 68 ff ff       	call   c0024cc6 <block_write>

  /* Do copy. */
  while (size > 0) 
c002e452:	83 c4 10             	add    $0x10,%esp
c002e455:	85 f6                	test   %esi,%esi
c002e457:	0f 8f 29 01 00 00    	jg     c002e586 <fsutil_append+0x1e2>
    }

  /* Write ustar end-of-archive marker, which is two consecutive
     sectors full of zeros.  Don't advance our position past
     them, though, in case we have more files to append. */
  memset (buffer, 0, BLOCK_SECTOR_SIZE);
c002e45d:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e462:	b8 00 00 00 00       	mov    $0x0,%eax
c002e467:	89 ef                	mov    %ebp,%edi
c002e469:	f3 ab                	rep stos %eax,%es:(%edi)
  block_write (dst, sector, buffer);
c002e46b:	83 ec 04             	sub    $0x4,%esp
c002e46e:	55                   	push   %ebp
c002e46f:	ff 35 e0 d2 03 c0    	pushl  0xc003d2e0
c002e475:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002e479:	57                   	push   %edi
c002e47a:	e8 47 68 ff ff       	call   c0024cc6 <block_write>
  block_write (dst, sector, buffer + 1);
c002e47f:	83 c4 0c             	add    $0xc,%esp
c002e482:	8d 45 01             	lea    0x1(%ebp),%eax
c002e485:	50                   	push   %eax
c002e486:	ff 35 e0 d2 03 c0    	pushl  0xc003d2e0
c002e48c:	57                   	push   %edi
c002e48d:	e8 34 68 ff ff       	call   c0024cc6 <block_write>

  /* Finish up. */
  file_close (src);
c002e492:	83 c4 04             	add    $0x4,%esp
c002e495:	ff 74 24 14          	pushl  0x14(%esp)
c002e499:	e8 74 e5 ff ff       	call   c002ca12 <file_close>
  free (buffer);
c002e49e:	89 2c 24             	mov    %ebp,(%esp)
c002e4a1:	e8 cb 56 ff ff       	call   c0023b71 <free>
}
c002e4a6:	83 c4 2c             	add    $0x2c,%esp
c002e4a9:	5b                   	pop    %ebx
c002e4aa:	5e                   	pop    %esi
c002e4ab:	5f                   	pop    %edi
c002e4ac:	5d                   	pop    %ebp
c002e4ad:	c3                   	ret    
    PANIC ("couldn't allocate buffer");
c002e4ae:	68 28 27 03 c0       	push   $0xc0032728
c002e4b3:	68 30 00 03 c0       	push   $0xc0030030
c002e4b8:	68 b5 00 00 00       	push   $0xb5
c002e4bd:	68 53 26 03 c0       	push   $0xc0032653
c002e4c2:	e8 60 a1 ff ff       	call   c0028627 <debug_panic>
    PANIC ("%s: open failed", file_name);
c002e4c7:	83 ec 0c             	sub    $0xc,%esp
c002e4ca:	ff 74 24 18          	pushl  0x18(%esp)
c002e4ce:	68 7a 26 03 c0       	push   $0xc003267a
c002e4d3:	68 30 00 03 c0       	push   $0xc0030030
c002e4d8:	68 ba 00 00 00       	push   $0xba
c002e4dd:	68 53 26 03 c0       	push   $0xc0032653
c002e4e2:	e8 40 a1 ff ff       	call   c0028627 <debug_panic>
    PANIC ("couldn't open scratch device");
c002e4e7:	68 c9 26 03 c0       	push   $0xc00326c9
c002e4ec:	68 30 00 03 c0       	push   $0xc0030030
c002e4f1:	68 c0 00 00 00       	push   $0xc0
c002e4f6:	68 53 26 03 c0       	push   $0xc0032653
c002e4fb:	e8 27 a1 ff ff       	call   c0028627 <debug_panic>
    PANIC ("%s: name too long for ustar format", file_name);
c002e500:	83 ec 0c             	sub    $0xc,%esp
c002e503:	ff 74 24 18          	pushl  0x18(%esp)
c002e507:	68 5c 28 03 c0       	push   $0xc003285c
c002e50c:	68 30 00 03 c0       	push   $0xc0030030
c002e511:	68 c4 00 00 00       	push   $0xc4
c002e516:	68 53 26 03 c0       	push   $0xc0032653
c002e51b:	e8 07 a1 ff ff       	call   c0028627 <debug_panic>
      if (sector >= block_size (dst))
c002e520:	83 ec 0c             	sub    $0xc,%esp
c002e523:	ff 74 24 10          	pushl  0x10(%esp)
c002e527:	e8 f6 67 ff ff       	call   c0024d22 <block_size>
c002e52c:	83 c4 10             	add    $0x10,%esp
c002e52f:	3b 05 e0 d2 03 c0    	cmp    0xc003d2e0,%eax
c002e535:	76 60                	jbe    c002e597 <fsutil_append+0x1f3>
      if (file_read (src, buffer, chunk_size) != chunk_size)
c002e537:	83 ec 04             	sub    $0x4,%esp
c002e53a:	53                   	push   %ebx
c002e53b:	55                   	push   %ebp
c002e53c:	ff 74 24 14          	pushl  0x14(%esp)
c002e540:	e8 bb e3 ff ff       	call   c002c900 <file_read>
c002e545:	83 c4 10             	add    $0x10,%esp
c002e548:	39 c3                	cmp    %eax,%ebx
c002e54a:	75 6b                	jne    c002e5b7 <fsutil_append+0x213>
      memset (buffer + chunk_size, 0, BLOCK_SECTOR_SIZE - chunk_size);
c002e54c:	b9 00 02 00 00       	mov    $0x200,%ecx
c002e551:	29 d9                	sub    %ebx,%ecx
c002e553:	8d 54 1d 00          	lea    0x0(%ebp,%ebx,1),%edx
c002e557:	89 d7                	mov    %edx,%edi
c002e559:	b0 00                	mov    $0x0,%al
c002e55b:	f3 aa                	rep stos %al,%es:(%edi)
      block_write (dst, sector++, buffer);
c002e55d:	a1 e0 d2 03 c0       	mov    0xc003d2e0,%eax
c002e562:	8d 50 01             	lea    0x1(%eax),%edx
c002e565:	89 15 e0 d2 03 c0    	mov    %edx,0xc003d2e0
c002e56b:	83 ec 04             	sub    $0x4,%esp
c002e56e:	55                   	push   %ebp
c002e56f:	50                   	push   %eax
c002e570:	ff 74 24 10          	pushl  0x10(%esp)
c002e574:	e8 4d 67 ff ff       	call   c0024cc6 <block_write>
      size -= chunk_size;
c002e579:	29 de                	sub    %ebx,%esi
  while (size > 0) 
c002e57b:	83 c4 10             	add    $0x10,%esp
c002e57e:	85 f6                	test   %esi,%esi
c002e580:	0f 8e d7 fe ff ff    	jle    c002e45d <fsutil_append+0xb9>
      int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
c002e586:	89 f3                	mov    %esi,%ebx
c002e588:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c002e58e:	7e 90                	jle    c002e520 <fsutil_append+0x17c>
c002e590:	bb 00 02 00 00       	mov    $0x200,%ebx
c002e595:	eb 89                	jmp    c002e520 <fsutil_append+0x17c>
        PANIC ("%s: out of space on scratch device", file_name);
c002e597:	83 ec 0c             	sub    $0xc,%esp
c002e59a:	ff 74 24 18          	pushl  0x18(%esp)
c002e59e:	68 80 28 03 c0       	push   $0xc0032880
c002e5a3:	68 30 00 03 c0       	push   $0xc0030030
c002e5a8:	68 cc 00 00 00       	push   $0xcc
c002e5ad:	68 53 26 03 c0       	push   $0xc0032653
c002e5b2:	e8 70 a0 ff ff       	call   c0028627 <debug_panic>
        PANIC ("%s: read failed with %"PROTd" bytes unread", file_name, size);
c002e5b7:	83 ec 08             	sub    $0x8,%esp
c002e5ba:	56                   	push   %esi
c002e5bb:	ff 74 24 18          	pushl  0x18(%esp)
c002e5bf:	68 a4 28 03 c0       	push   $0xc00328a4
c002e5c4:	68 30 00 03 c0       	push   $0xc0030030
c002e5c9:	68 ce 00 00 00       	push   $0xce
c002e5ce:	68 53 26 03 c0       	push   $0xc0032653
c002e5d3:	e8 4f a0 ff ff       	call   c0028627 <debug_panic>

c002e5d8 <cache_get_free>:
                                cache.sector_index = sector; } while (false)
static int cache_get_free (void);

static int
cache_get_free () { // only called by locked func
  current_cache = next_cache(current_cache);
c002e5d8:	a1 00 d3 03 c0       	mov    0xc003d300,%eax
c002e5dd:	40                   	inc    %eax
c002e5de:	25 3f 00 00 80       	and    $0x8000003f,%eax
c002e5e3:	78 2b                	js     c002e610 <cache_get_free+0x38>
c002e5e5:	89 c2                	mov    %eax,%edx
c002e5e7:	a3 00 d3 03 c0       	mov    %eax,0xc003d300
  while (caches[current_cache].used && caches[current_cache].recent) {
c002e5ec:	89 c1                	mov    %eax,%ecx
c002e5ee:	c1 e1 06             	shl    $0x6,%ecx
c002e5f1:	01 c1                	add    %eax,%ecx
c002e5f3:	80 3c cd 64 d5 03 c0 	cmpb   $0x0,-0x3ffc2a9c(,%ecx,8)
c002e5fa:	00 
c002e5fb:	74 63                	je     c002e660 <cache_get_free+0x88>
c002e5fd:	89 c1                	mov    %eax,%ecx
c002e5ff:	c1 e1 06             	shl    $0x6,%ecx
c002e602:	01 c8                	add    %ecx,%eax
c002e604:	80 3c c5 65 d5 03 c0 	cmpb   $0x0,-0x3ffc2a9b(,%eax,8)
c002e60b:	00 
c002e60c:	75 2d                	jne    c002e63b <cache_get_free+0x63>
c002e60e:	eb 5c                	jmp    c002e66c <cache_get_free+0x94>
  current_cache = next_cache(current_cache);
c002e610:	48                   	dec    %eax
c002e611:	83 c8 c0             	or     $0xffffffc0,%eax
c002e614:	40                   	inc    %eax
c002e615:	eb ce                	jmp    c002e5e5 <cache_get_free+0xd>
    caches[current_cache].recent = false;
    current_cache = next_cache(current_cache);
c002e617:	89 c2                	mov    %eax,%edx
  while (caches[current_cache].used && caches[current_cache].recent) {
c002e619:	89 c1                	mov    %eax,%ecx
c002e61b:	c1 e1 06             	shl    $0x6,%ecx
c002e61e:	01 c1                	add    %eax,%ecx
c002e620:	80 3c cd 64 d5 03 c0 	cmpb   $0x0,-0x3ffc2a9c(,%ecx,8)
c002e627:	00 
c002e628:	74 31                	je     c002e65b <cache_get_free+0x83>
c002e62a:	89 c1                	mov    %eax,%ecx
c002e62c:	c1 e1 06             	shl    $0x6,%ecx
c002e62f:	01 c8                	add    %ecx,%eax
c002e631:	80 3c c5 65 d5 03 c0 	cmpb   $0x0,-0x3ffc2a9b(,%eax,8)
c002e638:	00 
c002e639:	74 2b                	je     c002e666 <cache_get_free+0x8e>
    caches[current_cache].recent = false;
c002e63b:	89 d0                	mov    %edx,%eax
c002e63d:	c1 e0 06             	shl    $0x6,%eax
c002e640:	01 d0                	add    %edx,%eax
c002e642:	c6 04 c5 65 d5 03 c0 	movb   $0x0,-0x3ffc2a9b(,%eax,8)
c002e649:	00 
    current_cache = next_cache(current_cache);
c002e64a:	8d 42 01             	lea    0x1(%edx),%eax
c002e64d:	25 3f 00 00 80       	and    $0x8000003f,%eax
c002e652:	79 c3                	jns    c002e617 <cache_get_free+0x3f>
c002e654:	48                   	dec    %eax
c002e655:	83 c8 c0             	or     $0xffffffc0,%eax
c002e658:	40                   	inc    %eax
c002e659:	eb bc                	jmp    c002e617 <cache_get_free+0x3f>
c002e65b:	a3 00 d3 03 c0       	mov    %eax,0xc003d300
      caches[current_cache].dirty = false;
    }
    caches[current_cache].used = false;
    used_cnt --;
  }
  return current_cache;
c002e660:	a1 00 d3 03 c0       	mov    0xc003d300,%eax
}
c002e665:	c3                   	ret    
c002e666:	89 15 00 d3 03 c0    	mov    %edx,0xc003d300
cache_get_free () { // only called by locked func
c002e66c:	83 ec 0c             	sub    $0xc,%esp
    if (caches[current_cache].dirty) {
c002e66f:	89 d0                	mov    %edx,%eax
c002e671:	c1 e0 06             	shl    $0x6,%eax
c002e674:	01 d0                	add    %edx,%eax
c002e676:	80 3c c5 66 d5 03 c0 	cmpb   $0x0,-0x3ffc2a9a(,%eax,8)
c002e67d:	00 
c002e67e:	75 24                	jne    c002e6a4 <cache_get_free+0xcc>
    caches[current_cache].used = false;
c002e680:	8b 15 00 d3 03 c0    	mov    0xc003d300,%edx
c002e686:	89 d0                	mov    %edx,%eax
c002e688:	c1 e0 06             	shl    $0x6,%eax
c002e68b:	01 d0                	add    %edx,%eax
c002e68d:	c6 04 c5 64 d5 03 c0 	movb   $0x0,-0x3ffc2a9c(,%eax,8)
c002e694:	00 
    used_cnt --;
c002e695:	ff 0d 04 d3 03 c0    	decl   0xc003d304
  return current_cache;
c002e69b:	a1 00 d3 03 c0       	mov    0xc003d300,%eax
}
c002e6a0:	83 c4 0c             	add    $0xc,%esp
c002e6a3:	c3                   	ret    
      write_fs(caches[current_cache]);
c002e6a4:	83 ec 04             	sub    $0x4,%esp
c002e6a7:	89 d0                	mov    %edx,%eax
c002e6a9:	c1 e0 06             	shl    $0x6,%eax
c002e6ac:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002e6af:	8d 0c cd 60 d3 03 c0 	lea    -0x3ffc2ca0(,%ecx,8),%ecx
c002e6b6:	51                   	push   %ecx
c002e6b7:	01 d0                	add    %edx,%eax
c002e6b9:	ff 34 c5 60 d5 03 c0 	pushl  -0x3ffc2aa0(,%eax,8)
c002e6c0:	ff 35 98 55 04 c0    	pushl  0xc0045598
c002e6c6:	e8 fb 65 ff ff       	call   c0024cc6 <block_write>
      caches[current_cache].dirty = false;
c002e6cb:	8b 15 00 d3 03 c0    	mov    0xc003d300,%edx
c002e6d1:	89 d0                	mov    %edx,%eax
c002e6d3:	c1 e0 06             	shl    $0x6,%eax
c002e6d6:	01 d0                	add    %edx,%eax
c002e6d8:	c6 04 c5 66 d5 03 c0 	movb   $0x0,-0x3ffc2a9a(,%eax,8)
c002e6df:	00 
c002e6e0:	83 c4 10             	add    $0x10,%esp
c002e6e3:	eb 9b                	jmp    c002e680 <cache_get_free+0xa8>

c002e6e5 <cache_init>:

void
cache_init () {
c002e6e5:	57                   	push   %edi
c002e6e6:	83 ec 14             	sub    $0x14,%esp
  lock_init (&cache_lock);
c002e6e9:	68 20 d3 03 c0       	push   $0xc003d320
c002e6ee:	e8 16 46 ff ff       	call   c0022d09 <lock_init>
  used_cnt = 0;
c002e6f3:	c7 05 04 d3 03 c0 00 	movl   $0x0,0xc003d304
c002e6fa:	00 00 00 
  current_cache = -1;
c002e6fd:	c7 05 00 d3 03 c0 ff 	movl   $0xffffffff,0xc003d300
c002e704:	ff ff ff 
  memset(caches, 0, sizeof caches);
c002e707:	ba 60 d3 03 c0       	mov    $0xc003d360,%edx
c002e70c:	b9 80 20 00 00       	mov    $0x2080,%ecx
c002e711:	b8 00 00 00 00       	mov    $0x0,%eax
c002e716:	89 d7                	mov    %edx,%edi
c002e718:	f3 ab                	rep stos %eax,%es:(%edi)
}
c002e71a:	83 c4 18             	add    $0x18,%esp
c002e71d:	5f                   	pop    %edi
c002e71e:	c3                   	ret    

c002e71f <cache_read>:

void
cache_read (block_sector_t sector, void *buffer) {
c002e71f:	57                   	push   %edi
c002e720:	56                   	push   %esi
c002e721:	53                   	push   %ebx
c002e722:	8b 74 24 10          	mov    0x10(%esp),%esi
  lock_acquire (&cache_lock);
c002e726:	83 ec 0c             	sub    $0xc,%esp
c002e729:	68 20 d3 03 c0       	push   $0xc003d320
c002e72e:	e8 4a 47 ff ff       	call   c0022e7d <lock_acquire>
c002e733:	b8 60 d5 03 c0       	mov    $0xc003d560,%eax
c002e738:	83 c4 10             	add    $0x10,%esp
  int i;
  for (i = 0; i < CACHE_SIZE; ++i)
c002e73b:	bb 00 00 00 00       	mov    $0x0,%ebx
c002e740:	eb 0b                	jmp    c002e74d <cache_read+0x2e>
c002e742:	43                   	inc    %ebx
c002e743:	05 08 02 00 00       	add    $0x208,%eax
c002e748:	83 fb 40             	cmp    $0x40,%ebx
c002e74b:	74 45                	je     c002e792 <cache_read+0x73>
    if (caches[i].used && caches[i].sector_index == sector)
c002e74d:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
c002e751:	74 ef                	je     c002e742 <cache_read+0x23>
c002e753:	39 30                	cmp    %esi,(%eax)
c002e755:	75 eb                	jne    c002e742 <cache_read+0x23>
      break;
  if (i == CACHE_SIZE) {
c002e757:	83 fb 40             	cmp    $0x40,%ebx
c002e75a:	74 36                	je     c002e792 <cache_read+0x73>
    i = cache_get_free ();
    occupy_cache(caches[i], sector);
    read_fs(caches[i]);
  }
  caches[i].recent = true;
c002e75c:	89 d8                	mov    %ebx,%eax
c002e75e:	c1 e0 06             	shl    $0x6,%eax
c002e761:	8d 14 18             	lea    (%eax,%ebx,1),%edx
c002e764:	c6 04 d5 65 d5 03 c0 	movb   $0x1,-0x3ffc2a9b(,%edx,8)
c002e76b:	01 
  memcpy (buffer, caches[i].buffer, BLOCK_SECTOR_SIZE);
c002e76c:	8d 34 d5 60 d3 03 c0 	lea    -0x3ffc2ca0(,%edx,8),%esi
c002e773:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e778:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002e77c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lock_release (&cache_lock);
c002e77e:	83 ec 0c             	sub    $0xc,%esp
c002e781:	68 20 d3 03 c0       	push   $0xc003d320
c002e786:	e8 8f 48 ff ff       	call   c002301a <lock_release>
}
c002e78b:	83 c4 10             	add    $0x10,%esp
c002e78e:	5b                   	pop    %ebx
c002e78f:	5e                   	pop    %esi
c002e790:	5f                   	pop    %edi
c002e791:	c3                   	ret    
    i = cache_get_free ();
c002e792:	e8 41 fe ff ff       	call   c002e5d8 <cache_get_free>
c002e797:	89 c3                	mov    %eax,%ebx
    occupy_cache(caches[i], sector);
c002e799:	ff 05 04 d3 03 c0    	incl   0xc003d304
c002e79f:	c1 e0 06             	shl    $0x6,%eax
c002e7a2:	01 d8                	add    %ebx,%eax
c002e7a4:	8d 04 c5 60 d3 03 c0 	lea    -0x3ffc2ca0(,%eax,8),%eax
c002e7ab:	c6 80 04 02 00 00 01 	movb   $0x1,0x204(%eax)
c002e7b2:	89 b0 00 02 00 00    	mov    %esi,0x200(%eax)
    read_fs(caches[i]);
c002e7b8:	83 ec 04             	sub    $0x4,%esp
c002e7bb:	50                   	push   %eax
c002e7bc:	56                   	push   %esi
c002e7bd:	ff 35 98 55 04 c0    	pushl  0xc0045598
c002e7c3:	e8 ca 64 ff ff       	call   c0024c92 <block_read>
c002e7c8:	83 c4 10             	add    $0x10,%esp
c002e7cb:	eb 8f                	jmp    c002e75c <cache_read+0x3d>

c002e7cd <cache_write>:

void
cache_write (block_sector_t sector, const void *buffer) {
c002e7cd:	57                   	push   %edi
c002e7ce:	56                   	push   %esi
c002e7cf:	53                   	push   %ebx
c002e7d0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002e7d4:	8b 74 24 14          	mov    0x14(%esp),%esi
  lock_acquire (&cache_lock);
c002e7d8:	83 ec 0c             	sub    $0xc,%esp
c002e7db:	68 20 d3 03 c0       	push   $0xc003d320
c002e7e0:	e8 98 46 ff ff       	call   c0022e7d <lock_acquire>
c002e7e5:	ba 60 d5 03 c0       	mov    $0xc003d560,%edx
c002e7ea:	83 c4 10             	add    $0x10,%esp
  int i;
  for (i = 0; i < CACHE_SIZE; ++i)
c002e7ed:	b8 00 00 00 00       	mov    $0x0,%eax
c002e7f2:	eb 0c                	jmp    c002e800 <cache_write+0x33>
c002e7f4:	40                   	inc    %eax
c002e7f5:	81 c2 08 02 00 00    	add    $0x208,%edx
c002e7fb:	83 f8 40             	cmp    $0x40,%eax
c002e7fe:	74 4b                	je     c002e84b <cache_write+0x7e>
    if (caches[i].used && caches[i].sector_index == sector) 
c002e800:	80 7a 04 00          	cmpb   $0x0,0x4(%edx)
c002e804:	74 ee                	je     c002e7f4 <cache_write+0x27>
c002e806:	39 1a                	cmp    %ebx,(%edx)
c002e808:	75 ea                	jne    c002e7f4 <cache_write+0x27>
      break;
  if (i == CACHE_SIZE) {
c002e80a:	83 f8 40             	cmp    $0x40,%eax
c002e80d:	74 3c                	je     c002e84b <cache_write+0x7e>
    i = cache_get_free ();
    occupy_cache(caches[i], sector);
  }
  caches[i].dirty = true;
c002e80f:	89 c2                	mov    %eax,%edx
c002e811:	c1 e2 06             	shl    $0x6,%edx
c002e814:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c002e817:	8d 0c cd 60 d3 03 c0 	lea    -0x3ffc2ca0(,%ecx,8),%ecx
c002e81e:	c6 81 06 02 00 00 01 	movb   $0x1,0x206(%ecx)
  caches[i].recent = true;
c002e825:	c6 81 05 02 00 00 01 	movb   $0x1,0x205(%ecx)
  memcpy (caches[i].buffer, buffer, BLOCK_SECTOR_SIZE);
c002e82c:	89 c8                	mov    %ecx,%eax
c002e82e:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e833:	89 c7                	mov    %eax,%edi
c002e835:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lock_release (&cache_lock);
c002e837:	83 ec 0c             	sub    $0xc,%esp
c002e83a:	68 20 d3 03 c0       	push   $0xc003d320
c002e83f:	e8 d6 47 ff ff       	call   c002301a <lock_release>
}
c002e844:	83 c4 10             	add    $0x10,%esp
c002e847:	5b                   	pop    %ebx
c002e848:	5e                   	pop    %esi
c002e849:	5f                   	pop    %edi
c002e84a:	c3                   	ret    
    i = cache_get_free ();
c002e84b:	e8 88 fd ff ff       	call   c002e5d8 <cache_get_free>
    occupy_cache(caches[i], sector);
c002e850:	ff 05 04 d3 03 c0    	incl   0xc003d304
c002e856:	89 c2                	mov    %eax,%edx
c002e858:	c1 e2 06             	shl    $0x6,%edx
c002e85b:	01 c2                	add    %eax,%edx
c002e85d:	8d 14 d5 60 d3 03 c0 	lea    -0x3ffc2ca0(,%edx,8),%edx
c002e864:	c6 82 04 02 00 00 01 	movb   $0x1,0x204(%edx)
c002e86b:	89 9a 00 02 00 00    	mov    %ebx,0x200(%edx)
c002e871:	eb 9c                	jmp    c002e80f <cache_write+0x42>

c002e873 <cache_done>:

void
cache_done () {
c002e873:	56                   	push   %esi
c002e874:	53                   	push   %ebx
c002e875:	83 ec 04             	sub    $0x4,%esp
c002e878:	bb 60 d3 03 c0       	mov    $0xc003d360,%ebx
c002e87d:	be 60 55 04 c0       	mov    $0xc0045560,%esi
c002e882:	eb 0a                	jmp    c002e88e <cache_done+0x1b>
c002e884:	81 c3 08 02 00 00    	add    $0x208,%ebx
  int i;
  for (i = 0; i < CACHE_SIZE; ++i)
c002e88a:	39 f3                	cmp    %esi,%ebx
c002e88c:	74 2c                	je     c002e8ba <cache_done+0x47>
    if (caches[i].used && caches[i].dirty)
c002e88e:	80 bb 04 02 00 00 00 	cmpb   $0x0,0x204(%ebx)
c002e895:	74 ed                	je     c002e884 <cache_done+0x11>
c002e897:	80 bb 06 02 00 00 00 	cmpb   $0x0,0x206(%ebx)
c002e89e:	74 e4                	je     c002e884 <cache_done+0x11>
      write_fs (caches[i]);
c002e8a0:	83 ec 04             	sub    $0x4,%esp
c002e8a3:	53                   	push   %ebx
c002e8a4:	ff b3 00 02 00 00    	pushl  0x200(%ebx)
c002e8aa:	ff 35 98 55 04 c0    	pushl  0xc0045598
c002e8b0:	e8 11 64 ff ff       	call   c0024cc6 <block_write>
c002e8b5:	83 c4 10             	add    $0x10,%esp
c002e8b8:	eb ca                	jmp    c002e884 <cache_done+0x11>
c002e8ba:	83 c4 04             	add    $0x4,%esp
c002e8bd:	5b                   	pop    %ebx
c002e8be:	5e                   	pop    %esi
c002e8bf:	c3                   	ret    
