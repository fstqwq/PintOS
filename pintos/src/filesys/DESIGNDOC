			+--------------------+
			|        MS 110      |
			| PROJECT 4: FILESYS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

Zonghan Yang    <fstqwq@sjtu.edu.cn>
Yuheng Zhang    <yveh1999@sjtu.edu.cn>
Yunqing Li      <lyq_cs_sjtu@sjtu.edu.cn>
Yi Wang         <refraction334@sjtu.edu.cn>


---- 以下为中文 -----

1. 可变长文件设计

文件原有的方式是记录头指针，然后查询连续的 sector。这么做无法有效支持边长，因此需要一个 table 结构。

考虑到要支持 8MB 的文件，那么一个很自然的想法是做一个 128 叉树，一个 sector 里存 128 个指针，而恰好 128 * 128 * 512 = 8MB，因此就设计了两级的 table。当然，如果不严格要求 8MB，而是略小一点（7.75M）的话，第一级是可以放在 inode 里的——现在的 inode 非常浪费，512b 的空间只用了 13b。这应该也是符合原有要求的，但是没时间改了。如果你是参考我们设计的打算实现 filesys 的同学，可以这么操作一下，听起来很酷。

在写入 EOF 之后的位置时，立即分配新的 sector，直到文件足够长为止。这一部分的操作参考了陈宇轩老师、杨孟天老师的代码。

每次对文件信息进行修改之后立刻写入 inode，table 和文件内容的 sector。这么做不会很慢，原因是我们支持了 cache。

2. 子目录

原有的 filesys 中有 dir 相关基础函数。dir 被看做是一种特殊的文件，内容由提供的函数来管理以支持插入删除；但是没有管理目录之间的关系的函数。我们的工作主要就是给 dir 的支持写了一些函数。

首先修改了 inode，往里面加入了一个文件夹 flag，保证不会对文件夹进行错误操作。

然后，给每个文件夹默认加入了 . 和 .. 两个 entry，首先是指向自己（/ 指向自己）；如果不是根目录，那么建立 .. 的关系。

随后，为了能让 readdir 一个刚打开的目录直接支持是否查询空目录（以方便删除），将打开文件夹的默认 pos 设为 2，即跳过 . 和 ..。

其他都挺 trivial 的。

3. Cache

简单的时钟算法实现。按照 pintos 的要求，仅使用了 64 个 slot。


4. 调试建议

1) 如果你遇到了无限重启并且没有 execute 的情况，多半是 filesys 没有启动成功导致的 page fault，比如建立根目录挂了什么的。找到最后一条输出的位置，后面疯狂 print 来定位错误就好了。一般是 inode 或者 directory 挂了。
2) 记得消掉所有 warning，或者知道每个 warning 是什么意思。调试有一半的时间找出的错误全是连类型都传错导致的 page fault。
3) 建议在最后发现奇怪的无法解释的问题时，检查下 threads 的同步性问题。我们的 thread_check_switch 之前没上锁，导致在判断完 ready_list 非空后程序被切走了，然后 list 访问就挂了。