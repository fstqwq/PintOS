
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020058 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020058:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002005d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002005f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020060:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020062:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020064:	66 05 00 04          	add    $0x400,%ax
c0020068:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002006a:	66 3d 00 00          	cmp    $0x0,%ax
c002006e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020070:	76 06                	jbe    c0020078 <start+0x20>
	mov $0x10000, %eax
c0020072:	66 b8 00 00          	mov    $0x0,%ax
c0020076:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020078:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002007c:	67 66 a3 5e 01       	addr16 mov %ax,0x15e
c0020081:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c0020083:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020085:	a8 02                	test   $0x2,%al
	jnz 1b
c0020087:	75 fa                	jne    c0020083 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c0020089:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c002008b:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c002008d:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c002008f:	a8 02                	test   $0x2,%al
	jnz 1b
c0020091:	75 fa                	jne    c002008d <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c0020093:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c0020095:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c0020097:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020099:	a8 02                	test   $0x2,%al
	jnz 1b
c002009b:	75 fa                	jne    c0020097 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c002009d:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200a2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200a5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200a8:	66 b9 00 04          	mov    $0x400,%cx
c00200ac:	00 00                	add    %al,(%eax)
	rep stosl
c00200ae:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200b1:	66 b8 07 00          	mov    $0x7,%ax
c00200b5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200b7:	66 b9 11 00          	mov    $0x11,%cx
c00200bb:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200bd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200c0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200c7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200c8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200cb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200d2:	00 e2                	add    %ah,%dl
	loop 1b
c00200d4:	eb b8                	jmp    c002008e <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200d6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200d8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200da:	66 b8 07 00          	mov    $0x7,%ax
c00200de:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c00200e0:	66 b9 00 40          	mov    $0x4000,%cx
c00200e4:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200e6:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e9:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c00200f0:	66 
	addw $4, %di
	addl $0x1000, %eax
c00200f1:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c00200f6:	e2 f1                	loop   c00200e9 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c00200f8:	66 b8 00 f0          	mov    $0xf000,%ax
c00200fc:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c00200fe:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020101:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020102:	67 66 0f 01 15       	lgdtw  (%di)
c0020107:	58                   	pop    %eax
c0020108:	01 00                	add    %eax,(%eax)
c002010a:	00 0f                	add    %cl,(%edi)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002010c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002010e:	66 0d 05 00          	or     $0x5,%ax
c0020112:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020118:	ea 1f 01 02 c0 08 00 	ljmp   $0x8,$0xc002011f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002011f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020123:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020125:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020127:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020129:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002012b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002012d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020133:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020138:	e8 03 01 00 00       	call   c0020240 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002013d:	eb fe                	jmp    c002013d <start+0xe5>
	...

c0020140 <gdt>:
	...
c0020148:	ff                   	(bad)  
c0020149:	ff 00                	incl   (%eax)
c002014b:	00 00                	add    %al,(%eax)
c002014d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020154:	00                   	.byte 0x0
c0020155:	92                   	xchg   %eax,%edx
c0020156:	cf                   	iret   
	...

c0020158 <gdtdesc>:
c0020158:	17                   	pop    %ss
c0020159:	00 40 01             	add    %al,0x1(%eax)
c002015c:	02 c0                	add    %al,%al

c002015e <init_ram_pages>:
c002015e:	00 00                	add    %al,(%eax)
	...

c0020162 <locate_block_device>:
   block device with the given NAME, if NAME is non-null,
   otherwise the first block device in probe order of type
   ROLE. */
static void
locate_block_device (enum block_type role, const char *name)
{
c0020162:	57                   	push   %edi
c0020163:	56                   	push   %esi
c0020164:	53                   	push   %ebx
c0020165:	89 c6                	mov    %eax,%esi
  struct block *block = NULL;

  if (name != NULL)
c0020167:	85 d2                	test   %edx,%edx
c0020169:	74 64                	je     c00201cf <locate_block_device+0x6d>
c002016b:	89 d7                	mov    %edx,%edi
    {
      block = block_get_by_name (name);
c002016d:	83 ec 0c             	sub    $0xc,%esp
c0020170:	52                   	push   %edx
c0020171:	e8 13 4b 00 00       	call   c0024c89 <block_get_by_name>
c0020176:	89 c3                	mov    %eax,%ebx
      if (block == NULL)
c0020178:	83 c4 10             	add    $0x10,%esp
c002017b:	85 c0                	test   %eax,%eax
c002017d:	74 33                	je     c00201b2 <locate_block_device+0x50>
          break;
    }

  if (block != NULL)
    {
      printf ("%s: using %s\n", block_type_name (role), block_name (block));
c002017f:	83 ec 0c             	sub    $0xc,%esp
c0020182:	53                   	push   %ebx
c0020183:	e8 f8 4b 00 00       	call   c0024d80 <block_name>
c0020188:	89 c7                	mov    %eax,%edi
c002018a:	89 34 24             	mov    %esi,(%esp)
c002018d:	e8 f3 49 00 00       	call   c0024b85 <block_type_name>
c0020192:	83 c4 0c             	add    $0xc,%esp
c0020195:	57                   	push   %edi
c0020196:	50                   	push   %eax
c0020197:	68 2d 0c 03 c0       	push   $0xc0030c2d
c002019c:	e8 2e 6a 00 00       	call   c0026bcf <printf>
      block_set_role (role, block);
c00201a1:	83 c4 08             	add    $0x8,%esp
c00201a4:	53                   	push   %ebx
c00201a5:	56                   	push   %esi
c00201a6:	e8 44 4a 00 00       	call   c0024bef <block_set_role>
c00201ab:	83 c4 10             	add    $0x10,%esp
    }
}
c00201ae:	5b                   	pop    %ebx
c00201af:	5e                   	pop    %esi
c00201b0:	5f                   	pop    %edi
c00201b1:	c3                   	ret    
        PANIC ("No such block device \"%s\"", name);
c00201b2:	83 ec 0c             	sub    $0xc,%esp
c00201b5:	57                   	push   %edi
c00201b6:	68 fe 0b 03 c0       	push   $0xc0030bfe
c00201bb:	68 b4 f4 02 c0       	push   $0xc002f4b4
c00201c0:	68 c9 01 00 00       	push   $0x1c9
c00201c5:	68 18 0c 03 c0       	push   $0xc0030c18
c00201ca:	e8 ae 84 00 00       	call   c002867d <debug_panic>
      for (block = block_first (); block != NULL; block = block_next (block))
c00201cf:	e8 54 4a 00 00       	call   c0024c28 <block_first>
c00201d4:	89 c3                	mov    %eax,%ebx
c00201d6:	85 c0                	test   %eax,%eax
c00201d8:	74 d4                	je     c00201ae <locate_block_device+0x4c>
        if (block_type (block) == role)
c00201da:	83 ec 0c             	sub    $0xc,%esp
c00201dd:	53                   	push   %ebx
c00201de:	e8 a5 4b 00 00       	call   c0024d88 <block_type>
c00201e3:	83 c4 10             	add    $0x10,%esp
c00201e6:	39 f0                	cmp    %esi,%eax
c00201e8:	74 14                	je     c00201fe <locate_block_device+0x9c>
      for (block = block_first (); block != NULL; block = block_next (block))
c00201ea:	83 ec 0c             	sub    $0xc,%esp
c00201ed:	53                   	push   %ebx
c00201ee:	e8 66 4a 00 00       	call   c0024c59 <block_next>
c00201f3:	89 c3                	mov    %eax,%ebx
c00201f5:	83 c4 10             	add    $0x10,%esp
c00201f8:	85 c0                	test   %eax,%eax
c00201fa:	75 de                	jne    c00201da <locate_block_device+0x78>
c00201fc:	eb b0                	jmp    c00201ae <locate_block_device+0x4c>
  if (block != NULL)
c00201fe:	85 db                	test   %ebx,%ebx
c0020200:	74 ac                	je     c00201ae <locate_block_device+0x4c>
c0020202:	e9 78 ff ff ff       	jmp    c002017f <locate_block_device+0x1d>

c0020207 <run_task>:
{
c0020207:	53                   	push   %ebx
c0020208:	83 ec 10             	sub    $0x10,%esp
  const char *task = argv[1];
c002020b:	8b 44 24 18          	mov    0x18(%esp),%eax
c002020f:	8b 58 04             	mov    0x4(%eax),%ebx
  printf ("Executing '%s':\n", task);
c0020212:	53                   	push   %ebx
c0020213:	68 3b 0c 03 c0       	push   $0xc0030c3b
c0020218:	e8 b2 69 00 00       	call   c0026bcf <printf>
  process_wait (process_execute (task));
c002021d:	89 1c 24             	mov    %ebx,(%esp)
c0020220:	e8 ca 9f 00 00       	call   c002a1ef <process_execute>
c0020225:	89 04 24             	mov    %eax,(%esp)
c0020228:	e8 8b a0 00 00       	call   c002a2b8 <process_wait>
  printf ("Execution of '%s' complete.\n", task);
c002022d:	83 c4 08             	add    $0x8,%esp
c0020230:	53                   	push   %ebx
c0020231:	68 4c 0c 03 c0       	push   $0xc0030c4c
c0020236:	e8 94 69 00 00       	call   c0026bcf <printf>
}
c002023b:	83 c4 18             	add    $0x18,%esp
c002023e:	5b                   	pop    %ebx
c002023f:	c3                   	ret    

c0020240 <pintos_init>:
{
c0020240:	55                   	push   %ebp
c0020241:	57                   	push   %edi
c0020242:	56                   	push   %esi
c0020243:	53                   	push   %ebx
c0020244:	83 ec 2c             	sub    $0x2c,%esp
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c0020247:	b9 d4 6c 04 c0       	mov    $0xc0046cd4,%ecx
c002024c:	81 e9 94 c6 03 c0    	sub    $0xc003c694,%ecx
c0020252:	ba 94 c6 03 c0       	mov    $0xc003c694,%edx
c0020257:	b0 00                	mov    $0x0,%al
c0020259:	89 d7                	mov    %edx,%edi
c002025b:	f3 aa                	rep stos %al,%es:(%edi)
  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c002025d:	8b 3d 3a 7d 00 c0    	mov    0xc0007d3a,%edi
  for (i = 0; i < argc; i++) 
c0020263:	85 ff                	test   %edi,%edi
c0020265:	0f 8e a3 06 00 00    	jle    c002090e <pintos_init+0x6ce>
c002026b:	be 00 00 00 00       	mov    $0x0,%esi
c0020270:	bb 3e 7d 00 c0       	mov    $0xc0007d3e,%ebx
      p += strnlen (p, end - p) + 1;
c0020275:	bd be 7d 00 c0       	mov    $0xc0007dbe,%ebp
c002027a:	eb 08                	jmp    c0020284 <pintos_init+0x44>
      if (p >= end)
c002027c:	81 fb bd 7d 00 c0    	cmp    $0xc0007dbd,%ebx
c0020282:	77 43                	ja     c00202c7 <pintos_init+0x87>
      argv[i] = p;
c0020284:	89 1c b5 a0 c6 03 c0 	mov    %ebx,-0x3ffc3960(,%esi,4)
      p += strnlen (p, end - p) + 1;
c002028b:	83 ec 08             	sub    $0x8,%esp
c002028e:	89 e8                	mov    %ebp,%eax
c0020290:	29 d8                	sub    %ebx,%eax
c0020292:	50                   	push   %eax
c0020293:	53                   	push   %ebx
c0020294:	e8 b3 7a 00 00       	call   c0027d4c <strnlen>
c0020299:	8d 5c 03 01          	lea    0x1(%ebx,%eax,1),%ebx
  for (i = 0; i < argc; i++) 
c002029d:	46                   	inc    %esi
c002029e:	83 c4 10             	add    $0x10,%esp
c00202a1:	39 f7                	cmp    %esi,%edi
c00202a3:	75 d7                	jne    c002027c <pintos_init+0x3c>
  argv[argc] = NULL;
c00202a5:	c7 04 b5 a0 c6 03 c0 	movl   $0x0,-0x3ffc3960(,%esi,4)
c00202ac:	00 00 00 00 
  printf ("Kernel command line:");
c00202b0:	83 ec 0c             	sub    $0xc,%esp
c00202b3:	68 43 0d 03 c0       	push   $0xc0030d43
c00202b8:	e8 12 69 00 00       	call   c0026bcf <printf>
c00202bd:	83 c4 10             	add    $0x10,%esp
c00202c0:	bb 00 00 00 00       	mov    $0x0,%ebx
c00202c5:	eb 33                	jmp    c00202fa <pintos_init+0xba>
        PANIC ("command line arguments overflow");
c00202c7:	68 74 0d 03 c0       	push   $0xc0030d74
c00202cc:	68 ec f4 02 c0       	push   $0xc002f4ec
c00202d1:	68 fa 00 00 00       	push   $0xfa
c00202d6:	68 18 0c 03 c0       	push   $0xc0030c18
c00202db:	e8 9d 83 00 00       	call   c002867d <debug_panic>
      printf (" %s", argv[i]);
c00202e0:	83 ec 08             	sub    $0x8,%esp
c00202e3:	56                   	push   %esi
c00202e4:	68 87 1d 03 c0       	push   $0xc0031d87
c00202e9:	e8 e1 68 00 00       	call   c0026bcf <printf>
c00202ee:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00202f1:	43                   	inc    %ebx
c00202f2:	39 df                	cmp    %ebx,%edi
c00202f4:	0f 84 2f 06 00 00    	je     c0020929 <pintos_init+0x6e9>
    if (strchr (argv[i], ' ') == NULL)
c00202fa:	8b 34 9d a0 c6 03 c0 	mov    -0x3ffc3960(,%ebx,4),%esi
c0020301:	83 ec 08             	sub    $0x8,%esp
c0020304:	6a 20                	push   $0x20
c0020306:	56                   	push   %esi
c0020307:	e8 89 77 00 00       	call   c0027a95 <strchr>
c002030c:	83 c4 10             	add    $0x10,%esp
c002030f:	85 c0                	test   %eax,%eax
c0020311:	74 cd                	je     c00202e0 <pintos_init+0xa0>
      printf (" '%s'", argv[i]);
c0020313:	83 ec 08             	sub    $0x8,%esp
c0020316:	56                   	push   %esi
c0020317:	68 69 0c 03 c0       	push   $0xc0030c69
c002031c:	e8 ae 68 00 00       	call   c0026bcf <printf>
c0020321:	83 c4 10             	add    $0x10,%esp
c0020324:	eb cb                	jmp    c00202f1 <pintos_init+0xb1>
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020326:	83 ec 0c             	sub    $0xc,%esp
c0020329:	68 94 0d 03 c0       	push   $0xc0030d94
c002032e:	e8 31 9e 00 00       	call   c002a164 <puts>
  shutdown_power_off ();
c0020333:	e8 4b 61 00 00       	call   c0026483 <shutdown_power_off>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c0020338:	83 ec 0c             	sub    $0xc,%esp
c002033b:	6a 01                	push   $0x1
c002033d:	e8 cb 60 00 00       	call   c002640d <shutdown_configure>
c0020342:	83 c4 10             	add    $0x10,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020345:	83 c5 04             	add    $0x4,%ebp
c0020348:	8b 45 00             	mov    0x0(%ebp),%eax
c002034b:	85 c0                	test   %eax,%eax
c002034d:	0f 84 d8 01 00 00    	je     c002052b <pintos_init+0x2eb>
c0020353:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020356:	0f 85 cf 01 00 00    	jne    c002052b <pintos_init+0x2eb>
      char *name = strtok_r (*argv, "=", &save_ptr);
c002035c:	83 ec 04             	sub    $0x4,%esp
c002035f:	53                   	push   %ebx
c0020360:	68 1a 1c 03 c0       	push   $0xc0031c1a
c0020365:	50                   	push   %eax
c0020366:	e8 32 78 00 00       	call   c0027b9d <strtok_r>
c002036b:	89 c6                	mov    %eax,%esi
c002036d:	89 44 24 10          	mov    %eax,0x10(%esp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020371:	83 c4 0c             	add    $0xc,%esp
c0020374:	53                   	push   %ebx
c0020375:	68 c8 2c 03 c0       	push   $0xc0032cc8
c002037a:	6a 00                	push   $0x0
c002037c:	e8 1c 78 00 00       	call   c0027b9d <strtok_r>
c0020381:	89 44 24 14          	mov    %eax,0x14(%esp)
      if (!strcmp (name, "-h"))
c0020385:	bf 6f 0c 03 c0       	mov    $0xc0030c6f,%edi
c002038a:	b9 03 00 00 00       	mov    $0x3,%ecx
c002038f:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020391:	0f 97 c2             	seta   %dl
c0020394:	0f 92 c0             	setb   %al
c0020397:	83 c4 10             	add    $0x10,%esp
c002039a:	38 c2                	cmp    %al,%dl
c002039c:	74 88                	je     c0020326 <pintos_init+0xe6>
      else if (!strcmp (name, "-q"))
c002039e:	bf 72 0c 03 c0       	mov    $0xc0030c72,%edi
c00203a3:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203a8:	8b 34 24             	mov    (%esp),%esi
c00203ab:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203ad:	0f 97 c2             	seta   %dl
c00203b0:	0f 92 c0             	setb   %al
c00203b3:	38 c2                	cmp    %al,%dl
c00203b5:	74 81                	je     c0020338 <pintos_init+0xf8>
      else if (!strcmp (name, "-r"))
c00203b7:	bf 75 0c 03 c0       	mov    $0xc0030c75,%edi
c00203bc:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203c1:	8b 34 24             	mov    (%esp),%esi
c00203c4:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203c6:	0f 97 c2             	seta   %dl
c00203c9:	0f 92 c0             	setb   %al
c00203cc:	38 c2                	cmp    %al,%dl
c00203ce:	74 25                	je     c00203f5 <pintos_init+0x1b5>
      else if (!strcmp (name, "-f"))
c00203d0:	bf 78 0c 03 c0       	mov    $0xc0030c78,%edi
c00203d5:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203da:	8b 34 24             	mov    (%esp),%esi
c00203dd:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203df:	0f 97 c2             	seta   %dl
c00203e2:	0f 92 c0             	setb   %al
c00203e5:	38 c2                	cmp    %al,%dl
c00203e7:	75 1e                	jne    c0020407 <pintos_init+0x1c7>
        format_filesys = true;
c00203e9:	c6 05 4c c8 03 c0 01 	movb   $0x1,0xc003c84c
c00203f0:	e9 50 ff ff ff       	jmp    c0020345 <pintos_init+0x105>
        shutdown_configure (SHUTDOWN_REBOOT);
c00203f5:	83 ec 0c             	sub    $0xc,%esp
c00203f8:	6a 02                	push   $0x2
c00203fa:	e8 0e 60 00 00       	call   c002640d <shutdown_configure>
c00203ff:	83 c4 10             	add    $0x10,%esp
c0020402:	e9 3e ff ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-filesys"))
c0020407:	bf 7b 0c 03 c0       	mov    $0xc0030c7b,%edi
c002040c:	b9 09 00 00 00       	mov    $0x9,%ecx
c0020411:	8b 34 24             	mov    (%esp),%esi
c0020414:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020416:	0f 97 c2             	seta   %dl
c0020419:	0f 92 c0             	setb   %al
c002041c:	38 c2                	cmp    %al,%dl
c002041e:	75 0e                	jne    c002042e <pintos_init+0x1ee>
        filesys_bdev_name = value;
c0020420:	8b 44 24 04          	mov    0x4(%esp),%eax
c0020424:	a3 48 c8 03 c0       	mov    %eax,0xc003c848
c0020429:	e9 17 ff ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-scratch"))
c002042e:	bf 84 0c 03 c0       	mov    $0xc0030c84,%edi
c0020433:	b9 09 00 00 00       	mov    $0x9,%ecx
c0020438:	8b 34 24             	mov    (%esp),%esi
c002043b:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002043d:	0f 97 c2             	seta   %dl
c0020440:	0f 92 c0             	setb   %al
c0020443:	38 c2                	cmp    %al,%dl
c0020445:	75 0e                	jne    c0020455 <pintos_init+0x215>
        scratch_bdev_name = value;
c0020447:	8b 44 24 04          	mov    0x4(%esp),%eax
c002044b:	a3 44 c8 03 c0       	mov    %eax,0xc003c844
c0020450:	e9 f0 fe ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-swap"))
c0020455:	bf 8d 0c 03 c0       	mov    $0xc0030c8d,%edi
c002045a:	b9 06 00 00 00       	mov    $0x6,%ecx
c002045f:	8b 34 24             	mov    (%esp),%esi
c0020462:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020464:	0f 97 c2             	seta   %dl
c0020467:	0f 92 c0             	setb   %al
c002046a:	38 c2                	cmp    %al,%dl
c002046c:	75 0e                	jne    c002047c <pintos_init+0x23c>
        swap_bdev_name = value;
c002046e:	8b 44 24 04          	mov    0x4(%esp),%eax
c0020472:	a3 40 c8 03 c0       	mov    %eax,0xc003c840
c0020477:	e9 c9 fe ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-rs"))
c002047c:	bf 93 0c 03 c0       	mov    $0xc0030c93,%edi
c0020481:	b9 04 00 00 00       	mov    $0x4,%ecx
c0020486:	8b 34 24             	mov    (%esp),%esi
c0020489:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002048b:	0f 97 c2             	seta   %dl
c002048e:	0f 92 c0             	setb   %al
c0020491:	38 c2                	cmp    %al,%dl
c0020493:	74 24                	je     c00204b9 <pintos_init+0x279>
      else if (!strcmp (name, "-mlfqs"))
c0020495:	83 ec 08             	sub    $0x8,%esp
c0020498:	68 97 0c 03 c0       	push   $0xc0030c97
c002049d:	ff 74 24 0c          	pushl  0xc(%esp)
c00204a1:	e8 8c 75 00 00       	call   c0027a32 <strcmp>
c00204a6:	83 c4 10             	add    $0x10,%esp
c00204a9:	85 c0                	test   %eax,%eax
c00204ab:	75 28                	jne    c00204d5 <pintos_init+0x295>
        thread_mlfqs = true;
c00204ad:	c6 05 3c 6c 04 c0 01 	movb   $0x1,0xc0046c3c
c00204b4:	e9 8c fe ff ff       	jmp    c0020345 <pintos_init+0x105>
        random_init (atoi (value));
c00204b9:	83 ec 0c             	sub    $0xc,%esp
c00204bc:	ff 74 24 10          	pushl  0x10(%esp)
c00204c0:	e8 54 72 00 00       	call   c0027719 <atoi>
c00204c5:	89 04 24             	mov    %eax,(%esp)
c00204c8:	e8 7f 61 00 00       	call   c002664c <random_init>
c00204cd:	83 c4 10             	add    $0x10,%esp
c00204d0:	e9 70 fe ff ff       	jmp    c0020345 <pintos_init+0x105>
      else if (!strcmp (name, "-ul"))
c00204d5:	83 ec 08             	sub    $0x8,%esp
c00204d8:	68 9e 0c 03 c0       	push   $0xc0030c9e
c00204dd:	ff 74 24 0c          	pushl  0xc(%esp)
c00204e1:	e8 4c 75 00 00       	call   c0027a32 <strcmp>
c00204e6:	83 c4 10             	add    $0x10,%esp
c00204e9:	85 c0                	test   %eax,%eax
c00204eb:	75 19                	jne    c0020506 <pintos_init+0x2c6>
        user_page_limit = atoi (value);
c00204ed:	83 ec 0c             	sub    $0xc,%esp
c00204f0:	ff 74 24 10          	pushl  0x10(%esp)
c00204f4:	e8 20 72 00 00       	call   c0027719 <atoi>
c00204f9:	a3 4c c2 03 c0       	mov    %eax,0xc003c24c
c00204fe:	83 c4 10             	add    $0x10,%esp
c0020501:	e9 3f fe ff ff       	jmp    c0020345 <pintos_init+0x105>
        PANIC ("unknown option `%s' (use -h for help)", name);
c0020506:	83 ec 0c             	sub    $0xc,%esp
c0020509:	ff 74 24 0c          	pushl  0xc(%esp)
c002050d:	68 f8 11 03 c0       	push   $0xc00311f8
c0020512:	68 dc f4 02 c0       	push   $0xc002f4dc
c0020517:	68 33 01 00 00       	push   $0x133
c002051c:	68 18 0c 03 c0       	push   $0xc0030c18
c0020521:	e8 57 81 00 00       	call   c002867d <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020526:	bd a0 c6 03 c0       	mov    $0xc003c6a0,%ebp
  random_init (rtc_get_time ());
c002052b:	e8 4a 5d 00 00       	call   c002627a <rtc_get_time>
c0020530:	83 ec 0c             	sub    $0xc,%esp
c0020533:	50                   	push   %eax
c0020534:	e8 13 61 00 00       	call   c002664c <random_init>
  thread_init ();
c0020539:	e8 fb 06 00 00       	call   c0020c39 <thread_init>
  console_init ();
c002053e:	e8 b0 9b 00 00       	call   c002a0f3 <console_init>
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c0020543:	83 c4 08             	add    $0x8,%esp
          init_ram_pages * PGSIZE / 1024);
c0020546:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c002054b:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c002054e:	c1 e8 0a             	shr    $0xa,%eax
c0020551:	50                   	push   %eax
c0020552:	68 20 12 03 c0       	push   $0xc0031220
c0020557:	e8 73 66 00 00       	call   c0026bcf <printf>
  palloc_init (user_page_limit);
c002055c:	83 c4 04             	add    $0x4,%esp
c002055f:	ff 35 4c c2 03 c0    	pushl  0xc003c24c
c0020565:	e8 1b 30 00 00       	call   c0023585 <palloc_init>
  malloc_init ();
c002056a:	e8 c5 33 00 00       	call   c0023934 <malloc_init>
  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002056f:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0020576:	e8 33 31 00 00       	call   c00236ae <palloc_get_page>
c002057b:	89 44 24 18          	mov    %eax,0x18(%esp)
c002057f:	a3 34 6c 04 c0       	mov    %eax,0xc0046c34
  for (page = 0; page < init_ram_pages; page++)
c0020584:	83 c4 10             	add    $0x10,%esp
c0020587:	83 3d 5e 01 02 c0 00 	cmpl   $0x0,0xc002015e
c002058e:	0f 84 23 01 00 00    	je     c00206b7 <pintos_init+0x477>
c0020594:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
c0020599:	b8 00 00 00 00       	mov    $0x0,%eax
c002059e:	be 00 00 00 00       	mov    $0x0,%esi
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c00205a3:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
c00205a7:	eb 5c                	jmp    c0020605 <pintos_init+0x3c5>
  for (; *argv != NULL && **argv == '-'; argv++)
c00205a9:	bd a0 c6 03 c0       	mov    $0xc003c6a0,%ebp
c00205ae:	e9 78 ff ff ff       	jmp    c002052b <pintos_init+0x2eb>
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c00205b3:	b1 00                	mov    $0x0,%cl
c00205b5:	83 e1 01             	and    $0x1,%ecx
c00205b8:	88 4c 24 04          	mov    %cl,0x4(%esp)
      if (pd[pde_idx] == 0)
c00205bc:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c00205c0:	8d 2c 91             	lea    (%ecx,%edx,4),%ebp
c00205c3:	83 7d 00 00          	cmpl   $0x0,0x0(%ebp)
c00205c7:	74 62                	je     c002062b <pintos_init+0x3eb>
      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c00205c9:	8d 0c 98             	lea    (%eax,%ebx,4),%ecx
/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
  ASSERT (is_kernel_vaddr (vaddr));
c00205cc:	81 3c 24 ff ff ff bf 	cmpl   $0xbfffffff,(%esp)
c00205d3:	0f 86 bc 00 00 00    	jbe    c0020695 <pintos_init+0x455>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00205d9:	8d 97 00 00 00 40    	lea    0x40000000(%edi),%edx
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
  ASSERT (pg_ofs (page) == 0);
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c00205df:	8a 5c 24 04          	mov    0x4(%esp),%bl
c00205e3:	83 f3 01             	xor    $0x1,%ebx
c00205e6:	0f b6 db             	movzbl %bl,%ebx
c00205e9:	d1 e3                	shl    %ebx
c00205eb:	83 ca 01             	or     $0x1,%edx
c00205ee:	09 da                	or     %ebx,%edx
c00205f0:	89 11                	mov    %edx,(%ecx)
  for (page = 0; page < init_ram_pages; page++)
c00205f2:	46                   	inc    %esi
c00205f3:	3b 35 5e 01 02 c0    	cmp    0xc002015e,%esi
c00205f9:	0f 83 b4 00 00 00    	jae    c00206b3 <pintos_init+0x473>
c00205ff:	81 c7 00 10 00 00    	add    $0x1000,%edi
  return (uintptr_t) va >> PDSHIFT;
c0020605:	89 fa                	mov    %edi,%edx
c0020607:	c1 ea 16             	shr    $0x16,%edx
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002060a:	89 fb                	mov    %edi,%ebx
c002060c:	c1 eb 0c             	shr    $0xc,%ebx
c002060f:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
c0020615:	89 3c 24             	mov    %edi,(%esp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020618:	81 ff 00 00 02 c0    	cmp    $0xc0020000,%edi
c002061e:	72 93                	jb     c00205b3 <pintos_init+0x373>
c0020620:	81 ff 00 40 03 c0    	cmp    $0xc0034000,%edi
c0020626:	0f 92 c1             	setb   %cl
c0020629:	eb 8a                	jmp    c00205b5 <pintos_init+0x375>
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002062b:	83 ec 0c             	sub    $0xc,%esp
c002062e:	6a 03                	push   $0x3
c0020630:	e8 79 30 00 00       	call   c00236ae <palloc_get_page>
  return (uintptr_t) va & PGMASK;
c0020635:	89 c2                	mov    %eax,%edx
  ASSERT (pg_ofs (pt) == 0);
c0020637:	83 c4 10             	add    $0x10,%esp
c002063a:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002063f:	75 18                	jne    c0020659 <pintos_init+0x419>
  ASSERT (is_kernel_vaddr (vaddr));
c0020641:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020646:	76 2f                	jbe    c0020677 <pintos_init+0x437>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020648:	81 c2 00 00 00 40    	add    $0x40000000,%edx
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c002064e:	83 ca 07             	or     $0x7,%edx
c0020651:	89 55 00             	mov    %edx,0x0(%ebp)
c0020654:	e9 70 ff ff ff       	jmp    c00205c9 <pintos_init+0x389>
  ASSERT (pg_ofs (pt) == 0);
c0020659:	83 ec 0c             	sub    $0xc,%esp
c002065c:	68 a2 0c 03 c0       	push   $0xc0030ca2
c0020661:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020666:	68 d0 f4 02 c0       	push   $0xc002f4d0
c002066b:	6a 48                	push   $0x48
c002066d:	68 ca 0c 03 c0       	push   $0xc0030cca
c0020672:	e8 06 80 00 00       	call   c002867d <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c0020677:	83 ec 0c             	sub    $0xc,%esp
c002067a:	68 de 0c 03 c0       	push   $0xc0030cde
c002067f:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020684:	68 c8 f4 02 c0       	push   $0xc002f4c8
c0020689:	6a 54                	push   $0x54
c002068b:	68 f6 0c 03 c0       	push   $0xc0030cf6
c0020690:	e8 e8 7f 00 00       	call   c002867d <debug_panic>
c0020695:	83 ec 0c             	sub    $0xc,%esp
c0020698:	68 de 0c 03 c0       	push   $0xc0030cde
c002069d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00206a2:	68 c8 f4 02 c0       	push   $0xc002f4c8
c00206a7:	6a 54                	push   $0x54
c00206a9:	68 f6 0c 03 c0       	push   $0xc0030cf6
c00206ae:	e8 ca 7f 00 00       	call   c002867d <debug_panic>
c00206b3:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00206b7:	a1 34 6c 04 c0       	mov    0xc0046c34,%eax
c00206bc:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00206c1:	0f 86 c4 00 00 00    	jbe    c002078b <pintos_init+0x54b>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00206c7:	05 00 00 00 40       	add    $0x40000000,%eax
c00206cc:	0f 22 d8             	mov    %eax,%cr3
  tss_init ();
c00206cf:	e8 98 bd 00 00       	call   c002c46c <tss_init>
  gdt_init ();
c00206d4:	e8 6b bc 00 00       	call   c002c344 <gdt_init>
  intr_init ();
c00206d9:	e8 9e 13 00 00       	call   c0021a7c <intr_init>
  timer_init ();
c00206de:	e8 30 3a 00 00       	call   c0024113 <timer_init>
  kbd_init ();
c00206e3:	e8 ef 3e 00 00       	call   c00245d7 <kbd_init>
  input_init ();
c00206e8:	e8 86 56 00 00       	call   c0025d73 <input_init>
  exception_init ();
c00206ed:	e8 2d ad 00 00       	call   c002b41f <exception_init>
  syscall_init ();
c00206f2:	e8 c9 ae 00 00       	call   c002b5c0 <syscall_init>
  thread_start ();
c00206f7:	e8 fc 0f 00 00       	call   c00216f8 <thread_start>
  serial_init_queue ();
c00206fc:	e8 da 42 00 00       	call   c00249db <serial_init_queue>
  timer_calibrate ();
c0020701:	e8 33 3a 00 00       	call   c0024139 <timer_calibrate>
  ide_init ();
c0020706:	e8 9c 51 00 00       	call   c00258a7 <ide_init>
  locate_block_device (BLOCK_FILESYS, filesys_bdev_name);
c002070b:	8b 15 48 c8 03 c0    	mov    0xc003c848,%edx
c0020711:	b8 01 00 00 00       	mov    $0x1,%eax
c0020716:	e8 47 fa ff ff       	call   c0020162 <locate_block_device>
  locate_block_device (BLOCK_SCRATCH, scratch_bdev_name);
c002071b:	8b 15 44 c8 03 c0    	mov    0xc003c844,%edx
c0020721:	b8 02 00 00 00       	mov    $0x2,%eax
c0020726:	e8 37 fa ff ff       	call   c0020162 <locate_block_device>
  locate_block_device (BLOCK_SWAP, swap_bdev_name);
c002072b:	8b 15 40 c8 03 c0    	mov    0xc003c840,%edx
c0020731:	b8 03 00 00 00       	mov    $0x3,%eax
c0020736:	e8 27 fa ff ff       	call   c0020162 <locate_block_device>
  filesys_init (format_filesys);
c002073b:	83 ec 0c             	sub    $0xc,%esp
c002073e:	0f b6 05 4c c8 03 c0 	movzbl 0xc003c84c,%eax
c0020745:	50                   	push   %eax
c0020746:	e8 45 bd 00 00       	call   c002c490 <filesys_init>
  thread_init_dir ();
c002074b:	e8 63 11 00 00       	call   c00218b3 <thread_init_dir>
	lock_init(&filesys_lock);
c0020750:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c0020757:	e8 03 26 00 00       	call   c0022d5f <lock_init>
	page_init();
c002075c:	e8 4c e5 00 00       	call   c002ecad <page_init>
	frame_init();
c0020761:	e8 51 e9 00 00       	call   c002f0b7 <frame_init>
	swap_init();
c0020766:	e8 46 eb 00 00       	call   c002f2b1 <swap_init>
  printf ("Boot complete.\n");
c002076b:	c7 04 24 0c 0d 03 c0 	movl   $0xc0030d0c,(%esp)
c0020772:	e8 ed 99 00 00       	call   c002a164 <puts>
  if (*argv != NULL) {
c0020777:	8b 75 00             	mov    0x0(%ebp),%esi
c002077a:	83 c4 10             	add    $0x10,%esp
c002077d:	85 f6                	test   %esi,%esi
c002077f:	74 28                	je     c00207a9 <pintos_init+0x569>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c0020781:	bf 96 15 03 c0       	mov    $0xc0031596,%edi
c0020786:	e9 87 00 00 00       	jmp    c0020812 <pintos_init+0x5d2>
  ASSERT (is_kernel_vaddr (vaddr));
c002078b:	83 ec 0c             	sub    $0xc,%esp
c002078e:	68 de 0c 03 c0       	push   $0xc0030cde
c0020793:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020798:	68 c8 f4 02 c0       	push   $0xc002f4c8
c002079d:	6a 54                	push   $0x54
c002079f:	68 f6 0c 03 c0       	push   $0xc0030cf6
c00207a4:	e8 d4 7e 00 00       	call   c002867d <debug_panic>
c00207a9:	bb 00 00 00 00       	mov    $0x0,%ebx
        failed_cnt = 0;
c00207ae:	bd 00 00 00 00       	mov    $0x0,%ebp
c00207b3:	e9 aa 00 00 00       	jmp    c0020862 <pintos_init+0x622>
      for (i = 1; i < a->argc; i++)
c00207b8:	8b 53 04             	mov    0x4(%ebx),%edx
c00207bb:	83 fa 01             	cmp    $0x1,%edx
c00207be:	7e 36                	jle    c00207f6 <pintos_init+0x5b6>
        if (argv[i] == NULL)
c00207c0:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c00207c4:	74 11                	je     c00207d7 <pintos_init+0x597>
c00207c6:	b8 01 00 00 00       	mov    $0x1,%eax
      for (i = 1; i < a->argc; i++)
c00207cb:	40                   	inc    %eax
c00207cc:	39 d0                	cmp    %edx,%eax
c00207ce:	74 26                	je     c00207f6 <pintos_init+0x5b6>
        if (argv[i] == NULL)
c00207d0:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c00207d5:	75 f4                	jne    c00207cb <pintos_init+0x58b>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c00207d7:	83 ec 08             	sub    $0x8,%esp
c00207da:	4a                   	dec    %edx
c00207db:	52                   	push   %edx
c00207dc:	56                   	push   %esi
c00207dd:	68 6c 12 03 c0       	push   $0xc003126c
c00207e2:	68 40 f4 02 c0       	push   $0xc002f440
c00207e7:	68 7c 01 00 00       	push   $0x17c
c00207ec:	68 18 0c 03 c0       	push   $0xc0030c18
c00207f1:	e8 87 7e 00 00       	call   c002867d <debug_panic>
      a->function (argv);
c00207f6:	83 ec 0c             	sub    $0xc,%esp
c00207f9:	55                   	push   %ebp
c00207fa:	ff 53 08             	call   *0x8(%ebx)
      argv += a->argc;
c00207fd:	8b 43 04             	mov    0x4(%ebx),%eax
c0020800:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
  while (*argv != NULL)
c0020804:	8b 75 00             	mov    0x0(%ebp),%esi
c0020807:	83 c4 10             	add    $0x10,%esp
c002080a:	85 f6                	test   %esi,%esi
c002080c:	0f 84 f2 00 00 00    	je     c0020904 <pintos_init+0x6c4>
c0020812:	89 f8                	mov    %edi,%eax
c0020814:	bb 60 f4 02 c0       	mov    $0xc002f460,%ebx
        else if (!strcmp (*argv, a->name))
c0020819:	83 ec 08             	sub    $0x8,%esp
c002081c:	50                   	push   %eax
c002081d:	56                   	push   %esi
c002081e:	e8 0f 72 00 00       	call   c0027a32 <strcmp>
c0020823:	83 c4 10             	add    $0x10,%esp
c0020826:	85 c0                	test   %eax,%eax
c0020828:	74 8e                	je     c00207b8 <pintos_init+0x578>
      for (a = actions; ; a++)
c002082a:	83 c3 0c             	add    $0xc,%ebx
        if (a->name == NULL)
c002082d:	8b 03                	mov    (%ebx),%eax
c002082f:	85 c0                	test   %eax,%eax
c0020831:	75 e6                	jne    c0020819 <pintos_init+0x5d9>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c0020833:	83 ec 0c             	sub    $0xc,%esp
c0020836:	56                   	push   %esi
c0020837:	68 44 12 03 c0       	push   $0xc0031244
c002083c:	68 40 f4 02 c0       	push   $0xc002f440
c0020841:	68 75 01 00 00       	push   $0x175
c0020846:	68 18 0c 03 c0       	push   $0xc0030c18
c002084b:	e8 2d 7e 00 00       	call   c002867d <debug_panic>
        puts ("I am Pintakina!");
c0020850:	83 ec 0c             	sub    $0xc,%esp
c0020853:	68 2e 0d 03 c0       	push   $0xc0030d2e
c0020858:	e8 07 99 00 00       	call   c002a164 <puts>
c002085d:	83 c4 10             	add    $0x10,%esp
        failed_cnt = 0;
c0020860:	89 eb                	mov    %ebp,%ebx
      printf("Pintakina$ ");
c0020862:	83 ec 0c             	sub    $0xc,%esp
c0020865:	68 1b 0d 03 c0       	push   $0xc0030d1b
c002086a:	e8 60 63 00 00       	call   c0026bcf <printf>
      input_getline (cmd, MAX_CMD_LENGTH);
c002086f:	83 c4 08             	add    $0x8,%esp
c0020872:	68 80 00 00 00       	push   $0x80
c0020877:	68 c0 c7 03 c0       	push   $0xc003c7c0
c002087c:	e8 ea 55 00 00       	call   c0025e6b <input_getline>
      if (strcmp(cmd, "whoami") == 0) {
c0020881:	be c0 c7 03 c0       	mov    $0xc003c7c0,%esi
c0020886:	bf 27 0d 03 c0       	mov    $0xc0030d27,%edi
c002088b:	b9 07 00 00 00       	mov    $0x7,%ecx
c0020890:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020892:	0f 97 c2             	seta   %dl
c0020895:	0f 92 c0             	setb   %al
c0020898:	83 c4 10             	add    $0x10,%esp
c002089b:	38 c2                	cmp    %al,%dl
c002089d:	74 b1                	je     c0020850 <pintos_init+0x610>
      } else if (strcmp(cmd, "exit") == 0){
c002089f:	be c0 c7 03 c0       	mov    $0xc003c7c0,%esi
c00208a4:	bf 3e 0d 03 c0       	mov    $0xc0030d3e,%edi
c00208a9:	b9 05 00 00 00       	mov    $0x5,%ecx
c00208ae:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00208b0:	0f 97 c2             	seta   %dl
c00208b3:	0f 92 c0             	setb   %al
c00208b6:	38 c2                	cmp    %al,%dl
c00208b8:	74 3d                	je     c00208f7 <pintos_init+0x6b7>
      } else if (strcmp(cmd, "") != 0){
c00208ba:	80 3d c0 c7 03 c0 00 	cmpb   $0x0,0xc003c7c0
c00208c1:	74 9d                	je     c0020860 <pintos_init+0x620>
        failed_cnt ++;
c00208c3:	8d 73 01             	lea    0x1(%ebx),%esi
        for (i = 0; i < failed_cnt; i++) putchar ('?');
c00208c6:	85 f6                	test   %esi,%esi
c00208c8:	7e 19                	jle    c00208e3 <pintos_init+0x6a3>
c00208ca:	89 f7                	mov    %esi,%edi
c00208cc:	bb 00 00 00 00       	mov    $0x0,%ebx
c00208d1:	83 ec 0c             	sub    $0xc,%esp
c00208d4:	6a 3f                	push   $0x3f
c00208d6:	e8 f5 98 00 00       	call   c002a1d0 <putchar>
c00208db:	43                   	inc    %ebx
c00208dc:	83 c4 10             	add    $0x10,%esp
c00208df:	39 fb                	cmp    %edi,%ebx
c00208e1:	75 ee                	jne    c00208d1 <pintos_init+0x691>
        putchar ('\n');
c00208e3:	83 ec 0c             	sub    $0xc,%esp
c00208e6:	6a 0a                	push   $0xa
c00208e8:	e8 e3 98 00 00       	call   c002a1d0 <putchar>
c00208ed:	83 c4 10             	add    $0x10,%esp
        failed_cnt ++;
c00208f0:	89 f3                	mov    %esi,%ebx
c00208f2:	e9 6b ff ff ff       	jmp    c0020862 <pintos_init+0x622>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c00208f7:	83 ec 0c             	sub    $0xc,%esp
c00208fa:	6a 01                	push   $0x1
c00208fc:	e8 0c 5b 00 00       	call   c002640d <shutdown_configure>
        break;
c0020901:	83 c4 10             	add    $0x10,%esp
  shutdown ();
c0020904:	e8 08 5c 00 00       	call   c0026511 <shutdown>
  thread_exit ();
c0020909:	e8 a0 0e 00 00       	call   c00217ae <thread_exit>
  argv[argc] = NULL;
c002090e:	c7 04 bd a0 c6 03 c0 	movl   $0x0,-0x3ffc3960(,%edi,4)
c0020915:	00 00 00 00 
  printf ("Kernel command line:");
c0020919:	83 ec 0c             	sub    $0xc,%esp
c002091c:	68 43 0d 03 c0       	push   $0xc0030d43
c0020921:	e8 a9 62 00 00       	call   c0026bcf <printf>
c0020926:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0020929:	83 ec 0c             	sub    $0xc,%esp
c002092c:	6a 0a                	push   $0xa
c002092e:	e8 9d 98 00 00       	call   c002a1d0 <putchar>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020933:	a1 a0 c6 03 c0       	mov    0xc003c6a0,%eax
c0020938:	83 c4 10             	add    $0x10,%esp
c002093b:	85 c0                	test   %eax,%eax
c002093d:	0f 84 e3 fb ff ff    	je     c0020526 <pintos_init+0x2e6>
c0020943:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020946:	0f 85 5d fc ff ff    	jne    c00205a9 <pintos_init+0x369>
c002094c:	bd a0 c6 03 c0       	mov    $0xc003c6a0,%ebp
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020951:	8d 5c 24 1c          	lea    0x1c(%esp),%ebx
c0020955:	e9 02 fa ff ff       	jmp    c002035c <pintos_init+0x11c>

c002095a <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c002095a:	57                   	push   %edi
c002095b:	56                   	push   %esi
c002095c:	53                   	push   %ebx
c002095d:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level;

	ASSERT (t != NULL);
c0020960:	85 c0                	test   %eax,%eax
c0020962:	0f 84 31 01 00 00    	je     c0020a99 <init_thread+0x13f>
c0020968:	89 c3                	mov    %eax,%ebx
c002096a:	89 ce                	mov    %ecx,%esi
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c002096c:	83 f9 3f             	cmp    $0x3f,%ecx
c002096f:	0f 87 45 01 00 00    	ja     c0020aba <init_thread+0x160>
  ASSERT (name != NULL);
c0020975:	85 d2                	test   %edx,%edx
c0020977:	0f 84 5e 01 00 00    	je     c0020adb <init_thread+0x181>

  memset (t, 0, sizeof *t);
c002097d:	b9 3b 00 00 00       	mov    $0x3b,%ecx
c0020982:	b8 00 00 00 00       	mov    $0x0,%eax
c0020987:	89 df                	mov    %ebx,%edi
c0020989:	f3 ab                	rep stos %eax,%es:(%edi)
  t->status = THREAD_BLOCKED;
c002098b:	c7 43 08 02 00 00 00 	movl   $0x2,0x8(%ebx)
  strlcpy (t->name, name, sizeof t->name);
c0020992:	83 ec 04             	sub    $0x4,%esp
c0020995:	6a 10                	push   $0x10
c0020997:	52                   	push   %edx
c0020998:	8d 43 0c             	lea    0xc(%ebx),%eax
c002099b:	50                   	push   %eax
c002099c:	e8 d6 73 00 00       	call   c0027d77 <strlcpy>
  t->stack = (uint8_t *) t + PGSIZE;
c00209a1:	8d 83 00 10 00 00    	lea    0x1000(%ebx),%eax
c00209a7:	89 43 1c             	mov    %eax,0x1c(%ebx)
  t->priority = priority;
c00209aa:	89 73 20             	mov    %esi,0x20(%ebx)
/* fstqwq */
  t->sleep_remain = 0;
c00209ad:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)

  if (thread_mlfqs) {
c00209b4:	83 c4 10             	add    $0x10,%esp
c00209b7:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c00209be:	0f 85 38 01 00 00    	jne    c0020afc <init_thread+0x1a2>
    t->nice = 0;
    t->recent_cpu = fixed32_init(0);
    t->priority = 0;
  }

  list_init (&t->lock_list);
c00209c4:	83 ec 0c             	sub    $0xc,%esp
c00209c7:	8d 43 30             	lea    0x30(%ebx),%eax
c00209ca:	50                   	push   %eax
c00209cb:	e8 54 7d 00 00       	call   c0028724 <list_init>
  t->priority_to_set = -1;
c00209d0:	c7 43 44 ff ff ff ff 	movl   $0xffffffff,0x44(%ebx)
  t->max_donate_delta = 0;
c00209d7:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  t->father = 0;
c00209de:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)

/* end fstqwq */

  t->magic = THREAD_MAGIC;
c00209e5:	c7 83 e8 00 00 00 4b 	movl   $0xcd6abf4b,0xe8(%ebx)
c00209ec:	bf 6a cd 

  /* yveh */
#ifdef USERPROG
	t->ret_status = -1;
c00209ef:	c7 43 68 ff ff ff ff 	movl   $0xffffffff,0x68(%ebx)
  t->load_success = false;
c00209f6:	c6 83 a0 00 00 00 00 	movb   $0x0,0xa0(%ebx)
  sema_init(&t->load_sema, 0);
c00209fd:	83 c4 08             	add    $0x8,%esp
c0020a00:	6a 00                	push   $0x0
c0020a02:	8d 43 78             	lea    0x78(%ebx),%eax
c0020a05:	50                   	push   %eax
c0020a06:	e8 7a 20 00 00       	call   c0022a85 <sema_init>
  sema_init(&t->wait_sema, 0);
c0020a0b:	83 c4 08             	add    $0x8,%esp
c0020a0e:	6a 00                	push   $0x0
c0020a10:	8d 83 8c 00 00 00    	lea    0x8c(%ebx),%eax
c0020a16:	50                   	push   %eax
c0020a17:	e8 69 20 00 00       	call   c0022a85 <sema_init>
  t->wait_tid = -1;
c0020a1c:	c7 43 74 ff ff ff ff 	movl   $0xffffffff,0x74(%ebx)
  t->file_cnt = 2;
c0020a23:	c7 43 6c 02 00 00 00 	movl   $0x2,0x6c(%ebx)
  asm ("mov %%esp, %0" : "=g" (esp));
c0020a2a:	89 e0                	mov    %esp,%eax
  return (void *) ((uintptr_t) va & ~PGMASK);
c0020a2c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0020a31:	89 83 a4 00 00 00    	mov    %eax,0xa4(%ebx)
  t->parent = running_thread();
  t->self = NULL;
c0020a37:	c7 83 b8 00 00 00 00 	movl   $0x0,0xb8(%ebx)
c0020a3e:	00 00 00 
  list_init(&t->files);
c0020a41:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
c0020a47:	89 04 24             	mov    %eax,(%esp)
c0020a4a:	e8 d5 7c 00 00       	call   c0028724 <list_init>
  list_init(&t->children);
c0020a4f:	8d 83 a8 00 00 00    	lea    0xa8(%ebx),%eax
c0020a55:	89 04 24             	mov    %eax,(%esp)
c0020a58:	e8 c7 7c 00 00       	call   c0028724 <list_init>
#endif
#ifdef VM
  t->mapping_cnt = 2;
c0020a5d:	c7 43 70 02 00 00 00 	movl   $0x2,0x70(%ebx)
  list_init(&t->mappings);
c0020a64:	8d 83 cc 00 00 00    	lea    0xcc(%ebx),%eax
c0020a6a:	89 04 24             	mov    %eax,(%esp)
c0020a6d:	e8 b2 7c 00 00       	call   c0028724 <list_init>
#endif
  /* end yveh */

  old_level = intr_disable ();
c0020a72:	e8 e4 0f 00 00       	call   c0021a5b <intr_disable>
c0020a77:	89 c6                	mov    %eax,%esi
  list_push_back (&all_list, &t->allelem);
c0020a79:	83 c4 08             	add    $0x8,%esp
c0020a7c:	83 c3 54             	add    $0x54,%ebx
c0020a7f:	53                   	push   %ebx
c0020a80:	68 bc c8 03 c0       	push   $0xc003c8bc
c0020a85:	e8 e6 80 00 00       	call   c0028b70 <list_push_back>
  intr_set_level (old_level);
c0020a8a:	89 34 24             	mov    %esi,(%esp)
c0020a8d:	e8 d0 0f 00 00       	call   c0021a62 <intr_set_level>
}
c0020a92:	83 c4 20             	add    $0x20,%esp
c0020a95:	5b                   	pop    %ebx
c0020a96:	5e                   	pop    %esi
c0020a97:	5f                   	pop    %edi
c0020a98:	c3                   	ret    
	ASSERT (t != NULL);
c0020a99:	83 ec 0c             	sub    $0xc,%esp
c0020a9c:	68 eb 27 03 c0       	push   $0xc00327eb
c0020aa1:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020aa6:	68 54 f6 02 c0       	push   $0xc002f654
c0020aab:	68 8c 02 00 00       	push   $0x28c
c0020ab0:	68 90 12 03 c0       	push   $0xc0031290
c0020ab5:	e8 c3 7b 00 00       	call   c002867d <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020aba:	83 ec 0c             	sub    $0xc,%esp
c0020abd:	68 e8 13 03 c0       	push   $0xc00313e8
c0020ac2:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020ac7:	68 54 f6 02 c0       	push   $0xc002f654
c0020acc:	68 8d 02 00 00       	push   $0x28d
c0020ad1:	68 90 12 03 c0       	push   $0xc0031290
c0020ad6:	e8 a2 7b 00 00       	call   c002867d <debug_panic>
  ASSERT (name != NULL);
c0020adb:	83 ec 0c             	sub    $0xc,%esp
c0020ade:	68 a7 12 03 c0       	push   $0xc00312a7
c0020ae3:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020ae8:	68 54 f6 02 c0       	push   $0xc002f654
c0020aed:	68 8e 02 00 00       	push   $0x28e
c0020af2:	68 90 12 03 c0       	push   $0xc0031290
c0020af7:	e8 81 7b 00 00       	call   c002867d <debug_panic>
    t->nice = 0;
c0020afc:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
    t->recent_cpu = fixed32_init(0);
c0020b03:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020b07:	83 ec 08             	sub    $0x8,%esp
c0020b0a:	6a 00                	push   $0x0
c0020b0c:	50                   	push   %eax
c0020b0d:	e8 0a 32 00 00       	call   c0023d1c <fixed32_init>
c0020b12:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020b16:	89 43 2c             	mov    %eax,0x2c(%ebx)
    t->priority = 0;
c0020b19:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
c0020b20:	83 c4 0c             	add    $0xc,%esp
c0020b23:	e9 9c fe ff ff       	jmp    c00209c4 <init_thread+0x6a>

c0020b28 <is_thread>:
{
c0020b28:	53                   	push   %ebx
c0020b29:	83 ec 08             	sub    $0x8,%esp
c0020b2c:	89 c3                	mov    %eax,%ebx
  if (!(t != NULL && t->magic == THREAD_MAGIC)) {
c0020b2e:	85 c0                	test   %eax,%eax
c0020b30:	74 44                	je     c0020b76 <is_thread+0x4e>
c0020b32:	81 b8 e8 00 00 00 4b 	cmpl   $0xcd6abf4b,0xe8(%eax)
c0020b39:	bf 6a cd 
c0020b3c:	74 2a                	je     c0020b68 <is_thread+0x40>
    printf("is thread failed : %u", t);
c0020b3e:	83 ec 08             	sub    $0x8,%esp
c0020b41:	50                   	push   %eax
c0020b42:	68 b4 12 03 c0       	push   $0xc00312b4
c0020b47:	e8 83 60 00 00       	call   c0026bcf <printf>
  return t != NULL && t->magic == THREAD_MAGIC;
c0020b4c:	83 c4 10             	add    $0x10,%esp
c0020b4f:	81 bb e8 00 00 00 4b 	cmpl   $0xcd6abf4b,0xe8(%ebx)
c0020b56:	bf 6a cd 
c0020b59:	74 14                	je     c0020b6f <is_thread+0x47>
c0020b5b:	b8 00 00 00 00       	mov    $0x0,%eax
c0020b60:	83 e0 01             	and    $0x1,%eax
}
c0020b63:	83 c4 08             	add    $0x8,%esp
c0020b66:	5b                   	pop    %ebx
c0020b67:	c3                   	ret    
  return t != NULL && t->magic == THREAD_MAGIC;
c0020b68:	b8 01 00 00 00       	mov    $0x1,%eax
c0020b6d:	eb f1                	jmp    c0020b60 <is_thread+0x38>
c0020b6f:	b8 01 00 00 00       	mov    $0x1,%eax
c0020b74:	eb ea                	jmp    c0020b60 <is_thread+0x38>
    printf("is thread failed : %u", t);
c0020b76:	83 ec 08             	sub    $0x8,%esp
c0020b79:	50                   	push   %eax
c0020b7a:	68 b4 12 03 c0       	push   $0xc00312b4
c0020b7f:	e8 4b 60 00 00       	call   c0026bcf <printf>
c0020b84:	83 c4 10             	add    $0x10,%esp
c0020b87:	eb d2                	jmp    c0020b5b <is_thread+0x33>

c0020b89 <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c0020b89:	56                   	push   %esi
c0020b8a:	53                   	push   %ebx
c0020b8b:	83 ec 04             	sub    $0x4,%esp
c0020b8e:	89 c3                	mov    %eax,%ebx
c0020b90:	89 d6                	mov    %edx,%esi
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c0020b92:	e8 91 ff ff ff       	call   c0020b28 <is_thread>
c0020b97:	84 c0                	test   %al,%al
c0020b99:	74 16                	je     c0020bb1 <alloc_frame+0x28>
  ASSERT (size % sizeof (uint32_t) == 0);
c0020b9b:	f7 c6 03 00 00 00    	test   $0x3,%esi
c0020ba1:	75 2f                	jne    c0020bd2 <alloc_frame+0x49>

  t->stack -= size;
c0020ba3:	8b 43 1c             	mov    0x1c(%ebx),%eax
c0020ba6:	29 f0                	sub    %esi,%eax
c0020ba8:	89 43 1c             	mov    %eax,0x1c(%ebx)
  return t->stack;
}
c0020bab:	83 c4 04             	add    $0x4,%esp
c0020bae:	5b                   	pop    %ebx
c0020baf:	5e                   	pop    %esi
c0020bb0:	c3                   	ret    
  ASSERT (is_thread (t));
c0020bb1:	83 ec 0c             	sub    $0xc,%esp
c0020bb4:	68 ca 12 03 c0       	push   $0xc00312ca
c0020bb9:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020bbe:	68 28 f6 02 c0       	push   $0xc002f628
c0020bc3:	68 c5 02 00 00       	push   $0x2c5
c0020bc8:	68 90 12 03 c0       	push   $0xc0031290
c0020bcd:	e8 ab 7a 00 00       	call   c002867d <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c0020bd2:	83 ec 0c             	sub    $0xc,%esp
c0020bd5:	68 d8 12 03 c0       	push   $0xc00312d8
c0020bda:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020bdf:	68 28 f6 02 c0       	push   $0xc002f628
c0020be4:	68 c6 02 00 00       	push   $0x2c6
c0020be9:	68 90 12 03 c0       	push   $0xc0031290
c0020bee:	e8 8a 7a 00 00       	call   c002867d <debug_panic>

c0020bf3 <thread_update_priority>:
thread_update_priority(struct thread* t, void* aux UNUSED){
c0020bf3:	53                   	push   %ebx
c0020bf4:	83 ec 18             	sub    $0x18,%esp
c0020bf7:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  if(t != idle_thread) {
c0020bfb:	39 1d b8 c8 03 c0    	cmp    %ebx,0xc003c8b8
c0020c01:	74 31                	je     c0020c34 <thread_update_priority+0x41>
                - fixed32_trunc(fixed32_div_int(t->recent_cpu, 4))
c0020c03:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020c07:	83 ec 04             	sub    $0x4,%esp
c0020c0a:	6a 04                	push   $0x4
c0020c0c:	ff 73 2c             	pushl  0x2c(%ebx)
c0020c0f:	50                   	push   %eax
c0020c10:	e8 bb 32 00 00       	call   c0023ed0 <fixed32_div_int>
c0020c15:	ff 74 24 18          	pushl  0x18(%esp)
c0020c19:	e8 0e 31 00 00       	call   c0023d2c <fixed32_trunc>
c0020c1e:	ba 3f 00 00 00       	mov    $0x3f,%edx
c0020c23:	29 c2                	sub    %eax,%edx
c0020c25:	89 d0                	mov    %edx,%eax
                - t->nice * 2;
c0020c27:	8b 53 28             	mov    0x28(%ebx),%edx
c0020c2a:	01 d2                	add    %edx,%edx
c0020c2c:	29 d0                	sub    %edx,%eax
c0020c2e:	89 43 20             	mov    %eax,0x20(%ebx)
    t->priority = PRI_MAX
c0020c31:	83 c4 10             	add    $0x10,%esp
}
c0020c34:	83 c4 18             	add    $0x18,%esp
c0020c37:	5b                   	pop    %ebx
c0020c38:	c3                   	ret    

c0020c39 <thread_init>:
{
c0020c39:	56                   	push   %esi
c0020c3a:	53                   	push   %ebx
c0020c3b:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0020c3e:	e8 db 0d 00 00       	call   c0021a1e <intr_get_level>
c0020c43:	85 c0                	test   %eax,%eax
c0020c45:	75 7c                	jne    c0020cc3 <thread_init+0x8a>
  lock_init (&tid_lock);
c0020c47:	83 ec 0c             	sub    $0xc,%esp
c0020c4a:	68 80 c8 03 c0       	push   $0xc003c880
c0020c4f:	e8 0b 21 00 00       	call   c0022d5f <lock_init>
  list_init (&ready_list);
c0020c54:	c7 04 24 cc c8 03 c0 	movl   $0xc003c8cc,(%esp)
c0020c5b:	e8 c4 7a 00 00       	call   c0028724 <list_init>
  list_init (&all_list);
c0020c60:	c7 04 24 bc c8 03 c0 	movl   $0xc003c8bc,(%esp)
c0020c67:	e8 b8 7a 00 00       	call   c0028724 <list_init>
  asm ("mov %%esp, %0" : "=g" (esp));
c0020c6c:	89 e0                	mov    %esp,%eax
c0020c6e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  initial_thread = running_thread ();
c0020c73:	a3 b4 c8 03 c0       	mov    %eax,0xc003c8b4
  init_thread (initial_thread, "main", PRI_DEFAULT);
c0020c78:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c0020c7d:	ba 14 13 03 c0       	mov    $0xc0031314,%edx
c0020c82:	e8 d3 fc ff ff       	call   c002095a <init_thread>
  initial_thread->status = THREAD_RUNNING;
c0020c87:	8b 1d b4 c8 03 c0    	mov    0xc003c8b4,%ebx
c0020c8d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
allocate_tid (void) 
{
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c0020c94:	c7 04 24 80 c8 03 c0 	movl   $0xc003c880,(%esp)
c0020c9b:	e8 33 22 00 00       	call   c0022ed3 <lock_acquire>
  tid = next_tid++;
c0020ca0:	8b 35 50 c2 03 c0    	mov    0xc003c250,%esi
c0020ca6:	8d 46 01             	lea    0x1(%esi),%eax
c0020ca9:	a3 50 c2 03 c0       	mov    %eax,0xc003c250
  lock_release (&tid_lock);
c0020cae:	c7 04 24 80 c8 03 c0 	movl   $0xc003c880,(%esp)
c0020cb5:	e8 b6 23 00 00       	call   c0023070 <lock_release>
  initial_thread->tid = allocate_tid ();
c0020cba:	89 73 04             	mov    %esi,0x4(%ebx)
}
c0020cbd:	83 c4 14             	add    $0x14,%esp
c0020cc0:	5b                   	pop    %ebx
c0020cc1:	5e                   	pop    %esi
c0020cc2:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0020cc3:	83 ec 0c             	sub    $0xc,%esp
c0020cc6:	68 f6 12 03 c0       	push   $0xc00312f6
c0020ccb:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020cd0:	68 60 f6 02 c0       	push   $0xc002f660
c0020cd5:	6a 77                	push   $0x77
c0020cd7:	68 90 12 03 c0       	push   $0xc0031290
c0020cdc:	e8 9c 79 00 00       	call   c002867d <debug_panic>

c0020ce1 <thread_print_stats>:
{
c0020ce1:	83 ec 10             	sub    $0x10,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020ce4:	ff 35 6c c8 03 c0    	pushl  0xc003c86c
c0020cea:	ff 35 68 c8 03 c0    	pushl  0xc003c868
c0020cf0:	ff 35 74 c8 03 c0    	pushl  0xc003c874
c0020cf6:	ff 35 70 c8 03 c0    	pushl  0xc003c870
c0020cfc:	ff 35 7c c8 03 c0    	pushl  0xc003c87c
c0020d02:	ff 35 78 c8 03 c0    	pushl  0xc003c878
c0020d08:	68 14 14 03 c0       	push   $0xc0031414
c0020d0d:	e8 bd 5e 00 00       	call   c0026bcf <printf>
}
c0020d12:	83 c4 2c             	add    $0x2c,%esp
c0020d15:	c3                   	ret    

c0020d16 <thread_current>:
{
c0020d16:	53                   	push   %ebx
c0020d17:	83 ec 08             	sub    $0x8,%esp
  asm ("mov %%esp, %0" : "=g" (esp));
c0020d1a:	89 e3                	mov    %esp,%ebx
c0020d1c:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  ASSERT (is_thread (t));
c0020d22:	89 d8                	mov    %ebx,%eax
c0020d24:	e8 ff fd ff ff       	call   c0020b28 <is_thread>
c0020d29:	84 c0                	test   %al,%al
c0020d2b:	74 0d                	je     c0020d3a <thread_current+0x24>
  ASSERT (t->status == THREAD_RUNNING);
c0020d2d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c0020d31:	75 28                	jne    c0020d5b <thread_current+0x45>
}
c0020d33:	89 d8                	mov    %ebx,%eax
c0020d35:	83 c4 08             	add    $0x8,%esp
c0020d38:	5b                   	pop    %ebx
c0020d39:	c3                   	ret    
  ASSERT (is_thread (t));
c0020d3a:	83 ec 0c             	sub    $0xc,%esp
c0020d3d:	68 ca 12 03 c0       	push   $0xc00312ca
c0020d42:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020d47:	68 ec f5 02 c0       	push   $0xc002f5ec
c0020d4c:	68 44 01 00 00       	push   $0x144
c0020d51:	68 90 12 03 c0       	push   $0xc0031290
c0020d56:	e8 22 79 00 00       	call   c002867d <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020d5b:	83 ec 0c             	sub    $0xc,%esp
c0020d5e:	68 19 13 03 c0       	push   $0xc0031319
c0020d63:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020d68:	68 ec f5 02 c0       	push   $0xc002f5ec
c0020d6d:	68 45 01 00 00       	push   $0x145
c0020d72:	68 90 12 03 c0       	push   $0xc0031290
c0020d77:	e8 01 79 00 00       	call   c002867d <debug_panic>

c0020d7c <thread_tick>:
{
c0020d7c:	83 ec 0c             	sub    $0xc,%esp
  struct thread *t = thread_current ();
c0020d7f:	e8 92 ff ff ff       	call   c0020d16 <thread_current>
  if (t == idle_thread)
c0020d84:	3b 05 b8 c8 03 c0    	cmp    0xc003c8b8,%eax
c0020d8a:	74 28                	je     c0020db4 <thread_tick+0x38>
  else if (t->pagedir != NULL)
c0020d8c:	83 78 64 00          	cmpl   $0x0,0x64(%eax)
c0020d90:	74 32                	je     c0020dc4 <thread_tick+0x48>
    user_ticks++;
c0020d92:	83 05 68 c8 03 c0 01 	addl   $0x1,0xc003c868
c0020d99:	83 15 6c c8 03 c0 00 	adcl   $0x0,0xc003c86c
  if (++thread_ticks >= TIME_SLICE)
c0020da0:	a1 60 c8 03 c0       	mov    0xc003c860,%eax
c0020da5:	40                   	inc    %eax
c0020da6:	a3 60 c8 03 c0       	mov    %eax,0xc003c860
c0020dab:	83 f8 03             	cmp    $0x3,%eax
c0020dae:	77 24                	ja     c0020dd4 <thread_tick+0x58>
}
c0020db0:	83 c4 0c             	add    $0xc,%esp
c0020db3:	c3                   	ret    
    idle_ticks++;
c0020db4:	83 05 78 c8 03 c0 01 	addl   $0x1,0xc003c878
c0020dbb:	83 15 7c c8 03 c0 00 	adcl   $0x0,0xc003c87c
c0020dc2:	eb dc                	jmp    c0020da0 <thread_tick+0x24>
    kernel_ticks++;
c0020dc4:	83 05 70 c8 03 c0 01 	addl   $0x1,0xc003c870
c0020dcb:	83 15 74 c8 03 c0 00 	adcl   $0x0,0xc003c874
c0020dd2:	eb cc                	jmp    c0020da0 <thread_tick+0x24>
    intr_yield_on_return ();
c0020dd4:	e8 a9 0e 00 00       	call   c0021c82 <intr_yield_on_return>
}
c0020dd9:	eb d5                	jmp    c0020db0 <thread_tick+0x34>

c0020ddb <thread_name>:
{
c0020ddb:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->name;
c0020dde:	e8 33 ff ff ff       	call   c0020d16 <thread_current>
c0020de3:	83 c0 0c             	add    $0xc,%eax
}
c0020de6:	83 c4 0c             	add    $0xc,%esp
c0020de9:	c3                   	ret    

c0020dea <thread_tid>:
{
c0020dea:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->tid;
c0020ded:	e8 24 ff ff ff       	call   c0020d16 <thread_current>
c0020df2:	8b 40 04             	mov    0x4(%eax),%eax
}
c0020df5:	83 c4 0c             	add    $0xc,%esp
c0020df8:	c3                   	ret    

c0020df9 <thread_foreach>:
{
c0020df9:	57                   	push   %edi
c0020dfa:	56                   	push   %esi
c0020dfb:	53                   	push   %ebx
c0020dfc:	8b 74 24 10          	mov    0x10(%esp),%esi
c0020e00:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c0020e04:	e8 15 0c 00 00       	call   c0021a1e <intr_get_level>
c0020e09:	85 c0                	test   %eax,%eax
c0020e0b:	75 14                	jne    c0020e21 <thread_foreach+0x28>
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e0d:	83 ec 0c             	sub    $0xc,%esp
c0020e10:	68 bc c8 03 c0       	push   $0xc003c8bc
c0020e15:	e8 4d 79 00 00       	call   c0028767 <list_begin>
c0020e1a:	89 c3                	mov    %eax,%ebx
c0020e1c:	83 c4 10             	add    $0x10,%esp
c0020e1f:	eb 38                	jmp    c0020e59 <thread_foreach+0x60>
  ASSERT (intr_get_level () == INTR_OFF);
c0020e21:	83 ec 0c             	sub    $0xc,%esp
c0020e24:	68 f6 12 03 c0       	push   $0xc00312f6
c0020e29:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020e2e:	68 c0 f5 02 c0       	push   $0xc002f5c0
c0020e33:	68 88 01 00 00       	push   $0x188
c0020e38:	68 90 12 03 c0       	push   $0xc0031290
c0020e3d:	e8 3b 78 00 00       	call   c002867d <debug_panic>
      func (t, aux);
c0020e42:	83 ec 08             	sub    $0x8,%esp
c0020e45:	57                   	push   %edi
      struct thread *t = list_entry (e, struct thread, allelem);
c0020e46:	8d 43 ac             	lea    -0x54(%ebx),%eax
      func (t, aux);
c0020e49:	50                   	push   %eax
c0020e4a:	ff d6                	call   *%esi
       e = list_next (e))
c0020e4c:	89 1c 24             	mov    %ebx,(%esp)
c0020e4f:	e8 43 79 00 00       	call   c0028797 <list_next>
c0020e54:	89 c3                	mov    %eax,%ebx
c0020e56:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e59:	83 ec 0c             	sub    $0xc,%esp
c0020e5c:	68 bc c8 03 c0       	push   $0xc003c8bc
c0020e61:	e8 79 79 00 00       	call   c00287df <list_end>
c0020e66:	83 c4 10             	add    $0x10,%esp
c0020e69:	39 c3                	cmp    %eax,%ebx
c0020e6b:	75 d5                	jne    c0020e42 <thread_foreach+0x49>
}
c0020e6d:	5b                   	pop    %ebx
c0020e6e:	5e                   	pop    %esi
c0020e6f:	5f                   	pop    %edi
c0020e70:	c3                   	ret    

c0020e71 <thread_ready_list_get_min>:
thread_ready_list_get_min() {
c0020e71:	83 ec 18             	sub    $0x18,%esp
  ASSERT (! list_empty(&ready_list));
c0020e74:	68 cc c8 03 c0       	push   $0xc003c8cc
c0020e79:	e8 9a 7d 00 00       	call   c0028c18 <list_empty>
c0020e7e:	83 c4 10             	add    $0x10,%esp
c0020e81:	84 c0                	test   %al,%al
c0020e83:	75 18                	jne    c0020e9d <thread_ready_list_get_min+0x2c>
  struct list_elem* e = list_min(&ready_list, thread_priority_greater, NULL);
c0020e85:	83 ec 04             	sub    $0x4,%esp
c0020e88:	6a 00                	push   $0x0
c0020e8a:	68 1a 10 02 c0       	push   $0xc002101a
c0020e8f:	68 cc c8 03 c0       	push   $0xc003c8cc
c0020e94:	e8 cb 83 00 00       	call   c0029264 <list_min>
}
c0020e99:	83 c4 1c             	add    $0x1c,%esp
c0020e9c:	c3                   	ret    
  ASSERT (! list_empty(&ready_list));
c0020e9d:	83 ec 0c             	sub    $0xc,%esp
c0020ea0:	68 35 13 03 c0       	push   $0xc0031335
c0020ea5:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020eaa:	68 a4 f5 02 c0       	push   $0xc002f5a4
c0020eaf:	68 95 01 00 00       	push   $0x195
c0020eb4:	68 90 12 03 c0       	push   $0xc0031290
c0020eb9:	e8 bf 77 00 00       	call   c002867d <debug_panic>

c0020ebe <thread_insert_ready_list>:
thread_insert_ready_list(struct list_elem* elem) {
c0020ebe:	83 ec 14             	sub    $0x14,%esp
    list_push_back(&ready_list, elem);
c0020ec1:	ff 74 24 18          	pushl  0x18(%esp)
c0020ec5:	68 cc c8 03 c0       	push   $0xc003c8cc
c0020eca:	e8 a1 7c 00 00       	call   c0028b70 <list_push_back>
}
c0020ecf:	83 c4 1c             	add    $0x1c,%esp
c0020ed2:	c3                   	ret    

c0020ed3 <thread_unblock>:
{
c0020ed3:	56                   	push   %esi
c0020ed4:	53                   	push   %ebx
c0020ed5:	83 ec 04             	sub    $0x4,%esp
c0020ed8:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (is_thread (t));
c0020edc:	89 d8                	mov    %ebx,%eax
c0020ede:	e8 45 fc ff ff       	call   c0020b28 <is_thread>
c0020ee3:	84 c0                	test   %al,%al
c0020ee5:	74 2e                	je     c0020f15 <thread_unblock+0x42>
  old_level = intr_disable ();
c0020ee7:	e8 6f 0b 00 00       	call   c0021a5b <intr_disable>
c0020eec:	89 c6                	mov    %eax,%esi
  ASSERT (t->status == THREAD_BLOCKED);
c0020eee:	83 7b 08 02          	cmpl   $0x2,0x8(%ebx)
c0020ef2:	75 42                	jne    c0020f36 <thread_unblock+0x63>
  thread_insert_ready_list(&t->elem);
c0020ef4:	83 ec 0c             	sub    $0xc,%esp
c0020ef7:	8d 43 5c             	lea    0x5c(%ebx),%eax
c0020efa:	50                   	push   %eax
c0020efb:	e8 be ff ff ff       	call   c0020ebe <thread_insert_ready_list>
  t->status = THREAD_READY;
c0020f00:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
  intr_set_level (old_level);
c0020f07:	89 34 24             	mov    %esi,(%esp)
c0020f0a:	e8 53 0b 00 00       	call   c0021a62 <intr_set_level>
}
c0020f0f:	83 c4 14             	add    $0x14,%esp
c0020f12:	5b                   	pop    %ebx
c0020f13:	5e                   	pop    %esi
c0020f14:	c3                   	ret    
  ASSERT (is_thread (t));
c0020f15:	83 ec 0c             	sub    $0xc,%esp
c0020f18:	68 ca 12 03 c0       	push   $0xc00312ca
c0020f1d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020f22:	68 fc f5 02 c0       	push   $0xc002f5fc
c0020f27:	68 19 01 00 00       	push   $0x119
c0020f2c:	68 90 12 03 c0       	push   $0xc0031290
c0020f31:	e8 47 77 00 00       	call   c002867d <debug_panic>
  ASSERT (t->status == THREAD_BLOCKED);
c0020f36:	83 ec 0c             	sub    $0xc,%esp
c0020f39:	68 4f 13 03 c0       	push   $0xc003134f
c0020f3e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020f43:	68 fc f5 02 c0       	push   $0xc002f5fc
c0020f48:	68 1c 01 00 00       	push   $0x11c
c0020f4d:	68 90 12 03 c0       	push   $0xc0031290
c0020f52:	e8 26 77 00 00       	call   c002867d <debug_panic>

c0020f57 <thread_update_sleep>:
{
c0020f57:	53                   	push   %ebx
c0020f58:	83 ec 08             	sub    $0x8,%esp
c0020f5b:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (is_thread(t));
c0020f5f:	89 d8                	mov    %ebx,%eax
c0020f61:	e8 c2 fb ff ff       	call   c0020b28 <is_thread>
c0020f66:	84 c0                	test   %al,%al
c0020f68:	74 14                	je     c0020f7e <thread_update_sleep+0x27>
  if (t->sleep_remain > 0) {
c0020f6a:	8b 43 24             	mov    0x24(%ebx),%eax
c0020f6d:	85 c0                	test   %eax,%eax
c0020f6f:	7e 08                	jle    c0020f79 <thread_update_sleep+0x22>
    if (!--(t->sleep_remain)) {
c0020f71:	48                   	dec    %eax
c0020f72:	89 43 24             	mov    %eax,0x24(%ebx)
c0020f75:	85 c0                	test   %eax,%eax
c0020f77:	74 26                	je     c0020f9f <thread_update_sleep+0x48>
}
c0020f79:	83 c4 08             	add    $0x8,%esp
c0020f7c:	5b                   	pop    %ebx
c0020f7d:	c3                   	ret    
  ASSERT (is_thread(t));
c0020f7e:	83 ec 0c             	sub    $0xc,%esp
c0020f81:	68 6b 13 03 c0       	push   $0xc003136b
c0020f86:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0020f8b:	68 4c f5 02 c0       	push   $0xc002f54c
c0020f90:	68 33 02 00 00       	push   $0x233
c0020f95:	68 90 12 03 c0       	push   $0xc0031290
c0020f9a:	e8 de 76 00 00       	call   c002867d <debug_panic>
      thread_unblock (t);
c0020f9f:	83 ec 0c             	sub    $0xc,%esp
c0020fa2:	53                   	push   %ebx
c0020fa3:	e8 2b ff ff ff       	call   c0020ed3 <thread_unblock>
c0020fa8:	83 c4 10             	add    $0x10,%esp
}
c0020fab:	eb cc                	jmp    c0020f79 <thread_update_sleep+0x22>

c0020fad <thread_set_nice>:
{
c0020fad:	83 ec 0c             	sub    $0xc,%esp
  thread_current()->nice = nice;
c0020fb0:	e8 61 fd ff ff       	call   c0020d16 <thread_current>
c0020fb5:	8b 54 24 10          	mov    0x10(%esp),%edx
c0020fb9:	89 50 28             	mov    %edx,0x28(%eax)
  if (thread_mlfqs) {
c0020fbc:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c0020fc3:	75 04                	jne    c0020fc9 <thread_set_nice+0x1c>
}
c0020fc5:	83 c4 0c             	add    $0xc,%esp
c0020fc8:	c3                   	ret    
    thread_update_priority(thread_current(), NULL);
c0020fc9:	e8 48 fd ff ff       	call   c0020d16 <thread_current>
c0020fce:	83 ec 08             	sub    $0x8,%esp
c0020fd1:	6a 00                	push   $0x0
c0020fd3:	50                   	push   %eax
c0020fd4:	e8 1a fc ff ff       	call   c0020bf3 <thread_update_priority>
c0020fd9:	83 c4 10             	add    $0x10,%esp
}
c0020fdc:	eb e7                	jmp    c0020fc5 <thread_set_nice+0x18>

c0020fde <thread_get_nice>:
{
c0020fde:	83 ec 0c             	sub    $0xc,%esp
  return thread_current()->nice;
c0020fe1:	e8 30 fd ff ff       	call   c0020d16 <thread_current>
c0020fe6:	8b 40 28             	mov    0x28(%eax),%eax
}
c0020fe9:	83 c4 0c             	add    $0xc,%esp
c0020fec:	c3                   	ret    

c0020fed <thread_get_certain_priority>:
{
c0020fed:	8b 54 24 04          	mov    0x4(%esp),%edx
  if (thread_mlfqs) {
c0020ff1:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c0020ff8:	75 07                	jne    c0021001 <thread_get_certain_priority+0x14>
    return t->max_donate_delta + t->priority;
c0020ffa:	8b 42 20             	mov    0x20(%edx),%eax
c0020ffd:	03 42 40             	add    0x40(%edx),%eax
}
c0021000:	c3                   	ret    
    return t->priority;
c0021001:	8b 42 20             	mov    0x20(%edx),%eax
c0021004:	c3                   	ret    

c0021005 <thread_get_priority>:
{
c0021005:	83 ec 0c             	sub    $0xc,%esp
  return thread_get_certain_priority (thread_current ());
c0021008:	e8 09 fd ff ff       	call   c0020d16 <thread_current>
c002100d:	83 ec 0c             	sub    $0xc,%esp
c0021010:	50                   	push   %eax
c0021011:	e8 d7 ff ff ff       	call   c0020fed <thread_get_certain_priority>
}
c0021016:	83 c4 1c             	add    $0x1c,%esp
c0021019:	c3                   	ret    

c002101a <thread_priority_greater>:
{
c002101a:	53                   	push   %ebx
  return thread_get_certain_priority (list_entry (a_, struct thread, elem))
c002101b:	8b 44 24 08          	mov    0x8(%esp),%eax
c002101f:	83 e8 5c             	sub    $0x5c,%eax
c0021022:	50                   	push   %eax
c0021023:	e8 c5 ff ff ff       	call   c0020fed <thread_get_certain_priority>
c0021028:	89 c3                	mov    %eax,%ebx
       > thread_get_certain_priority (list_entry (b_, struct thread, elem));
c002102a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002102e:	83 e8 5c             	sub    $0x5c,%eax
c0021031:	89 04 24             	mov    %eax,(%esp)
c0021034:	e8 b4 ff ff ff       	call   c0020fed <thread_get_certain_priority>
c0021039:	83 c4 04             	add    $0x4,%esp
c002103c:	39 c3                	cmp    %eax,%ebx
c002103e:	0f 9f c0             	setg   %al
}
c0021041:	5b                   	pop    %ebx
c0021042:	c3                   	ret    

c0021043 <thread_get_load_avg>:
{
c0021043:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT(thread_mlfqs);
c0021046:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c002104d:	74 22                	je     c0021071 <thread_get_load_avg+0x2e>
  return fixed32_round(fixed32_mul_int(load_avg, 100));
c002104f:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0021053:	83 ec 04             	sub    $0x4,%esp
c0021056:	6a 64                	push   $0x64
c0021058:	ff 35 dc c8 03 c0    	pushl  0xc003c8dc
c002105e:	50                   	push   %eax
c002105f:	e8 28 2e 00 00       	call   c0023e8c <fixed32_mul_int>
c0021064:	ff 74 24 18          	pushl  0x18(%esp)
c0021068:	e8 d5 2c 00 00       	call   c0023d42 <fixed32_round>
}
c002106d:	83 c4 2c             	add    $0x2c,%esp
c0021070:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0021071:	83 ec 0c             	sub    $0xc,%esp
c0021074:	68 78 13 03 c0       	push   $0xc0031378
c0021079:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002107e:	68 90 f5 02 c0       	push   $0xc002f590
c0021083:	68 f7 01 00 00       	push   $0x1f7
c0021088:	68 90 12 03 c0       	push   $0xc0031290
c002108d:	e8 eb 75 00 00       	call   c002867d <debug_panic>

c0021092 <thread_update_recent_cpu>:
{
c0021092:	57                   	push   %edi
c0021093:	56                   	push   %esi
c0021094:	53                   	push   %ebx
c0021095:	83 ec 10             	sub    $0x10,%esp
c0021098:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  ASSERT(thread_mlfqs);
c002109c:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c00210a3:	74 48                	je     c00210ed <thread_update_recent_cpu+0x5b>
  int load_avg_2 = thread_get_load_avg() * 2;
c00210a5:	e8 99 ff ff ff       	call   c0021043 <thread_get_load_avg>
c00210aa:	01 c0                	add    %eax,%eax
  t->recent_cpu = fixed32_add_int(
c00210ac:	8b 7b 28             	mov    0x28(%ebx),%edi
c00210af:	8d 74 24 0c          	lea    0xc(%esp),%esi
c00210b3:	83 ec 04             	sub    $0x4,%esp
c00210b6:	8d 50 64             	lea    0x64(%eax),%edx
c00210b9:	52                   	push   %edx
c00210ba:	50                   	push   %eax
c00210bb:	56                   	push   %esi
c00210bc:	e8 23 2e 00 00       	call   c0023ee4 <fixed32_div_int_int>
c00210c1:	83 ec 08             	sub    $0x8,%esp
c00210c4:	ff 73 2c             	pushl  0x2c(%ebx)
c00210c7:	ff 74 24 24          	pushl  0x24(%esp)
c00210cb:	56                   	push   %esi
c00210cc:	e8 6e 2d 00 00       	call   c0023e3f <fixed32_mul>
c00210d1:	83 c4 08             	add    $0x8,%esp
c00210d4:	57                   	push   %edi
c00210d5:	ff 74 24 24          	pushl  0x24(%esp)
c00210d9:	56                   	push   %esi
c00210da:	e8 25 2d 00 00       	call   c0023e04 <fixed32_add_int>
c00210df:	8b 44 24 28          	mov    0x28(%esp),%eax
c00210e3:	89 43 2c             	mov    %eax,0x2c(%ebx)
}
c00210e6:	83 c4 2c             	add    $0x2c,%esp
c00210e9:	5b                   	pop    %ebx
c00210ea:	5e                   	pop    %esi
c00210eb:	5f                   	pop    %edi
c00210ec:	c3                   	ret    
  ASSERT(thread_mlfqs);
c00210ed:	83 ec 0c             	sub    $0xc,%esp
c00210f0:	68 78 13 03 c0       	push   $0xc0031378
c00210f5:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00210fa:	68 30 f5 02 c0       	push   $0xc002f530
c00210ff:	68 0a 02 00 00       	push   $0x20a
c0021104:	68 90 12 03 c0       	push   $0xc0031290
c0021109:	e8 6f 75 00 00       	call   c002867d <debug_panic>

c002110e <thread_add_recent_cpu>:
{
c002110e:	53                   	push   %ebx
c002110f:	83 ec 18             	sub    $0x18,%esp
  ASSERT(thread_mlfqs);
c0021112:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c0021119:	74 3b                	je     c0021156 <thread_add_recent_cpu+0x48>
  struct thread* t = thread_current();
c002111b:	e8 f6 fb ff ff       	call   c0020d16 <thread_current>
c0021120:	89 c3                	mov    %eax,%ebx
  if (t != idle_thread) {
c0021122:	3b 05 b8 c8 03 c0    	cmp    0xc003c8b8,%eax
c0021128:	74 1c                	je     c0021146 <thread_add_recent_cpu+0x38>
    t->recent_cpu = fixed32_add_int(t->recent_cpu, 1);
c002112a:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002112e:	83 ec 04             	sub    $0x4,%esp
c0021131:	6a 01                	push   $0x1
c0021133:	ff 73 2c             	pushl  0x2c(%ebx)
c0021136:	50                   	push   %eax
c0021137:	e8 c8 2c 00 00       	call   c0023e04 <fixed32_add_int>
c002113c:	8b 44 24 18          	mov    0x18(%esp),%eax
c0021140:	89 43 2c             	mov    %eax,0x2c(%ebx)
c0021143:	83 c4 0c             	add    $0xc,%esp
  thread_update_priority(t, NULL);
c0021146:	83 ec 08             	sub    $0x8,%esp
c0021149:	6a 00                	push   $0x0
c002114b:	53                   	push   %ebx
c002114c:	e8 a2 fa ff ff       	call   c0020bf3 <thread_update_priority>
}
c0021151:	83 c4 28             	add    $0x28,%esp
c0021154:	5b                   	pop    %ebx
c0021155:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0021156:	83 ec 0c             	sub    $0xc,%esp
c0021159:	68 78 13 03 c0       	push   $0xc0031378
c002115e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021163:	68 78 f5 02 c0       	push   $0xc002f578
c0021168:	68 fe 01 00 00       	push   $0x1fe
c002116d:	68 90 12 03 c0       	push   $0xc0031290
c0021172:	e8 06 75 00 00       	call   c002867d <debug_panic>

c0021177 <thread_get_recent_cpu>:
{
c0021177:	83 ec 1c             	sub    $0x1c,%esp
  ASSERT(thread_mlfqs);
c002117a:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c0021181:	74 24                	je     c00211a7 <thread_get_recent_cpu+0x30>
  return fixed32_trunc(fixed32_mul_int(thread_current()->recent_cpu, 100));
c0021183:	e8 8e fb ff ff       	call   c0020d16 <thread_current>
c0021188:	8d 54 24 0c          	lea    0xc(%esp),%edx
c002118c:	83 ec 04             	sub    $0x4,%esp
c002118f:	6a 64                	push   $0x64
c0021191:	ff 70 2c             	pushl  0x2c(%eax)
c0021194:	52                   	push   %edx
c0021195:	e8 f2 2c 00 00       	call   c0023e8c <fixed32_mul_int>
c002119a:	ff 74 24 18          	pushl  0x18(%esp)
c002119e:	e8 89 2b 00 00       	call   c0023d2c <fixed32_trunc>
}
c00211a3:	83 c4 2c             	add    $0x2c,%esp
c00211a6:	c3                   	ret    
  ASSERT(thread_mlfqs);
c00211a7:	83 ec 0c             	sub    $0xc,%esp
c00211aa:	68 78 13 03 c0       	push   $0xc0031378
c00211af:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00211b4:	68 60 f5 02 c0       	push   $0xc002f560
c00211b9:	68 16 02 00 00       	push   $0x216
c00211be:	68 90 12 03 c0       	push   $0xc0031290
c00211c3:	e8 b5 74 00 00       	call   c002867d <debug_panic>

c00211c8 <thread_tick_events>:
void thread_tick_events(bool a_second) {
c00211c8:	56                   	push   %esi
c00211c9:	53                   	push   %ebx
c00211ca:	83 ec 14             	sub    $0x14,%esp
c00211cd:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  if (thread_mlfqs) {
c00211d1:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c00211d8:	75 15                	jne    c00211ef <thread_tick_events+0x27>
  thread_foreach(thread_update_sleep, NULL);
c00211da:	83 ec 08             	sub    $0x8,%esp
c00211dd:	6a 00                	push   $0x0
c00211df:	68 57 0f 02 c0       	push   $0xc0020f57
c00211e4:	e8 10 fc ff ff       	call   c0020df9 <thread_foreach>
}
c00211e9:	83 c4 24             	add    $0x24,%esp
c00211ec:	5b                   	pop    %ebx
c00211ed:	5e                   	pop    %esi
c00211ee:	c3                   	ret    
    thread_add_recent_cpu();
c00211ef:	e8 1a ff ff ff       	call   c002110e <thread_add_recent_cpu>
    if (a_second) {
c00211f4:	84 db                	test   %bl,%bl
c00211f6:	74 e2                	je     c00211da <thread_tick_events+0x12>
  ASSERT(thread_mlfqs);
c00211f8:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c00211ff:	74 19                	je     c002121a <thread_tick_events+0x52>
  for (e = list_begin (&all_list); e != list_end (&all_list); e = list_next (e)) {
c0021201:	83 ec 0c             	sub    $0xc,%esp
c0021204:	68 bc c8 03 c0       	push   $0xc003c8bc
c0021209:	e8 59 75 00 00       	call   c0028767 <list_begin>
c002120e:	89 c3                	mov    %eax,%ebx
c0021210:	83 c4 10             	add    $0x10,%esp
  int ready_count = 0;
c0021213:	be 00 00 00 00       	mov    $0x0,%esi
c0021218:	eb 2f                	jmp    c0021249 <thread_tick_events+0x81>
  ASSERT(thread_mlfqs);
c002121a:	83 ec 0c             	sub    $0xc,%esp
c002121d:	68 78 13 03 c0       	push   $0xc0031378
c0021222:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021227:	68 18 f5 02 c0       	push   $0xc002f518
c002122c:	68 d0 01 00 00       	push   $0x1d0
c0021231:	68 90 12 03 c0       	push   $0xc0031290
c0021236:	e8 42 74 00 00       	call   c002867d <debug_panic>
  for (e = list_begin (&all_list); e != list_end (&all_list); e = list_next (e)) {
c002123b:	83 ec 0c             	sub    $0xc,%esp
c002123e:	53                   	push   %ebx
c002123f:	e8 53 75 00 00       	call   c0028797 <list_next>
c0021244:	89 c3                	mov    %eax,%ebx
c0021246:	83 c4 10             	add    $0x10,%esp
c0021249:	83 ec 0c             	sub    $0xc,%esp
c002124c:	68 bc c8 03 c0       	push   $0xc003c8bc
c0021251:	e8 89 75 00 00       	call   c00287df <list_end>
c0021256:	83 c4 10             	add    $0x10,%esp
c0021259:	39 c3                	cmp    %eax,%ebx
c002125b:	74 14                	je     c0021271 <thread_tick_events+0xa9>
    if ((t->status == THREAD_RUNNING || t->status == THREAD_READY) && t != idle_thread) {
c002125d:	83 7b b4 01          	cmpl   $0x1,-0x4c(%ebx)
c0021261:	77 d8                	ja     c002123b <thread_tick_events+0x73>
    struct thread *t = list_entry (e, struct thread, allelem);
c0021263:	8d 43 ac             	lea    -0x54(%ebx),%eax
    if ((t->status == THREAD_RUNNING || t->status == THREAD_READY) && t != idle_thread) {
c0021266:	39 05 b8 c8 03 c0    	cmp    %eax,0xc003c8b8
c002126c:	74 cd                	je     c002123b <thread_tick_events+0x73>
      ready_count++;
c002126e:	46                   	inc    %esi
c002126f:	eb ca                	jmp    c002123b <thread_tick_events+0x73>
  load_avg = fixed32_div_int(
c0021271:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
c0021275:	83 ec 04             	sub    $0x4,%esp
c0021278:	6a 3b                	push   $0x3b
c002127a:	ff 35 dc c8 03 c0    	pushl  0xc003c8dc
c0021280:	53                   	push   %ebx
c0021281:	e8 06 2c 00 00       	call   c0023e8c <fixed32_mul_int>
c0021286:	83 ec 08             	sub    $0x8,%esp
c0021289:	56                   	push   %esi
c002128a:	ff 74 24 24          	pushl  0x24(%esp)
c002128e:	53                   	push   %ebx
c002128f:	e8 70 2b 00 00       	call   c0023e04 <fixed32_add_int>
c0021294:	83 c4 08             	add    $0x8,%esp
c0021297:	6a 3c                	push   $0x3c
c0021299:	ff 74 24 24          	pushl  0x24(%esp)
c002129d:	53                   	push   %ebx
c002129e:	e8 2d 2c 00 00       	call   c0023ed0 <fixed32_div_int>
c00212a3:	8b 44 24 28          	mov    0x28(%esp),%eax
c00212a7:	a3 dc c8 03 c0       	mov    %eax,0xc003c8dc
      thread_foreach(thread_update_recent_cpu, NULL);
c00212ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c00212b3:	68 92 10 02 c0       	push   $0xc0021092
c00212b8:	e8 3c fb ff ff       	call   c0020df9 <thread_foreach>
      thread_foreach(thread_update_priority, NULL);
c00212bd:	83 c4 18             	add    $0x18,%esp
c00212c0:	6a 00                	push   $0x0
c00212c2:	68 f3 0b 02 c0       	push   $0xc0020bf3
c00212c7:	e8 2d fb ff ff       	call   c0020df9 <thread_foreach>
c00212cc:	83 c4 10             	add    $0x10,%esp
c00212cf:	e9 06 ff ff ff       	jmp    c00211da <thread_tick_events+0x12>

c00212d4 <thread_schedule_tail>:
{
c00212d4:	56                   	push   %esi
c00212d5:	53                   	push   %ebx
c00212d6:	83 ec 04             	sub    $0x4,%esp
c00212d9:	8b 74 24 10          	mov    0x10(%esp),%esi
  asm ("mov %%esp, %0" : "=g" (esp));
c00212dd:	89 e3                	mov    %esp,%ebx
c00212df:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00212e5:	e8 34 07 00 00       	call   c0021a1e <intr_get_level>
c00212ea:	85 c0                	test   %eax,%eax
c00212ec:	75 26                	jne    c0021314 <thread_schedule_tail+0x40>
  cur->status = THREAD_RUNNING;
c00212ee:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  thread_ticks = 0;
c00212f5:	c7 05 60 c8 03 c0 00 	movl   $0x0,0xc003c860
c00212fc:	00 00 00 
  process_activate ();
c00212ff:	e8 c8 91 00 00       	call   c002a4cc <process_activate>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0021304:	85 f6                	test   %esi,%esi
c0021306:	74 06                	je     c002130e <thread_schedule_tail+0x3a>
c0021308:	83 7e 08 03          	cmpl   $0x3,0x8(%esi)
c002130c:	74 27                	je     c0021335 <thread_schedule_tail+0x61>
}
c002130e:	83 c4 04             	add    $0x4,%esp
c0021311:	5b                   	pop    %ebx
c0021312:	5e                   	pop    %esi
c0021313:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0021314:	83 ec 0c             	sub    $0xc,%esp
c0021317:	68 f6 12 03 c0       	push   $0xc00312f6
c002131c:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021321:	68 00 f5 02 c0       	push   $0xc002f500
c0021326:	68 f2 02 00 00       	push   $0x2f2
c002132b:	68 90 12 03 c0       	push   $0xc0031290
c0021330:	e8 48 73 00 00       	call   c002867d <debug_panic>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0021335:	3b 35 b4 c8 03 c0    	cmp    0xc003c8b4,%esi
c002133b:	74 d1                	je     c002130e <thread_schedule_tail+0x3a>
      ASSERT (prev != cur);
c002133d:	39 de                	cmp    %ebx,%esi
c002133f:	74 0e                	je     c002134f <thread_schedule_tail+0x7b>
      palloc_free_page (prev);
c0021341:	83 ec 0c             	sub    $0xc,%esp
c0021344:	56                   	push   %esi
c0021345:	e8 8e 24 00 00       	call   c00237d8 <palloc_free_page>
c002134a:	83 c4 10             	add    $0x10,%esp
}
c002134d:	eb bf                	jmp    c002130e <thread_schedule_tail+0x3a>
      ASSERT (prev != cur);
c002134f:	83 ec 0c             	sub    $0xc,%esp
c0021352:	68 85 13 03 c0       	push   $0xc0031385
c0021357:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002135c:	68 00 f5 02 c0       	push   $0xc002f500
c0021361:	68 06 03 00 00       	push   $0x306
c0021366:	68 90 12 03 c0       	push   $0xc0031290
c002136b:	e8 0d 73 00 00       	call   c002867d <debug_panic>

c0021370 <schedule>:
{
c0021370:	56                   	push   %esi
c0021371:	53                   	push   %ebx
c0021372:	83 ec 10             	sub    $0x10,%esp
  asm ("mov %%esp, %0" : "=g" (esp));
c0021375:	89 e3                	mov    %esp,%ebx
c0021377:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  if (list_empty (&ready_list))
c002137d:	68 cc c8 03 c0       	push   $0xc003c8cc
c0021382:	e8 91 78 00 00       	call   c0028c18 <list_empty>
c0021387:	83 c4 10             	add    $0x10,%esp
c002138a:	84 c0                	test   %al,%al
c002138c:	74 44                	je     c00213d2 <schedule+0x62>
    return idle_thread;
c002138e:	8b 35 b8 c8 03 c0    	mov    0xc003c8b8,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c0021394:	e8 85 06 00 00       	call   c0021a1e <intr_get_level>
c0021399:	85 c0                	test   %eax,%eax
c002139b:	75 4d                	jne    c00213ea <schedule+0x7a>
  ASSERT (cur->status != THREAD_RUNNING);
c002139d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c00213a1:	74 68                	je     c002140b <schedule+0x9b>
  ASSERT (is_thread (next));
c00213a3:	89 f0                	mov    %esi,%eax
c00213a5:	e8 7e f7 ff ff       	call   c0020b28 <is_thread>
c00213aa:	84 c0                	test   %al,%al
c00213ac:	74 7e                	je     c002142c <schedule+0xbc>
  if (cur != next)
c00213ae:	39 de                	cmp    %ebx,%esi
c00213b0:	0f 84 97 00 00 00    	je     c002144d <schedule+0xdd>
    prev = switch_threads (cur, next);
c00213b6:	83 ec 08             	sub    $0x8,%esp
c00213b9:	56                   	push   %esi
c00213ba:	53                   	push   %ebx
c00213bb:	e8 0d 05 00 00       	call   c00218cd <switch_threads>
c00213c0:	83 c4 10             	add    $0x10,%esp
  thread_schedule_tail (prev);
c00213c3:	83 ec 0c             	sub    $0xc,%esp
c00213c6:	50                   	push   %eax
c00213c7:	e8 08 ff ff ff       	call   c00212d4 <thread_schedule_tail>
}
c00213cc:	83 c4 14             	add    $0x14,%esp
c00213cf:	5b                   	pop    %ebx
c00213d0:	5e                   	pop    %esi
c00213d1:	c3                   	ret    
    struct list_elem* e = thread_ready_list_get_min();
c00213d2:	e8 9a fa ff ff       	call   c0020e71 <thread_ready_list_get_min>
c00213d7:	89 c6                	mov    %eax,%esi
    list_remove(e);
c00213d9:	83 ec 0c             	sub    $0xc,%esp
c00213dc:	50                   	push   %eax
c00213dd:	e8 ab 77 00 00       	call   c0028b8d <list_remove>
    return list_entry (e, struct thread, elem);
c00213e2:	83 ee 5c             	sub    $0x5c,%esi
c00213e5:	83 c4 10             	add    $0x10,%esp
c00213e8:	eb aa                	jmp    c0021394 <schedule+0x24>
  ASSERT (intr_get_level () == INTR_OFF);
c00213ea:	83 ec 0c             	sub    $0xc,%esp
c00213ed:	68 f6 12 03 c0       	push   $0xc00312f6
c00213f2:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00213f7:	68 0c f6 02 c0       	push   $0xc002f60c
c00213fc:	68 19 03 00 00       	push   $0x319
c0021401:	68 90 12 03 c0       	push   $0xc0031290
c0021406:	e8 72 72 00 00       	call   c002867d <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c002140b:	83 ec 0c             	sub    $0xc,%esp
c002140e:	68 91 13 03 c0       	push   $0xc0031391
c0021413:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021418:	68 0c f6 02 c0       	push   $0xc002f60c
c002141d:	68 1a 03 00 00       	push   $0x31a
c0021422:	68 90 12 03 c0       	push   $0xc0031290
c0021427:	e8 51 72 00 00       	call   c002867d <debug_panic>
  ASSERT (is_thread (next));
c002142c:	83 ec 0c             	sub    $0xc,%esp
c002142f:	68 af 13 03 c0       	push   $0xc00313af
c0021434:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021439:	68 0c f6 02 c0       	push   $0xc002f60c
c002143e:	68 1b 03 00 00       	push   $0x31b
c0021443:	68 90 12 03 c0       	push   $0xc0031290
c0021448:	e8 30 72 00 00       	call   c002867d <debug_panic>
  struct thread *prev = NULL;
c002144d:	b8 00 00 00 00       	mov    $0x0,%eax
c0021452:	e9 6c ff ff ff       	jmp    c00213c3 <schedule+0x53>

c0021457 <thread_block>:
{
c0021457:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (!intr_context ());
c002145a:	e8 1d 08 00 00       	call   c0021c7c <intr_context>
c002145f:	84 c0                	test   %al,%al
c0021461:	75 1e                	jne    c0021481 <thread_block+0x2a>
  ASSERT (intr_get_level () == INTR_OFF);
c0021463:	e8 b6 05 00 00       	call   c0021a1e <intr_get_level>
c0021468:	85 c0                	test   %eax,%eax
c002146a:	75 36                	jne    c00214a2 <thread_block+0x4b>
  thread_current ()->status = THREAD_BLOCKED;
c002146c:	e8 a5 f8 ff ff       	call   c0020d16 <thread_current>
c0021471:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
  schedule ();
c0021478:	e8 f3 fe ff ff       	call   c0021370 <schedule>
}
c002147d:	83 c4 0c             	add    $0xc,%esp
c0021480:	c3                   	ret    
  ASSERT (!intr_context ());
c0021481:	83 ec 0c             	sub    $0xc,%esp
c0021484:	68 c0 13 03 c0       	push   $0xc00313c0
c0021489:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002148e:	68 18 f6 02 c0       	push   $0xc002f618
c0021493:	68 05 01 00 00       	push   $0x105
c0021498:	68 90 12 03 c0       	push   $0xc0031290
c002149d:	e8 db 71 00 00       	call   c002867d <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c00214a2:	83 ec 0c             	sub    $0xc,%esp
c00214a5:	68 f6 12 03 c0       	push   $0xc00312f6
c00214aa:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00214af:	68 18 f6 02 c0       	push   $0xc002f618
c00214b4:	68 06 01 00 00       	push   $0x106
c00214b9:	68 90 12 03 c0       	push   $0xc0031290
c00214be:	e8 ba 71 00 00       	call   c002867d <debug_panic>

c00214c3 <idle>:
{
c00214c3:	83 ec 0c             	sub    $0xc,%esp
  idle_thread = thread_current ();
c00214c6:	e8 4b f8 ff ff       	call   c0020d16 <thread_current>
c00214cb:	a3 b8 c8 03 c0       	mov    %eax,0xc003c8b8
  sema_up (idle_started);
c00214d0:	83 ec 0c             	sub    $0xc,%esp
c00214d3:	ff 74 24 1c          	pushl  0x1c(%esp)
c00214d7:	e8 f8 16 00 00       	call   c0022bd4 <sema_up>
c00214dc:	83 c4 10             	add    $0x10,%esp
      intr_disable ();
c00214df:	e8 77 05 00 00       	call   c0021a5b <intr_disable>
      thread_block ();
c00214e4:	e8 6e ff ff ff       	call   c0021457 <thread_block>
      asm volatile ("sti; hlt" : : : "memory");
c00214e9:	fb                   	sti    
c00214ea:	f4                   	hlt    
c00214eb:	eb f2                	jmp    c00214df <idle+0x1c>

c00214ed <thread_yield>:
{
c00214ed:	56                   	push   %esi
c00214ee:	53                   	push   %ebx
c00214ef:	83 ec 04             	sub    $0x4,%esp
  struct thread *cur = thread_current ();
c00214f2:	e8 1f f8 ff ff       	call   c0020d16 <thread_current>
c00214f7:	89 c3                	mov    %eax,%ebx
  ASSERT (!intr_context ());
c00214f9:	e8 7e 07 00 00       	call   c0021c7c <intr_context>
c00214fe:	84 c0                	test   %al,%al
c0021500:	75 39                	jne    c002153b <thread_yield+0x4e>
  old_level = intr_disable ();
c0021502:	e8 54 05 00 00       	call   c0021a5b <intr_disable>
c0021507:	89 c6                	mov    %eax,%esi
  if (cur != idle_thread) 
c0021509:	3b 1d b8 c8 03 c0    	cmp    0xc003c8b8,%ebx
c002150f:	74 0f                	je     c0021520 <thread_yield+0x33>
    thread_insert_ready_list (&cur->elem);
c0021511:	83 ec 0c             	sub    $0xc,%esp
c0021514:	8d 43 5c             	lea    0x5c(%ebx),%eax
c0021517:	50                   	push   %eax
c0021518:	e8 a1 f9 ff ff       	call   c0020ebe <thread_insert_ready_list>
c002151d:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0021520:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
  schedule ();
c0021527:	e8 44 fe ff ff       	call   c0021370 <schedule>
  intr_set_level (old_level);
c002152c:	83 ec 0c             	sub    $0xc,%esp
c002152f:	56                   	push   %esi
c0021530:	e8 2d 05 00 00       	call   c0021a62 <intr_set_level>
}
c0021535:	83 c4 14             	add    $0x14,%esp
c0021538:	5b                   	pop    %ebx
c0021539:	5e                   	pop    %esi
c002153a:	c3                   	ret    
  ASSERT (!intr_context ());
c002153b:	83 ec 0c             	sub    $0xc,%esp
c002153e:	68 c0 13 03 c0       	push   $0xc00313c0
c0021543:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021548:	68 d0 f5 02 c0       	push   $0xc002f5d0
c002154d:	68 77 01 00 00       	push   $0x177
c0021552:	68 90 12 03 c0       	push   $0xc0031290
c0021557:	e8 21 71 00 00       	call   c002867d <debug_panic>

c002155c <thread_check_switch>:
void thread_check_switch() {
c002155c:	56                   	push   %esi
c002155d:	53                   	push   %ebx
c002155e:	83 ec 04             	sub    $0x4,%esp
	enum intr_level old_level = intr_disable();
c0021561:	e8 f5 04 00 00       	call   c0021a5b <intr_disable>
c0021566:	89 c3                	mov    %eax,%ebx
  if (thread_current () != idle_thread &&
c0021568:	e8 a9 f7 ff ff       	call   c0020d16 <thread_current>
c002156d:	3b 05 b8 c8 03 c0    	cmp    0xc003c8b8,%eax
c0021573:	74 14                	je     c0021589 <thread_check_switch+0x2d>
   !list_empty (&ready_list) && 
c0021575:	83 ec 0c             	sub    $0xc,%esp
c0021578:	68 cc c8 03 c0       	push   $0xc003c8cc
c002157d:	e8 96 76 00 00       	call   c0028c18 <list_empty>
  if (thread_current () != idle_thread &&
c0021582:	83 c4 10             	add    $0x10,%esp
c0021585:	84 c0                	test   %al,%al
c0021587:	74 12                	je     c002159b <thread_check_switch+0x3f>
    intr_set_level (old_level);
c0021589:	83 ec 0c             	sub    $0xc,%esp
c002158c:	53                   	push   %ebx
c002158d:	e8 d0 04 00 00       	call   c0021a62 <intr_set_level>
c0021592:	83 c4 10             	add    $0x10,%esp
}
c0021595:	83 c4 04             	add    $0x4,%esp
c0021598:	5b                   	pop    %ebx
c0021599:	5e                   	pop    %esi
c002159a:	c3                   	ret    
   thread_get_priority () <
c002159b:	e8 65 fa ff ff       	call   c0021005 <thread_get_priority>
c00215a0:	89 c6                	mov    %eax,%esi
   thread_get_certain_priority (list_entry (thread_ready_list_get_min(), struct thread, elem))) {
c00215a2:	e8 ca f8 ff ff       	call   c0020e71 <thread_ready_list_get_min>
c00215a7:	83 ec 0c             	sub    $0xc,%esp
c00215aa:	83 e8 5c             	sub    $0x5c,%eax
c00215ad:	50                   	push   %eax
c00215ae:	e8 3a fa ff ff       	call   c0020fed <thread_get_certain_priority>
c00215b3:	83 c4 10             	add    $0x10,%esp
   !list_empty (&ready_list) && 
c00215b6:	39 c6                	cmp    %eax,%esi
c00215b8:	7d cf                	jge    c0021589 <thread_check_switch+0x2d>
    intr_set_level (old_level);
c00215ba:	83 ec 0c             	sub    $0xc,%esp
c00215bd:	53                   	push   %ebx
c00215be:	e8 9f 04 00 00       	call   c0021a62 <intr_set_level>
    thread_yield ();
c00215c3:	e8 25 ff ff ff       	call   c00214ed <thread_yield>
c00215c8:	83 c4 10             	add    $0x10,%esp
c00215cb:	eb c8                	jmp    c0021595 <thread_check_switch+0x39>

c00215cd <thread_create>:
{
c00215cd:	57                   	push   %edi
c00215ce:	56                   	push   %esi
c00215cf:	53                   	push   %ebx
c00215d0:	8b 7c 24 18          	mov    0x18(%esp),%edi
  ASSERT (function != NULL);
c00215d4:	85 ff                	test   %edi,%edi
c00215d6:	0f 84 f4 00 00 00    	je     c00216d0 <thread_create+0x103>
  t = palloc_get_page (PAL_ZERO);
c00215dc:	83 ec 0c             	sub    $0xc,%esp
c00215df:	6a 02                	push   $0x2
c00215e1:	e8 c8 20 00 00       	call   c00236ae <palloc_get_page>
c00215e6:	89 c3                	mov    %eax,%ebx
  if (t == NULL)
c00215e8:	83 c4 10             	add    $0x10,%esp
c00215eb:	85 c0                	test   %eax,%eax
c00215ed:	0f 84 fe 00 00 00    	je     c00216f1 <thread_create+0x124>
  init_thread (t, name, priority);
c00215f3:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00215f7:	8b 54 24 10          	mov    0x10(%esp),%edx
c00215fb:	e8 5a f3 ff ff       	call   c002095a <init_thread>
  lock_acquire (&tid_lock);
c0021600:	83 ec 0c             	sub    $0xc,%esp
c0021603:	68 80 c8 03 c0       	push   $0xc003c880
c0021608:	e8 c6 18 00 00       	call   c0022ed3 <lock_acquire>
  tid = next_tid++;
c002160d:	8b 35 50 c2 03 c0    	mov    0xc003c250,%esi
c0021613:	8d 46 01             	lea    0x1(%esi),%eax
c0021616:	a3 50 c2 03 c0       	mov    %eax,0xc003c250
  lock_release (&tid_lock);
c002161b:	c7 04 24 80 c8 03 c0 	movl   $0xc003c880,(%esp)
c0021622:	e8 49 1a 00 00       	call   c0023070 <lock_release>
  tid = t->tid = allocate_tid ();
c0021627:	89 73 04             	mov    %esi,0x4(%ebx)
	struct child_process *ch = malloc(sizeof(*ch));
c002162a:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c0021631:	e8 ee 23 00 00       	call   c0023a24 <malloc>
  ch->tid = t->tid;
c0021636:	89 30                	mov    %esi,(%eax)
  ch->ret_status = t->ret_status;
c0021638:	8b 53 68             	mov    0x68(%ebx),%edx
c002163b:	89 50 04             	mov    %edx,0x4(%eax)
  ch->done = false;
c002163e:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  ch->waited = false;
c0021642:	c6 40 09 00          	movb   $0x0,0x9(%eax)
  asm ("mov %%esp, %0" : "=g" (esp));
c0021646:	89 e2                	mov    %esp,%edx
	list_push_back(&running_thread()->children, &ch->elem);
c0021648:	83 c4 08             	add    $0x8,%esp
c002164b:	83 c0 0c             	add    $0xc,%eax
c002164e:	50                   	push   %eax
c002164f:	89 d0                	mov    %edx,%eax
c0021651:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0021656:	05 a8 00 00 00       	add    $0xa8,%eax
c002165b:	50                   	push   %eax
c002165c:	e8 0f 75 00 00       	call   c0028b70 <list_push_back>
  t->dir = thread_current()->dir;
c0021661:	e8 b0 f6 ff ff       	call   c0020d16 <thread_current>
c0021666:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c002166c:	89 83 e4 00 00 00    	mov    %eax,0xe4(%ebx)
  kf = alloc_frame (t, sizeof *kf);
c0021672:	ba 0c 00 00 00       	mov    $0xc,%edx
c0021677:	89 d8                	mov    %ebx,%eax
c0021679:	e8 0b f5 ff ff       	call   c0020b89 <alloc_frame>
  kf->eip = NULL;
c002167e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0021684:	89 78 04             	mov    %edi,0x4(%eax)
  kf->aux = aux;
c0021687:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c002168b:	89 50 08             	mov    %edx,0x8(%eax)
  ef = alloc_frame (t, sizeof *ef);
c002168e:	ba 04 00 00 00       	mov    $0x4,%edx
c0021693:	89 d8                	mov    %ebx,%eax
c0021695:	e8 ef f4 ff ff       	call   c0020b89 <alloc_frame>
  ef->eip = (void (*) (void)) kernel_thread;
c002169a:	c7 00 73 18 02 c0    	movl   $0xc0021873,(%eax)
  sf = alloc_frame (t, sizeof *sf);
c00216a0:	ba 1c 00 00 00       	mov    $0x1c,%edx
c00216a5:	89 d8                	mov    %ebx,%eax
c00216a7:	e8 dd f4 ff ff       	call   c0020b89 <alloc_frame>
  sf->eip = switch_entry;
c00216ac:	c7 40 10 ea 18 02 c0 	movl   $0xc00218ea,0x10(%eax)
  sf->ebp = 0;
c00216b3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  thread_unblock (t);
c00216ba:	89 1c 24             	mov    %ebx,(%esp)
c00216bd:	e8 11 f8 ff ff       	call   c0020ed3 <thread_unblock>
  thread_check_switch();
c00216c2:	e8 95 fe ff ff       	call   c002155c <thread_check_switch>
	return tid;
c00216c7:	83 c4 10             	add    $0x10,%esp
}
c00216ca:	89 f0                	mov    %esi,%eax
c00216cc:	5b                   	pop    %ebx
c00216cd:	5e                   	pop    %esi
c00216ce:	5f                   	pop    %edi
c00216cf:	c3                   	ret    
  ASSERT (function != NULL);
c00216d0:	83 ec 0c             	sub    $0xc,%esp
c00216d3:	68 d1 13 03 c0       	push   $0xc00313d1
c00216d8:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00216dd:	68 44 f6 02 c0       	push   $0xc002f644
c00216e2:	68 cc 00 00 00       	push   $0xcc
c00216e7:	68 90 12 03 c0       	push   $0xc0031290
c00216ec:	e8 8c 6f 00 00       	call   c002867d <debug_panic>
    return TID_ERROR;
c00216f1:	be ff ff ff ff       	mov    $0xffffffff,%esi
c00216f6:	eb d2                	jmp    c00216ca <thread_create+0xfd>

c00216f8 <thread_start>:
{
c00216f8:	53                   	push   %ebx
c00216f9:	83 ec 30             	sub    $0x30,%esp
  sema_init (&idle_started, 0);
c00216fc:	6a 00                	push   $0x0
c00216fe:	8d 5c 24 18          	lea    0x18(%esp),%ebx
c0021702:	53                   	push   %ebx
c0021703:	e8 7d 13 00 00       	call   c0022a85 <sema_init>
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c0021708:	53                   	push   %ebx
c0021709:	68 c3 14 02 c0       	push   $0xc00214c3
c002170e:	6a 00                	push   $0x0
c0021710:	68 e2 13 03 c0       	push   $0xc00313e2
c0021715:	e8 b3 fe ff ff       	call   c00215cd <thread_create>
  intr_enable ();
c002171a:	83 c4 20             	add    $0x20,%esp
c002171d:	e8 05 03 00 00       	call   c0021a27 <intr_enable>
  sema_down (&idle_started);
c0021722:	83 ec 0c             	sub    $0xc,%esp
c0021725:	53                   	push   %ebx
c0021726:	e8 c8 13 00 00       	call   c0022af3 <sema_down>
}
c002172b:	83 c4 38             	add    $0x38,%esp
c002172e:	5b                   	pop    %ebx
c002172f:	c3                   	ret    

c0021730 <thread_set_priority>:
  if (thread_mlfqs) {
c0021730:	80 3d 3c 6c 04 c0 00 	cmpb   $0x0,0xc0046c3c
c0021737:	74 01                	je     c002173a <thread_set_priority+0xa>
}
c0021739:	c3                   	ret    
{
c002173a:	83 ec 0c             	sub    $0xc,%esp
  struct thread* t = thread_current ();
c002173d:	e8 d4 f5 ff ff       	call   c0020d16 <thread_current>
  if (t->max_donate_delta) {
c0021742:	83 78 40 00          	cmpl   $0x0,0x40(%eax)
c0021746:	74 0c                	je     c0021754 <thread_set_priority+0x24>
    t->priority_to_set = new_priority;
c0021748:	8b 54 24 10          	mov    0x10(%esp),%edx
c002174c:	89 50 44             	mov    %edx,0x44(%eax)
}
c002174f:	83 c4 0c             	add    $0xc,%esp
c0021752:	eb e5                	jmp    c0021739 <thread_set_priority+0x9>
    t->priority = new_priority;
c0021754:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0021758:	89 48 20             	mov    %ecx,0x20(%eax)
    thread_check_switch();
c002175b:	e8 fc fd ff ff       	call   c002155c <thread_check_switch>
c0021760:	eb ed                	jmp    c002174f <thread_set_priority+0x1f>

c0021762 <get_child_by_tid>:
/* Offset of `stack' member within `struct thread'.
   Used by switch.S, which can't figure it out on its own. */
uint32_t thread_stack_ofs = offsetof (struct thread, stack);

struct child_process *
get_child_by_tid(struct list* children, tid_t tid) {
c0021762:	57                   	push   %edi
c0021763:	56                   	push   %esi
c0021764:	53                   	push   %ebx
c0021765:	8b 74 24 10          	mov    0x10(%esp),%esi
c0021769:	8b 7c 24 14          	mov    0x14(%esp),%edi
//	ASSERT (intr_get_level () == INTR_OFF);
	struct child_process *ch;
	for (struct list_elem *e = list_begin(children); e != list_end(children); e = list_next(e)) {
c002176d:	83 ec 0c             	sub    $0xc,%esp
c0021770:	56                   	push   %esi
c0021771:	e8 f1 6f 00 00       	call   c0028767 <list_begin>
c0021776:	89 c3                	mov    %eax,%ebx
c0021778:	83 c4 10             	add    $0x10,%esp
c002177b:	83 ec 0c             	sub    $0xc,%esp
c002177e:	56                   	push   %esi
c002177f:	e8 5b 70 00 00       	call   c00287df <list_end>
c0021784:	83 c4 10             	add    $0x10,%esp
c0021787:	39 c3                	cmp    %eax,%ebx
c0021789:	74 1a                	je     c00217a5 <get_child_by_tid+0x43>
		ch = list_entry(e, struct child_process, elem);
		if (ch->tid == tid)
c002178b:	39 7b f4             	cmp    %edi,-0xc(%ebx)
c002178e:	74 10                	je     c00217a0 <get_child_by_tid+0x3e>
	for (struct list_elem *e = list_begin(children); e != list_end(children); e = list_next(e)) {
c0021790:	83 ec 0c             	sub    $0xc,%esp
c0021793:	53                   	push   %ebx
c0021794:	e8 fe 6f 00 00       	call   c0028797 <list_next>
c0021799:	89 c3                	mov    %eax,%ebx
c002179b:	83 c4 10             	add    $0x10,%esp
c002179e:	eb db                	jmp    c002177b <get_child_by_tid+0x19>
		ch = list_entry(e, struct child_process, elem);
c00217a0:	8d 43 f4             	lea    -0xc(%ebx),%eax
c00217a3:	eb 05                	jmp    c00217aa <get_child_by_tid+0x48>
			return ch;
	}
	return NULL;
c00217a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00217aa:	5b                   	pop    %ebx
c00217ab:	5e                   	pop    %esi
c00217ac:	5f                   	pop    %edi
c00217ad:	c3                   	ret    

c00217ae <thread_exit>:
{
c00217ae:	56                   	push   %esi
c00217af:	53                   	push   %ebx
c00217b0:	83 ec 04             	sub    $0x4,%esp
  ASSERT (!intr_context ());
c00217b3:	e8 c4 04 00 00       	call   c0021c7c <intr_context>
c00217b8:	84 c0                	test   %al,%al
c00217ba:	74 21                	je     c00217dd <thread_exit+0x2f>
c00217bc:	83 ec 0c             	sub    $0xc,%esp
c00217bf:	68 c0 13 03 c0       	push   $0xc00313c0
c00217c4:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00217c9:	68 e0 f5 02 c0       	push   $0xc002f5e0
c00217ce:	68 56 01 00 00       	push   $0x156
c00217d3:	68 90 12 03 c0       	push   $0xc0031290
c00217d8:	e8 a0 6e 00 00       	call   c002867d <debug_panic>
	enum intr_level old_level = intr_disable();
c00217dd:	e8 79 02 00 00       	call   c0021a5b <intr_disable>
c00217e2:	89 c6                	mov    %eax,%esi
	struct thread *t = thread_current();
c00217e4:	e8 2d f5 ff ff       	call   c0020d16 <thread_current>
c00217e9:	89 c3                	mov    %eax,%ebx
	if (t->parent->wait_tid == t->tid) {
c00217eb:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c00217f1:	8b 53 04             	mov    0x4(%ebx),%edx
c00217f4:	39 50 74             	cmp    %edx,0x74(%eax)
c00217f7:	74 67                	je     c0021860 <thread_exit+0xb2>
	struct child_process *ch = get_child_by_tid(&t->parent->children, t->tid);
c00217f9:	83 ec 08             	sub    $0x8,%esp
c00217fc:	ff 73 04             	pushl  0x4(%ebx)
c00217ff:	8b 83 a4 00 00 00    	mov    0xa4(%ebx),%eax
c0021805:	05 a8 00 00 00       	add    $0xa8,%eax
c002180a:	50                   	push   %eax
c002180b:	e8 52 ff ff ff       	call   c0021762 <get_child_by_tid>
	ch->done = true;
c0021810:	c6 40 08 01          	movb   $0x1,0x8(%eax)
	intr_set_level(old_level);
c0021814:	89 34 24             	mov    %esi,(%esp)
c0021817:	e8 46 02 00 00       	call   c0021a62 <intr_set_level>
  process_exit ();
c002181c:	e8 06 8b 00 00       	call   c002a327 <process_exit>
	intr_disable ();
c0021821:	e8 35 02 00 00       	call   c0021a5b <intr_disable>
	list_remove (&thread_current()->allelem);
c0021826:	e8 eb f4 ff ff       	call   c0020d16 <thread_current>
c002182b:	83 c0 54             	add    $0x54,%eax
c002182e:	89 04 24             	mov    %eax,(%esp)
c0021831:	e8 57 73 00 00       	call   c0028b8d <list_remove>
	thread_current ()->status = THREAD_DYING;
c0021836:	e8 db f4 ff ff       	call   c0020d16 <thread_current>
c002183b:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	schedule ();
c0021842:	e8 29 fb ff ff       	call   c0021370 <schedule>
	NOT_REACHED ();
c0021847:	68 54 14 03 c0       	push   $0xc0031454
c002184c:	68 e0 f5 02 c0       	push   $0xc002f5e0
c0021851:	68 6c 01 00 00       	push   $0x16c
c0021856:	68 90 12 03 c0       	push   $0xc0031290
c002185b:	e8 1d 6e 00 00       	call   c002867d <debug_panic>
		sema_up(&t->parent->wait_sema);
c0021860:	83 ec 0c             	sub    $0xc,%esp
c0021863:	05 8c 00 00 00       	add    $0x8c,%eax
c0021868:	50                   	push   %eax
c0021869:	e8 66 13 00 00       	call   c0022bd4 <sema_up>
c002186e:	83 c4 10             	add    $0x10,%esp
c0021871:	eb 86                	jmp    c00217f9 <thread_exit+0x4b>

c0021873 <kernel_thread>:
{
c0021873:	53                   	push   %ebx
c0021874:	83 ec 08             	sub    $0x8,%esp
c0021877:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (function != NULL);
c002187b:	85 db                	test   %ebx,%ebx
c002187d:	74 13                	je     c0021892 <kernel_thread+0x1f>
  intr_enable ();       /* The scheduler runs with interrupts off. */
c002187f:	e8 a3 01 00 00       	call   c0021a27 <intr_enable>
  function (aux);       /* Execute the thread function. */
c0021884:	83 ec 0c             	sub    $0xc,%esp
c0021887:	ff 74 24 20          	pushl  0x20(%esp)
c002188b:	ff d3                	call   *%ebx
  thread_exit ();       /* If function() returns, kill the thread. */
c002188d:	e8 1c ff ff ff       	call   c00217ae <thread_exit>
  ASSERT (function != NULL);
c0021892:	83 ec 0c             	sub    $0xc,%esp
c0021895:	68 d1 13 03 c0       	push   $0xc00313d1
c002189a:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002189f:	68 34 f6 02 c0       	push   $0xc002f634
c00218a4:	68 66 02 00 00       	push   $0x266
c00218a9:	68 90 12 03 c0       	push   $0xc0031290
c00218ae:	e8 ca 6d 00 00       	call   c002867d <debug_panic>

c00218b3 <thread_init_dir>:
#ifdef FILESYS
void
thread_init_dir () {
c00218b3:	53                   	push   %ebx
c00218b4:	83 ec 08             	sub    $0x8,%esp
  initial_thread->dir = dir_open_root();
c00218b7:	8b 1d b4 c8 03 c0    	mov    0xc003c8b4,%ebx
c00218bd:	e8 18 b7 00 00       	call   c002cfda <dir_open_root>
c00218c2:	89 83 e4 00 00 00    	mov    %eax,0xe4(%ebx)
}
c00218c8:	83 c4 08             	add    $0x8,%esp
c00218cb:	5b                   	pop    %ebx
c00218cc:	c3                   	ret    

c00218cd <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c00218cd:	53                   	push   %ebx
	pushl %ebp
c00218ce:	55                   	push   %ebp
	pushl %esi
c00218cf:	56                   	push   %esi
	pushl %edi
c00218d0:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c00218d1:	8b 15 54 c2 03 c0    	mov    0xc003c254,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c00218d7:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c00218db:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c00218de:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c00218e2:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c00218e5:	5f                   	pop    %edi
	popl %esi
c00218e6:	5e                   	pop    %esi
	popl %ebp
c00218e7:	5d                   	pop    %ebp
	popl %ebx
c00218e8:	5b                   	pop    %ebx
        ret
c00218e9:	c3                   	ret    

c00218ea <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c00218ea:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c00218ed:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c00218ee:	e8 e1 f9 ff ff       	call   c00212d4 <thread_schedule_tail>
	addl $4, %esp
c00218f3:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c00218f6:	c3                   	ret    

c00218f7 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c00218f7:	83 ec 0c             	sub    $0xc,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00218fa:	85 c0                	test   %eax,%eax
c00218fc:	74 2b                	je     c0021929 <make_gate+0x32>
  ASSERT (dpl >= 0 && dpl <= 3);
c00218fe:	83 fa 03             	cmp    $0x3,%edx
c0021901:	77 47                	ja     c002194a <make_gate+0x53>
  ASSERT (type >= 0 && type <= 15);
c0021903:	83 f9 0f             	cmp    $0xf,%ecx
c0021906:	77 63                	ja     c002196b <make_gate+0x74>

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021908:	c1 e1 08             	shl    $0x8,%ecx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c002190b:	80 cd 80             	or     $0x80,%ch
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c002190e:	c1 e2 0d             	shl    $0xd,%edx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021911:	09 ca                	or     %ecx,%edx
c0021913:	89 c1                	mov    %eax,%ecx
c0021915:	81 e1 00 00 ff ff    	and    $0xffff0000,%ecx
c002191b:	09 ca                	or     %ecx,%edx
  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c002191d:	0f b7 c0             	movzwl %ax,%eax
c0021920:	0d 00 00 08 00       	or     $0x80000,%eax

  return e0 | ((uint64_t) e1 << 32);
}
c0021925:	83 c4 0c             	add    $0xc,%esp
c0021928:	c3                   	ret    
  ASSERT (function != NULL);
c0021929:	83 ec 0c             	sub    $0xc,%esp
c002192c:	68 d1 13 03 c0       	push   $0xc00313d1
c0021931:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021936:	68 e8 f6 02 c0       	push   $0xc002f6e8
c002193b:	68 2a 01 00 00       	push   $0x12a
c0021940:	68 76 14 03 c0       	push   $0xc0031476
c0021945:	e8 33 6d 00 00       	call   c002867d <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c002194a:	83 ec 0c             	sub    $0xc,%esp
c002194d:	68 90 14 03 c0       	push   $0xc0031490
c0021952:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021957:	68 e8 f6 02 c0       	push   $0xc002f6e8
c002195c:	68 2b 01 00 00       	push   $0x12b
c0021961:	68 76 14 03 c0       	push   $0xc0031476
c0021966:	e8 12 6d 00 00       	call   c002867d <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c002196b:	83 ec 0c             	sub    $0xc,%esp
c002196e:	68 a5 14 03 c0       	push   $0xc00314a5
c0021973:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021978:	68 e8 f6 02 c0       	push   $0xc002f6e8
c002197d:	68 2c 01 00 00       	push   $0x12c
c0021982:	68 76 14 03 c0       	push   $0xc0031476
c0021987:	e8 f1 6c 00 00       	call   c002867d <debug_panic>

c002198c <register_handler>:
{
c002198c:	53                   	push   %ebx
c002198d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_handlers[vec_no] == NULL);
c0021990:	0f b6 d8             	movzbl %al,%ebx
c0021993:	83 3c 9d 00 d1 03 c0 	cmpl   $0x0,-0x3ffc2f00(,%ebx,4)
c002199a:	00 
c002199b:	75 3f                	jne    c00219dc <register_handler+0x50>
  if (level == INTR_ON)
c002199d:	83 f9 01             	cmp    $0x1,%ecx
c00219a0:	74 5b                	je     c00219fd <register_handler+0x71>
/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 14);
c00219a2:	8b 04 9d 58 c2 03 c0 	mov    -0x3ffc3da8(,%ebx,4),%eax
c00219a9:	b9 0e 00 00 00       	mov    $0xe,%ecx
c00219ae:	e8 44 ff ff ff       	call   c00218f7 <make_gate>
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c00219b3:	89 04 dd 00 d5 03 c0 	mov    %eax,-0x3ffc2b00(,%ebx,8)
c00219ba:	89 14 dd 04 d5 03 c0 	mov    %edx,-0x3ffc2afc(,%ebx,8)
  intr_handlers[vec_no] = handler;
c00219c1:	8b 44 24 10          	mov    0x10(%esp),%eax
c00219c5:	89 04 9d 00 d1 03 c0 	mov    %eax,-0x3ffc2f00(,%ebx,4)
  intr_names[vec_no] = name;
c00219cc:	8b 44 24 14          	mov    0x14(%esp),%eax
c00219d0:	89 04 9d 00 cd 03 c0 	mov    %eax,-0x3ffc3300(,%ebx,4)
}
c00219d7:	83 c4 08             	add    $0x8,%esp
c00219da:	5b                   	pop    %ebx
c00219db:	c3                   	ret    
  ASSERT (intr_handlers[vec_no] == NULL);
c00219dc:	83 ec 0c             	sub    $0xc,%esp
c00219df:	68 bd 14 03 c0       	push   $0xc00314bd
c00219e4:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00219e9:	68 c0 f6 02 c0       	push   $0xc002f6c0
c00219ee:	68 a8 00 00 00       	push   $0xa8
c00219f3:	68 76 14 03 c0       	push   $0xc0031476
c00219f8:	e8 80 6c 00 00       	call   c002867d <debug_panic>
/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 15);
c00219fd:	8b 04 9d 58 c2 03 c0 	mov    -0x3ffc3da8(,%ebx,4),%eax
c0021a04:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0021a09:	e8 e9 fe ff ff       	call   c00218f7 <make_gate>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021a0e:	89 04 dd 00 d5 03 c0 	mov    %eax,-0x3ffc2b00(,%ebx,8)
c0021a15:	89 14 dd 04 d5 03 c0 	mov    %edx,-0x3ffc2afc(,%ebx,8)
c0021a1c:	eb a3                	jmp    c00219c1 <register_handler+0x35>

c0021a1e <intr_get_level>:
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021a1e:	9c                   	pushf  
c0021a1f:	58                   	pop    %eax
  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021a20:	c1 e8 09             	shr    $0x9,%eax
c0021a23:	83 e0 01             	and    $0x1,%eax
}
c0021a26:	c3                   	ret    

c0021a27 <intr_enable>:
{
c0021a27:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_get_level ();
c0021a2a:	e8 ef ff ff ff       	call   c0021a1e <intr_get_level>
  ASSERT (!intr_context ());
c0021a2f:	80 3d e1 c8 03 c0 00 	cmpb   $0x0,0xc003c8e1
c0021a36:	75 05                	jne    c0021a3d <intr_enable+0x16>
  asm volatile ("sti");
c0021a38:	fb                   	sti    
}
c0021a39:	83 c4 0c             	add    $0xc,%esp
c0021a3c:	c3                   	ret    
  ASSERT (!intr_context ());
c0021a3d:	83 ec 0c             	sub    $0xc,%esp
c0021a40:	68 c0 13 03 c0       	push   $0xc00313c0
c0021a45:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021a4a:	68 f4 f6 02 c0       	push   $0xc002f6f4
c0021a4f:	6a 5b                	push   $0x5b
c0021a51:	68 76 14 03 c0       	push   $0xc0031476
c0021a56:	e8 22 6c 00 00       	call   c002867d <debug_panic>

c0021a5b <intr_disable>:
  enum intr_level old_level = intr_get_level ();
c0021a5b:	e8 be ff ff ff       	call   c0021a1e <intr_get_level>
  asm volatile ("cli" : : : "memory");
c0021a60:	fa                   	cli    
}
c0021a61:	c3                   	ret    

c0021a62 <intr_set_level>:
{
c0021a62:	83 ec 0c             	sub    $0xc,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021a65:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021a6a:	74 09                	je     c0021a75 <intr_set_level+0x13>
c0021a6c:	e8 ea ff ff ff       	call   c0021a5b <intr_disable>
}
c0021a71:	83 c4 0c             	add    $0xc,%esp
c0021a74:	c3                   	ret    
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021a75:	e8 ad ff ff ff       	call   c0021a27 <intr_enable>
c0021a7a:	eb f5                	jmp    c0021a71 <intr_set_level+0xf>

c0021a7c <intr_init>:
{
c0021a7c:	53                   	push   %ebx
c0021a7d:	83 ec 18             	sub    $0x18,%esp
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021a80:	b0 ff                	mov    $0xff,%al
c0021a82:	e6 21                	out    %al,$0x21
c0021a84:	e6 a1                	out    %al,$0xa1
c0021a86:	b0 11                	mov    $0x11,%al
c0021a88:	e6 20                	out    %al,$0x20
c0021a8a:	b0 20                	mov    $0x20,%al
c0021a8c:	e6 21                	out    %al,$0x21
c0021a8e:	b0 04                	mov    $0x4,%al
c0021a90:	e6 21                	out    %al,$0x21
c0021a92:	b0 01                	mov    $0x1,%al
c0021a94:	e6 21                	out    %al,$0x21
c0021a96:	b0 11                	mov    $0x11,%al
c0021a98:	e6 a0                	out    %al,$0xa0
c0021a9a:	b0 28                	mov    $0x28,%al
c0021a9c:	e6 a1                	out    %al,$0xa1
c0021a9e:	b0 02                	mov    $0x2,%al
c0021aa0:	e6 a1                	out    %al,$0xa1
c0021aa2:	b0 01                	mov    $0x1,%al
c0021aa4:	e6 a1                	out    %al,$0xa1
c0021aa6:	b0 00                	mov    $0x0,%al
c0021aa8:	e6 21                	out    %al,$0x21
c0021aaa:	e6 a1                	out    %al,$0xa1
c0021aac:	bb 00 00 00 00       	mov    $0x0,%ebx
  return make_gate (function, dpl, 14);
c0021ab1:	8b 83 58 c2 03 c0    	mov    -0x3ffc3da8(%ebx),%eax
c0021ab7:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021abc:	ba 00 00 00 00       	mov    $0x0,%edx
c0021ac1:	e8 31 fe ff ff       	call   c00218f7 <make_gate>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021ac6:	89 84 1b 00 d5 03 c0 	mov    %eax,-0x3ffc2b00(%ebx,%ebx,1)
c0021acd:	89 94 1b 04 d5 03 c0 	mov    %edx,-0x3ffc2afc(%ebx,%ebx,1)
c0021ad4:	83 c3 04             	add    $0x4,%ebx
  for (i = 0; i < INTR_CNT; i++)
c0021ad7:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
c0021add:	75 d2                	jne    c0021ab1 <intr_init+0x35>
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021adf:	b8 00 d5 03 c0       	mov    $0xc003d500,%eax
c0021ae4:	ba 00 00 00 00       	mov    $0x0,%edx
c0021ae9:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021aed:	c1 e0 10             	shl    $0x10,%eax
c0021af0:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021af5:	89 44 24 08          	mov    %eax,0x8(%esp)
c0021af9:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021afd:	0f 01 5c 24 08       	lidtl  0x8(%esp)
c0021b02:	b8 00 cd 03 c0       	mov    $0xc003cd00,%eax
c0021b07:	ba 00 d1 03 c0       	mov    $0xc003d100,%edx
    intr_names[i] = "unknown";
c0021b0c:	c7 00 db 14 03 c0    	movl   $0xc00314db,(%eax)
c0021b12:	83 c0 04             	add    $0x4,%eax
  for (i = 0; i < INTR_CNT; i++)
c0021b15:	39 c2                	cmp    %eax,%edx
c0021b17:	75 f3                	jne    c0021b0c <intr_init+0x90>
  intr_names[0] = "#DE Divide Error";
c0021b19:	c7 05 00 cd 03 c0 e3 	movl   $0xc00314e3,0xc003cd00
c0021b20:	14 03 c0 
  intr_names[1] = "#DB Debug Exception";
c0021b23:	c7 05 04 cd 03 c0 f4 	movl   $0xc00314f4,0xc003cd04
c0021b2a:	14 03 c0 
  intr_names[2] = "NMI Interrupt";
c0021b2d:	c7 05 08 cd 03 c0 08 	movl   $0xc0031508,0xc003cd08
c0021b34:	15 03 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c0021b37:	c7 05 0c cd 03 c0 16 	movl   $0xc0031516,0xc003cd0c
c0021b3e:	15 03 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021b41:	c7 05 10 cd 03 c0 2f 	movl   $0xc003152f,0xc003cd10
c0021b48:	15 03 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021b4b:	c7 05 14 cd 03 c0 6c 	movl   $0xc003166c,0xc003cd14
c0021b52:	16 03 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021b55:	c7 05 18 cd 03 c0 46 	movl   $0xc0031546,0xc003cd18
c0021b5c:	15 03 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c0021b5f:	c7 05 1c cd 03 c0 90 	movl   $0xc0031690,0xc003cd1c
c0021b66:	16 03 c0 
  intr_names[8] = "#DF Double Fault Exception";
c0021b69:	c7 05 20 cd 03 c0 63 	movl   $0xc0031563,0xc003cd20
c0021b70:	15 03 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c0021b73:	c7 05 24 cd 03 c0 7e 	movl   $0xc003157e,0xc003cd24
c0021b7a:	15 03 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c0021b7d:	c7 05 28 cd 03 c0 9a 	movl   $0xc003159a,0xc003cd28
c0021b84:	15 03 c0 
  intr_names[11] = "#NP Segment Not Present";
c0021b87:	c7 05 2c cd 03 c0 b4 	movl   $0xc00315b4,0xc003cd2c
c0021b8e:	15 03 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c0021b91:	c7 05 30 cd 03 c0 cc 	movl   $0xc00315cc,0xc003cd30
c0021b98:	15 03 c0 
  intr_names[13] = "#GP General Protection Exception";
c0021b9b:	c7 05 34 cd 03 c0 b4 	movl   $0xc00316b4,0xc003cd34
c0021ba2:	16 03 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c0021ba5:	c7 05 38 cd 03 c0 e6 	movl   $0xc00315e6,0xc003cd38
c0021bac:	15 03 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021baf:	c7 05 40 cd 03 c0 d8 	movl   $0xc00316d8,0xc003cd40
c0021bb6:	16 03 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c0021bb9:	c7 05 44 cd 03 c0 ff 	movl   $0xc00315ff,0xc003cd44
c0021bc0:	15 03 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c0021bc3:	c7 05 48 cd 03 c0 1d 	movl   $0xc003161d,0xc003cd48
c0021bca:	16 03 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021bcd:	c7 05 4c cd 03 c0 fc 	movl   $0xc00316fc,0xc003cd4c
c0021bd4:	16 03 c0 
}
c0021bd7:	83 c4 18             	add    $0x18,%esp
c0021bda:	5b                   	pop    %ebx
c0021bdb:	c3                   	ret    

c0021bdc <intr_register_ext>:
{
c0021bdc:	83 ec 0c             	sub    $0xc,%esp
c0021bdf:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021be3:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021be6:	80 fa 0f             	cmp    $0xf,%dl
c0021be9:	77 21                	ja     c0021c0c <intr_register_ext+0x30>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021beb:	0f b6 c0             	movzbl %al,%eax
c0021bee:	83 ec 08             	sub    $0x8,%esp
c0021bf1:	ff 74 24 20          	pushl  0x20(%esp)
c0021bf5:	ff 74 24 20          	pushl  0x20(%esp)
c0021bf9:	b9 00 00 00 00       	mov    $0x0,%ecx
c0021bfe:	ba 00 00 00 00       	mov    $0x0,%edx
c0021c03:	e8 84 fd ff ff       	call   c002198c <register_handler>
}
c0021c08:	83 c4 1c             	add    $0x1c,%esp
c0021c0b:	c3                   	ret    
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021c0c:	83 ec 0c             	sub    $0xc,%esp
c0021c0f:	68 20 17 03 c0       	push   $0xc0031720
c0021c14:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021c19:	68 d4 f6 02 c0       	push   $0xc002f6d4
c0021c1e:	68 b8 00 00 00       	push   $0xb8
c0021c23:	68 76 14 03 c0       	push   $0xc0031476
c0021c28:	e8 50 6a 00 00       	call   c002867d <debug_panic>

c0021c2d <intr_register_int>:
{
c0021c2d:	83 ec 0c             	sub    $0xc,%esp
c0021c30:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021c34:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021c37:	80 fa 0f             	cmp    $0xf,%dl
c0021c3a:	76 1f                	jbe    c0021c5b <intr_register_int+0x2e>
  register_handler (vec_no, dpl, level, handler, name);
c0021c3c:	0f b6 c0             	movzbl %al,%eax
c0021c3f:	83 ec 08             	sub    $0x8,%esp
c0021c42:	ff 74 24 28          	pushl  0x28(%esp)
c0021c46:	ff 74 24 28          	pushl  0x28(%esp)
c0021c4a:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0021c4e:	8b 54 24 24          	mov    0x24(%esp),%edx
c0021c52:	e8 35 fd ff ff       	call   c002198c <register_handler>
}
c0021c57:	83 c4 1c             	add    $0x1c,%esp
c0021c5a:	c3                   	ret    
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021c5b:	83 ec 0c             	sub    $0xc,%esp
c0021c5e:	68 44 17 03 c0       	push   $0xc0031744
c0021c63:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021c68:	68 ac f6 02 c0       	push   $0xc002f6ac
c0021c6d:	68 cd 00 00 00       	push   $0xcd
c0021c72:	68 76 14 03 c0       	push   $0xc0031476
c0021c77:	e8 01 6a 00 00       	call   c002867d <debug_panic>

c0021c7c <intr_context>:
}
c0021c7c:	a0 e1 c8 03 c0       	mov    0xc003c8e1,%al
c0021c81:	c3                   	ret    

c0021c82 <intr_yield_on_return>:
  ASSERT (intr_context ());
c0021c82:	80 3d e1 c8 03 c0 00 	cmpb   $0x0,0xc003c8e1
c0021c89:	74 08                	je     c0021c93 <intr_yield_on_return+0x11>
  yield_on_return = true;
c0021c8b:	c6 05 e0 c8 03 c0 01 	movb   $0x1,0xc003c8e0
c0021c92:	c3                   	ret    
{
c0021c93:	83 ec 18             	sub    $0x18,%esp
  ASSERT (intr_context ());
c0021c96:	68 c1 13 03 c0       	push   $0xc00313c1
c0021c9b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021ca0:	68 94 f6 02 c0       	push   $0xc002f694
c0021ca5:	68 e0 00 00 00       	push   $0xe0
c0021caa:	68 76 14 03 c0       	push   $0xc0031476
c0021caf:	e8 c9 69 00 00       	call   c002867d <debug_panic>

c0021cb4 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021cb4:	56                   	push   %esi
c0021cb5:	53                   	push   %ebx
c0021cb6:	83 ec 04             	sub    $0x4,%esp
c0021cb9:	8b 74 24 10          	mov    0x10(%esp),%esi

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021cbd:	8b 46 30             	mov    0x30(%esi),%eax
c0021cc0:	8d 58 e0             	lea    -0x20(%eax),%ebx
  if (external) 
c0021cc3:	83 fb 0f             	cmp    $0xf,%ebx
c0021cc6:	77 64                	ja     c0021d2c <intr_handler+0x78>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021cc8:	e8 51 fd ff ff       	call   c0021a1e <intr_get_level>
c0021ccd:	85 c0                	test   %eax,%eax
c0021ccf:	75 19                	jne    c0021cea <intr_handler+0x36>
      ASSERT (!intr_context ());
c0021cd1:	80 3d e1 c8 03 c0 00 	cmpb   $0x0,0xc003c8e1
c0021cd8:	75 31                	jne    c0021d0b <intr_handler+0x57>

      in_external_intr = true;
c0021cda:	c6 05 e1 c8 03 c0 01 	movb   $0x1,0xc003c8e1
      yield_on_return = false;
c0021ce1:	c6 05 e0 c8 03 c0 00 	movb   $0x0,0xc003c8e0
c0021ce8:	eb 50                	jmp    c0021d3a <intr_handler+0x86>
      ASSERT (intr_get_level () == INTR_OFF);
c0021cea:	83 ec 0c             	sub    $0xc,%esp
c0021ced:	68 f6 12 03 c0       	push   $0xc00312f6
c0021cf2:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021cf7:	68 84 f6 02 c0       	push   $0xc002f684
c0021cfc:	68 65 01 00 00       	push   $0x165
c0021d01:	68 76 14 03 c0       	push   $0xc0031476
c0021d06:	e8 72 69 00 00       	call   c002867d <debug_panic>
      ASSERT (!intr_context ());
c0021d0b:	83 ec 0c             	sub    $0xc,%esp
c0021d0e:	68 c0 13 03 c0       	push   $0xc00313c0
c0021d13:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021d18:	68 84 f6 02 c0       	push   $0xc002f684
c0021d1d:	68 66 01 00 00       	push   $0x166
c0021d22:	68 76 14 03 c0       	push   $0xc0031476
c0021d27:	e8 51 69 00 00       	call   c002867d <debug_panic>
    }
#ifdef VM
	else
    thread_current()->esp = frame->esp;
c0021d2c:	e8 e5 ef ff ff       	call   c0020d16 <thread_current>
c0021d31:	8b 56 48             	mov    0x48(%esi),%edx
c0021d34:	89 90 e0 00 00 00    	mov    %edx,0xe0(%eax)
#endif

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021d3a:	8b 56 30             	mov    0x30(%esi),%edx
c0021d3d:	8b 04 95 00 d1 03 c0 	mov    -0x3ffc2f00(,%edx,4),%eax
  if (handler != NULL)
c0021d44:	85 c0                	test   %eax,%eax
c0021d46:	74 14                	je     c0021d5c <intr_handler+0xa8>
    handler (frame);
c0021d48:	83 ec 0c             	sub    $0xc,%esp
c0021d4b:	56                   	push   %esi
c0021d4c:	ff d0                	call   *%eax
c0021d4e:	83 c4 10             	add    $0x10,%esp
    }
  else
    unexpected_interrupt (frame);

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021d51:	83 fb 0f             	cmp    $0xf,%ebx
c0021d54:	76 3f                	jbe    c0021d95 <intr_handler+0xe1>
      pic_end_of_interrupt (frame->vec_no); 

      if (yield_on_return) 
        thread_yield (); 
    }
}
c0021d56:	83 c4 04             	add    $0x4,%esp
c0021d59:	5b                   	pop    %ebx
c0021d5a:	5e                   	pop    %esi
c0021d5b:	c3                   	ret    
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021d5c:	89 d0                	mov    %edx,%eax
c0021d5e:	83 e0 f7             	and    $0xfffffff7,%eax
c0021d61:	83 f8 27             	cmp    $0x27,%eax
c0021d64:	74 eb                	je     c0021d51 <intr_handler+0x9d>
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021d66:	8b 0c 95 00 c9 03 c0 	mov    -0x3ffc3700(,%edx,4),%ecx
c0021d6d:	8d 41 01             	lea    0x1(%ecx),%eax
c0021d70:	89 04 95 00 c9 03 c0 	mov    %eax,-0x3ffc3700(,%edx,4)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021d77:	85 c1                	test   %eax,%ecx
c0021d79:	75 d6                	jne    c0021d51 <intr_handler+0x9d>
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021d7b:	83 ec 04             	sub    $0x4,%esp
c0021d7e:	ff 34 95 00 cd 03 c0 	pushl  -0x3ffc3300(,%edx,4)
c0021d85:	52                   	push   %edx
c0021d86:	68 64 17 03 c0       	push   $0xc0031764
c0021d8b:	e8 3f 4e 00 00       	call   c0026bcf <printf>
c0021d90:	83 c4 10             	add    $0x10,%esp
c0021d93:	eb bc                	jmp    c0021d51 <intr_handler+0x9d>
      ASSERT (intr_get_level () == INTR_OFF);
c0021d95:	e8 84 fc ff ff       	call   c0021a1e <intr_get_level>
c0021d9a:	85 c0                	test   %eax,%eax
c0021d9c:	75 36                	jne    c0021dd4 <intr_handler+0x120>
      ASSERT (intr_context ());
c0021d9e:	80 3d e1 c8 03 c0 00 	cmpb   $0x0,0xc003c8e1
c0021da5:	74 4e                	je     c0021df5 <intr_handler+0x141>
      in_external_intr = false;
c0021da7:	c6 05 e1 c8 03 c0 00 	movb   $0x0,0xc003c8e1
      pic_end_of_interrupt (frame->vec_no); 
c0021dae:	8b 56 30             	mov    0x30(%esi),%edx
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021db1:	8d 42 e0             	lea    -0x20(%edx),%eax
c0021db4:	83 f8 0f             	cmp    $0xf,%eax
c0021db7:	77 5d                	ja     c0021e16 <intr_handler+0x162>
c0021db9:	b0 20                	mov    $0x20,%al
c0021dbb:	e6 20                	out    %al,$0x20
  if (irq >= 0x28)
c0021dbd:	83 fa 27             	cmp    $0x27,%edx
c0021dc0:	7e 02                	jle    c0021dc4 <intr_handler+0x110>
c0021dc2:	e6 a0                	out    %al,$0xa0
      if (yield_on_return) 
c0021dc4:	80 3d e0 c8 03 c0 00 	cmpb   $0x0,0xc003c8e0
c0021dcb:	74 89                	je     c0021d56 <intr_handler+0xa2>
        thread_yield (); 
c0021dcd:	e8 1b f7 ff ff       	call   c00214ed <thread_yield>
}
c0021dd2:	eb 82                	jmp    c0021d56 <intr_handler+0xa2>
      ASSERT (intr_get_level () == INTR_OFF);
c0021dd4:	83 ec 0c             	sub    $0xc,%esp
c0021dd7:	68 f6 12 03 c0       	push   $0xc00312f6
c0021ddc:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021de1:	68 84 f6 02 c0       	push   $0xc002f684
c0021de6:	68 80 01 00 00       	push   $0x180
c0021deb:	68 76 14 03 c0       	push   $0xc0031476
c0021df0:	e8 88 68 00 00       	call   c002867d <debug_panic>
      ASSERT (intr_context ());
c0021df5:	83 ec 0c             	sub    $0xc,%esp
c0021df8:	68 c1 13 03 c0       	push   $0xc00313c1
c0021dfd:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021e02:	68 84 f6 02 c0       	push   $0xc002f684
c0021e07:	68 81 01 00 00       	push   $0x181
c0021e0c:	68 76 14 03 c0       	push   $0xc0031476
c0021e11:	e8 67 68 00 00       	call   c002867d <debug_panic>
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021e16:	83 ec 0c             	sub    $0xc,%esp
c0021e19:	68 39 16 03 c0       	push   $0xc0031639
c0021e1e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0021e23:	68 6c f6 02 c0       	push   $0xc002f66c
c0021e28:	68 0b 01 00 00       	push   $0x10b
c0021e2d:	68 76 14 03 c0       	push   $0xc0031476
c0021e32:	e8 46 68 00 00       	call   c002867d <debug_panic>

c0021e37 <intr_dump_frame>:
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021e37:	56                   	push   %esi
c0021e38:	53                   	push   %ebx
c0021e39:	83 ec 04             	sub    $0x4,%esp
c0021e3c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021e40:	0f 20 d6             	mov    %cr2,%esi

  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021e43:	8b 43 30             	mov    0x30(%ebx),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021e46:	ff 73 3c             	pushl  0x3c(%ebx)
c0021e49:	ff 34 85 00 cd 03 c0 	pushl  -0x3ffc3300(,%eax,4)
c0021e50:	50                   	push   %eax
c0021e51:	68 88 17 03 c0       	push   $0xc0031788
c0021e56:	e8 74 4d 00 00       	call   c0026bcf <printf>
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021e5b:	83 c4 0c             	add    $0xc,%esp
c0021e5e:	ff 73 34             	pushl  0x34(%ebx)
c0021e61:	56                   	push   %esi
c0021e62:	68 53 16 03 c0       	push   $0xc0031653
c0021e67:	e8 63 4d 00 00       	call   c0026bcf <printf>
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021e6c:	83 c4 04             	add    $0x4,%esp
c0021e6f:	ff 73 14             	pushl  0x14(%ebx)
c0021e72:	ff 73 18             	pushl  0x18(%ebx)
c0021e75:	ff 73 10             	pushl  0x10(%ebx)
c0021e78:	ff 73 1c             	pushl  0x1c(%ebx)
c0021e7b:	68 a8 17 03 c0       	push   $0xc00317a8
c0021e80:	e8 4a 4d 00 00       	call   c0026bcf <printf>
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021e85:	83 c4 14             	add    $0x14,%esp
c0021e88:	ff 73 08             	pushl  0x8(%ebx)
c0021e8b:	ff 73 48             	pushl  0x48(%ebx)
c0021e8e:	ff 33                	pushl  (%ebx)
c0021e90:	ff 73 04             	pushl  0x4(%ebx)
c0021e93:	68 d0 17 03 c0       	push   $0xc00317d0
c0021e98:	e8 32 4d 00 00       	call   c0026bcf <printf>
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021e9d:	83 c4 14             	add    $0x14,%esp
c0021ea0:	0f b7 43 4c          	movzwl 0x4c(%ebx),%eax
c0021ea4:	50                   	push   %eax
c0021ea5:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
c0021ea9:	50                   	push   %eax
c0021eaa:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
c0021eae:	50                   	push   %eax
c0021eaf:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
c0021eb3:	50                   	push   %eax
c0021eb4:	68 f8 17 03 c0       	push   $0xc00317f8
c0021eb9:	e8 11 4d 00 00       	call   c0026bcf <printf>
          f->cs, f->ds, f->es, f->ss);
}
c0021ebe:	83 c4 24             	add    $0x24,%esp
c0021ec1:	5b                   	pop    %ebx
c0021ec2:	5e                   	pop    %esi
c0021ec3:	c3                   	ret    

c0021ec4 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
  return intr_names[vec];
c0021ec4:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0021ec9:	8b 04 85 00 cd 03 c0 	mov    -0x3ffc3300(,%eax,4),%eax
}
c0021ed0:	c3                   	ret    

c0021ed1 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021ed1:	1e                   	push   %ds
	pushl %es
c0021ed2:	06                   	push   %es
	pushl %fs
c0021ed3:	0f a0                	push   %fs
	pushl %gs
c0021ed5:	0f a8                	push   %gs
	pushal
c0021ed7:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021ed8:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021ed9:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021ede:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021ee0:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021ee2:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021ee6:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021ee7:	e8 c8 fd ff ff       	call   c0021cb4 <intr_handler>
	addl $4, %esp
c0021eec:	83 c4 04             	add    $0x4,%esp

c0021eef <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021eef:	61                   	popa   
	popl %gs
c0021ef0:	0f a9                	pop    %gs
	popl %fs
c0021ef2:	0f a1                	pop    %fs
	popl %es
c0021ef4:	07                   	pop    %es
	popl %ds
c0021ef5:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021ef6:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021ef9:	cf                   	iret   

c0021efa <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021efa:	55                   	push   %ebp
c0021efb:	6a 00                	push   $0x0
c0021efd:	6a 00                	push   $0x0
c0021eff:	eb d0                	jmp    c0021ed1 <intr_entry>

c0021f01 <intr01_stub>:
c0021f01:	55                   	push   %ebp
c0021f02:	6a 00                	push   $0x0
c0021f04:	6a 01                	push   $0x1
c0021f06:	eb c9                	jmp    c0021ed1 <intr_entry>

c0021f08 <intr02_stub>:
c0021f08:	55                   	push   %ebp
c0021f09:	6a 00                	push   $0x0
c0021f0b:	6a 02                	push   $0x2
c0021f0d:	eb c2                	jmp    c0021ed1 <intr_entry>

c0021f0f <intr03_stub>:
c0021f0f:	55                   	push   %ebp
c0021f10:	6a 00                	push   $0x0
c0021f12:	6a 03                	push   $0x3
c0021f14:	eb bb                	jmp    c0021ed1 <intr_entry>

c0021f16 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021f16:	55                   	push   %ebp
c0021f17:	6a 00                	push   $0x0
c0021f19:	6a 04                	push   $0x4
c0021f1b:	eb b4                	jmp    c0021ed1 <intr_entry>

c0021f1d <intr05_stub>:
c0021f1d:	55                   	push   %ebp
c0021f1e:	6a 00                	push   $0x0
c0021f20:	6a 05                	push   $0x5
c0021f22:	eb ad                	jmp    c0021ed1 <intr_entry>

c0021f24 <intr06_stub>:
c0021f24:	55                   	push   %ebp
c0021f25:	6a 00                	push   $0x0
c0021f27:	6a 06                	push   $0x6
c0021f29:	eb a6                	jmp    c0021ed1 <intr_entry>

c0021f2b <intr07_stub>:
c0021f2b:	55                   	push   %ebp
c0021f2c:	6a 00                	push   $0x0
c0021f2e:	6a 07                	push   $0x7
c0021f30:	eb 9f                	jmp    c0021ed1 <intr_entry>

c0021f32 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021f32:	ff 34 24             	pushl  (%esp)
c0021f35:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f39:	6a 08                	push   $0x8
c0021f3b:	eb 94                	jmp    c0021ed1 <intr_entry>

c0021f3d <intr09_stub>:
c0021f3d:	55                   	push   %ebp
c0021f3e:	6a 00                	push   $0x0
c0021f40:	6a 09                	push   $0x9
c0021f42:	eb 8d                	jmp    c0021ed1 <intr_entry>

c0021f44 <intr0a_stub>:
c0021f44:	ff 34 24             	pushl  (%esp)
c0021f47:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f4b:	6a 0a                	push   $0xa
c0021f4d:	eb 82                	jmp    c0021ed1 <intr_entry>

c0021f4f <intr0b_stub>:
c0021f4f:	ff 34 24             	pushl  (%esp)
c0021f52:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f56:	6a 0b                	push   $0xb
c0021f58:	e9 74 ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021f5d <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021f5d:	55                   	push   %ebp
c0021f5e:	6a 00                	push   $0x0
c0021f60:	6a 0c                	push   $0xc
c0021f62:	e9 6a ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021f67 <intr0d_stub>:
c0021f67:	ff 34 24             	pushl  (%esp)
c0021f6a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f6e:	6a 0d                	push   $0xd
c0021f70:	e9 5c ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021f75 <intr0e_stub>:
c0021f75:	ff 34 24             	pushl  (%esp)
c0021f78:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f7c:	6a 0e                	push   $0xe
c0021f7e:	e9 4e ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021f83 <intr0f_stub>:
c0021f83:	55                   	push   %ebp
c0021f84:	6a 00                	push   $0x0
c0021f86:	6a 0f                	push   $0xf
c0021f88:	e9 44 ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021f8d <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021f8d:	55                   	push   %ebp
c0021f8e:	6a 00                	push   $0x0
c0021f90:	6a 10                	push   $0x10
c0021f92:	e9 3a ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021f97 <intr11_stub>:
c0021f97:	ff 34 24             	pushl  (%esp)
c0021f9a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f9e:	6a 11                	push   $0x11
c0021fa0:	e9 2c ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021fa5 <intr12_stub>:
c0021fa5:	55                   	push   %ebp
c0021fa6:	6a 00                	push   $0x0
c0021fa8:	6a 12                	push   $0x12
c0021faa:	e9 22 ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021faf <intr13_stub>:
c0021faf:	55                   	push   %ebp
c0021fb0:	6a 00                	push   $0x0
c0021fb2:	6a 13                	push   $0x13
c0021fb4:	e9 18 ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021fb9 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021fb9:	55                   	push   %ebp
c0021fba:	6a 00                	push   $0x0
c0021fbc:	6a 14                	push   $0x14
c0021fbe:	e9 0e ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021fc3 <intr15_stub>:
c0021fc3:	55                   	push   %ebp
c0021fc4:	6a 00                	push   $0x0
c0021fc6:	6a 15                	push   $0x15
c0021fc8:	e9 04 ff ff ff       	jmp    c0021ed1 <intr_entry>

c0021fcd <intr16_stub>:
c0021fcd:	55                   	push   %ebp
c0021fce:	6a 00                	push   $0x0
c0021fd0:	6a 16                	push   $0x16
c0021fd2:	e9 fa fe ff ff       	jmp    c0021ed1 <intr_entry>

c0021fd7 <intr17_stub>:
c0021fd7:	55                   	push   %ebp
c0021fd8:	6a 00                	push   $0x0
c0021fda:	6a 17                	push   $0x17
c0021fdc:	e9 f0 fe ff ff       	jmp    c0021ed1 <intr_entry>

c0021fe1 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021fe1:	ff 34 24             	pushl  (%esp)
c0021fe4:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021fe8:	6a 18                	push   $0x18
c0021fea:	e9 e2 fe ff ff       	jmp    c0021ed1 <intr_entry>

c0021fef <intr19_stub>:
c0021fef:	55                   	push   %ebp
c0021ff0:	6a 00                	push   $0x0
c0021ff2:	6a 19                	push   $0x19
c0021ff4:	e9 d8 fe ff ff       	jmp    c0021ed1 <intr_entry>

c0021ff9 <intr1a_stub>:
c0021ff9:	ff 34 24             	pushl  (%esp)
c0021ffc:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022000:	6a 1a                	push   $0x1a
c0022002:	e9 ca fe ff ff       	jmp    c0021ed1 <intr_entry>

c0022007 <intr1b_stub>:
c0022007:	ff 34 24             	pushl  (%esp)
c002200a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002200e:	6a 1b                	push   $0x1b
c0022010:	e9 bc fe ff ff       	jmp    c0021ed1 <intr_entry>

c0022015 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0022015:	55                   	push   %ebp
c0022016:	6a 00                	push   $0x0
c0022018:	6a 1c                	push   $0x1c
c002201a:	e9 b2 fe ff ff       	jmp    c0021ed1 <intr_entry>

c002201f <intr1d_stub>:
c002201f:	ff 34 24             	pushl  (%esp)
c0022022:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022026:	6a 1d                	push   $0x1d
c0022028:	e9 a4 fe ff ff       	jmp    c0021ed1 <intr_entry>

c002202d <intr1e_stub>:
c002202d:	ff 34 24             	pushl  (%esp)
c0022030:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022034:	6a 1e                	push   $0x1e
c0022036:	e9 96 fe ff ff       	jmp    c0021ed1 <intr_entry>

c002203b <intr1f_stub>:
c002203b:	55                   	push   %ebp
c002203c:	6a 00                	push   $0x0
c002203e:	6a 1f                	push   $0x1f
c0022040:	e9 8c fe ff ff       	jmp    c0021ed1 <intr_entry>

c0022045 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0022045:	55                   	push   %ebp
c0022046:	6a 00                	push   $0x0
c0022048:	6a 20                	push   $0x20
c002204a:	e9 82 fe ff ff       	jmp    c0021ed1 <intr_entry>

c002204f <intr21_stub>:
c002204f:	55                   	push   %ebp
c0022050:	6a 00                	push   $0x0
c0022052:	6a 21                	push   $0x21
c0022054:	e9 78 fe ff ff       	jmp    c0021ed1 <intr_entry>

c0022059 <intr22_stub>:
c0022059:	55                   	push   %ebp
c002205a:	6a 00                	push   $0x0
c002205c:	6a 22                	push   $0x22
c002205e:	e9 6e fe ff ff       	jmp    c0021ed1 <intr_entry>

c0022063 <intr23_stub>:
c0022063:	55                   	push   %ebp
c0022064:	6a 00                	push   $0x0
c0022066:	6a 23                	push   $0x23
c0022068:	e9 64 fe ff ff       	jmp    c0021ed1 <intr_entry>

c002206d <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c002206d:	55                   	push   %ebp
c002206e:	6a 00                	push   $0x0
c0022070:	6a 24                	push   $0x24
c0022072:	e9 5a fe ff ff       	jmp    c0021ed1 <intr_entry>

c0022077 <intr25_stub>:
c0022077:	55                   	push   %ebp
c0022078:	6a 00                	push   $0x0
c002207a:	6a 25                	push   $0x25
c002207c:	e9 50 fe ff ff       	jmp    c0021ed1 <intr_entry>

c0022081 <intr26_stub>:
c0022081:	55                   	push   %ebp
c0022082:	6a 00                	push   $0x0
c0022084:	6a 26                	push   $0x26
c0022086:	e9 46 fe ff ff       	jmp    c0021ed1 <intr_entry>

c002208b <intr27_stub>:
c002208b:	55                   	push   %ebp
c002208c:	6a 00                	push   $0x0
c002208e:	6a 27                	push   $0x27
c0022090:	e9 3c fe ff ff       	jmp    c0021ed1 <intr_entry>

c0022095 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0022095:	55                   	push   %ebp
c0022096:	6a 00                	push   $0x0
c0022098:	6a 28                	push   $0x28
c002209a:	e9 32 fe ff ff       	jmp    c0021ed1 <intr_entry>

c002209f <intr29_stub>:
c002209f:	55                   	push   %ebp
c00220a0:	6a 00                	push   $0x0
c00220a2:	6a 29                	push   $0x29
c00220a4:	e9 28 fe ff ff       	jmp    c0021ed1 <intr_entry>

c00220a9 <intr2a_stub>:
c00220a9:	55                   	push   %ebp
c00220aa:	6a 00                	push   $0x0
c00220ac:	6a 2a                	push   $0x2a
c00220ae:	e9 1e fe ff ff       	jmp    c0021ed1 <intr_entry>

c00220b3 <intr2b_stub>:
c00220b3:	55                   	push   %ebp
c00220b4:	6a 00                	push   $0x0
c00220b6:	6a 2b                	push   $0x2b
c00220b8:	e9 14 fe ff ff       	jmp    c0021ed1 <intr_entry>

c00220bd <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c00220bd:	55                   	push   %ebp
c00220be:	6a 00                	push   $0x0
c00220c0:	6a 2c                	push   $0x2c
c00220c2:	e9 0a fe ff ff       	jmp    c0021ed1 <intr_entry>

c00220c7 <intr2d_stub>:
c00220c7:	55                   	push   %ebp
c00220c8:	6a 00                	push   $0x0
c00220ca:	6a 2d                	push   $0x2d
c00220cc:	e9 00 fe ff ff       	jmp    c0021ed1 <intr_entry>

c00220d1 <intr2e_stub>:
c00220d1:	55                   	push   %ebp
c00220d2:	6a 00                	push   $0x0
c00220d4:	6a 2e                	push   $0x2e
c00220d6:	e9 f6 fd ff ff       	jmp    c0021ed1 <intr_entry>

c00220db <intr2f_stub>:
c00220db:	55                   	push   %ebp
c00220dc:	6a 00                	push   $0x0
c00220de:	6a 2f                	push   $0x2f
c00220e0:	e9 ec fd ff ff       	jmp    c0021ed1 <intr_entry>

c00220e5 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c00220e5:	55                   	push   %ebp
c00220e6:	6a 00                	push   $0x0
c00220e8:	6a 30                	push   $0x30
c00220ea:	e9 e2 fd ff ff       	jmp    c0021ed1 <intr_entry>

c00220ef <intr31_stub>:
c00220ef:	55                   	push   %ebp
c00220f0:	6a 00                	push   $0x0
c00220f2:	6a 31                	push   $0x31
c00220f4:	e9 d8 fd ff ff       	jmp    c0021ed1 <intr_entry>

c00220f9 <intr32_stub>:
c00220f9:	55                   	push   %ebp
c00220fa:	6a 00                	push   $0x0
c00220fc:	6a 32                	push   $0x32
c00220fe:	e9 ce fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022103 <intr33_stub>:
c0022103:	55                   	push   %ebp
c0022104:	6a 00                	push   $0x0
c0022106:	6a 33                	push   $0x33
c0022108:	e9 c4 fd ff ff       	jmp    c0021ed1 <intr_entry>

c002210d <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c002210d:	55                   	push   %ebp
c002210e:	6a 00                	push   $0x0
c0022110:	6a 34                	push   $0x34
c0022112:	e9 ba fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022117 <intr35_stub>:
c0022117:	55                   	push   %ebp
c0022118:	6a 00                	push   $0x0
c002211a:	6a 35                	push   $0x35
c002211c:	e9 b0 fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022121 <intr36_stub>:
c0022121:	55                   	push   %ebp
c0022122:	6a 00                	push   $0x0
c0022124:	6a 36                	push   $0x36
c0022126:	e9 a6 fd ff ff       	jmp    c0021ed1 <intr_entry>

c002212b <intr37_stub>:
c002212b:	55                   	push   %ebp
c002212c:	6a 00                	push   $0x0
c002212e:	6a 37                	push   $0x37
c0022130:	e9 9c fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022135 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0022135:	55                   	push   %ebp
c0022136:	6a 00                	push   $0x0
c0022138:	6a 38                	push   $0x38
c002213a:	e9 92 fd ff ff       	jmp    c0021ed1 <intr_entry>

c002213f <intr39_stub>:
c002213f:	55                   	push   %ebp
c0022140:	6a 00                	push   $0x0
c0022142:	6a 39                	push   $0x39
c0022144:	e9 88 fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022149 <intr3a_stub>:
c0022149:	55                   	push   %ebp
c002214a:	6a 00                	push   $0x0
c002214c:	6a 3a                	push   $0x3a
c002214e:	e9 7e fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022153 <intr3b_stub>:
c0022153:	55                   	push   %ebp
c0022154:	6a 00                	push   $0x0
c0022156:	6a 3b                	push   $0x3b
c0022158:	e9 74 fd ff ff       	jmp    c0021ed1 <intr_entry>

c002215d <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c002215d:	55                   	push   %ebp
c002215e:	6a 00                	push   $0x0
c0022160:	6a 3c                	push   $0x3c
c0022162:	e9 6a fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022167 <intr3d_stub>:
c0022167:	55                   	push   %ebp
c0022168:	6a 00                	push   $0x0
c002216a:	6a 3d                	push   $0x3d
c002216c:	e9 60 fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022171 <intr3e_stub>:
c0022171:	55                   	push   %ebp
c0022172:	6a 00                	push   $0x0
c0022174:	6a 3e                	push   $0x3e
c0022176:	e9 56 fd ff ff       	jmp    c0021ed1 <intr_entry>

c002217b <intr3f_stub>:
c002217b:	55                   	push   %ebp
c002217c:	6a 00                	push   $0x0
c002217e:	6a 3f                	push   $0x3f
c0022180:	e9 4c fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022185 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0022185:	55                   	push   %ebp
c0022186:	6a 00                	push   $0x0
c0022188:	6a 40                	push   $0x40
c002218a:	e9 42 fd ff ff       	jmp    c0021ed1 <intr_entry>

c002218f <intr41_stub>:
c002218f:	55                   	push   %ebp
c0022190:	6a 00                	push   $0x0
c0022192:	6a 41                	push   $0x41
c0022194:	e9 38 fd ff ff       	jmp    c0021ed1 <intr_entry>

c0022199 <intr42_stub>:
c0022199:	55                   	push   %ebp
c002219a:	6a 00                	push   $0x0
c002219c:	6a 42                	push   $0x42
c002219e:	e9 2e fd ff ff       	jmp    c0021ed1 <intr_entry>

c00221a3 <intr43_stub>:
c00221a3:	55                   	push   %ebp
c00221a4:	6a 00                	push   $0x0
c00221a6:	6a 43                	push   $0x43
c00221a8:	e9 24 fd ff ff       	jmp    c0021ed1 <intr_entry>

c00221ad <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c00221ad:	55                   	push   %ebp
c00221ae:	6a 00                	push   $0x0
c00221b0:	6a 44                	push   $0x44
c00221b2:	e9 1a fd ff ff       	jmp    c0021ed1 <intr_entry>

c00221b7 <intr45_stub>:
c00221b7:	55                   	push   %ebp
c00221b8:	6a 00                	push   $0x0
c00221ba:	6a 45                	push   $0x45
c00221bc:	e9 10 fd ff ff       	jmp    c0021ed1 <intr_entry>

c00221c1 <intr46_stub>:
c00221c1:	55                   	push   %ebp
c00221c2:	6a 00                	push   $0x0
c00221c4:	6a 46                	push   $0x46
c00221c6:	e9 06 fd ff ff       	jmp    c0021ed1 <intr_entry>

c00221cb <intr47_stub>:
c00221cb:	55                   	push   %ebp
c00221cc:	6a 00                	push   $0x0
c00221ce:	6a 47                	push   $0x47
c00221d0:	e9 fc fc ff ff       	jmp    c0021ed1 <intr_entry>

c00221d5 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c00221d5:	55                   	push   %ebp
c00221d6:	6a 00                	push   $0x0
c00221d8:	6a 48                	push   $0x48
c00221da:	e9 f2 fc ff ff       	jmp    c0021ed1 <intr_entry>

c00221df <intr49_stub>:
c00221df:	55                   	push   %ebp
c00221e0:	6a 00                	push   $0x0
c00221e2:	6a 49                	push   $0x49
c00221e4:	e9 e8 fc ff ff       	jmp    c0021ed1 <intr_entry>

c00221e9 <intr4a_stub>:
c00221e9:	55                   	push   %ebp
c00221ea:	6a 00                	push   $0x0
c00221ec:	6a 4a                	push   $0x4a
c00221ee:	e9 de fc ff ff       	jmp    c0021ed1 <intr_entry>

c00221f3 <intr4b_stub>:
c00221f3:	55                   	push   %ebp
c00221f4:	6a 00                	push   $0x0
c00221f6:	6a 4b                	push   $0x4b
c00221f8:	e9 d4 fc ff ff       	jmp    c0021ed1 <intr_entry>

c00221fd <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c00221fd:	55                   	push   %ebp
c00221fe:	6a 00                	push   $0x0
c0022200:	6a 4c                	push   $0x4c
c0022202:	e9 ca fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022207 <intr4d_stub>:
c0022207:	55                   	push   %ebp
c0022208:	6a 00                	push   $0x0
c002220a:	6a 4d                	push   $0x4d
c002220c:	e9 c0 fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022211 <intr4e_stub>:
c0022211:	55                   	push   %ebp
c0022212:	6a 00                	push   $0x0
c0022214:	6a 4e                	push   $0x4e
c0022216:	e9 b6 fc ff ff       	jmp    c0021ed1 <intr_entry>

c002221b <intr4f_stub>:
c002221b:	55                   	push   %ebp
c002221c:	6a 00                	push   $0x0
c002221e:	6a 4f                	push   $0x4f
c0022220:	e9 ac fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022225 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0022225:	55                   	push   %ebp
c0022226:	6a 00                	push   $0x0
c0022228:	6a 50                	push   $0x50
c002222a:	e9 a2 fc ff ff       	jmp    c0021ed1 <intr_entry>

c002222f <intr51_stub>:
c002222f:	55                   	push   %ebp
c0022230:	6a 00                	push   $0x0
c0022232:	6a 51                	push   $0x51
c0022234:	e9 98 fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022239 <intr52_stub>:
c0022239:	55                   	push   %ebp
c002223a:	6a 00                	push   $0x0
c002223c:	6a 52                	push   $0x52
c002223e:	e9 8e fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022243 <intr53_stub>:
c0022243:	55                   	push   %ebp
c0022244:	6a 00                	push   $0x0
c0022246:	6a 53                	push   $0x53
c0022248:	e9 84 fc ff ff       	jmp    c0021ed1 <intr_entry>

c002224d <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c002224d:	55                   	push   %ebp
c002224e:	6a 00                	push   $0x0
c0022250:	6a 54                	push   $0x54
c0022252:	e9 7a fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022257 <intr55_stub>:
c0022257:	55                   	push   %ebp
c0022258:	6a 00                	push   $0x0
c002225a:	6a 55                	push   $0x55
c002225c:	e9 70 fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022261 <intr56_stub>:
c0022261:	55                   	push   %ebp
c0022262:	6a 00                	push   $0x0
c0022264:	6a 56                	push   $0x56
c0022266:	e9 66 fc ff ff       	jmp    c0021ed1 <intr_entry>

c002226b <intr57_stub>:
c002226b:	55                   	push   %ebp
c002226c:	6a 00                	push   $0x0
c002226e:	6a 57                	push   $0x57
c0022270:	e9 5c fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022275 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0022275:	55                   	push   %ebp
c0022276:	6a 00                	push   $0x0
c0022278:	6a 58                	push   $0x58
c002227a:	e9 52 fc ff ff       	jmp    c0021ed1 <intr_entry>

c002227f <intr59_stub>:
c002227f:	55                   	push   %ebp
c0022280:	6a 00                	push   $0x0
c0022282:	6a 59                	push   $0x59
c0022284:	e9 48 fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022289 <intr5a_stub>:
c0022289:	55                   	push   %ebp
c002228a:	6a 00                	push   $0x0
c002228c:	6a 5a                	push   $0x5a
c002228e:	e9 3e fc ff ff       	jmp    c0021ed1 <intr_entry>

c0022293 <intr5b_stub>:
c0022293:	55                   	push   %ebp
c0022294:	6a 00                	push   $0x0
c0022296:	6a 5b                	push   $0x5b
c0022298:	e9 34 fc ff ff       	jmp    c0021ed1 <intr_entry>

c002229d <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c002229d:	55                   	push   %ebp
c002229e:	6a 00                	push   $0x0
c00222a0:	6a 5c                	push   $0x5c
c00222a2:	e9 2a fc ff ff       	jmp    c0021ed1 <intr_entry>

c00222a7 <intr5d_stub>:
c00222a7:	55                   	push   %ebp
c00222a8:	6a 00                	push   $0x0
c00222aa:	6a 5d                	push   $0x5d
c00222ac:	e9 20 fc ff ff       	jmp    c0021ed1 <intr_entry>

c00222b1 <intr5e_stub>:
c00222b1:	55                   	push   %ebp
c00222b2:	6a 00                	push   $0x0
c00222b4:	6a 5e                	push   $0x5e
c00222b6:	e9 16 fc ff ff       	jmp    c0021ed1 <intr_entry>

c00222bb <intr5f_stub>:
c00222bb:	55                   	push   %ebp
c00222bc:	6a 00                	push   $0x0
c00222be:	6a 5f                	push   $0x5f
c00222c0:	e9 0c fc ff ff       	jmp    c0021ed1 <intr_entry>

c00222c5 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c00222c5:	55                   	push   %ebp
c00222c6:	6a 00                	push   $0x0
c00222c8:	6a 60                	push   $0x60
c00222ca:	e9 02 fc ff ff       	jmp    c0021ed1 <intr_entry>

c00222cf <intr61_stub>:
c00222cf:	55                   	push   %ebp
c00222d0:	6a 00                	push   $0x0
c00222d2:	6a 61                	push   $0x61
c00222d4:	e9 f8 fb ff ff       	jmp    c0021ed1 <intr_entry>

c00222d9 <intr62_stub>:
c00222d9:	55                   	push   %ebp
c00222da:	6a 00                	push   $0x0
c00222dc:	6a 62                	push   $0x62
c00222de:	e9 ee fb ff ff       	jmp    c0021ed1 <intr_entry>

c00222e3 <intr63_stub>:
c00222e3:	55                   	push   %ebp
c00222e4:	6a 00                	push   $0x0
c00222e6:	6a 63                	push   $0x63
c00222e8:	e9 e4 fb ff ff       	jmp    c0021ed1 <intr_entry>

c00222ed <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c00222ed:	55                   	push   %ebp
c00222ee:	6a 00                	push   $0x0
c00222f0:	6a 64                	push   $0x64
c00222f2:	e9 da fb ff ff       	jmp    c0021ed1 <intr_entry>

c00222f7 <intr65_stub>:
c00222f7:	55                   	push   %ebp
c00222f8:	6a 00                	push   $0x0
c00222fa:	6a 65                	push   $0x65
c00222fc:	e9 d0 fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022301 <intr66_stub>:
c0022301:	55                   	push   %ebp
c0022302:	6a 00                	push   $0x0
c0022304:	6a 66                	push   $0x66
c0022306:	e9 c6 fb ff ff       	jmp    c0021ed1 <intr_entry>

c002230b <intr67_stub>:
c002230b:	55                   	push   %ebp
c002230c:	6a 00                	push   $0x0
c002230e:	6a 67                	push   $0x67
c0022310:	e9 bc fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022315 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c0022315:	55                   	push   %ebp
c0022316:	6a 00                	push   $0x0
c0022318:	6a 68                	push   $0x68
c002231a:	e9 b2 fb ff ff       	jmp    c0021ed1 <intr_entry>

c002231f <intr69_stub>:
c002231f:	55                   	push   %ebp
c0022320:	6a 00                	push   $0x0
c0022322:	6a 69                	push   $0x69
c0022324:	e9 a8 fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022329 <intr6a_stub>:
c0022329:	55                   	push   %ebp
c002232a:	6a 00                	push   $0x0
c002232c:	6a 6a                	push   $0x6a
c002232e:	e9 9e fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022333 <intr6b_stub>:
c0022333:	55                   	push   %ebp
c0022334:	6a 00                	push   $0x0
c0022336:	6a 6b                	push   $0x6b
c0022338:	e9 94 fb ff ff       	jmp    c0021ed1 <intr_entry>

c002233d <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c002233d:	55                   	push   %ebp
c002233e:	6a 00                	push   $0x0
c0022340:	6a 6c                	push   $0x6c
c0022342:	e9 8a fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022347 <intr6d_stub>:
c0022347:	55                   	push   %ebp
c0022348:	6a 00                	push   $0x0
c002234a:	6a 6d                	push   $0x6d
c002234c:	e9 80 fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022351 <intr6e_stub>:
c0022351:	55                   	push   %ebp
c0022352:	6a 00                	push   $0x0
c0022354:	6a 6e                	push   $0x6e
c0022356:	e9 76 fb ff ff       	jmp    c0021ed1 <intr_entry>

c002235b <intr6f_stub>:
c002235b:	55                   	push   %ebp
c002235c:	6a 00                	push   $0x0
c002235e:	6a 6f                	push   $0x6f
c0022360:	e9 6c fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022365 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c0022365:	55                   	push   %ebp
c0022366:	6a 00                	push   $0x0
c0022368:	6a 70                	push   $0x70
c002236a:	e9 62 fb ff ff       	jmp    c0021ed1 <intr_entry>

c002236f <intr71_stub>:
c002236f:	55                   	push   %ebp
c0022370:	6a 00                	push   $0x0
c0022372:	6a 71                	push   $0x71
c0022374:	e9 58 fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022379 <intr72_stub>:
c0022379:	55                   	push   %ebp
c002237a:	6a 00                	push   $0x0
c002237c:	6a 72                	push   $0x72
c002237e:	e9 4e fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022383 <intr73_stub>:
c0022383:	55                   	push   %ebp
c0022384:	6a 00                	push   $0x0
c0022386:	6a 73                	push   $0x73
c0022388:	e9 44 fb ff ff       	jmp    c0021ed1 <intr_entry>

c002238d <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c002238d:	55                   	push   %ebp
c002238e:	6a 00                	push   $0x0
c0022390:	6a 74                	push   $0x74
c0022392:	e9 3a fb ff ff       	jmp    c0021ed1 <intr_entry>

c0022397 <intr75_stub>:
c0022397:	55                   	push   %ebp
c0022398:	6a 00                	push   $0x0
c002239a:	6a 75                	push   $0x75
c002239c:	e9 30 fb ff ff       	jmp    c0021ed1 <intr_entry>

c00223a1 <intr76_stub>:
c00223a1:	55                   	push   %ebp
c00223a2:	6a 00                	push   $0x0
c00223a4:	6a 76                	push   $0x76
c00223a6:	e9 26 fb ff ff       	jmp    c0021ed1 <intr_entry>

c00223ab <intr77_stub>:
c00223ab:	55                   	push   %ebp
c00223ac:	6a 00                	push   $0x0
c00223ae:	6a 77                	push   $0x77
c00223b0:	e9 1c fb ff ff       	jmp    c0021ed1 <intr_entry>

c00223b5 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c00223b5:	55                   	push   %ebp
c00223b6:	6a 00                	push   $0x0
c00223b8:	6a 78                	push   $0x78
c00223ba:	e9 12 fb ff ff       	jmp    c0021ed1 <intr_entry>

c00223bf <intr79_stub>:
c00223bf:	55                   	push   %ebp
c00223c0:	6a 00                	push   $0x0
c00223c2:	6a 79                	push   $0x79
c00223c4:	e9 08 fb ff ff       	jmp    c0021ed1 <intr_entry>

c00223c9 <intr7a_stub>:
c00223c9:	55                   	push   %ebp
c00223ca:	6a 00                	push   $0x0
c00223cc:	6a 7a                	push   $0x7a
c00223ce:	e9 fe fa ff ff       	jmp    c0021ed1 <intr_entry>

c00223d3 <intr7b_stub>:
c00223d3:	55                   	push   %ebp
c00223d4:	6a 00                	push   $0x0
c00223d6:	6a 7b                	push   $0x7b
c00223d8:	e9 f4 fa ff ff       	jmp    c0021ed1 <intr_entry>

c00223dd <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00223dd:	55                   	push   %ebp
c00223de:	6a 00                	push   $0x0
c00223e0:	6a 7c                	push   $0x7c
c00223e2:	e9 ea fa ff ff       	jmp    c0021ed1 <intr_entry>

c00223e7 <intr7d_stub>:
c00223e7:	55                   	push   %ebp
c00223e8:	6a 00                	push   $0x0
c00223ea:	6a 7d                	push   $0x7d
c00223ec:	e9 e0 fa ff ff       	jmp    c0021ed1 <intr_entry>

c00223f1 <intr7e_stub>:
c00223f1:	55                   	push   %ebp
c00223f2:	6a 00                	push   $0x0
c00223f4:	6a 7e                	push   $0x7e
c00223f6:	e9 d6 fa ff ff       	jmp    c0021ed1 <intr_entry>

c00223fb <intr7f_stub>:
c00223fb:	55                   	push   %ebp
c00223fc:	6a 00                	push   $0x0
c00223fe:	6a 7f                	push   $0x7f
c0022400:	e9 cc fa ff ff       	jmp    c0021ed1 <intr_entry>

c0022405 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c0022405:	55                   	push   %ebp
c0022406:	6a 00                	push   $0x0
c0022408:	68 80 00 00 00       	push   $0x80
c002240d:	e9 bf fa ff ff       	jmp    c0021ed1 <intr_entry>

c0022412 <intr81_stub>:
c0022412:	55                   	push   %ebp
c0022413:	6a 00                	push   $0x0
c0022415:	68 81 00 00 00       	push   $0x81
c002241a:	e9 b2 fa ff ff       	jmp    c0021ed1 <intr_entry>

c002241f <intr82_stub>:
c002241f:	55                   	push   %ebp
c0022420:	6a 00                	push   $0x0
c0022422:	68 82 00 00 00       	push   $0x82
c0022427:	e9 a5 fa ff ff       	jmp    c0021ed1 <intr_entry>

c002242c <intr83_stub>:
c002242c:	55                   	push   %ebp
c002242d:	6a 00                	push   $0x0
c002242f:	68 83 00 00 00       	push   $0x83
c0022434:	e9 98 fa ff ff       	jmp    c0021ed1 <intr_entry>

c0022439 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c0022439:	55                   	push   %ebp
c002243a:	6a 00                	push   $0x0
c002243c:	68 84 00 00 00       	push   $0x84
c0022441:	e9 8b fa ff ff       	jmp    c0021ed1 <intr_entry>

c0022446 <intr85_stub>:
c0022446:	55                   	push   %ebp
c0022447:	6a 00                	push   $0x0
c0022449:	68 85 00 00 00       	push   $0x85
c002244e:	e9 7e fa ff ff       	jmp    c0021ed1 <intr_entry>

c0022453 <intr86_stub>:
c0022453:	55                   	push   %ebp
c0022454:	6a 00                	push   $0x0
c0022456:	68 86 00 00 00       	push   $0x86
c002245b:	e9 71 fa ff ff       	jmp    c0021ed1 <intr_entry>

c0022460 <intr87_stub>:
c0022460:	55                   	push   %ebp
c0022461:	6a 00                	push   $0x0
c0022463:	68 87 00 00 00       	push   $0x87
c0022468:	e9 64 fa ff ff       	jmp    c0021ed1 <intr_entry>

c002246d <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c002246d:	55                   	push   %ebp
c002246e:	6a 00                	push   $0x0
c0022470:	68 88 00 00 00       	push   $0x88
c0022475:	e9 57 fa ff ff       	jmp    c0021ed1 <intr_entry>

c002247a <intr89_stub>:
c002247a:	55                   	push   %ebp
c002247b:	6a 00                	push   $0x0
c002247d:	68 89 00 00 00       	push   $0x89
c0022482:	e9 4a fa ff ff       	jmp    c0021ed1 <intr_entry>

c0022487 <intr8a_stub>:
c0022487:	55                   	push   %ebp
c0022488:	6a 00                	push   $0x0
c002248a:	68 8a 00 00 00       	push   $0x8a
c002248f:	e9 3d fa ff ff       	jmp    c0021ed1 <intr_entry>

c0022494 <intr8b_stub>:
c0022494:	55                   	push   %ebp
c0022495:	6a 00                	push   $0x0
c0022497:	68 8b 00 00 00       	push   $0x8b
c002249c:	e9 30 fa ff ff       	jmp    c0021ed1 <intr_entry>

c00224a1 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c00224a1:	55                   	push   %ebp
c00224a2:	6a 00                	push   $0x0
c00224a4:	68 8c 00 00 00       	push   $0x8c
c00224a9:	e9 23 fa ff ff       	jmp    c0021ed1 <intr_entry>

c00224ae <intr8d_stub>:
c00224ae:	55                   	push   %ebp
c00224af:	6a 00                	push   $0x0
c00224b1:	68 8d 00 00 00       	push   $0x8d
c00224b6:	e9 16 fa ff ff       	jmp    c0021ed1 <intr_entry>

c00224bb <intr8e_stub>:
c00224bb:	55                   	push   %ebp
c00224bc:	6a 00                	push   $0x0
c00224be:	68 8e 00 00 00       	push   $0x8e
c00224c3:	e9 09 fa ff ff       	jmp    c0021ed1 <intr_entry>

c00224c8 <intr8f_stub>:
c00224c8:	55                   	push   %ebp
c00224c9:	6a 00                	push   $0x0
c00224cb:	68 8f 00 00 00       	push   $0x8f
c00224d0:	e9 fc f9 ff ff       	jmp    c0021ed1 <intr_entry>

c00224d5 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c00224d5:	55                   	push   %ebp
c00224d6:	6a 00                	push   $0x0
c00224d8:	68 90 00 00 00       	push   $0x90
c00224dd:	e9 ef f9 ff ff       	jmp    c0021ed1 <intr_entry>

c00224e2 <intr91_stub>:
c00224e2:	55                   	push   %ebp
c00224e3:	6a 00                	push   $0x0
c00224e5:	68 91 00 00 00       	push   $0x91
c00224ea:	e9 e2 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c00224ef <intr92_stub>:
c00224ef:	55                   	push   %ebp
c00224f0:	6a 00                	push   $0x0
c00224f2:	68 92 00 00 00       	push   $0x92
c00224f7:	e9 d5 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c00224fc <intr93_stub>:
c00224fc:	55                   	push   %ebp
c00224fd:	6a 00                	push   $0x0
c00224ff:	68 93 00 00 00       	push   $0x93
c0022504:	e9 c8 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c0022509 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c0022509:	55                   	push   %ebp
c002250a:	6a 00                	push   $0x0
c002250c:	68 94 00 00 00       	push   $0x94
c0022511:	e9 bb f9 ff ff       	jmp    c0021ed1 <intr_entry>

c0022516 <intr95_stub>:
c0022516:	55                   	push   %ebp
c0022517:	6a 00                	push   $0x0
c0022519:	68 95 00 00 00       	push   $0x95
c002251e:	e9 ae f9 ff ff       	jmp    c0021ed1 <intr_entry>

c0022523 <intr96_stub>:
c0022523:	55                   	push   %ebp
c0022524:	6a 00                	push   $0x0
c0022526:	68 96 00 00 00       	push   $0x96
c002252b:	e9 a1 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c0022530 <intr97_stub>:
c0022530:	55                   	push   %ebp
c0022531:	6a 00                	push   $0x0
c0022533:	68 97 00 00 00       	push   $0x97
c0022538:	e9 94 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c002253d <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c002253d:	55                   	push   %ebp
c002253e:	6a 00                	push   $0x0
c0022540:	68 98 00 00 00       	push   $0x98
c0022545:	e9 87 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c002254a <intr99_stub>:
c002254a:	55                   	push   %ebp
c002254b:	6a 00                	push   $0x0
c002254d:	68 99 00 00 00       	push   $0x99
c0022552:	e9 7a f9 ff ff       	jmp    c0021ed1 <intr_entry>

c0022557 <intr9a_stub>:
c0022557:	55                   	push   %ebp
c0022558:	6a 00                	push   $0x0
c002255a:	68 9a 00 00 00       	push   $0x9a
c002255f:	e9 6d f9 ff ff       	jmp    c0021ed1 <intr_entry>

c0022564 <intr9b_stub>:
c0022564:	55                   	push   %ebp
c0022565:	6a 00                	push   $0x0
c0022567:	68 9b 00 00 00       	push   $0x9b
c002256c:	e9 60 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c0022571 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c0022571:	55                   	push   %ebp
c0022572:	6a 00                	push   $0x0
c0022574:	68 9c 00 00 00       	push   $0x9c
c0022579:	e9 53 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c002257e <intr9d_stub>:
c002257e:	55                   	push   %ebp
c002257f:	6a 00                	push   $0x0
c0022581:	68 9d 00 00 00       	push   $0x9d
c0022586:	e9 46 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c002258b <intr9e_stub>:
c002258b:	55                   	push   %ebp
c002258c:	6a 00                	push   $0x0
c002258e:	68 9e 00 00 00       	push   $0x9e
c0022593:	e9 39 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c0022598 <intr9f_stub>:
c0022598:	55                   	push   %ebp
c0022599:	6a 00                	push   $0x0
c002259b:	68 9f 00 00 00       	push   $0x9f
c00225a0:	e9 2c f9 ff ff       	jmp    c0021ed1 <intr_entry>

c00225a5 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00225a5:	55                   	push   %ebp
c00225a6:	6a 00                	push   $0x0
c00225a8:	68 a0 00 00 00       	push   $0xa0
c00225ad:	e9 1f f9 ff ff       	jmp    c0021ed1 <intr_entry>

c00225b2 <intra1_stub>:
c00225b2:	55                   	push   %ebp
c00225b3:	6a 00                	push   $0x0
c00225b5:	68 a1 00 00 00       	push   $0xa1
c00225ba:	e9 12 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c00225bf <intra2_stub>:
c00225bf:	55                   	push   %ebp
c00225c0:	6a 00                	push   $0x0
c00225c2:	68 a2 00 00 00       	push   $0xa2
c00225c7:	e9 05 f9 ff ff       	jmp    c0021ed1 <intr_entry>

c00225cc <intra3_stub>:
c00225cc:	55                   	push   %ebp
c00225cd:	6a 00                	push   $0x0
c00225cf:	68 a3 00 00 00       	push   $0xa3
c00225d4:	e9 f8 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c00225d9 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c00225d9:	55                   	push   %ebp
c00225da:	6a 00                	push   $0x0
c00225dc:	68 a4 00 00 00       	push   $0xa4
c00225e1:	e9 eb f8 ff ff       	jmp    c0021ed1 <intr_entry>

c00225e6 <intra5_stub>:
c00225e6:	55                   	push   %ebp
c00225e7:	6a 00                	push   $0x0
c00225e9:	68 a5 00 00 00       	push   $0xa5
c00225ee:	e9 de f8 ff ff       	jmp    c0021ed1 <intr_entry>

c00225f3 <intra6_stub>:
c00225f3:	55                   	push   %ebp
c00225f4:	6a 00                	push   $0x0
c00225f6:	68 a6 00 00 00       	push   $0xa6
c00225fb:	e9 d1 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c0022600 <intra7_stub>:
c0022600:	55                   	push   %ebp
c0022601:	6a 00                	push   $0x0
c0022603:	68 a7 00 00 00       	push   $0xa7
c0022608:	e9 c4 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c002260d <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c002260d:	55                   	push   %ebp
c002260e:	6a 00                	push   $0x0
c0022610:	68 a8 00 00 00       	push   $0xa8
c0022615:	e9 b7 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c002261a <intra9_stub>:
c002261a:	55                   	push   %ebp
c002261b:	6a 00                	push   $0x0
c002261d:	68 a9 00 00 00       	push   $0xa9
c0022622:	e9 aa f8 ff ff       	jmp    c0021ed1 <intr_entry>

c0022627 <intraa_stub>:
c0022627:	55                   	push   %ebp
c0022628:	6a 00                	push   $0x0
c002262a:	68 aa 00 00 00       	push   $0xaa
c002262f:	e9 9d f8 ff ff       	jmp    c0021ed1 <intr_entry>

c0022634 <intrab_stub>:
c0022634:	55                   	push   %ebp
c0022635:	6a 00                	push   $0x0
c0022637:	68 ab 00 00 00       	push   $0xab
c002263c:	e9 90 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c0022641 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022641:	55                   	push   %ebp
c0022642:	6a 00                	push   $0x0
c0022644:	68 ac 00 00 00       	push   $0xac
c0022649:	e9 83 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c002264e <intrad_stub>:
c002264e:	55                   	push   %ebp
c002264f:	6a 00                	push   $0x0
c0022651:	68 ad 00 00 00       	push   $0xad
c0022656:	e9 76 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c002265b <intrae_stub>:
c002265b:	55                   	push   %ebp
c002265c:	6a 00                	push   $0x0
c002265e:	68 ae 00 00 00       	push   $0xae
c0022663:	e9 69 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c0022668 <intraf_stub>:
c0022668:	55                   	push   %ebp
c0022669:	6a 00                	push   $0x0
c002266b:	68 af 00 00 00       	push   $0xaf
c0022670:	e9 5c f8 ff ff       	jmp    c0021ed1 <intr_entry>

c0022675 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022675:	55                   	push   %ebp
c0022676:	6a 00                	push   $0x0
c0022678:	68 b0 00 00 00       	push   $0xb0
c002267d:	e9 4f f8 ff ff       	jmp    c0021ed1 <intr_entry>

c0022682 <intrb1_stub>:
c0022682:	55                   	push   %ebp
c0022683:	6a 00                	push   $0x0
c0022685:	68 b1 00 00 00       	push   $0xb1
c002268a:	e9 42 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c002268f <intrb2_stub>:
c002268f:	55                   	push   %ebp
c0022690:	6a 00                	push   $0x0
c0022692:	68 b2 00 00 00       	push   $0xb2
c0022697:	e9 35 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c002269c <intrb3_stub>:
c002269c:	55                   	push   %ebp
c002269d:	6a 00                	push   $0x0
c002269f:	68 b3 00 00 00       	push   $0xb3
c00226a4:	e9 28 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c00226a9 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00226a9:	55                   	push   %ebp
c00226aa:	6a 00                	push   $0x0
c00226ac:	68 b4 00 00 00       	push   $0xb4
c00226b1:	e9 1b f8 ff ff       	jmp    c0021ed1 <intr_entry>

c00226b6 <intrb5_stub>:
c00226b6:	55                   	push   %ebp
c00226b7:	6a 00                	push   $0x0
c00226b9:	68 b5 00 00 00       	push   $0xb5
c00226be:	e9 0e f8 ff ff       	jmp    c0021ed1 <intr_entry>

c00226c3 <intrb6_stub>:
c00226c3:	55                   	push   %ebp
c00226c4:	6a 00                	push   $0x0
c00226c6:	68 b6 00 00 00       	push   $0xb6
c00226cb:	e9 01 f8 ff ff       	jmp    c0021ed1 <intr_entry>

c00226d0 <intrb7_stub>:
c00226d0:	55                   	push   %ebp
c00226d1:	6a 00                	push   $0x0
c00226d3:	68 b7 00 00 00       	push   $0xb7
c00226d8:	e9 f4 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c00226dd <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c00226dd:	55                   	push   %ebp
c00226de:	6a 00                	push   $0x0
c00226e0:	68 b8 00 00 00       	push   $0xb8
c00226e5:	e9 e7 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c00226ea <intrb9_stub>:
c00226ea:	55                   	push   %ebp
c00226eb:	6a 00                	push   $0x0
c00226ed:	68 b9 00 00 00       	push   $0xb9
c00226f2:	e9 da f7 ff ff       	jmp    c0021ed1 <intr_entry>

c00226f7 <intrba_stub>:
c00226f7:	55                   	push   %ebp
c00226f8:	6a 00                	push   $0x0
c00226fa:	68 ba 00 00 00       	push   $0xba
c00226ff:	e9 cd f7 ff ff       	jmp    c0021ed1 <intr_entry>

c0022704 <intrbb_stub>:
c0022704:	55                   	push   %ebp
c0022705:	6a 00                	push   $0x0
c0022707:	68 bb 00 00 00       	push   $0xbb
c002270c:	e9 c0 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c0022711 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022711:	55                   	push   %ebp
c0022712:	6a 00                	push   $0x0
c0022714:	68 bc 00 00 00       	push   $0xbc
c0022719:	e9 b3 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c002271e <intrbd_stub>:
c002271e:	55                   	push   %ebp
c002271f:	6a 00                	push   $0x0
c0022721:	68 bd 00 00 00       	push   $0xbd
c0022726:	e9 a6 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c002272b <intrbe_stub>:
c002272b:	55                   	push   %ebp
c002272c:	6a 00                	push   $0x0
c002272e:	68 be 00 00 00       	push   $0xbe
c0022733:	e9 99 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c0022738 <intrbf_stub>:
c0022738:	55                   	push   %ebp
c0022739:	6a 00                	push   $0x0
c002273b:	68 bf 00 00 00       	push   $0xbf
c0022740:	e9 8c f7 ff ff       	jmp    c0021ed1 <intr_entry>

c0022745 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022745:	55                   	push   %ebp
c0022746:	6a 00                	push   $0x0
c0022748:	68 c0 00 00 00       	push   $0xc0
c002274d:	e9 7f f7 ff ff       	jmp    c0021ed1 <intr_entry>

c0022752 <intrc1_stub>:
c0022752:	55                   	push   %ebp
c0022753:	6a 00                	push   $0x0
c0022755:	68 c1 00 00 00       	push   $0xc1
c002275a:	e9 72 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c002275f <intrc2_stub>:
c002275f:	55                   	push   %ebp
c0022760:	6a 00                	push   $0x0
c0022762:	68 c2 00 00 00       	push   $0xc2
c0022767:	e9 65 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c002276c <intrc3_stub>:
c002276c:	55                   	push   %ebp
c002276d:	6a 00                	push   $0x0
c002276f:	68 c3 00 00 00       	push   $0xc3
c0022774:	e9 58 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c0022779 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022779:	55                   	push   %ebp
c002277a:	6a 00                	push   $0x0
c002277c:	68 c4 00 00 00       	push   $0xc4
c0022781:	e9 4b f7 ff ff       	jmp    c0021ed1 <intr_entry>

c0022786 <intrc5_stub>:
c0022786:	55                   	push   %ebp
c0022787:	6a 00                	push   $0x0
c0022789:	68 c5 00 00 00       	push   $0xc5
c002278e:	e9 3e f7 ff ff       	jmp    c0021ed1 <intr_entry>

c0022793 <intrc6_stub>:
c0022793:	55                   	push   %ebp
c0022794:	6a 00                	push   $0x0
c0022796:	68 c6 00 00 00       	push   $0xc6
c002279b:	e9 31 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c00227a0 <intrc7_stub>:
c00227a0:	55                   	push   %ebp
c00227a1:	6a 00                	push   $0x0
c00227a3:	68 c7 00 00 00       	push   $0xc7
c00227a8:	e9 24 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c00227ad <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c00227ad:	55                   	push   %ebp
c00227ae:	6a 00                	push   $0x0
c00227b0:	68 c8 00 00 00       	push   $0xc8
c00227b5:	e9 17 f7 ff ff       	jmp    c0021ed1 <intr_entry>

c00227ba <intrc9_stub>:
c00227ba:	55                   	push   %ebp
c00227bb:	6a 00                	push   $0x0
c00227bd:	68 c9 00 00 00       	push   $0xc9
c00227c2:	e9 0a f7 ff ff       	jmp    c0021ed1 <intr_entry>

c00227c7 <intrca_stub>:
c00227c7:	55                   	push   %ebp
c00227c8:	6a 00                	push   $0x0
c00227ca:	68 ca 00 00 00       	push   $0xca
c00227cf:	e9 fd f6 ff ff       	jmp    c0021ed1 <intr_entry>

c00227d4 <intrcb_stub>:
c00227d4:	55                   	push   %ebp
c00227d5:	6a 00                	push   $0x0
c00227d7:	68 cb 00 00 00       	push   $0xcb
c00227dc:	e9 f0 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c00227e1 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c00227e1:	55                   	push   %ebp
c00227e2:	6a 00                	push   $0x0
c00227e4:	68 cc 00 00 00       	push   $0xcc
c00227e9:	e9 e3 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c00227ee <intrcd_stub>:
c00227ee:	55                   	push   %ebp
c00227ef:	6a 00                	push   $0x0
c00227f1:	68 cd 00 00 00       	push   $0xcd
c00227f6:	e9 d6 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c00227fb <intrce_stub>:
c00227fb:	55                   	push   %ebp
c00227fc:	6a 00                	push   $0x0
c00227fe:	68 ce 00 00 00       	push   $0xce
c0022803:	e9 c9 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c0022808 <intrcf_stub>:
c0022808:	55                   	push   %ebp
c0022809:	6a 00                	push   $0x0
c002280b:	68 cf 00 00 00       	push   $0xcf
c0022810:	e9 bc f6 ff ff       	jmp    c0021ed1 <intr_entry>

c0022815 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022815:	55                   	push   %ebp
c0022816:	6a 00                	push   $0x0
c0022818:	68 d0 00 00 00       	push   $0xd0
c002281d:	e9 af f6 ff ff       	jmp    c0021ed1 <intr_entry>

c0022822 <intrd1_stub>:
c0022822:	55                   	push   %ebp
c0022823:	6a 00                	push   $0x0
c0022825:	68 d1 00 00 00       	push   $0xd1
c002282a:	e9 a2 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c002282f <intrd2_stub>:
c002282f:	55                   	push   %ebp
c0022830:	6a 00                	push   $0x0
c0022832:	68 d2 00 00 00       	push   $0xd2
c0022837:	e9 95 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c002283c <intrd3_stub>:
c002283c:	55                   	push   %ebp
c002283d:	6a 00                	push   $0x0
c002283f:	68 d3 00 00 00       	push   $0xd3
c0022844:	e9 88 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c0022849 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022849:	55                   	push   %ebp
c002284a:	6a 00                	push   $0x0
c002284c:	68 d4 00 00 00       	push   $0xd4
c0022851:	e9 7b f6 ff ff       	jmp    c0021ed1 <intr_entry>

c0022856 <intrd5_stub>:
c0022856:	55                   	push   %ebp
c0022857:	6a 00                	push   $0x0
c0022859:	68 d5 00 00 00       	push   $0xd5
c002285e:	e9 6e f6 ff ff       	jmp    c0021ed1 <intr_entry>

c0022863 <intrd6_stub>:
c0022863:	55                   	push   %ebp
c0022864:	6a 00                	push   $0x0
c0022866:	68 d6 00 00 00       	push   $0xd6
c002286b:	e9 61 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c0022870 <intrd7_stub>:
c0022870:	55                   	push   %ebp
c0022871:	6a 00                	push   $0x0
c0022873:	68 d7 00 00 00       	push   $0xd7
c0022878:	e9 54 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c002287d <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c002287d:	55                   	push   %ebp
c002287e:	6a 00                	push   $0x0
c0022880:	68 d8 00 00 00       	push   $0xd8
c0022885:	e9 47 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c002288a <intrd9_stub>:
c002288a:	55                   	push   %ebp
c002288b:	6a 00                	push   $0x0
c002288d:	68 d9 00 00 00       	push   $0xd9
c0022892:	e9 3a f6 ff ff       	jmp    c0021ed1 <intr_entry>

c0022897 <intrda_stub>:
c0022897:	55                   	push   %ebp
c0022898:	6a 00                	push   $0x0
c002289a:	68 da 00 00 00       	push   $0xda
c002289f:	e9 2d f6 ff ff       	jmp    c0021ed1 <intr_entry>

c00228a4 <intrdb_stub>:
c00228a4:	55                   	push   %ebp
c00228a5:	6a 00                	push   $0x0
c00228a7:	68 db 00 00 00       	push   $0xdb
c00228ac:	e9 20 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c00228b1 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c00228b1:	55                   	push   %ebp
c00228b2:	6a 00                	push   $0x0
c00228b4:	68 dc 00 00 00       	push   $0xdc
c00228b9:	e9 13 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c00228be <intrdd_stub>:
c00228be:	55                   	push   %ebp
c00228bf:	6a 00                	push   $0x0
c00228c1:	68 dd 00 00 00       	push   $0xdd
c00228c6:	e9 06 f6 ff ff       	jmp    c0021ed1 <intr_entry>

c00228cb <intrde_stub>:
c00228cb:	55                   	push   %ebp
c00228cc:	6a 00                	push   $0x0
c00228ce:	68 de 00 00 00       	push   $0xde
c00228d3:	e9 f9 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c00228d8 <intrdf_stub>:
c00228d8:	55                   	push   %ebp
c00228d9:	6a 00                	push   $0x0
c00228db:	68 df 00 00 00       	push   $0xdf
c00228e0:	e9 ec f5 ff ff       	jmp    c0021ed1 <intr_entry>

c00228e5 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c00228e5:	55                   	push   %ebp
c00228e6:	6a 00                	push   $0x0
c00228e8:	68 e0 00 00 00       	push   $0xe0
c00228ed:	e9 df f5 ff ff       	jmp    c0021ed1 <intr_entry>

c00228f2 <intre1_stub>:
c00228f2:	55                   	push   %ebp
c00228f3:	6a 00                	push   $0x0
c00228f5:	68 e1 00 00 00       	push   $0xe1
c00228fa:	e9 d2 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c00228ff <intre2_stub>:
c00228ff:	55                   	push   %ebp
c0022900:	6a 00                	push   $0x0
c0022902:	68 e2 00 00 00       	push   $0xe2
c0022907:	e9 c5 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c002290c <intre3_stub>:
c002290c:	55                   	push   %ebp
c002290d:	6a 00                	push   $0x0
c002290f:	68 e3 00 00 00       	push   $0xe3
c0022914:	e9 b8 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c0022919 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022919:	55                   	push   %ebp
c002291a:	6a 00                	push   $0x0
c002291c:	68 e4 00 00 00       	push   $0xe4
c0022921:	e9 ab f5 ff ff       	jmp    c0021ed1 <intr_entry>

c0022926 <intre5_stub>:
c0022926:	55                   	push   %ebp
c0022927:	6a 00                	push   $0x0
c0022929:	68 e5 00 00 00       	push   $0xe5
c002292e:	e9 9e f5 ff ff       	jmp    c0021ed1 <intr_entry>

c0022933 <intre6_stub>:
c0022933:	55                   	push   %ebp
c0022934:	6a 00                	push   $0x0
c0022936:	68 e6 00 00 00       	push   $0xe6
c002293b:	e9 91 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c0022940 <intre7_stub>:
c0022940:	55                   	push   %ebp
c0022941:	6a 00                	push   $0x0
c0022943:	68 e7 00 00 00       	push   $0xe7
c0022948:	e9 84 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c002294d <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c002294d:	55                   	push   %ebp
c002294e:	6a 00                	push   $0x0
c0022950:	68 e8 00 00 00       	push   $0xe8
c0022955:	e9 77 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c002295a <intre9_stub>:
c002295a:	55                   	push   %ebp
c002295b:	6a 00                	push   $0x0
c002295d:	68 e9 00 00 00       	push   $0xe9
c0022962:	e9 6a f5 ff ff       	jmp    c0021ed1 <intr_entry>

c0022967 <intrea_stub>:
c0022967:	55                   	push   %ebp
c0022968:	6a 00                	push   $0x0
c002296a:	68 ea 00 00 00       	push   $0xea
c002296f:	e9 5d f5 ff ff       	jmp    c0021ed1 <intr_entry>

c0022974 <intreb_stub>:
c0022974:	55                   	push   %ebp
c0022975:	6a 00                	push   $0x0
c0022977:	68 eb 00 00 00       	push   $0xeb
c002297c:	e9 50 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c0022981 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022981:	55                   	push   %ebp
c0022982:	6a 00                	push   $0x0
c0022984:	68 ec 00 00 00       	push   $0xec
c0022989:	e9 43 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c002298e <intred_stub>:
c002298e:	55                   	push   %ebp
c002298f:	6a 00                	push   $0x0
c0022991:	68 ed 00 00 00       	push   $0xed
c0022996:	e9 36 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c002299b <intree_stub>:
c002299b:	55                   	push   %ebp
c002299c:	6a 00                	push   $0x0
c002299e:	68 ee 00 00 00       	push   $0xee
c00229a3:	e9 29 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c00229a8 <intref_stub>:
c00229a8:	55                   	push   %ebp
c00229a9:	6a 00                	push   $0x0
c00229ab:	68 ef 00 00 00       	push   $0xef
c00229b0:	e9 1c f5 ff ff       	jmp    c0021ed1 <intr_entry>

c00229b5 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c00229b5:	55                   	push   %ebp
c00229b6:	6a 00                	push   $0x0
c00229b8:	68 f0 00 00 00       	push   $0xf0
c00229bd:	e9 0f f5 ff ff       	jmp    c0021ed1 <intr_entry>

c00229c2 <intrf1_stub>:
c00229c2:	55                   	push   %ebp
c00229c3:	6a 00                	push   $0x0
c00229c5:	68 f1 00 00 00       	push   $0xf1
c00229ca:	e9 02 f5 ff ff       	jmp    c0021ed1 <intr_entry>

c00229cf <intrf2_stub>:
c00229cf:	55                   	push   %ebp
c00229d0:	6a 00                	push   $0x0
c00229d2:	68 f2 00 00 00       	push   $0xf2
c00229d7:	e9 f5 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c00229dc <intrf3_stub>:
c00229dc:	55                   	push   %ebp
c00229dd:	6a 00                	push   $0x0
c00229df:	68 f3 00 00 00       	push   $0xf3
c00229e4:	e9 e8 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c00229e9 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c00229e9:	55                   	push   %ebp
c00229ea:	6a 00                	push   $0x0
c00229ec:	68 f4 00 00 00       	push   $0xf4
c00229f1:	e9 db f4 ff ff       	jmp    c0021ed1 <intr_entry>

c00229f6 <intrf5_stub>:
c00229f6:	55                   	push   %ebp
c00229f7:	6a 00                	push   $0x0
c00229f9:	68 f5 00 00 00       	push   $0xf5
c00229fe:	e9 ce f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a03 <intrf6_stub>:
c0022a03:	55                   	push   %ebp
c0022a04:	6a 00                	push   $0x0
c0022a06:	68 f6 00 00 00       	push   $0xf6
c0022a0b:	e9 c1 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a10 <intrf7_stub>:
c0022a10:	55                   	push   %ebp
c0022a11:	6a 00                	push   $0x0
c0022a13:	68 f7 00 00 00       	push   $0xf7
c0022a18:	e9 b4 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a1d <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022a1d:	55                   	push   %ebp
c0022a1e:	6a 00                	push   $0x0
c0022a20:	68 f8 00 00 00       	push   $0xf8
c0022a25:	e9 a7 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a2a <intrf9_stub>:
c0022a2a:	55                   	push   %ebp
c0022a2b:	6a 00                	push   $0x0
c0022a2d:	68 f9 00 00 00       	push   $0xf9
c0022a32:	e9 9a f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a37 <intrfa_stub>:
c0022a37:	55                   	push   %ebp
c0022a38:	6a 00                	push   $0x0
c0022a3a:	68 fa 00 00 00       	push   $0xfa
c0022a3f:	e9 8d f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a44 <intrfb_stub>:
c0022a44:	55                   	push   %ebp
c0022a45:	6a 00                	push   $0x0
c0022a47:	68 fb 00 00 00       	push   $0xfb
c0022a4c:	e9 80 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a51 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022a51:	55                   	push   %ebp
c0022a52:	6a 00                	push   $0x0
c0022a54:	68 fc 00 00 00       	push   $0xfc
c0022a59:	e9 73 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a5e <intrfd_stub>:
c0022a5e:	55                   	push   %ebp
c0022a5f:	6a 00                	push   $0x0
c0022a61:	68 fd 00 00 00       	push   $0xfd
c0022a66:	e9 66 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a6b <intrfe_stub>:
c0022a6b:	55                   	push   %ebp
c0022a6c:	6a 00                	push   $0x0
c0022a6e:	68 fe 00 00 00       	push   $0xfe
c0022a73:	e9 59 f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a78 <intrff_stub>:
c0022a78:	55                   	push   %ebp
c0022a79:	6a 00                	push   $0x0
c0022a7b:	68 ff 00 00 00       	push   $0xff
c0022a80:	e9 4c f4 ff ff       	jmp    c0021ed1 <intr_entry>

c0022a85 <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c0022a85:	53                   	push   %ebx
c0022a86:	83 ec 08             	sub    $0x8,%esp
c0022a89:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (sema != NULL);
c0022a8d:	85 c0                	test   %eax,%eax
c0022a8f:	74 26                	je     c0022ab7 <sema_init+0x32>

  sema->value = value;
c0022a91:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022a95:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c0022a97:	8d 58 04             	lea    0x4(%eax),%ebx
c0022a9a:	83 ec 0c             	sub    $0xc,%esp
c0022a9d:	53                   	push   %ebx
c0022a9e:	e8 81 5c 00 00       	call   c0028724 <list_init>
  ASSERT (list_empty(&sema->waiters));
c0022aa3:	89 1c 24             	mov    %ebx,(%esp)
c0022aa6:	e8 6d 61 00 00       	call   c0028c18 <list_empty>
c0022aab:	83 c4 10             	add    $0x10,%esp
c0022aae:	84 c0                	test   %al,%al
c0022ab0:	74 23                	je     c0022ad5 <sema_init+0x50>
}
c0022ab2:	83 c4 08             	add    $0x8,%esp
c0022ab5:	5b                   	pop    %ebx
c0022ab6:	c3                   	ret    
  ASSERT (sema != NULL);
c0022ab7:	83 ec 0c             	sub    $0xc,%esp
c0022aba:	68 1e 18 03 c0       	push   $0xc003181e
c0022abf:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022ac4:	68 ac f7 02 c0       	push   $0xc002f7ac
c0022ac9:	6a 31                	push   $0x31
c0022acb:	68 2b 18 03 c0       	push   $0xc003182b
c0022ad0:	e8 a8 5b 00 00       	call   c002867d <debug_panic>
  ASSERT (list_empty(&sema->waiters));
c0022ad5:	83 ec 0c             	sub    $0xc,%esp
c0022ad8:	68 41 18 03 c0       	push   $0xc0031841
c0022add:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022ae2:	68 ac f7 02 c0       	push   $0xc002f7ac
c0022ae7:	6a 35                	push   $0x35
c0022ae9:	68 2b 18 03 c0       	push   $0xc003182b
c0022aee:	e8 8a 5b 00 00       	call   c002867d <debug_panic>

c0022af3 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c0022af3:	57                   	push   %edi
c0022af4:	56                   	push   %esi
c0022af5:	53                   	push   %ebx
c0022af6:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022afa:	85 db                	test   %ebx,%ebx
c0022afc:	74 4c                	je     c0022b4a <sema_down+0x57>
  ASSERT (!intr_context ());
c0022afe:	e8 79 f1 ff ff       	call   c0021c7c <intr_context>
c0022b03:	84 c0                	test   %al,%al
c0022b05:	75 61                	jne    c0022b68 <sema_down+0x75>

  old_level = intr_disable ();
c0022b07:	e8 4f ef ff ff       	call   c0021a5b <intr_disable>
c0022b0c:	89 c7                	mov    %eax,%edi
  while (sema->value == 0) 
c0022b0e:	8b 03                	mov    (%ebx),%eax
c0022b10:	85 c0                	test   %eax,%eax
c0022b12:	75 23                	jne    c0022b37 <sema_down+0x44>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c0022b14:	8d 73 04             	lea    0x4(%ebx),%esi
c0022b17:	e8 fa e1 ff ff       	call   c0020d16 <thread_current>
c0022b1c:	83 ec 08             	sub    $0x8,%esp
c0022b1f:	83 c0 5c             	add    $0x5c,%eax
c0022b22:	50                   	push   %eax
c0022b23:	56                   	push   %esi
c0022b24:	e8 47 60 00 00       	call   c0028b70 <list_push_back>
      thread_block ();
c0022b29:	e8 29 e9 ff ff       	call   c0021457 <thread_block>
  while (sema->value == 0) 
c0022b2e:	8b 03                	mov    (%ebx),%eax
c0022b30:	83 c4 10             	add    $0x10,%esp
c0022b33:	85 c0                	test   %eax,%eax
c0022b35:	74 e0                	je     c0022b17 <sema_down+0x24>
    }
  sema->value--;
c0022b37:	48                   	dec    %eax
c0022b38:	89 03                	mov    %eax,(%ebx)
  intr_set_level (old_level);
c0022b3a:	83 ec 0c             	sub    $0xc,%esp
c0022b3d:	57                   	push   %edi
c0022b3e:	e8 1f ef ff ff       	call   c0021a62 <intr_set_level>
}
c0022b43:	83 c4 10             	add    $0x10,%esp
c0022b46:	5b                   	pop    %ebx
c0022b47:	5e                   	pop    %esi
c0022b48:	5f                   	pop    %edi
c0022b49:	c3                   	ret    
  ASSERT (sema != NULL);
c0022b4a:	83 ec 0c             	sub    $0xc,%esp
c0022b4d:	68 1e 18 03 c0       	push   $0xc003181e
c0022b52:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022b57:	68 a0 f7 02 c0       	push   $0xc002f7a0
c0022b5c:	6a 44                	push   $0x44
c0022b5e:	68 2b 18 03 c0       	push   $0xc003182b
c0022b63:	e8 15 5b 00 00       	call   c002867d <debug_panic>
  ASSERT (!intr_context ());
c0022b68:	83 ec 0c             	sub    $0xc,%esp
c0022b6b:	68 c0 13 03 c0       	push   $0xc00313c0
c0022b70:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022b75:	68 a0 f7 02 c0       	push   $0xc002f7a0
c0022b7a:	6a 45                	push   $0x45
c0022b7c:	68 2b 18 03 c0       	push   $0xc003182b
c0022b81:	e8 f7 5a 00 00       	call   c002867d <debug_panic>

c0022b86 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022b86:	53                   	push   %ebx
c0022b87:	83 ec 08             	sub    $0x8,%esp
c0022b8a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c0022b8e:	85 db                	test   %ebx,%ebx
c0022b90:	74 20                	je     c0022bb2 <sema_try_down+0x2c>

  old_level = intr_disable ();
c0022b92:	e8 c4 ee ff ff       	call   c0021a5b <intr_disable>
  if (sema->value > 0) 
c0022b97:	8b 13                	mov    (%ebx),%edx
c0022b99:	85 d2                	test   %edx,%edx
c0022b9b:	74 33                	je     c0022bd0 <sema_try_down+0x4a>
    {
      sema->value--;
c0022b9d:	4a                   	dec    %edx
c0022b9e:	89 13                	mov    %edx,(%ebx)
      success = true; 
c0022ba0:	b3 01                	mov    $0x1,%bl
    }
  else
    success = false;
  intr_set_level (old_level);
c0022ba2:	83 ec 0c             	sub    $0xc,%esp
c0022ba5:	50                   	push   %eax
c0022ba6:	e8 b7 ee ff ff       	call   c0021a62 <intr_set_level>

  return success;
}
c0022bab:	88 d8                	mov    %bl,%al
c0022bad:	83 c4 18             	add    $0x18,%esp
c0022bb0:	5b                   	pop    %ebx
c0022bb1:	c3                   	ret    
  ASSERT (sema != NULL);
c0022bb2:	83 ec 0c             	sub    $0xc,%esp
c0022bb5:	68 1e 18 03 c0       	push   $0xc003181e
c0022bba:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022bbf:	68 90 f7 02 c0       	push   $0xc002f790
c0022bc4:	6a 5c                	push   $0x5c
c0022bc6:	68 2b 18 03 c0       	push   $0xc003182b
c0022bcb:	e8 ad 5a 00 00       	call   c002867d <debug_panic>
    success = false;
c0022bd0:	b3 00                	mov    $0x0,%bl
c0022bd2:	eb ce                	jmp    c0022ba2 <sema_try_down+0x1c>

c0022bd4 <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0022bd4:	55                   	push   %ebp
c0022bd5:	57                   	push   %edi
c0022bd6:	56                   	push   %esi
c0022bd7:	53                   	push   %ebx
c0022bd8:	83 ec 1c             	sub    $0x1c,%esp
c0022bdb:	8b 74 24 30          	mov    0x30(%esp),%esi
  enum intr_level old_level = intr_disable ();
c0022bdf:	e8 77 ee ff ff       	call   c0021a5b <intr_disable>
c0022be4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  sema->value++;
c0022be8:	ff 06                	incl   (%esi)

  if (!list_empty (&sema->waiters)) {
c0022bea:	83 c6 04             	add    $0x4,%esi
c0022bed:	83 ec 0c             	sub    $0xc,%esp
c0022bf0:	56                   	push   %esi
c0022bf1:	e8 22 60 00 00       	call   c0028c18 <list_empty>
c0022bf6:	83 c4 10             	add    $0x10,%esp
c0022bf9:	84 c0                	test   %al,%al
c0022bfb:	74 14                	je     c0022c11 <sema_up+0x3d>
      }
    }
  }
  //  thread_unblock (list_entry (list_pop_front (&sema->waiters), struct thread, elem));
  
  intr_set_level (old_level);
c0022bfd:	83 ec 0c             	sub    $0xc,%esp
c0022c00:	ff 74 24 18          	pushl  0x18(%esp)
c0022c04:	e8 59 ee ff ff       	call   c0021a62 <intr_set_level>
}
c0022c09:	83 c4 2c             	add    $0x2c,%esp
c0022c0c:	5b                   	pop    %ebx
c0022c0d:	5e                   	pop    %esi
c0022c0e:	5f                   	pop    %edi
c0022c0f:	5d                   	pop    %ebp
c0022c10:	c3                   	ret    
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c0022c11:	83 ec 0c             	sub    $0xc,%esp
c0022c14:	56                   	push   %esi
c0022c15:	e8 4d 5b 00 00       	call   c0028767 <list_begin>
c0022c1a:	89 c3                	mov    %eax,%ebx
c0022c1c:	83 c4 10             	add    $0x10,%esp
    int maxp = -1, tmpp;
c0022c1f:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c0022c24:	eb 0e                	jmp    c0022c34 <sema_up+0x60>
              e = list_next (e)) {
c0022c26:	83 ec 0c             	sub    $0xc,%esp
c0022c29:	53                   	push   %ebx
c0022c2a:	e8 68 5b 00 00       	call   c0028797 <list_next>
c0022c2f:	89 c3                	mov    %eax,%ebx
c0022c31:	83 c4 10             	add    $0x10,%esp
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c0022c34:	83 ec 0c             	sub    $0xc,%esp
c0022c37:	56                   	push   %esi
c0022c38:	e8 a2 5b 00 00       	call   c00287df <list_end>
c0022c3d:	83 c4 10             	add    $0x10,%esp
c0022c40:	39 c3                	cmp    %eax,%ebx
c0022c42:	74 17                	je     c0022c5b <sema_up+0x87>
      tmpp = thread_get_certain_priority(t);
c0022c44:	83 ec 0c             	sub    $0xc,%esp
      struct thread *t = list_entry (e, struct thread, elem);
c0022c47:	8d 43 a4             	lea    -0x5c(%ebx),%eax
      tmpp = thread_get_certain_priority(t);
c0022c4a:	50                   	push   %eax
c0022c4b:	e8 9d e3 ff ff       	call   c0020fed <thread_get_certain_priority>
c0022c50:	83 c4 10             	add    $0x10,%esp
c0022c53:	39 c7                	cmp    %eax,%edi
c0022c55:	7d cf                	jge    c0022c26 <sema_up+0x52>
c0022c57:	89 c7                	mov    %eax,%edi
c0022c59:	eb cb                	jmp    c0022c26 <sema_up+0x52>
    for (e = list_begin (&sema->waiters); e != list_end (&sema->waiters);
c0022c5b:	83 ec 0c             	sub    $0xc,%esp
c0022c5e:	56                   	push   %esi
c0022c5f:	e8 03 5b 00 00       	call   c0028767 <list_begin>
c0022c64:	89 c3                	mov    %eax,%ebx
c0022c66:	83 c4 10             	add    $0x10,%esp
c0022c69:	83 ec 0c             	sub    $0xc,%esp
c0022c6c:	56                   	push   %esi
c0022c6d:	e8 6d 5b 00 00       	call   c00287df <list_end>
c0022c72:	83 c4 10             	add    $0x10,%esp
c0022c75:	39 c3                	cmp    %eax,%ebx
c0022c77:	74 84                	je     c0022bfd <sema_up+0x29>
      struct thread *t = list_entry (e, struct thread, elem);
c0022c79:	8d 6b a4             	lea    -0x5c(%ebx),%ebp
      tmpp = thread_get_certain_priority(t);
c0022c7c:	83 ec 0c             	sub    $0xc,%esp
c0022c7f:	55                   	push   %ebp
c0022c80:	e8 68 e3 ff ff       	call   c0020fed <thread_get_certain_priority>
      if (tmpp == maxp) {
c0022c85:	83 c4 10             	add    $0x10,%esp
c0022c88:	39 c7                	cmp    %eax,%edi
c0022c8a:	74 10                	je     c0022c9c <sema_up+0xc8>
              e = list_next (e)) {
c0022c8c:	83 ec 0c             	sub    $0xc,%esp
c0022c8f:	53                   	push   %ebx
c0022c90:	e8 02 5b 00 00       	call   c0028797 <list_next>
c0022c95:	89 c3                	mov    %eax,%ebx
c0022c97:	83 c4 10             	add    $0x10,%esp
c0022c9a:	eb cd                	jmp    c0022c69 <sema_up+0x95>
        list_remove(e);
c0022c9c:	83 ec 0c             	sub    $0xc,%esp
c0022c9f:	53                   	push   %ebx
c0022ca0:	e8 e8 5e 00 00       	call   c0028b8d <list_remove>
        thread_unblock (t);
c0022ca5:	89 2c 24             	mov    %ebp,(%esp)
c0022ca8:	e8 26 e2 ff ff       	call   c0020ed3 <thread_unblock>
        thread_check_switch ();
c0022cad:	e8 aa e8 ff ff       	call   c002155c <thread_check_switch>
        break;
c0022cb2:	83 c4 10             	add    $0x10,%esp
c0022cb5:	e9 43 ff ff ff       	jmp    c0022bfd <sema_up+0x29>

c0022cba <sema_test_helper>:
}

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022cba:	57                   	push   %edi
c0022cbb:	56                   	push   %esi
c0022cbc:	53                   	push   %ebx
c0022cbd:	8b 74 24 10          	mov    0x10(%esp),%esi
c0022cc1:	bb 0a 00 00 00       	mov    $0xa,%ebx
  int i;

  for (i = 0; i < 10; i++) 
    {
      sema_down (&sema[0]);
      sema_up (&sema[1]);
c0022cc6:	8d 7e 14             	lea    0x14(%esi),%edi
      sema_down (&sema[0]);
c0022cc9:	83 ec 0c             	sub    $0xc,%esp
c0022ccc:	56                   	push   %esi
c0022ccd:	e8 21 fe ff ff       	call   c0022af3 <sema_down>
      sema_up (&sema[1]);
c0022cd2:	89 3c 24             	mov    %edi,(%esp)
c0022cd5:	e8 fa fe ff ff       	call   c0022bd4 <sema_up>
  for (i = 0; i < 10; i++) 
c0022cda:	83 c4 10             	add    $0x10,%esp
c0022cdd:	4b                   	dec    %ebx
c0022cde:	75 e9                	jne    c0022cc9 <sema_test_helper+0xf>
    }
}
c0022ce0:	5b                   	pop    %ebx
c0022ce1:	5e                   	pop    %esi
c0022ce2:	5f                   	pop    %edi
c0022ce3:	c3                   	ret    

c0022ce4 <sema_self_test>:
{
c0022ce4:	57                   	push   %edi
c0022ce5:	56                   	push   %esi
c0022ce6:	53                   	push   %ebx
c0022ce7:	83 ec 3c             	sub    $0x3c,%esp
  printf ("Testing semaphores...");
c0022cea:	68 5c 18 03 c0       	push   $0xc003185c
c0022cef:	e8 db 3e 00 00       	call   c0026bcf <printf>
  sema_init (&sema[0], 0);
c0022cf4:	83 c4 08             	add    $0x8,%esp
c0022cf7:	6a 00                	push   $0x0
c0022cf9:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c0022cfd:	53                   	push   %ebx
c0022cfe:	e8 82 fd ff ff       	call   c0022a85 <sema_init>
  sema_init (&sema[1], 0);
c0022d03:	83 c4 08             	add    $0x8,%esp
c0022d06:	6a 00                	push   $0x0
c0022d08:	8d 44 24 28          	lea    0x28(%esp),%eax
c0022d0c:	50                   	push   %eax
c0022d0d:	e8 73 fd ff ff       	call   c0022a85 <sema_init>
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022d12:	53                   	push   %ebx
c0022d13:	68 ba 2c 02 c0       	push   $0xc0022cba
c0022d18:	6a 1f                	push   $0x1f
c0022d1a:	68 72 18 03 c0       	push   $0xc0031872
c0022d1f:	e8 a9 e8 ff ff       	call   c00215cd <thread_create>
c0022d24:	83 c4 20             	add    $0x20,%esp
c0022d27:	bb 0a 00 00 00       	mov    $0xa,%ebx
      sema_up (&sema[0]);
c0022d2c:	8d 7c 24 08          	lea    0x8(%esp),%edi
      sema_down (&sema[1]);
c0022d30:	8d 74 24 1c          	lea    0x1c(%esp),%esi
      sema_up (&sema[0]);
c0022d34:	83 ec 0c             	sub    $0xc,%esp
c0022d37:	57                   	push   %edi
c0022d38:	e8 97 fe ff ff       	call   c0022bd4 <sema_up>
      sema_down (&sema[1]);
c0022d3d:	89 34 24             	mov    %esi,(%esp)
c0022d40:	e8 ae fd ff ff       	call   c0022af3 <sema_down>
  for (i = 0; i < 10; i++) 
c0022d45:	83 c4 10             	add    $0x10,%esp
c0022d48:	4b                   	dec    %ebx
c0022d49:	75 e9                	jne    c0022d34 <sema_self_test+0x50>
  printf ("done.\n");
c0022d4b:	83 ec 0c             	sub    $0xc,%esp
c0022d4e:	68 7c 18 03 c0       	push   $0xc003187c
c0022d53:	e8 0c 74 00 00       	call   c002a164 <puts>
}
c0022d58:	83 c4 40             	add    $0x40,%esp
c0022d5b:	5b                   	pop    %ebx
c0022d5c:	5e                   	pop    %esi
c0022d5d:	5f                   	pop    %edi
c0022d5e:	c3                   	ret    

c0022d5f <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0022d5f:	53                   	push   %ebx
c0022d60:	83 ec 08             	sub    $0x8,%esp
c0022d63:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022d67:	85 db                	test   %ebx,%ebx
c0022d69:	74 2c                	je     c0022d97 <lock_init+0x38>

  lock->holder = NULL;
c0022d6b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  lock->max_donate_delta = 0;
c0022d71:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
  list_init (&lock->donaters);
c0022d78:	83 ec 0c             	sub    $0xc,%esp
c0022d7b:	8d 43 1c             	lea    0x1c(%ebx),%eax
c0022d7e:	50                   	push   %eax
c0022d7f:	e8 a0 59 00 00       	call   c0028724 <list_init>
  sema_init (&lock->semaphore, 1);
c0022d84:	83 c4 08             	add    $0x8,%esp
c0022d87:	6a 01                	push   $0x1
c0022d89:	83 c3 04             	add    $0x4,%ebx
c0022d8c:	53                   	push   %ebx
c0022d8d:	e8 f3 fc ff ff       	call   c0022a85 <sema_init>
}
c0022d92:	83 c4 18             	add    $0x18,%esp
c0022d95:	5b                   	pop    %ebx
c0022d96:	c3                   	ret    
  ASSERT (lock != NULL);
c0022d97:	83 ec 0c             	sub    $0xc,%esp
c0022d9a:	68 82 18 03 c0       	push   $0xc0031882
c0022d9f:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022da4:	68 84 f7 02 c0       	push   $0xc002f784
c0022da9:	68 c8 00 00 00       	push   $0xc8
c0022dae:	68 2b 18 03 c0       	push   $0xc003182b
c0022db3:	e8 c5 58 00 00       	call   c002867d <debug_panic>

c0022db8 <notify_donation>:

/* Update donation when lock status changes. */
void
notify_donation(struct thread *t) {
c0022db8:	55                   	push   %ebp
c0022db9:	57                   	push   %edi
c0022dba:	56                   	push   %esi
c0022dbb:	53                   	push   %ebx
c0022dbc:	83 ec 1c             	sub    $0x1c,%esp
c0022dbf:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  if (t == NULL || t->father == NULL) {
c0022dc3:	85 ed                	test   %ebp,%ebp
c0022dc5:	0f 84 c2 00 00 00    	je     c0022e8d <notify_donation+0xd5>
c0022dcb:	8b 45 48             	mov    0x48(%ebp),%eax
c0022dce:	85 c0                	test   %eax,%eax
c0022dd0:	0f 84 b7 00 00 00    	je     c0022e8d <notify_donation+0xd5>
    return;
  }
  int max_donate_delta = 0;

  struct list_elem *lock_elem, *donater_elem;
  for (lock_elem = list_begin (&t->father->lock_list);
c0022dd6:	83 ec 0c             	sub    $0xc,%esp
c0022dd9:	83 c0 30             	add    $0x30,%eax
c0022ddc:	50                   	push   %eax
c0022ddd:	e8 85 59 00 00       	call   c0028767 <list_begin>
c0022de2:	89 c6                	mov    %eax,%esi
c0022de4:	83 c4 10             	add    $0x10,%esp
  int max_donate_delta = 0;
c0022de7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0022dee:	00 
  for (lock_elem = list_begin (&t->father->lock_list);
c0022def:	eb 4f                	jmp    c0022e40 <notify_donation+0x88>
      lock_elem = list_next (lock_elem)) {
    struct lock* l = list_entry (lock_elem, struct lock, elem);
    l->max_donate_delta = 0;
    for (donater_elem = list_begin (&l->donaters);
        donater_elem != list_end (&l->donaters);
        donater_elem = list_next (donater_elem)) {
c0022df1:	83 ec 0c             	sub    $0xc,%esp
c0022df4:	53                   	push   %ebx
c0022df5:	e8 9d 59 00 00       	call   c0028797 <list_next>
c0022dfa:	89 c3                	mov    %eax,%ebx
c0022dfc:	83 c4 10             	add    $0x10,%esp
        donater_elem != list_end (&l->donaters);
c0022dff:	83 ec 0c             	sub    $0xc,%esp
c0022e02:	57                   	push   %edi
c0022e03:	e8 d7 59 00 00       	call   c00287df <list_end>
    for (donater_elem = list_begin (&l->donaters);
c0022e08:	83 c4 10             	add    $0x10,%esp
c0022e0b:	39 c3                	cmp    %eax,%ebx
c0022e0d:	74 16                	je     c0022e25 <notify_donation+0x6d>
        struct thread *tmp = list_entry (donater_elem, struct thread, donate_elem);
        if (tmp->priority + tmp->max_donate_delta - t->father->priority > l->max_donate_delta) {
c0022e0f:	8b 43 f4             	mov    -0xc(%ebx),%eax
c0022e12:	03 43 d4             	add    -0x2c(%ebx),%eax
c0022e15:	8b 55 48             	mov    0x48(%ebp),%edx
c0022e18:	2b 42 20             	sub    0x20(%edx),%eax
c0022e1b:	3b 46 ec             	cmp    -0x14(%esi),%eax
c0022e1e:	7e d1                	jle    c0022df1 <notify_donation+0x39>
          l->max_donate_delta = tmp->priority + tmp->max_donate_delta - t->father->priority;
c0022e20:	89 46 ec             	mov    %eax,-0x14(%esi)
c0022e23:	eb cc                	jmp    c0022df1 <notify_donation+0x39>
c0022e25:	8b 46 ec             	mov    -0x14(%esi),%eax
c0022e28:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c0022e2c:	7d 04                	jge    c0022e32 <notify_donation+0x7a>
c0022e2e:	89 44 24 0c          	mov    %eax,0xc(%esp)
      lock_elem = list_next (lock_elem)) {
c0022e32:	83 ec 0c             	sub    $0xc,%esp
c0022e35:	56                   	push   %esi
c0022e36:	e8 5c 59 00 00       	call   c0028797 <list_next>
c0022e3b:	89 c6                	mov    %eax,%esi
c0022e3d:	83 c4 10             	add    $0x10,%esp
      lock_elem != list_end (&t->father->lock_list);
c0022e40:	83 ec 0c             	sub    $0xc,%esp
c0022e43:	8b 45 48             	mov    0x48(%ebp),%eax
c0022e46:	83 c0 30             	add    $0x30,%eax
c0022e49:	50                   	push   %eax
c0022e4a:	e8 90 59 00 00       	call   c00287df <list_end>
  for (lock_elem = list_begin (&t->father->lock_list);
c0022e4f:	83 c4 10             	add    $0x10,%esp
c0022e52:	39 c6                	cmp    %eax,%esi
c0022e54:	74 1a                	je     c0022e70 <notify_donation+0xb8>
    l->max_donate_delta = 0;
c0022e56:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
    for (donater_elem = list_begin (&l->donaters);
c0022e5d:	8d 7e f0             	lea    -0x10(%esi),%edi
c0022e60:	83 ec 0c             	sub    $0xc,%esp
c0022e63:	57                   	push   %edi
c0022e64:	e8 fe 58 00 00       	call   c0028767 <list_begin>
c0022e69:	89 c3                	mov    %eax,%ebx
c0022e6b:	83 c4 10             	add    $0x10,%esp
c0022e6e:	eb 8f                	jmp    c0022dff <notify_donation+0x47>
      }
    if (l->max_donate_delta > max_donate_delta) {
      max_donate_delta = l->max_donate_delta;
    }
  }
  if (t->father->max_donate_delta != max_donate_delta) {
c0022e70:	8b 45 48             	mov    0x48(%ebp),%eax
c0022e73:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0022e77:	3b 48 40             	cmp    0x40(%eax),%ecx
c0022e7a:	74 11                	je     c0022e8d <notify_donation+0xd5>
    t->father->max_donate_delta = max_donate_delta;
c0022e7c:	89 48 40             	mov    %ecx,0x40(%eax)
    notify_donation(t->father);
c0022e7f:	83 ec 0c             	sub    $0xc,%esp
c0022e82:	ff 75 48             	pushl  0x48(%ebp)
c0022e85:	e8 2e ff ff ff       	call   c0022db8 <notify_donation>
c0022e8a:	83 c4 10             	add    $0x10,%esp
  }
}
c0022e8d:	83 c4 1c             	add    $0x1c,%esp
c0022e90:	5b                   	pop    %ebx
c0022e91:	5e                   	pop    %esi
c0022e92:	5f                   	pop    %edi
c0022e93:	5d                   	pop    %ebp
c0022e94:	c3                   	ret    

c0022e95 <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022e95:	53                   	push   %ebx
c0022e96:	83 ec 08             	sub    $0x8,%esp
c0022e99:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c0022e9d:	85 c0                	test   %eax,%eax
c0022e9f:	74 11                	je     c0022eb2 <lock_held_by_current_thread+0x1d>

  return lock->holder == thread_current ();
c0022ea1:	8b 18                	mov    (%eax),%ebx
c0022ea3:	e8 6e de ff ff       	call   c0020d16 <thread_current>
c0022ea8:	39 c3                	cmp    %eax,%ebx
c0022eaa:	0f 94 c0             	sete   %al
}
c0022ead:	83 c4 08             	add    $0x8,%esp
c0022eb0:	5b                   	pop    %ebx
c0022eb1:	c3                   	ret    
  ASSERT (lock != NULL);
c0022eb2:	83 ec 0c             	sub    $0xc,%esp
c0022eb5:	68 82 18 03 c0       	push   $0xc0031882
c0022eba:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022ebf:	68 34 f7 02 c0       	push   $0xc002f734
c0022ec4:	68 5b 01 00 00       	push   $0x15b
c0022ec9:	68 2b 18 03 c0       	push   $0xc003182b
c0022ece:	e8 aa 57 00 00       	call   c002867d <debug_panic>

c0022ed3 <lock_acquire>:
{
c0022ed3:	56                   	push   %esi
c0022ed4:	53                   	push   %ebx
c0022ed5:	83 ec 04             	sub    $0x4,%esp
c0022ed8:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022edc:	85 db                	test   %ebx,%ebx
c0022ede:	0f 84 8f 00 00 00    	je     c0022f73 <lock_acquire+0xa0>
  ASSERT (!intr_context ());
c0022ee4:	e8 93 ed ff ff       	call   c0021c7c <intr_context>
c0022ee9:	84 c0                	test   %al,%al
c0022eeb:	0f 85 a3 00 00 00    	jne    c0022f94 <lock_acquire+0xc1>
  ASSERT (!lock_held_by_current_thread (lock));
c0022ef1:	83 ec 0c             	sub    $0xc,%esp
c0022ef4:	53                   	push   %ebx
c0022ef5:	e8 9b ff ff ff       	call   c0022e95 <lock_held_by_current_thread>
c0022efa:	83 c4 10             	add    $0x10,%esp
c0022efd:	84 c0                	test   %al,%al
c0022eff:	0f 85 b0 00 00 00    	jne    c0022fb5 <lock_acquire+0xe2>
  if (lock->holder != NULL) {
c0022f05:	83 3b 00             	cmpl   $0x0,(%ebx)
c0022f08:	74 40                	je     c0022f4a <lock_acquire+0x77>
    int delta = thread_get_priority () - lock->holder->priority;
c0022f0a:	e8 f6 e0 ff ff       	call   c0021005 <thread_get_priority>
c0022f0f:	8b 13                	mov    (%ebx),%edx
c0022f11:	2b 42 20             	sub    0x20(%edx),%eax
c0022f14:	89 c6                	mov    %eax,%esi
    if (delta > 0) {
c0022f16:	85 c0                	test   %eax,%eax
c0022f18:	7e 30                	jle    c0022f4a <lock_acquire+0x77>
      struct thread *t = thread_current ();
c0022f1a:	e8 f7 dd ff ff       	call   c0020d16 <thread_current>
      t->father = lock->holder;
c0022f1f:	8b 13                	mov    (%ebx),%edx
c0022f21:	89 50 48             	mov    %edx,0x48(%eax)
      list_push_back(&lock->donaters, &t->donate_elem);
c0022f24:	83 ec 08             	sub    $0x8,%esp
c0022f27:	83 c0 4c             	add    $0x4c,%eax
c0022f2a:	50                   	push   %eax
c0022f2b:	8d 43 1c             	lea    0x1c(%ebx),%eax
c0022f2e:	50                   	push   %eax
c0022f2f:	e8 3c 5c 00 00       	call   c0028b70 <list_push_back>
      if (delta > lock->max_donate_delta) {
c0022f34:	83 c4 10             	add    $0x10,%esp
c0022f37:	3b 73 18             	cmp    0x18(%ebx),%esi
c0022f3a:	7e 03                	jle    c0022f3f <lock_acquire+0x6c>
        lock->max_donate_delta = delta;
c0022f3c:	89 73 18             	mov    %esi,0x18(%ebx)
      if (delta > lock->holder->max_donate_delta) {
c0022f3f:	8b 03                	mov    (%ebx),%eax
c0022f41:	3b 70 40             	cmp    0x40(%eax),%esi
c0022f44:	0f 8f 8c 00 00 00    	jg     c0022fd6 <lock_acquire+0x103>
  sema_down (&lock->semaphore);
c0022f4a:	83 ec 0c             	sub    $0xc,%esp
c0022f4d:	8d 43 04             	lea    0x4(%ebx),%eax
c0022f50:	50                   	push   %eax
c0022f51:	e8 9d fb ff ff       	call   c0022af3 <sema_down>
  lock->holder = thread_current ();
c0022f56:	e8 bb dd ff ff       	call   c0020d16 <thread_current>
c0022f5b:	89 03                	mov    %eax,(%ebx)
  list_push_back (&lock->holder->lock_list, &lock->elem);
c0022f5d:	83 c4 08             	add    $0x8,%esp
c0022f60:	83 c3 2c             	add    $0x2c,%ebx
c0022f63:	53                   	push   %ebx
c0022f64:	83 c0 30             	add    $0x30,%eax
c0022f67:	50                   	push   %eax
c0022f68:	e8 03 5c 00 00       	call   c0028b70 <list_push_back>
}
c0022f6d:	83 c4 14             	add    $0x14,%esp
c0022f70:	5b                   	pop    %ebx
c0022f71:	5e                   	pop    %esi
c0022f72:	c3                   	ret    
  ASSERT (lock != NULL);
c0022f73:	83 ec 0c             	sub    $0xc,%esp
c0022f76:	68 82 18 03 c0       	push   $0xc0031882
c0022f7b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022f80:	68 74 f7 02 c0       	push   $0xc002f774
c0022f85:	68 fc 00 00 00       	push   $0xfc
c0022f8a:	68 2b 18 03 c0       	push   $0xc003182b
c0022f8f:	e8 e9 56 00 00       	call   c002867d <debug_panic>
  ASSERT (!intr_context ());
c0022f94:	83 ec 0c             	sub    $0xc,%esp
c0022f97:	68 c0 13 03 c0       	push   $0xc00313c0
c0022f9c:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022fa1:	68 74 f7 02 c0       	push   $0xc002f774
c0022fa6:	68 fd 00 00 00       	push   $0xfd
c0022fab:	68 2b 18 03 c0       	push   $0xc003182b
c0022fb0:	e8 c8 56 00 00       	call   c002867d <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022fb5:	83 ec 0c             	sub    $0xc,%esp
c0022fb8:	68 9c 18 03 c0       	push   $0xc003189c
c0022fbd:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0022fc2:	68 74 f7 02 c0       	push   $0xc002f774
c0022fc7:	68 fe 00 00 00       	push   $0xfe
c0022fcc:	68 2b 18 03 c0       	push   $0xc003182b
c0022fd1:	e8 a7 56 00 00       	call   c002867d <debug_panic>
        lock->holder->max_donate_delta = delta;
c0022fd6:	89 70 40             	mov    %esi,0x40(%eax)
        notify_donation (lock->holder);
c0022fd9:	83 ec 0c             	sub    $0xc,%esp
c0022fdc:	ff 33                	pushl  (%ebx)
c0022fde:	e8 d5 fd ff ff       	call   c0022db8 <notify_donation>
c0022fe3:	83 c4 10             	add    $0x10,%esp
c0022fe6:	e9 5f ff ff ff       	jmp    c0022f4a <lock_acquire+0x77>

c0022feb <lock_try_acquire>:
{
c0022feb:	56                   	push   %esi
c0022fec:	53                   	push   %ebx
c0022fed:	83 ec 04             	sub    $0x4,%esp
c0022ff0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (lock != NULL);
c0022ff4:	85 db                	test   %ebx,%ebx
c0022ff6:	74 2d                	je     c0023025 <lock_try_acquire+0x3a>
  ASSERT (!lock_held_by_current_thread (lock));
c0022ff8:	83 ec 0c             	sub    $0xc,%esp
c0022ffb:	53                   	push   %ebx
c0022ffc:	e8 94 fe ff ff       	call   c0022e95 <lock_held_by_current_thread>
c0023001:	83 c4 10             	add    $0x10,%esp
c0023004:	84 c0                	test   %al,%al
c0023006:	75 3e                	jne    c0023046 <lock_try_acquire+0x5b>
  success = sema_try_down (&lock->semaphore);
c0023008:	83 ec 0c             	sub    $0xc,%esp
c002300b:	8d 43 04             	lea    0x4(%ebx),%eax
c002300e:	50                   	push   %eax
c002300f:	e8 72 fb ff ff       	call   c0022b86 <sema_try_down>
c0023014:	89 c6                	mov    %eax,%esi
  if (success)
c0023016:	83 c4 10             	add    $0x10,%esp
c0023019:	84 c0                	test   %al,%al
c002301b:	75 4a                	jne    c0023067 <lock_try_acquire+0x7c>
}
c002301d:	89 f0                	mov    %esi,%eax
c002301f:	83 c4 04             	add    $0x4,%esp
c0023022:	5b                   	pop    %ebx
c0023023:	5e                   	pop    %esi
c0023024:	c3                   	ret    
  ASSERT (lock != NULL);
c0023025:	83 ec 0c             	sub    $0xc,%esp
c0023028:	68 82 18 03 c0       	push   $0xc0031882
c002302d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023032:	68 60 f7 02 c0       	push   $0xc002f760
c0023037:	68 20 01 00 00       	push   $0x120
c002303c:	68 2b 18 03 c0       	push   $0xc003182b
c0023041:	e8 37 56 00 00       	call   c002867d <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0023046:	83 ec 0c             	sub    $0xc,%esp
c0023049:	68 9c 18 03 c0       	push   $0xc003189c
c002304e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023053:	68 60 f7 02 c0       	push   $0xc002f760
c0023058:	68 21 01 00 00       	push   $0x121
c002305d:	68 2b 18 03 c0       	push   $0xc003182b
c0023062:	e8 16 56 00 00       	call   c002867d <debug_panic>
    lock->holder = thread_current ();
c0023067:	e8 aa dc ff ff       	call   c0020d16 <thread_current>
c002306c:	89 03                	mov    %eax,(%ebx)
  return success;
c002306e:	eb ad                	jmp    c002301d <lock_try_acquire+0x32>

c0023070 <lock_release>:
{
c0023070:	55                   	push   %ebp
c0023071:	57                   	push   %edi
c0023072:	56                   	push   %esi
c0023073:	53                   	push   %ebx
c0023074:	83 ec 0c             	sub    $0xc,%esp
c0023077:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  ASSERT (lock != NULL);
c002307b:	85 ed                	test   %ebp,%ebp
c002307d:	74 26                	je     c00230a5 <lock_release+0x35>
  ASSERT (lock_held_by_current_thread (lock));
c002307f:	83 ec 0c             	sub    $0xc,%esp
c0023082:	55                   	push   %ebp
c0023083:	e8 0d fe ff ff       	call   c0022e95 <lock_held_by_current_thread>
c0023088:	83 c4 10             	add    $0x10,%esp
c002308b:	84 c0                	test   %al,%al
c002308d:	74 37                	je     c00230c6 <lock_release+0x56>
  struct thread *t = lock->holder;
c002308f:	8b 7d 00             	mov    0x0(%ebp),%edi
  for (e = list_begin (&lock->donaters); e != list_end (&lock->donaters); e = list_next (e)) {
c0023092:	8d 75 1c             	lea    0x1c(%ebp),%esi
c0023095:	83 ec 0c             	sub    $0xc,%esp
c0023098:	56                   	push   %esi
c0023099:	e8 c9 56 00 00       	call   c0028767 <list_begin>
c002309e:	89 c3                	mov    %eax,%ebx
c00230a0:	83 c4 10             	add    $0x10,%esp
c00230a3:	eb 57                	jmp    c00230fc <lock_release+0x8c>
  ASSERT (lock != NULL);
c00230a5:	83 ec 0c             	sub    $0xc,%esp
c00230a8:	68 82 18 03 c0       	push   $0xc0031882
c00230ad:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00230b2:	68 50 f7 02 c0       	push   $0xc002f750
c00230b7:	68 31 01 00 00       	push   $0x131
c00230bc:	68 2b 18 03 c0       	push   $0xc003182b
c00230c1:	e8 b7 55 00 00       	call   c002867d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00230c6:	83 ec 0c             	sub    $0xc,%esp
c00230c9:	68 c0 18 03 c0       	push   $0xc00318c0
c00230ce:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00230d3:	68 50 f7 02 c0       	push   $0xc002f750
c00230d8:	68 32 01 00 00       	push   $0x132
c00230dd:	68 2b 18 03 c0       	push   $0xc003182b
c00230e2:	e8 96 55 00 00       	call   c002867d <debug_panic>
    list_entry (e, struct thread, donate_elem)->father = NULL;
c00230e7:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
  for (e = list_begin (&lock->donaters); e != list_end (&lock->donaters); e = list_next (e)) {
c00230ee:	83 ec 0c             	sub    $0xc,%esp
c00230f1:	53                   	push   %ebx
c00230f2:	e8 a0 56 00 00       	call   c0028797 <list_next>
c00230f7:	89 c3                	mov    %eax,%ebx
c00230f9:	83 c4 10             	add    $0x10,%esp
c00230fc:	83 ec 0c             	sub    $0xc,%esp
c00230ff:	56                   	push   %esi
c0023100:	e8 da 56 00 00       	call   c00287df <list_end>
c0023105:	83 c4 10             	add    $0x10,%esp
c0023108:	39 c3                	cmp    %eax,%ebx
c002310a:	75 db                	jne    c00230e7 <lock_release+0x77>
  list_remove (&lock->elem);
c002310c:	83 ec 0c             	sub    $0xc,%esp
c002310f:	8d 45 2c             	lea    0x2c(%ebp),%eax
c0023112:	50                   	push   %eax
c0023113:	e8 75 5a 00 00       	call   c0028b8d <list_remove>
  lock->max_donate_delta = 0;
c0023118:	c7 45 18 00 00 00 00 	movl   $0x0,0x18(%ebp)
  lock->holder = NULL;
c002311f:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
  while (!list_empty (&lock->donaters)) {
c0023126:	83 c4 10             	add    $0x10,%esp
c0023129:	eb 0c                	jmp    c0023137 <lock_release+0xc7>
    list_pop_front (&lock->donaters);
c002312b:	83 ec 0c             	sub    $0xc,%esp
c002312e:	56                   	push   %esi
c002312f:	e8 46 5b 00 00       	call   c0028c7a <list_pop_front>
c0023134:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&lock->donaters)) {
c0023137:	83 ec 0c             	sub    $0xc,%esp
c002313a:	56                   	push   %esi
c002313b:	e8 d8 5a 00 00       	call   c0028c18 <list_empty>
c0023140:	83 c4 10             	add    $0x10,%esp
c0023143:	84 c0                	test   %al,%al
c0023145:	74 e4                	je     c002312b <lock_release+0xbb>
  sema_up (&lock->semaphore);
c0023147:	83 ec 0c             	sub    $0xc,%esp
c002314a:	83 c5 04             	add    $0x4,%ebp
c002314d:	55                   	push   %ebp
c002314e:	e8 81 fa ff ff       	call   c0022bd4 <sema_up>
  for (e = list_begin (&t->lock_list); e != list_end (&t->lock_list); e = list_next (e)) {
c0023153:	8d 6f 30             	lea    0x30(%edi),%ebp
c0023156:	89 2c 24             	mov    %ebp,(%esp)
c0023159:	e8 09 56 00 00       	call   c0028767 <list_begin>
c002315e:	89 c3                	mov    %eax,%ebx
c0023160:	83 c4 10             	add    $0x10,%esp
  int max_donate_delta = 0;
c0023163:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin (&t->lock_list); e != list_end (&t->lock_list); e = list_next (e)) {
c0023168:	eb 0e                	jmp    c0023178 <lock_release+0x108>
c002316a:	83 ec 0c             	sub    $0xc,%esp
c002316d:	53                   	push   %ebx
c002316e:	e8 24 56 00 00       	call   c0028797 <list_next>
c0023173:	89 c3                	mov    %eax,%ebx
c0023175:	83 c4 10             	add    $0x10,%esp
c0023178:	83 ec 0c             	sub    $0xc,%esp
c002317b:	55                   	push   %ebp
c002317c:	e8 5e 56 00 00       	call   c00287df <list_end>
c0023181:	83 c4 10             	add    $0x10,%esp
c0023184:	39 c3                	cmp    %eax,%ebx
c0023186:	74 0b                	je     c0023193 <lock_release+0x123>
c0023188:	8b 43 ec             	mov    -0x14(%ebx),%eax
c002318b:	39 c6                	cmp    %eax,%esi
c002318d:	7d db                	jge    c002316a <lock_release+0xfa>
c002318f:	89 c6                	mov    %eax,%esi
c0023191:	eb d7                	jmp    c002316a <lock_release+0xfa>
  if (t->max_donate_delta != max_donate_delta) {
c0023193:	3b 77 40             	cmp    0x40(%edi),%esi
c0023196:	74 0f                	je     c00231a7 <lock_release+0x137>
    t->max_donate_delta = max_donate_delta;
c0023198:	89 77 40             	mov    %esi,0x40(%edi)
    notify_donation (t);
c002319b:	83 ec 0c             	sub    $0xc,%esp
c002319e:	57                   	push   %edi
c002319f:	e8 14 fc ff ff       	call   c0022db8 <notify_donation>
c00231a4:	83 c4 10             	add    $0x10,%esp
  if (t->max_donate_delta == 0 && t->priority_to_set > -1) {
c00231a7:	83 7f 40 00          	cmpl   $0x0,0x40(%edi)
c00231ab:	75 11                	jne    c00231be <lock_release+0x14e>
c00231ad:	8b 47 44             	mov    0x44(%edi),%eax
c00231b0:	85 c0                	test   %eax,%eax
c00231b2:	78 0a                	js     c00231be <lock_release+0x14e>
    t->priority = t->priority_to_set;
c00231b4:	89 47 20             	mov    %eax,0x20(%edi)
    t->priority_to_set = -1;
c00231b7:	c7 47 44 ff ff ff ff 	movl   $0xffffffff,0x44(%edi)
  thread_check_switch();
c00231be:	e8 99 e3 ff ff       	call   c002155c <thread_check_switch>
}
c00231c3:	83 c4 0c             	add    $0xc,%esp
c00231c6:	5b                   	pop    %ebx
c00231c7:	5e                   	pop    %esi
c00231c8:	5f                   	pop    %edi
c00231c9:	5d                   	pop    %ebp
c00231ca:	c3                   	ret    

c00231cb <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c00231cb:	83 ec 0c             	sub    $0xc,%esp
c00231ce:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (cond != NULL);
c00231d2:	85 c0                	test   %eax,%eax
c00231d4:	74 0d                	je     c00231e3 <cond_init+0x18>

  list_init (&cond->waiters);
c00231d6:	83 ec 0c             	sub    $0xc,%esp
c00231d9:	50                   	push   %eax
c00231da:	e8 45 55 00 00       	call   c0028724 <list_init>
}
c00231df:	83 c4 1c             	add    $0x1c,%esp
c00231e2:	c3                   	ret    
  ASSERT (cond != NULL);
c00231e3:	83 ec 0c             	sub    $0xc,%esp
c00231e6:	68 8f 18 03 c0       	push   $0xc003188f
c00231eb:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00231f0:	68 28 f7 02 c0       	push   $0xc002f728
c00231f5:	68 6e 01 00 00       	push   $0x16e
c00231fa:	68 2b 18 03 c0       	push   $0xc003182b
c00231ff:	e8 79 54 00 00       	call   c002867d <debug_panic>

c0023204 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0023204:	55                   	push   %ebp
c0023205:	57                   	push   %edi
c0023206:	56                   	push   %esi
c0023207:	53                   	push   %ebx
c0023208:	83 ec 2c             	sub    $0x2c,%esp
c002320b:	8b 74 24 40          	mov    0x40(%esp),%esi
c002320f:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0023213:	85 f6                	test   %esi,%esi
c0023215:	74 6f                	je     c0023286 <cond_wait+0x82>
  ASSERT (lock != NULL);
c0023217:	85 db                	test   %ebx,%ebx
c0023219:	0f 84 88 00 00 00    	je     c00232a7 <cond_wait+0xa3>
  ASSERT (!intr_context ());
c002321f:	e8 58 ea ff ff       	call   c0021c7c <intr_context>
c0023224:	84 c0                	test   %al,%al
c0023226:	0f 85 9c 00 00 00    	jne    c00232c8 <cond_wait+0xc4>
  ASSERT (lock_held_by_current_thread (lock));
c002322c:	83 ec 0c             	sub    $0xc,%esp
c002322f:	53                   	push   %ebx
c0023230:	e8 60 fc ff ff       	call   c0022e95 <lock_held_by_current_thread>
c0023235:	83 c4 10             	add    $0x10,%esp
c0023238:	84 c0                	test   %al,%al
c002323a:	0f 84 a9 00 00 00    	je     c00232e9 <cond_wait+0xe5>
  
  sema_init (&waiter.semaphore, 0);
c0023240:	83 ec 08             	sub    $0x8,%esp
c0023243:	6a 00                	push   $0x0
c0023245:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c0023249:	8d 7c 24 14          	lea    0x14(%esp),%edi
c002324d:	57                   	push   %edi
c002324e:	e8 32 f8 ff ff       	call   c0022a85 <sema_init>
  list_push_back (&cond->waiters, &waiter.elem);
c0023253:	83 c4 08             	add    $0x8,%esp
c0023256:	55                   	push   %ebp
c0023257:	56                   	push   %esi
c0023258:	e8 13 59 00 00       	call   c0028b70 <list_push_back>
  lock_release (lock);
c002325d:	89 1c 24             	mov    %ebx,(%esp)
c0023260:	e8 0b fe ff ff       	call   c0023070 <lock_release>
  waiter.pthread = thread_current();
c0023265:	e8 ac da ff ff       	call   c0020d16 <thread_current>
c002326a:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  sema_down (&waiter.semaphore);
c002326e:	89 3c 24             	mov    %edi,(%esp)
c0023271:	e8 7d f8 ff ff       	call   c0022af3 <sema_down>
  lock_acquire (lock);
c0023276:	89 1c 24             	mov    %ebx,(%esp)
c0023279:	e8 55 fc ff ff       	call   c0022ed3 <lock_acquire>
}
c002327e:	83 c4 3c             	add    $0x3c,%esp
c0023281:	5b                   	pop    %ebx
c0023282:	5e                   	pop    %esi
c0023283:	5f                   	pop    %edi
c0023284:	5d                   	pop    %ebp
c0023285:	c3                   	ret    
  ASSERT (cond != NULL);
c0023286:	83 ec 0c             	sub    $0xc,%esp
c0023289:	68 8f 18 03 c0       	push   $0xc003188f
c002328e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023293:	68 1c f7 02 c0       	push   $0xc002f71c
c0023298:	68 8c 01 00 00       	push   $0x18c
c002329d:	68 2b 18 03 c0       	push   $0xc003182b
c00232a2:	e8 d6 53 00 00       	call   c002867d <debug_panic>
  ASSERT (lock != NULL);
c00232a7:	83 ec 0c             	sub    $0xc,%esp
c00232aa:	68 82 18 03 c0       	push   $0xc0031882
c00232af:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00232b4:	68 1c f7 02 c0       	push   $0xc002f71c
c00232b9:	68 8d 01 00 00       	push   $0x18d
c00232be:	68 2b 18 03 c0       	push   $0xc003182b
c00232c3:	e8 b5 53 00 00       	call   c002867d <debug_panic>
  ASSERT (!intr_context ());
c00232c8:	83 ec 0c             	sub    $0xc,%esp
c00232cb:	68 c0 13 03 c0       	push   $0xc00313c0
c00232d0:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00232d5:	68 1c f7 02 c0       	push   $0xc002f71c
c00232da:	68 8e 01 00 00       	push   $0x18e
c00232df:	68 2b 18 03 c0       	push   $0xc003182b
c00232e4:	e8 94 53 00 00       	call   c002867d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00232e9:	83 ec 0c             	sub    $0xc,%esp
c00232ec:	68 c0 18 03 c0       	push   $0xc00318c0
c00232f1:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00232f6:	68 1c f7 02 c0       	push   $0xc002f71c
c00232fb:	68 8f 01 00 00       	push   $0x18f
c0023300:	68 2b 18 03 c0       	push   $0xc003182b
c0023305:	e8 73 53 00 00       	call   c002867d <debug_panic>

c002330a <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c002330a:	55                   	push   %ebp
c002330b:	57                   	push   %edi
c002330c:	56                   	push   %esi
c002330d:	53                   	push   %ebx
c002330e:	83 ec 0c             	sub    $0xc,%esp
c0023311:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0023315:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  ASSERT (cond != NULL);
c0023319:	85 ed                	test   %ebp,%ebp
c002331b:	74 3f                	je     c002335c <cond_signal+0x52>
  ASSERT (lock != NULL);
c002331d:	85 db                	test   %ebx,%ebx
c002331f:	74 5c                	je     c002337d <cond_signal+0x73>
  ASSERT (!intr_context ());
c0023321:	e8 56 e9 ff ff       	call   c0021c7c <intr_context>
c0023326:	84 c0                	test   %al,%al
c0023328:	75 74                	jne    c002339e <cond_signal+0x94>
  ASSERT (lock_held_by_current_thread (lock));
c002332a:	83 ec 0c             	sub    $0xc,%esp
c002332d:	53                   	push   %ebx
c002332e:	e8 62 fb ff ff       	call   c0022e95 <lock_held_by_current_thread>
c0023333:	83 c4 10             	add    $0x10,%esp
c0023336:	84 c0                	test   %al,%al
c0023338:	0f 84 81 00 00 00    	je     c00233bf <cond_signal+0xb5>

  if (!list_empty (&cond->waiters)) {
c002333e:	89 ef                	mov    %ebp,%edi
c0023340:	83 ec 0c             	sub    $0xc,%esp
c0023343:	55                   	push   %ebp
c0023344:	e8 cf 58 00 00       	call   c0028c18 <list_empty>
c0023349:	83 c4 10             	add    $0x10,%esp
c002334c:	84 c0                	test   %al,%al
c002334e:	0f 84 8c 00 00 00    	je     c00233e0 <cond_signal+0xd6>
        sema_up (&t->semaphore);
        break;
      }
    }
  }
}
c0023354:	83 c4 0c             	add    $0xc,%esp
c0023357:	5b                   	pop    %ebx
c0023358:	5e                   	pop    %esi
c0023359:	5f                   	pop    %edi
c002335a:	5d                   	pop    %ebp
c002335b:	c3                   	ret    
  ASSERT (cond != NULL);
c002335c:	83 ec 0c             	sub    $0xc,%esp
c002335f:	68 8f 18 03 c0       	push   $0xc003188f
c0023364:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023369:	68 10 f7 02 c0       	push   $0xc002f710
c002336e:	68 a3 01 00 00       	push   $0x1a3
c0023373:	68 2b 18 03 c0       	push   $0xc003182b
c0023378:	e8 00 53 00 00       	call   c002867d <debug_panic>
  ASSERT (lock != NULL);
c002337d:	83 ec 0c             	sub    $0xc,%esp
c0023380:	68 82 18 03 c0       	push   $0xc0031882
c0023385:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002338a:	68 10 f7 02 c0       	push   $0xc002f710
c002338f:	68 a4 01 00 00       	push   $0x1a4
c0023394:	68 2b 18 03 c0       	push   $0xc003182b
c0023399:	e8 df 52 00 00       	call   c002867d <debug_panic>
  ASSERT (!intr_context ());
c002339e:	83 ec 0c             	sub    $0xc,%esp
c00233a1:	68 c0 13 03 c0       	push   $0xc00313c0
c00233a6:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00233ab:	68 10 f7 02 c0       	push   $0xc002f710
c00233b0:	68 a5 01 00 00       	push   $0x1a5
c00233b5:	68 2b 18 03 c0       	push   $0xc003182b
c00233ba:	e8 be 52 00 00       	call   c002867d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00233bf:	83 ec 0c             	sub    $0xc,%esp
c00233c2:	68 c0 18 03 c0       	push   $0xc00318c0
c00233c7:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00233cc:	68 10 f7 02 c0       	push   $0xc002f710
c00233d1:	68 a6 01 00 00       	push   $0x1a6
c00233d6:	68 2b 18 03 c0       	push   $0xc003182b
c00233db:	e8 9d 52 00 00       	call   c002867d <debug_panic>
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c00233e0:	83 ec 0c             	sub    $0xc,%esp
c00233e3:	55                   	push   %ebp
c00233e4:	e8 7e 53 00 00       	call   c0028767 <list_begin>
c00233e9:	89 c3                	mov    %eax,%ebx
c00233eb:	83 c4 10             	add    $0x10,%esp
    int maxp = -1, tmpp;
c00233ee:	be ff ff ff ff       	mov    $0xffffffff,%esi
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c00233f3:	eb 0e                	jmp    c0023403 <cond_signal+0xf9>
              e = list_next (e)) {
c00233f5:	83 ec 0c             	sub    $0xc,%esp
c00233f8:	53                   	push   %ebx
c00233f9:	e8 99 53 00 00       	call   c0028797 <list_next>
c00233fe:	89 c3                	mov    %eax,%ebx
c0023400:	83 c4 10             	add    $0x10,%esp
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c0023403:	83 ec 0c             	sub    $0xc,%esp
c0023406:	57                   	push   %edi
c0023407:	e8 d3 53 00 00       	call   c00287df <list_end>
c002340c:	83 c4 10             	add    $0x10,%esp
c002340f:	39 c3                	cmp    %eax,%ebx
c0023411:	74 16                	je     c0023429 <cond_signal+0x11f>
      tmpp = thread_get_certain_priority(t->pthread);
c0023413:	83 ec 0c             	sub    $0xc,%esp
c0023416:	ff 73 1c             	pushl  0x1c(%ebx)
c0023419:	e8 cf db ff ff       	call   c0020fed <thread_get_certain_priority>
c002341e:	83 c4 10             	add    $0x10,%esp
c0023421:	39 c6                	cmp    %eax,%esi
c0023423:	7d d0                	jge    c00233f5 <cond_signal+0xeb>
c0023425:	89 c6                	mov    %eax,%esi
c0023427:	eb cc                	jmp    c00233f5 <cond_signal+0xeb>
    for (e = list_begin (&cond->waiters); e != list_end (&cond->waiters);
c0023429:	83 ec 0c             	sub    $0xc,%esp
c002342c:	55                   	push   %ebp
c002342d:	e8 35 53 00 00       	call   c0028767 <list_begin>
c0023432:	89 c3                	mov    %eax,%ebx
c0023434:	83 c4 10             	add    $0x10,%esp
c0023437:	83 ec 0c             	sub    $0xc,%esp
c002343a:	57                   	push   %edi
c002343b:	e8 9f 53 00 00       	call   c00287df <list_end>
c0023440:	83 c4 10             	add    $0x10,%esp
c0023443:	39 c3                	cmp    %eax,%ebx
c0023445:	0f 84 09 ff ff ff    	je     c0023354 <cond_signal+0x4a>
      tmpp = thread_get_certain_priority(t->pthread);
c002344b:	83 ec 0c             	sub    $0xc,%esp
c002344e:	ff 73 1c             	pushl  0x1c(%ebx)
c0023451:	e8 97 db ff ff       	call   c0020fed <thread_get_certain_priority>
      if (tmpp == maxp) {
c0023456:	83 c4 10             	add    $0x10,%esp
c0023459:	39 c6                	cmp    %eax,%esi
c002345b:	74 10                	je     c002346d <cond_signal+0x163>
              e = list_next (e)) {
c002345d:	83 ec 0c             	sub    $0xc,%esp
c0023460:	53                   	push   %ebx
c0023461:	e8 31 53 00 00       	call   c0028797 <list_next>
c0023466:	89 c3                	mov    %eax,%ebx
c0023468:	83 c4 10             	add    $0x10,%esp
c002346b:	eb ca                	jmp    c0023437 <cond_signal+0x12d>
        list_remove (e);
c002346d:	83 ec 0c             	sub    $0xc,%esp
c0023470:	53                   	push   %ebx
c0023471:	e8 17 57 00 00       	call   c0028b8d <list_remove>
        sema_up (&t->semaphore);
c0023476:	83 c3 08             	add    $0x8,%ebx
c0023479:	89 1c 24             	mov    %ebx,(%esp)
c002347c:	e8 53 f7 ff ff       	call   c0022bd4 <sema_up>
        break;
c0023481:	83 c4 10             	add    $0x10,%esp
c0023484:	e9 cb fe ff ff       	jmp    c0023354 <cond_signal+0x4a>

c0023489 <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0023489:	56                   	push   %esi
c002348a:	53                   	push   %ebx
c002348b:	83 ec 04             	sub    $0x4,%esp
c002348e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0023492:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (cond != NULL);
c0023496:	85 db                	test   %ebx,%ebx
c0023498:	74 25                	je     c00234bf <cond_broadcast+0x36>
  ASSERT (lock != NULL);
c002349a:	85 f6                	test   %esi,%esi
c002349c:	75 4f                	jne    c00234ed <cond_broadcast+0x64>
c002349e:	83 ec 0c             	sub    $0xc,%esp
c00234a1:	68 82 18 03 c0       	push   $0xc0031882
c00234a6:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00234ab:	68 00 f7 02 c0       	push   $0xc002f700
c00234b0:	68 ca 01 00 00       	push   $0x1ca
c00234b5:	68 2b 18 03 c0       	push   $0xc003182b
c00234ba:	e8 be 51 00 00       	call   c002867d <debug_panic>
  ASSERT (cond != NULL);
c00234bf:	83 ec 0c             	sub    $0xc,%esp
c00234c2:	68 8f 18 03 c0       	push   $0xc003188f
c00234c7:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00234cc:	68 00 f7 02 c0       	push   $0xc002f700
c00234d1:	68 c9 01 00 00       	push   $0x1c9
c00234d6:	68 2b 18 03 c0       	push   $0xc003182b
c00234db:	e8 9d 51 00 00       	call   c002867d <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c00234e0:	83 ec 08             	sub    $0x8,%esp
c00234e3:	56                   	push   %esi
c00234e4:	53                   	push   %ebx
c00234e5:	e8 20 fe ff ff       	call   c002330a <cond_signal>
c00234ea:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c00234ed:	83 ec 0c             	sub    $0xc,%esp
c00234f0:	53                   	push   %ebx
c00234f1:	e8 22 57 00 00       	call   c0028c18 <list_empty>
c00234f6:	83 c4 10             	add    $0x10,%esp
c00234f9:	84 c0                	test   %al,%al
c00234fb:	74 e3                	je     c00234e0 <cond_broadcast+0x57>
}
c00234fd:	83 c4 04             	add    $0x4,%esp
c0023500:	5b                   	pop    %ebx
c0023501:	5e                   	pop    %esi
c0023502:	c3                   	ret    

c0023503 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c0023503:	55                   	push   %ebp
c0023504:	57                   	push   %edi
c0023505:	56                   	push   %esi
c0023506:	53                   	push   %ebx
c0023507:	83 ec 18             	sub    $0x18,%esp
c002350a:	89 c5                	mov    %eax,%ebp
c002350c:	89 d7                	mov    %edx,%edi
c002350e:	89 ce                	mov    %ecx,%esi
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c0023510:	51                   	push   %ecx
c0023511:	e8 c3 5d 00 00       	call   c00292d9 <bitmap_buf_size>
c0023516:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
c002351c:	89 d8                	mov    %ebx,%eax
c002351e:	c1 e8 0c             	shr    $0xc,%eax
  if (bm_pages > page_cnt)
c0023521:	83 c4 10             	add    $0x10,%esp
c0023524:	39 c6                	cmp    %eax,%esi
c0023526:	72 3d                	jb     c0023565 <init_pool+0x62>
    PANIC ("Not enough memory in %s for bitmap.", name);
  page_cnt -= bm_pages;
c0023528:	29 c6                	sub    %eax,%esi

  printf ("%zu pages available in %s.\n", page_cnt, name);
c002352a:	83 ec 04             	sub    $0x4,%esp
c002352d:	ff 74 24 24          	pushl  0x24(%esp)
c0023531:	56                   	push   %esi
c0023532:	68 4f 19 03 c0       	push   $0xc003194f
c0023537:	e8 93 36 00 00       	call   c0026bcf <printf>

  /* Initialize the pool. */
  lock_init (&p->lock);
c002353c:	89 2c 24             	mov    %ebp,(%esp)
c002353f:	e8 1b f8 ff ff       	call   c0022d5f <lock_init>
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c0023544:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c002354a:	83 c4 0c             	add    $0xc,%esp
c002354d:	53                   	push   %ebx
c002354e:	57                   	push   %edi
c002354f:	56                   	push   %esi
c0023550:	e8 5d 60 00 00       	call   c00295b2 <bitmap_create_in_buf>
c0023555:	89 45 34             	mov    %eax,0x34(%ebp)
  p->base = base + bm_pages * PGSIZE;
c0023558:	01 df                	add    %ebx,%edi
c002355a:	89 7d 38             	mov    %edi,0x38(%ebp)
}
c002355d:	83 c4 1c             	add    $0x1c,%esp
c0023560:	5b                   	pop    %ebx
c0023561:	5e                   	pop    %esi
c0023562:	5f                   	pop    %edi
c0023563:	5d                   	pop    %ebp
c0023564:	c3                   	ret    
    PANIC ("Not enough memory in %s for bitmap.", name);
c0023565:	83 ec 0c             	sub    $0xc,%esp
c0023568:	ff 74 24 2c          	pushl  0x2c(%esp)
c002356c:	68 e4 18 03 c0       	push   $0xc00318e4
c0023571:	68 e4 f7 02 c0       	push   $0xc002f7e4
c0023576:	68 a1 00 00 00       	push   $0xa1
c002357b:	68 38 19 03 c0       	push   $0xc0031938
c0023580:	e8 f8 50 00 00       	call   c002867d <debug_panic>

c0023585 <palloc_init>:
{
c0023585:	56                   	push   %esi
c0023586:	53                   	push   %ebx
c0023587:	83 ec 04             	sub    $0x4,%esp
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c002358a:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c002358f:	c1 e0 0c             	shl    $0xc,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c0023592:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0023597:	77 5b                	ja     c00235f4 <palloc_init+0x6f>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0023599:	2d 00 00 10 00       	sub    $0x100000,%eax
c002359e:	89 c3                	mov    %eax,%ebx
c00235a0:	85 c0                	test   %eax,%eax
c00235a2:	78 6e                	js     c0023612 <palloc_init+0x8d>
c00235a4:	c1 fb 0c             	sar    $0xc,%ebx
  size_t user_pages = free_pages / 2;
c00235a7:	89 d8                	mov    %ebx,%eax
c00235a9:	d1 e8                	shr    %eax
c00235ab:	89 c6                	mov    %eax,%esi
c00235ad:	3b 44 24 10          	cmp    0x10(%esp),%eax
c00235b1:	76 04                	jbe    c00235b7 <palloc_init+0x32>
c00235b3:	8b 74 24 10          	mov    0x10(%esp),%esi
  kernel_pages = free_pages - user_pages;
c00235b7:	29 f3                	sub    %esi,%ebx
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c00235b9:	83 ec 0c             	sub    $0xc,%esp
c00235bc:	68 86 19 03 c0       	push   $0xc0031986
c00235c1:	89 d9                	mov    %ebx,%ecx
c00235c3:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c00235c8:	b8 40 dd 03 c0       	mov    $0xc003dd40,%eax
c00235cd:	e8 31 ff ff ff       	call   c0023503 <init_pool>
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c00235d2:	c1 e3 0c             	shl    $0xc,%ebx
c00235d5:	8d 93 00 00 10 c0    	lea    -0x3ff00000(%ebx),%edx
c00235db:	c7 04 24 92 19 03 c0 	movl   $0xc0031992,(%esp)
c00235e2:	89 f1                	mov    %esi,%ecx
c00235e4:	b8 00 dd 03 c0       	mov    $0xc003dd00,%eax
c00235e9:	e8 15 ff ff ff       	call   c0023503 <init_pool>
}
c00235ee:	83 c4 14             	add    $0x14,%esp
c00235f1:	5b                   	pop    %ebx
c00235f2:	5e                   	pop    %esi
c00235f3:	c3                   	ret    
c00235f4:	83 ec 0c             	sub    $0xc,%esp
c00235f7:	68 6b 19 03 c0       	push   $0xc003196b
c00235fc:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023601:	68 f0 f7 02 c0       	push   $0xc002f7f0
c0023606:	6a 4a                	push   $0x4a
c0023608:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002360d:	e8 6b 50 00 00       	call   c002867d <debug_panic>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0023612:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
c0023618:	eb 8a                	jmp    c00235a4 <palloc_init+0x1f>

c002361a <palloc_get_multiple>:
{
c002361a:	57                   	push   %edi
c002361b:	56                   	push   %esi
c002361c:	53                   	push   %ebx
c002361d:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0023621:	f6 44 24 10 04       	testb  $0x4,0x10(%esp)
c0023626:	75 47                	jne    c002366f <palloc_get_multiple+0x55>
c0023628:	bb 40 dd 03 c0       	mov    $0xc003dd40,%ebx
  if (page_cnt == 0)
c002362d:	85 ff                	test   %edi,%edi
c002362f:	74 76                	je     c00236a7 <palloc_get_multiple+0x8d>
  lock_acquire (&pool->lock);
c0023631:	83 ec 0c             	sub    $0xc,%esp
c0023634:	53                   	push   %ebx
c0023635:	e8 99 f8 ff ff       	call   c0022ed3 <lock_acquire>
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c002363a:	6a 00                	push   $0x0
c002363c:	57                   	push   %edi
c002363d:	6a 00                	push   $0x0
c002363f:	ff 73 34             	pushl  0x34(%ebx)
c0023642:	e8 3a 62 00 00       	call   c0029881 <bitmap_scan_and_flip>
c0023647:	89 c6                	mov    %eax,%esi
  lock_release (&pool->lock);
c0023649:	83 c4 14             	add    $0x14,%esp
c002364c:	53                   	push   %ebx
c002364d:	e8 1e fa ff ff       	call   c0023070 <lock_release>
  if (page_idx != BITMAP_ERROR)
c0023652:	83 c4 10             	add    $0x10,%esp
c0023655:	83 fe ff             	cmp    $0xffffffff,%esi
c0023658:	74 29                	je     c0023683 <palloc_get_multiple+0x69>
    pages = pool->base + PGSIZE * page_idx;
c002365a:	c1 e6 0c             	shl    $0xc,%esi
  if (pages != NULL) 
c002365d:	03 73 38             	add    0x38(%ebx),%esi
c0023660:	74 21                	je     c0023683 <palloc_get_multiple+0x69>
      if (flags & PAL_ZERO)
c0023662:	f6 44 24 10 02       	testb  $0x2,0x10(%esp)
c0023667:	75 0d                	jne    c0023676 <palloc_get_multiple+0x5c>
}
c0023669:	89 f0                	mov    %esi,%eax
c002366b:	5b                   	pop    %ebx
c002366c:	5e                   	pop    %esi
c002366d:	5f                   	pop    %edi
c002366e:	c3                   	ret    
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c002366f:	bb 00 dd 03 c0       	mov    $0xc003dd00,%ebx
c0023674:	eb b7                	jmp    c002362d <palloc_get_multiple+0x13>
        memset (pages, 0, PGSIZE * page_cnt);
c0023676:	89 f9                	mov    %edi,%ecx
c0023678:	c1 e1 0c             	shl    $0xc,%ecx
c002367b:	b0 00                	mov    $0x0,%al
c002367d:	89 f7                	mov    %esi,%edi
c002367f:	f3 aa                	rep stos %al,%es:(%edi)
c0023681:	eb e6                	jmp    c0023669 <palloc_get_multiple+0x4f>
      if (flags & PAL_ASSERT)
c0023683:	f6 44 24 10 01       	testb  $0x1,0x10(%esp)
c0023688:	75 07                	jne    c0023691 <palloc_get_multiple+0x77>
  return pages;
c002368a:	be 00 00 00 00       	mov    $0x0,%esi
c002368f:	eb d8                	jmp    c0023669 <palloc_get_multiple+0x4f>
        PANIC ("palloc_get: out of pages");
c0023691:	68 9c 19 03 c0       	push   $0xc003199c
c0023696:	68 d0 f7 02 c0       	push   $0xc002f7d0
c002369b:	6a 61                	push   $0x61
c002369d:	68 38 19 03 c0       	push   $0xc0031938
c00236a2:	e8 d6 4f 00 00       	call   c002867d <debug_panic>
    return NULL;
c00236a7:	be 00 00 00 00       	mov    $0x0,%esi
c00236ac:	eb bb                	jmp    c0023669 <palloc_get_multiple+0x4f>

c00236ae <palloc_get_page>:
{
c00236ae:	83 ec 14             	sub    $0x14,%esp
  return palloc_get_multiple (flags, 1);
c00236b1:	6a 01                	push   $0x1
c00236b3:	ff 74 24 1c          	pushl  0x1c(%esp)
c00236b7:	e8 5e ff ff ff       	call   c002361a <palloc_get_multiple>
}
c00236bc:	83 c4 1c             	add    $0x1c,%esp
c00236bf:	c3                   	ret    

c00236c0 <palloc_free_multiple>:
{
c00236c0:	55                   	push   %ebp
c00236c1:	57                   	push   %edi
c00236c2:	56                   	push   %esi
c00236c3:	53                   	push   %ebx
c00236c4:	83 ec 0c             	sub    $0xc,%esp
c00236c7:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  ASSERT (pg_ofs (pages) == 0);
c00236cb:	f7 44 24 20 ff 0f 00 	testl  $0xfff,0x20(%esp)
c00236d2:	00 
c00236d3:	75 13                	jne    c00236e8 <palloc_free_multiple+0x28>
  if (pages == NULL || page_cnt == 0)
c00236d5:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c00236da:	74 04                	je     c00236e0 <palloc_free_multiple+0x20>
c00236dc:	85 db                	test   %ebx,%ebx
c00236de:	75 26                	jne    c0023706 <palloc_free_multiple+0x46>
}
c00236e0:	83 c4 0c             	add    $0xc,%esp
c00236e3:	5b                   	pop    %ebx
c00236e4:	5e                   	pop    %esi
c00236e5:	5f                   	pop    %edi
c00236e6:	5d                   	pop    %ebp
c00236e7:	c3                   	ret    
  ASSERT (pg_ofs (pages) == 0);
c00236e8:	83 ec 0c             	sub    $0xc,%esp
c00236eb:	68 b5 19 03 c0       	push   $0xc00319b5
c00236f0:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00236f5:	68 b8 f7 02 c0       	push   $0xc002f7b8
c00236fa:	6a 7b                	push   $0x7b
c00236fc:	68 38 19 03 c0       	push   $0xc0031938
c0023701:	e8 77 4f 00 00       	call   c002867d <debug_panic>
  return (uintptr_t) va >> PGBITS;
c0023706:	8b 74 24 20          	mov    0x20(%esp),%esi
c002370a:	c1 ee 0c             	shr    $0xc,%esi
c002370d:	8b 2d 78 dd 03 c0    	mov    0xc003dd78,%ebp
c0023713:	c1 ed 0c             	shr    $0xc,%ebp
static bool
page_from_pool (const struct pool *pool, void *page) 
{
  size_t page_no = pg_no (page);
  size_t start_page = pg_no (pool->base);
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023716:	83 ec 0c             	sub    $0xc,%esp
c0023719:	ff 35 74 dd 03 c0    	pushl  0xc003dd74
c002371f:	e8 ee 5b 00 00       	call   c0029312 <bitmap_size>

  return page_no >= start_page && page_no < end_page;
c0023724:	83 c4 10             	add    $0x10,%esp
c0023727:	39 ee                	cmp    %ebp,%esi
c0023729:	72 06                	jb     c0023731 <palloc_free_multiple+0x71>
  size_t end_page = start_page + bitmap_size (pool->used_map);
c002372b:	01 c5                	add    %eax,%ebp
  return page_no >= start_page && page_no < end_page;
c002372d:	39 ee                	cmp    %ebp,%esi
c002372f:	72 44                	jb     c0023775 <palloc_free_multiple+0xb5>
c0023731:	8b 2d 38 dd 03 c0    	mov    0xc003dd38,%ebp
c0023737:	c1 ed 0c             	shr    $0xc,%ebp
  size_t end_page = start_page + bitmap_size (pool->used_map);
c002373a:	83 ec 0c             	sub    $0xc,%esp
c002373d:	ff 35 34 dd 03 c0    	pushl  0xc003dd34
c0023743:	e8 ca 5b 00 00       	call   c0029312 <bitmap_size>
  return page_no >= start_page && page_no < end_page;
c0023748:	83 c4 10             	add    $0x10,%esp
c002374b:	39 ee                	cmp    %ebp,%esi
c002374d:	73 19                	jae    c0023768 <palloc_free_multiple+0xa8>
    NOT_REACHED ();
c002374f:	68 54 14 03 c0       	push   $0xc0031454
c0023754:	68 b8 f7 02 c0       	push   $0xc002f7b8
c0023759:	68 84 00 00 00       	push   $0x84
c002375e:	68 38 19 03 c0       	push   $0xc0031938
c0023763:	e8 15 4f 00 00       	call   c002867d <debug_panic>
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023768:	01 e8                	add    %ebp,%eax
  return page_no >= start_page && page_no < end_page;
c002376a:	39 c6                	cmp    %eax,%esi
c002376c:	73 e1                	jae    c002374f <palloc_free_multiple+0x8f>
    pool = &user_pool;
c002376e:	bd 00 dd 03 c0       	mov    $0xc003dd00,%ebp
c0023773:	eb 05                	jmp    c002377a <palloc_free_multiple+0xba>
    pool = &kernel_pool;
c0023775:	bd 40 dd 03 c0       	mov    $0xc003dd40,%ebp
c002377a:	8b 45 38             	mov    0x38(%ebp),%eax
c002377d:	c1 e8 0c             	shr    $0xc,%eax
  page_idx = pg_no (pages) - pg_no (pool->base);
c0023780:	29 c6                	sub    %eax,%esi
  memset (pages, 0xcc, PGSIZE * page_cnt);
c0023782:	89 d9                	mov    %ebx,%ecx
c0023784:	c1 e1 0c             	shl    $0xc,%ecx
c0023787:	b0 cc                	mov    $0xcc,%al
c0023789:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002378d:	f3 aa                	rep stos %al,%es:(%edi)
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c002378f:	83 ec 04             	sub    $0x4,%esp
c0023792:	53                   	push   %ebx
c0023793:	56                   	push   %esi
c0023794:	ff 75 34             	pushl  0x34(%ebp)
c0023797:	e8 18 60 00 00       	call   c00297b4 <bitmap_all>
c002379c:	83 c4 10             	add    $0x10,%esp
c002379f:	84 c0                	test   %al,%al
c00237a1:	74 14                	je     c00237b7 <palloc_free_multiple+0xf7>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c00237a3:	6a 00                	push   $0x0
c00237a5:	53                   	push   %ebx
c00237a6:	56                   	push   %esi
c00237a7:	ff 75 34             	pushl  0x34(%ebp)
c00237aa:	e8 b0 5c 00 00       	call   c002945f <bitmap_set_multiple>
c00237af:	83 c4 10             	add    $0x10,%esp
c00237b2:	e9 29 ff ff ff       	jmp    c00236e0 <palloc_free_multiple+0x20>
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c00237b7:	83 ec 0c             	sub    $0xc,%esp
c00237ba:	68 08 19 03 c0       	push   $0xc0031908
c00237bf:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00237c4:	68 b8 f7 02 c0       	push   $0xc002f7b8
c00237c9:	68 8c 00 00 00       	push   $0x8c
c00237ce:	68 38 19 03 c0       	push   $0xc0031938
c00237d3:	e8 a5 4e 00 00       	call   c002867d <debug_panic>

c00237d8 <palloc_free_page>:
{
c00237d8:	83 ec 14             	sub    $0x14,%esp
  palloc_free_multiple (page, 1);
c00237db:	6a 01                	push   $0x1
c00237dd:	ff 74 24 1c          	pushl  0x1c(%esp)
c00237e1:	e8 da fe ff ff       	call   c00236c0 <palloc_free_multiple>
}
c00237e6:	83 c4 1c             	add    $0x1c,%esp
c00237e9:	c3                   	ret    

c00237ea <arena_to_block>:
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c00237ea:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (a != NULL);
c00237ed:	85 c0                	test   %eax,%eax
c00237ef:	74 1b                	je     c002380c <arena_to_block+0x22>
  ASSERT (a->magic == ARENA_MAGIC);
c00237f1:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c00237f7:	75 34                	jne    c002382d <arena_to_block+0x43>
  ASSERT (idx < a->desc->blocks_per_arena);
c00237f9:	8b 48 04             	mov    0x4(%eax),%ecx
c00237fc:	39 51 04             	cmp    %edx,0x4(%ecx)
c00237ff:	76 4d                	jbe    c002384e <arena_to_block+0x64>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0023801:	0f af 11             	imul   (%ecx),%edx
  return (struct block *) ((uint8_t *) a
c0023804:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c0023808:	83 c4 0c             	add    $0xc,%esp
c002380b:	c3                   	ret    
  ASSERT (a != NULL);
c002380c:	83 ec 0c             	sub    $0xc,%esp
c002380f:	68 21 18 03 c0       	push   $0xc0031821
c0023814:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023819:	68 10 f8 02 c0       	push   $0xc002f810
c002381e:	68 20 01 00 00       	push   $0x120
c0023823:	68 c9 19 03 c0       	push   $0xc00319c9
c0023828:	e8 50 4e 00 00       	call   c002867d <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c002382d:	83 ec 0c             	sub    $0xc,%esp
c0023830:	68 e0 19 03 c0       	push   $0xc00319e0
c0023835:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002383a:	68 10 f8 02 c0       	push   $0xc002f810
c002383f:	68 21 01 00 00       	push   $0x121
c0023844:	68 c9 19 03 c0       	push   $0xc00319c9
c0023849:	e8 2f 4e 00 00       	call   c002867d <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c002384e:	83 ec 0c             	sub    $0xc,%esp
c0023851:	68 f8 19 03 c0       	push   $0xc00319f8
c0023856:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002385b:	68 10 f8 02 c0       	push   $0xc002f810
c0023860:	68 22 01 00 00       	push   $0x122
c0023865:	68 c9 19 03 c0       	push   $0xc00319c9
c002386a:	e8 0e 4e 00 00       	call   c002867d <debug_panic>

c002386f <block_to_arena>:
{
c002386f:	53                   	push   %ebx
c0023870:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0023873:	89 c1                	mov    %eax,%ecx
c0023875:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c002387b:	74 29                	je     c00238a6 <block_to_arena+0x37>
  ASSERT (a->magic == ARENA_MAGIC);
c002387d:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0023883:	75 42                	jne    c00238c7 <block_to_arena+0x58>
  ASSERT (a->desc == NULL
c0023885:	8b 59 04             	mov    0x4(%ecx),%ebx
c0023888:	85 db                	test   %ebx,%ebx
c002388a:	74 7d                	je     c0023909 <block_to_arena+0x9a>
  return (uintptr_t) va & PGMASK;
c002388c:	25 ff 0f 00 00       	and    $0xfff,%eax
c0023891:	83 e8 0c             	sub    $0xc,%eax
c0023894:	ba 00 00 00 00       	mov    $0x0,%edx
c0023899:	f7 33                	divl   (%ebx)
c002389b:	85 d2                	test   %edx,%edx
c002389d:	75 49                	jne    c00238e8 <block_to_arena+0x79>
}
c002389f:	89 c8                	mov    %ecx,%eax
c00238a1:	83 c4 08             	add    $0x8,%esp
c00238a4:	5b                   	pop    %ebx
c00238a5:	c3                   	ret    
  ASSERT (a != NULL);
c00238a6:	83 ec 0c             	sub    $0xc,%esp
c00238a9:	68 21 18 03 c0       	push   $0xc0031821
c00238ae:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00238b3:	68 00 f8 02 c0       	push   $0xc002f800
c00238b8:	68 11 01 00 00       	push   $0x111
c00238bd:	68 c9 19 03 c0       	push   $0xc00319c9
c00238c2:	e8 b6 4d 00 00       	call   c002867d <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00238c7:	83 ec 0c             	sub    $0xc,%esp
c00238ca:	68 e0 19 03 c0       	push   $0xc00319e0
c00238cf:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00238d4:	68 00 f8 02 c0       	push   $0xc002f800
c00238d9:	68 12 01 00 00       	push   $0x112
c00238de:	68 c9 19 03 c0       	push   $0xc00319c9
c00238e3:	e8 95 4d 00 00       	call   c002867d <debug_panic>
  ASSERT (a->desc == NULL
c00238e8:	83 ec 0c             	sub    $0xc,%esp
c00238eb:	68 18 1a 03 c0       	push   $0xc0031a18
c00238f0:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00238f5:	68 00 f8 02 c0       	push   $0xc002f800
c00238fa:	68 16 01 00 00       	push   $0x116
c00238ff:	68 c9 19 03 c0       	push   $0xc00319c9
c0023904:	e8 74 4d 00 00       	call   c002867d <debug_panic>
c0023909:	25 ff 0f 00 00       	and    $0xfff,%eax
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c002390e:	83 f8 0c             	cmp    $0xc,%eax
c0023911:	74 8c                	je     c002389f <block_to_arena+0x30>
c0023913:	83 ec 0c             	sub    $0xc,%esp
c0023916:	68 60 1a 03 c0       	push   $0xc0031a60
c002391b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023920:	68 00 f8 02 c0       	push   $0xc002f800
c0023925:	68 17 01 00 00       	push   $0x117
c002392a:	68 c9 19 03 c0       	push   $0xc00319c9
c002392f:	e8 49 4d 00 00       	call   c002867d <debug_panic>

c0023934 <malloc_init>:
{
c0023934:	55                   	push   %ebp
c0023935:	57                   	push   %edi
c0023936:	56                   	push   %esi
c0023937:	53                   	push   %ebx
c0023938:	83 ec 0c             	sub    $0xc,%esp
      struct desc *d = &descs[desc_cnt++];
c002393b:	a1 80 dd 03 c0       	mov    0xc003dd80,%eax
c0023940:	8d 50 01             	lea    0x1(%eax),%edx
c0023943:	89 15 80 dd 03 c0    	mov    %edx,0xc003dd80
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023949:	83 fa 0a             	cmp    $0xa,%edx
c002394c:	0f 87 b4 00 00 00    	ja     c0023a06 <malloc_init+0xd2>
      d->block_size = block_size;
c0023952:	8d 1c c0             	lea    (%eax,%eax,8),%ebx
c0023955:	01 db                	add    %ebx,%ebx
c0023957:	8d 14 03             	lea    (%ebx,%eax,1),%edx
c002395a:	c1 e2 02             	shl    $0x2,%edx
c002395d:	c7 82 a0 dd 03 c0 10 	movl   $0x10,-0x3ffc2260(%edx)
c0023964:	00 00 00 
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023967:	c7 82 a4 dd 03 c0 ff 	movl   $0xff,-0x3ffc225c(%edx)
c002396e:	00 00 00 
c0023971:	89 d3                	mov    %edx,%ebx
      list_init (&d->free_list);
c0023973:	83 ec 0c             	sub    $0xc,%esp
c0023976:	8d 82 a8 dd 03 c0    	lea    -0x3ffc2258(%edx),%eax
c002397c:	50                   	push   %eax
c002397d:	e8 a2 4d 00 00       	call   c0028724 <list_init>
      lock_init (&d->lock);
c0023982:	81 c3 b8 dd 03 c0    	add    $0xc003ddb8,%ebx
c0023988:	89 1c 24             	mov    %ebx,(%esp)
c002398b:	e8 cf f3 ff ff       	call   c0022d5f <lock_init>
c0023990:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023993:	be 20 00 00 00       	mov    $0x20,%esi
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023998:	bf f4 0f 00 00       	mov    $0xff4,%edi
      struct desc *d = &descs[desc_cnt++];
c002399d:	8b 0d 80 dd 03 c0    	mov    0xc003dd80,%ecx
c00239a3:	8d 41 01             	lea    0x1(%ecx),%eax
c00239a6:	a3 80 dd 03 c0       	mov    %eax,0xc003dd80
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00239ab:	83 f8 0a             	cmp    $0xa,%eax
c00239ae:	77 56                	ja     c0023a06 <malloc_init+0xd2>
      d->block_size = block_size;
c00239b0:	8d 1c c9             	lea    (%ecx,%ecx,8),%ebx
c00239b3:	01 db                	add    %ebx,%ebx
c00239b5:	8d 2c 0b             	lea    (%ebx,%ecx,1),%ebp
c00239b8:	c1 e5 02             	shl    $0x2,%ebp
c00239bb:	89 b5 a0 dd 03 c0    	mov    %esi,-0x3ffc2260(%ebp)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c00239c1:	89 f8                	mov    %edi,%eax
c00239c3:	ba 00 00 00 00       	mov    $0x0,%edx
c00239c8:	f7 f6                	div    %esi
c00239ca:	89 85 a4 dd 03 c0    	mov    %eax,-0x3ffc225c(%ebp)
c00239d0:	89 eb                	mov    %ebp,%ebx
      list_init (&d->free_list);
c00239d2:	83 ec 0c             	sub    $0xc,%esp
c00239d5:	8d 85 a8 dd 03 c0    	lea    -0x3ffc2258(%ebp),%eax
c00239db:	50                   	push   %eax
c00239dc:	e8 43 4d 00 00       	call   c0028724 <list_init>
      lock_init (&d->lock);
c00239e1:	81 c3 b8 dd 03 c0    	add    $0xc003ddb8,%ebx
c00239e7:	89 1c 24             	mov    %ebx,(%esp)
c00239ea:	e8 70 f3 ff ff       	call   c0022d5f <lock_init>
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c00239ef:	8d 04 36             	lea    (%esi,%esi,1),%eax
c00239f2:	89 c6                	mov    %eax,%esi
c00239f4:	83 c4 10             	add    $0x10,%esp
c00239f7:	3d ff 07 00 00       	cmp    $0x7ff,%eax
c00239fc:	76 9f                	jbe    c002399d <malloc_init+0x69>
}
c00239fe:	83 c4 0c             	add    $0xc,%esp
c0023a01:	5b                   	pop    %ebx
c0023a02:	5e                   	pop    %esi
c0023a03:	5f                   	pop    %edi
c0023a04:	5d                   	pop    %ebp
c0023a05:	c3                   	ret    
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023a06:	83 ec 0c             	sub    $0xc,%esp
c0023a09:	68 8c 1a 03 c0       	push   $0xc0031a8c
c0023a0e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023a13:	68 20 f8 02 c0       	push   $0xc002f820
c0023a18:	6a 4f                	push   $0x4f
c0023a1a:	68 c9 19 03 c0       	push   $0xc00319c9
c0023a1f:	e8 59 4c 00 00       	call   c002867d <debug_panic>

c0023a24 <malloc>:
{
c0023a24:	55                   	push   %ebp
c0023a25:	57                   	push   %edi
c0023a26:	56                   	push   %esi
c0023a27:	53                   	push   %ebx
c0023a28:	83 ec 1c             	sub    $0x1c,%esp
c0023a2b:	8b 44 24 30          	mov    0x30(%esp),%eax
  if (size == 0)
c0023a2f:	85 c0                	test   %eax,%eax
c0023a31:	0f 84 2e 01 00 00    	je     c0023b65 <malloc+0x141>
  for (d = descs; d < descs + desc_cnt; d++)
c0023a37:	8b 0d 80 dd 03 c0    	mov    0xc003dd80,%ecx
c0023a3d:	8d 14 c9             	lea    (%ecx,%ecx,8),%edx
c0023a40:	01 d2                	add    %edx,%edx
c0023a42:	01 ca                	add    %ecx,%edx
c0023a44:	8d 14 95 a0 dd 03 c0 	lea    -0x3ffc2260(,%edx,4),%edx
c0023a4b:	81 fa a0 dd 03 c0    	cmp    $0xc003dda0,%edx
c0023a51:	0f 86 bb 00 00 00    	jbe    c0023b12 <malloc+0xee>
    if (d->block_size >= size)
c0023a57:	3b 05 a0 dd 03 c0    	cmp    0xc003dda0,%eax
c0023a5d:	0f 86 10 01 00 00    	jbe    c0023b73 <malloc+0x14f>
c0023a63:	bb a0 dd 03 c0       	mov    $0xc003dda0,%ebx
  for (d = descs; d < descs + desc_cnt; d++)
c0023a68:	83 c3 4c             	add    $0x4c,%ebx
c0023a6b:	39 d3                	cmp    %edx,%ebx
c0023a6d:	0f 83 a4 00 00 00    	jae    c0023b17 <malloc+0xf3>
    if (d->block_size >= size)
c0023a73:	3b 03                	cmp    (%ebx),%eax
c0023a75:	77 f1                	ja     c0023a68 <malloc+0x44>
  lock_acquire (&d->lock);
c0023a77:	8d 43 18             	lea    0x18(%ebx),%eax
c0023a7a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0023a7e:	83 ec 0c             	sub    $0xc,%esp
c0023a81:	50                   	push   %eax
c0023a82:	e8 4c f4 ff ff       	call   c0022ed3 <lock_acquire>
  if (list_empty (&d->free_list))
c0023a87:	8d 7b 08             	lea    0x8(%ebx),%edi
c0023a8a:	89 3c 24             	mov    %edi,(%esp)
c0023a8d:	e8 86 51 00 00       	call   c0028c18 <list_empty>
c0023a92:	83 c4 10             	add    $0x10,%esp
c0023a95:	84 c0                	test   %al,%al
c0023a97:	74 4d                	je     c0023ae6 <malloc+0xc2>
      a = palloc_get_page (0);
c0023a99:	83 ec 0c             	sub    $0xc,%esp
c0023a9c:	6a 00                	push   $0x0
c0023a9e:	e8 0b fc ff ff       	call   c00236ae <palloc_get_page>
c0023aa3:	89 c5                	mov    %eax,%ebp
      if (a == NULL) 
c0023aa5:	83 c4 10             	add    $0x10,%esp
c0023aa8:	85 c0                	test   %eax,%eax
c0023aaa:	0f 84 9f 00 00 00    	je     c0023b4f <malloc+0x12b>
      a->magic = ARENA_MAGIC;
c0023ab0:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c0023ab6:	89 58 04             	mov    %ebx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c0023ab9:	8b 43 04             	mov    0x4(%ebx),%eax
c0023abc:	89 45 08             	mov    %eax,0x8(%ebp)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023abf:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0023ac3:	74 21                	je     c0023ae6 <malloc+0xc2>
c0023ac5:	be 00 00 00 00       	mov    $0x0,%esi
          struct block *b = arena_to_block (a, i);
c0023aca:	89 f2                	mov    %esi,%edx
c0023acc:	89 e8                	mov    %ebp,%eax
c0023ace:	e8 17 fd ff ff       	call   c00237ea <arena_to_block>
          list_push_back (&d->free_list, &b->free_elem);
c0023ad3:	83 ec 08             	sub    $0x8,%esp
c0023ad6:	50                   	push   %eax
c0023ad7:	57                   	push   %edi
c0023ad8:	e8 93 50 00 00       	call   c0028b70 <list_push_back>
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023add:	46                   	inc    %esi
c0023ade:	83 c4 10             	add    $0x10,%esp
c0023ae1:	39 73 04             	cmp    %esi,0x4(%ebx)
c0023ae4:	77 e4                	ja     c0023aca <malloc+0xa6>
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023ae6:	83 ec 0c             	sub    $0xc,%esp
c0023ae9:	57                   	push   %edi
c0023aea:	e8 8b 51 00 00       	call   c0028c7a <list_pop_front>
c0023aef:	89 c3                	mov    %eax,%ebx
  a = block_to_arena (b);
c0023af1:	e8 79 fd ff ff       	call   c002386f <block_to_arena>
  a->free_cnt--;
c0023af6:	ff 48 08             	decl   0x8(%eax)
  lock_release (&d->lock);
c0023af9:	83 c4 04             	add    $0x4,%esp
c0023afc:	ff 74 24 18          	pushl  0x18(%esp)
c0023b00:	e8 6b f5 ff ff       	call   c0023070 <lock_release>
  return b;
c0023b05:	83 c4 10             	add    $0x10,%esp
c0023b08:	89 d8                	mov    %ebx,%eax
}
c0023b0a:	83 c4 1c             	add    $0x1c,%esp
c0023b0d:	5b                   	pop    %ebx
c0023b0e:	5e                   	pop    %esi
c0023b0f:	5f                   	pop    %edi
c0023b10:	5d                   	pop    %ebp
c0023b11:	c3                   	ret    
  for (d = descs; d < descs + desc_cnt; d++)
c0023b12:	bb a0 dd 03 c0       	mov    $0xc003dda0,%ebx
  if (d == descs + desc_cnt) 
c0023b17:	39 da                	cmp    %ebx,%edx
c0023b19:	0f 85 58 ff ff ff    	jne    c0023a77 <malloc+0x53>
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c0023b1f:	8d 98 0b 10 00 00    	lea    0x100b(%eax),%ebx
c0023b25:	c1 eb 0c             	shr    $0xc,%ebx
      a = palloc_get_multiple (0, page_cnt);
c0023b28:	83 ec 08             	sub    $0x8,%esp
c0023b2b:	53                   	push   %ebx
c0023b2c:	6a 00                	push   $0x0
c0023b2e:	e8 e7 fa ff ff       	call   c002361a <palloc_get_multiple>
      if (a == NULL)
c0023b33:	83 c4 10             	add    $0x10,%esp
c0023b36:	85 c0                	test   %eax,%eax
c0023b38:	74 32                	je     c0023b6c <malloc+0x148>
      a->magic = ARENA_MAGIC;
c0023b3a:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c0023b40:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023b47:	89 58 08             	mov    %ebx,0x8(%eax)
      return a + 1;
c0023b4a:	83 c0 0c             	add    $0xc,%eax
c0023b4d:	eb bb                	jmp    c0023b0a <malloc+0xe6>
          lock_release (&d->lock);
c0023b4f:	83 ec 0c             	sub    $0xc,%esp
c0023b52:	ff 74 24 18          	pushl  0x18(%esp)
c0023b56:	e8 15 f5 ff ff       	call   c0023070 <lock_release>
          return NULL; 
c0023b5b:	83 c4 10             	add    $0x10,%esp
c0023b5e:	b8 00 00 00 00       	mov    $0x0,%eax
c0023b63:	eb a5                	jmp    c0023b0a <malloc+0xe6>
    return NULL;
c0023b65:	b8 00 00 00 00       	mov    $0x0,%eax
c0023b6a:	eb 9e                	jmp    c0023b0a <malloc+0xe6>
        return NULL;
c0023b6c:	b8 00 00 00 00       	mov    $0x0,%eax
c0023b71:	eb 97                	jmp    c0023b0a <malloc+0xe6>
    if (d->block_size >= size)
c0023b73:	bb a0 dd 03 c0       	mov    $0xc003dda0,%ebx
c0023b78:	e9 fa fe ff ff       	jmp    c0023a77 <malloc+0x53>

c0023b7d <calloc>:
{
c0023b7d:	57                   	push   %edi
c0023b7e:	53                   	push   %ebx
c0023b7f:	83 ec 04             	sub    $0x4,%esp
c0023b82:	8b 44 24 10          	mov    0x10(%esp),%eax
  size = a * b;
c0023b86:	89 c3                	mov    %eax,%ebx
c0023b88:	0f af 5c 24 14       	imul   0x14(%esp),%ebx
  if (size < a || size < b)
c0023b8d:	39 d8                	cmp    %ebx,%eax
c0023b8f:	77 28                	ja     c0023bb9 <calloc+0x3c>
c0023b91:	39 5c 24 14          	cmp    %ebx,0x14(%esp)
c0023b95:	77 29                	ja     c0023bc0 <calloc+0x43>
  p = malloc (size);
c0023b97:	83 ec 0c             	sub    $0xc,%esp
c0023b9a:	53                   	push   %ebx
c0023b9b:	e8 84 fe ff ff       	call   c0023a24 <malloc>
c0023ba0:	89 c2                	mov    %eax,%edx
  if (p != NULL)
c0023ba2:	83 c4 10             	add    $0x10,%esp
c0023ba5:	85 c0                	test   %eax,%eax
c0023ba7:	74 08                	je     c0023bb1 <calloc+0x34>
    memset (p, 0, size);
c0023ba9:	b0 00                	mov    $0x0,%al
c0023bab:	89 d7                	mov    %edx,%edi
c0023bad:	89 d9                	mov    %ebx,%ecx
c0023baf:	f3 aa                	rep stos %al,%es:(%edi)
}
c0023bb1:	89 d0                	mov    %edx,%eax
c0023bb3:	83 c4 04             	add    $0x4,%esp
c0023bb6:	5b                   	pop    %ebx
c0023bb7:	5f                   	pop    %edi
c0023bb8:	c3                   	ret    
    return NULL;
c0023bb9:	ba 00 00 00 00       	mov    $0x0,%edx
c0023bbe:	eb f1                	jmp    c0023bb1 <calloc+0x34>
c0023bc0:	ba 00 00 00 00       	mov    $0x0,%edx
c0023bc5:	eb ea                	jmp    c0023bb1 <calloc+0x34>

c0023bc7 <free>:
{
c0023bc7:	55                   	push   %ebp
c0023bc8:	57                   	push   %edi
c0023bc9:	56                   	push   %esi
c0023bca:	53                   	push   %ebx
c0023bcb:	83 ec 0c             	sub    $0xc,%esp
c0023bce:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  if (p != NULL)
c0023bd2:	85 ed                	test   %ebp,%ebp
c0023bd4:	0f 84 86 00 00 00    	je     c0023c60 <free+0x99>
      struct arena *a = block_to_arena (b);
c0023bda:	89 e8                	mov    %ebp,%eax
c0023bdc:	e8 8e fc ff ff       	call   c002386f <block_to_arena>
c0023be1:	89 c6                	mov    %eax,%esi
      struct desc *d = a->desc;
c0023be3:	8b 58 04             	mov    0x4(%eax),%ebx
      if (d != NULL) 
c0023be6:	85 db                	test   %ebx,%ebx
c0023be8:	0f 84 9b 00 00 00    	je     c0023c89 <free+0xc2>
          memset (b, 0xcc, d->block_size);
c0023bee:	8b 0b                	mov    (%ebx),%ecx
c0023bf0:	b0 cc                	mov    $0xcc,%al
c0023bf2:	89 ef                	mov    %ebp,%edi
c0023bf4:	f3 aa                	rep stos %al,%es:(%edi)
          lock_acquire (&d->lock);
c0023bf6:	8d 7b 18             	lea    0x18(%ebx),%edi
c0023bf9:	83 ec 0c             	sub    $0xc,%esp
c0023bfc:	57                   	push   %edi
c0023bfd:	e8 d1 f2 ff ff       	call   c0022ed3 <lock_acquire>
          list_push_front (&d->free_list, &b->free_elem);
c0023c02:	83 c4 08             	add    $0x8,%esp
c0023c05:	55                   	push   %ebp
c0023c06:	8d 43 08             	lea    0x8(%ebx),%eax
c0023c09:	50                   	push   %eax
c0023c0a:	e8 44 4f 00 00       	call   c0028b53 <list_push_front>
          if (++a->free_cnt >= d->blocks_per_arena) 
c0023c0f:	8b 46 08             	mov    0x8(%esi),%eax
c0023c12:	40                   	inc    %eax
c0023c13:	89 46 08             	mov    %eax,0x8(%esi)
c0023c16:	8b 53 04             	mov    0x4(%ebx),%edx
c0023c19:	83 c4 10             	add    $0x10,%esp
c0023c1c:	39 d0                	cmp    %edx,%eax
c0023c1e:	72 34                	jb     c0023c54 <free+0x8d>
              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023c20:	39 d0                	cmp    %edx,%eax
c0023c22:	75 44                	jne    c0023c68 <free+0xa1>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023c24:	bd 00 00 00 00       	mov    $0x0,%ebp
c0023c29:	85 c0                	test   %eax,%eax
c0023c2b:	74 1b                	je     c0023c48 <free+0x81>
                  struct block *b = arena_to_block (a, i);
c0023c2d:	89 ea                	mov    %ebp,%edx
c0023c2f:	89 f0                	mov    %esi,%eax
c0023c31:	e8 b4 fb ff ff       	call   c00237ea <arena_to_block>
                  list_remove (&b->free_elem);
c0023c36:	83 ec 0c             	sub    $0xc,%esp
c0023c39:	50                   	push   %eax
c0023c3a:	e8 4e 4f 00 00       	call   c0028b8d <list_remove>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023c3f:	45                   	inc    %ebp
c0023c40:	83 c4 10             	add    $0x10,%esp
c0023c43:	39 6b 04             	cmp    %ebp,0x4(%ebx)
c0023c46:	77 e5                	ja     c0023c2d <free+0x66>
              palloc_free_page (a);
c0023c48:	83 ec 0c             	sub    $0xc,%esp
c0023c4b:	56                   	push   %esi
c0023c4c:	e8 87 fb ff ff       	call   c00237d8 <palloc_free_page>
c0023c51:	83 c4 10             	add    $0x10,%esp
          lock_release (&d->lock);
c0023c54:	83 ec 0c             	sub    $0xc,%esp
c0023c57:	57                   	push   %edi
c0023c58:	e8 13 f4 ff ff       	call   c0023070 <lock_release>
c0023c5d:	83 c4 10             	add    $0x10,%esp
}
c0023c60:	83 c4 0c             	add    $0xc,%esp
c0023c63:	5b                   	pop    %ebx
c0023c64:	5e                   	pop    %esi
c0023c65:	5f                   	pop    %edi
c0023c66:	5d                   	pop    %ebp
c0023c67:	c3                   	ret    
              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023c68:	83 ec 0c             	sub    $0xc,%esp
c0023c6b:	68 b8 1a 03 c0       	push   $0xc0031ab8
c0023c70:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023c75:	68 f8 f7 02 c0       	push   $0xc002f7f8
c0023c7a:	68 f6 00 00 00       	push   $0xf6
c0023c7f:	68 c9 19 03 c0       	push   $0xc00319c9
c0023c84:	e8 f4 49 00 00       	call   c002867d <debug_panic>
          palloc_free_multiple (a, a->free_cnt);
c0023c89:	83 ec 08             	sub    $0x8,%esp
c0023c8c:	ff 70 08             	pushl  0x8(%eax)
c0023c8f:	50                   	push   %eax
c0023c90:	e8 2b fa ff ff       	call   c00236c0 <palloc_free_multiple>
          return;
c0023c95:	83 c4 10             	add    $0x10,%esp
c0023c98:	eb c6                	jmp    c0023c60 <free+0x99>

c0023c9a <realloc>:
{
c0023c9a:	55                   	push   %ebp
c0023c9b:	57                   	push   %edi
c0023c9c:	56                   	push   %esi
c0023c9d:	53                   	push   %ebx
c0023c9e:	83 ec 0c             	sub    $0xc,%esp
c0023ca1:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0023ca5:	8b 74 24 24          	mov    0x24(%esp),%esi
  if (new_size == 0) 
c0023ca9:	85 f6                	test   %esi,%esi
c0023cab:	74 4a                	je     c0023cf7 <realloc+0x5d>
      void *new_block = malloc (new_size);
c0023cad:	83 ec 0c             	sub    $0xc,%esp
c0023cb0:	56                   	push   %esi
c0023cb1:	e8 6e fd ff ff       	call   c0023a24 <malloc>
c0023cb6:	89 c5                	mov    %eax,%ebp
      if (old_block != NULL && new_block != NULL)
c0023cb8:	83 c4 10             	add    $0x10,%esp
c0023cbb:	85 db                	test   %ebx,%ebx
c0023cbd:	74 2e                	je     c0023ced <realloc+0x53>
c0023cbf:	85 c0                	test   %eax,%eax
c0023cc1:	74 2a                	je     c0023ced <realloc+0x53>
  struct arena *a = block_to_arena (b);
c0023cc3:	89 d8                	mov    %ebx,%eax
c0023cc5:	e8 a5 fb ff ff       	call   c002386f <block_to_arena>
  struct desc *d = a->desc;
c0023cca:	8b 50 04             	mov    0x4(%eax),%edx
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023ccd:	85 d2                	test   %edx,%edx
c0023ccf:	74 39                	je     c0023d0a <realloc+0x70>
c0023cd1:	8b 02                	mov    (%edx),%eax
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023cd3:	89 f1                	mov    %esi,%ecx
c0023cd5:	39 c6                	cmp    %eax,%esi
c0023cd7:	76 02                	jbe    c0023cdb <realloc+0x41>
c0023cd9:	89 c1                	mov    %eax,%ecx
          memcpy (new_block, old_block, min_size);
c0023cdb:	89 ef                	mov    %ebp,%edi
c0023cdd:	89 de                	mov    %ebx,%esi
c0023cdf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
          free (old_block);
c0023ce1:	83 ec 0c             	sub    $0xc,%esp
c0023ce4:	53                   	push   %ebx
c0023ce5:	e8 dd fe ff ff       	call   c0023bc7 <free>
c0023cea:	83 c4 10             	add    $0x10,%esp
}
c0023ced:	89 e8                	mov    %ebp,%eax
c0023cef:	83 c4 0c             	add    $0xc,%esp
c0023cf2:	5b                   	pop    %ebx
c0023cf3:	5e                   	pop    %esi
c0023cf4:	5f                   	pop    %edi
c0023cf5:	5d                   	pop    %ebp
c0023cf6:	c3                   	ret    
      free (old_block);
c0023cf7:	83 ec 0c             	sub    $0xc,%esp
c0023cfa:	53                   	push   %ebx
c0023cfb:	e8 c7 fe ff ff       	call   c0023bc7 <free>
      return NULL;
c0023d00:	83 c4 10             	add    $0x10,%esp
c0023d03:	bd 00 00 00 00       	mov    $0x0,%ebp
c0023d08:	eb e3                	jmp    c0023ced <realloc+0x53>
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023d0a:	8b 40 08             	mov    0x8(%eax),%eax
c0023d0d:	c1 e0 0c             	shl    $0xc,%eax
c0023d10:	89 da                	mov    %ebx,%edx
c0023d12:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0023d18:	29 d0                	sub    %edx,%eax
c0023d1a:	eb b7                	jmp    c0023cd3 <realloc+0x39>

c0023d1c <fixed32_init>:

#include "fixed_point.h"
const int FLOAT_POINT = 1 << 14;

struct fixed32 fixed32_init(int32_t x) {
c0023d1c:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {x * FLOAT_POINT};
c0023d20:	8b 54 24 08          	mov    0x8(%esp),%edx
c0023d24:	c1 e2 0e             	shl    $0xe,%edx
c0023d27:	89 10                	mov    %edx,(%eax)
  return res;
}
c0023d29:	c2 04 00             	ret    $0x4

c0023d2c <fixed32_trunc>:
  } else {
    printf("-%d.%03d", -num / 1000, -num % 1000);
  }
}

int32_t fixed32_trunc(struct fixed32 a) {
c0023d2c:	8b 54 24 04          	mov    0x4(%esp),%edx
  return a.num / FLOAT_POINT;
c0023d30:	89 d0                	mov    %edx,%eax
c0023d32:	85 d2                	test   %edx,%edx
c0023d34:	78 04                	js     c0023d3a <fixed32_trunc+0xe>
c0023d36:	c1 f8 0e             	sar    $0xe,%eax
}
c0023d39:	c3                   	ret    
  return a.num / FLOAT_POINT;
c0023d3a:	8d 82 ff 3f 00 00    	lea    0x3fff(%edx),%eax
c0023d40:	eb f4                	jmp    c0023d36 <fixed32_trunc+0xa>

c0023d42 <fixed32_round>:

int32_t fixed32_round(struct fixed32 a) {
c0023d42:	8b 54 24 04          	mov    0x4(%esp),%edx
  /* int div round to zero */
  return (a.num + ((a.num >= 0) ? 1 : -1) * (FLOAT_POINT >> 1)) / FLOAT_POINT;
c0023d46:	89 d0                	mov    %edx,%eax
c0023d48:	c1 f8 1f             	sar    $0x1f,%eax
c0023d4b:	25 00 c0 ff ff       	and    $0xffffc000,%eax
c0023d50:	8d 94 10 00 20 00 00 	lea    0x2000(%eax,%edx,1),%edx
c0023d57:	89 d0                	mov    %edx,%eax
c0023d59:	85 d2                	test   %edx,%edx
c0023d5b:	78 04                	js     c0023d61 <fixed32_round+0x1f>
c0023d5d:	c1 f8 0e             	sar    $0xe,%eax
}
c0023d60:	c3                   	ret    
  return (a.num + ((a.num >= 0) ? 1 : -1) * (FLOAT_POINT >> 1)) / FLOAT_POINT;
c0023d61:	8d 82 ff 3f 00 00    	lea    0x3fff(%edx),%eax
c0023d67:	eb f4                	jmp    c0023d5d <fixed32_round+0x1b>

c0023d69 <fixed32_print>:
void fixed32_print(struct fixed32 a) {
c0023d69:	53                   	push   %ebx
c0023d6a:	83 ec 08             	sub    $0x8,%esp
c0023d6d:	8b 44 24 10          	mov    0x10(%esp),%eax
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
  return res;
}

struct fixed32 fixed32_mul_int(struct fixed32 a, int32_t b) {
  struct fixed32 res = {a.num * b};
c0023d71:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023d74:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023d77:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0023d7a:	c1 e0 03             	shl    $0x3,%eax
  int num = fixed32_round(fixed32_mul_int(a, 1000));
c0023d7d:	50                   	push   %eax
c0023d7e:	e8 bf ff ff ff       	call   c0023d42 <fixed32_round>
c0023d83:	83 c4 04             	add    $0x4,%esp
c0023d86:	89 c1                	mov    %eax,%ecx
  if (num >= 0) {
c0023d88:	85 c0                	test   %eax,%eax
c0023d8a:	78 30                	js     c0023dbc <fixed32_print+0x53>
    printf("%d.%03d", num / 1000, num % 1000);
c0023d8c:	83 ec 04             	sub    $0x4,%esp
c0023d8f:	bb e8 03 00 00       	mov    $0x3e8,%ebx
c0023d94:	99                   	cltd   
c0023d95:	f7 fb                	idiv   %ebx
c0023d97:	52                   	push   %edx
c0023d98:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c0023d9d:	f7 e9                	imul   %ecx
c0023d9f:	89 d0                	mov    %edx,%eax
c0023da1:	c1 f8 06             	sar    $0x6,%eax
c0023da4:	c1 f9 1f             	sar    $0x1f,%ecx
c0023da7:	29 c8                	sub    %ecx,%eax
c0023da9:	50                   	push   %eax
c0023daa:	68 dc 1a 03 c0       	push   $0xc0031adc
c0023daf:	e8 1b 2e 00 00       	call   c0026bcf <printf>
c0023db4:	83 c4 10             	add    $0x10,%esp
}
c0023db7:	83 c4 08             	add    $0x8,%esp
c0023dba:	5b                   	pop    %ebx
c0023dbb:	c3                   	ret    
    printf("-%d.%03d", -num / 1000, -num % 1000);
c0023dbc:	f7 d9                	neg    %ecx
c0023dbe:	83 ec 04             	sub    $0x4,%esp
c0023dc1:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c0023dc6:	f7 e9                	imul   %ecx
c0023dc8:	89 d0                	mov    %edx,%eax
c0023dca:	c1 f8 06             	sar    $0x6,%eax
c0023dcd:	89 ca                	mov    %ecx,%edx
c0023dcf:	c1 fa 1f             	sar    $0x1f,%edx
c0023dd2:	29 d0                	sub    %edx,%eax
c0023dd4:	8d 14 80             	lea    (%eax,%eax,4),%edx
c0023dd7:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0023dda:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0023ddd:	c1 e2 03             	shl    $0x3,%edx
c0023de0:	29 d1                	sub    %edx,%ecx
c0023de2:	51                   	push   %ecx
c0023de3:	50                   	push   %eax
c0023de4:	68 db 1a 03 c0       	push   $0xc0031adb
c0023de9:	e8 e1 2d 00 00       	call   c0026bcf <printf>
c0023dee:	83 c4 10             	add    $0x10,%esp
}
c0023df1:	eb c4                	jmp    c0023db7 <fixed32_print+0x4e>

c0023df3 <fixed32_add>:
struct fixed32 fixed32_add(struct fixed32 a, struct fixed32 b) {
c0023df3:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num + b.num};
c0023df7:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023dfb:	03 54 24 08          	add    0x8(%esp),%edx
c0023dff:	89 10                	mov    %edx,(%eax)
}
c0023e01:	c2 04 00             	ret    $0x4

c0023e04 <fixed32_add_int>:
struct fixed32 fixed32_add_int(struct fixed32 a, int32_t b) {
c0023e04:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num + b * FLOAT_POINT};
c0023e08:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023e0c:	c1 e2 0e             	shl    $0xe,%edx
c0023e0f:	03 54 24 08          	add    0x8(%esp),%edx
c0023e13:	89 10                	mov    %edx,(%eax)
}
c0023e15:	c2 04 00             	ret    $0x4

c0023e18 <fixed32_sub>:
struct fixed32 fixed32_sub(struct fixed32 a, struct fixed32 b) {
c0023e18:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num - b.num};
c0023e1c:	8b 54 24 08          	mov    0x8(%esp),%edx
c0023e20:	2b 54 24 0c          	sub    0xc(%esp),%edx
c0023e24:	89 10                	mov    %edx,(%eax)
}
c0023e26:	c2 04 00             	ret    $0x4

c0023e29 <fixed32_sub_int>:
struct fixed32 fixed32_sub_int(struct fixed32 a, int32_t b) {
c0023e29:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num - b * FLOAT_POINT};
c0023e2d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023e31:	c1 e2 0e             	shl    $0xe,%edx
c0023e34:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0023e38:	29 d1                	sub    %edx,%ecx
c0023e3a:	89 08                	mov    %ecx,(%eax)
}
c0023e3c:	c2 04 00             	ret    $0x4

c0023e3f <fixed32_mul>:
struct fixed32 fixed32_mul(struct fixed32 a, struct fixed32 b) {
c0023e3f:	55                   	push   %ebp
c0023e40:	57                   	push   %edi
c0023e41:	56                   	push   %esi
c0023e42:	53                   	push   %ebx
c0023e43:	8b 54 24 18          	mov    0x18(%esp),%edx
c0023e47:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
c0023e4b:	89 d3                	mov    %edx,%ebx
c0023e4d:	c1 fb 1f             	sar    $0x1f,%ebx
c0023e50:	89 c7                	mov    %eax,%edi
c0023e52:	c1 ff 1f             	sar    $0x1f,%edi
c0023e55:	89 dd                	mov    %ebx,%ebp
c0023e57:	0f af e8             	imul   %eax,%ebp
c0023e5a:	89 fe                	mov    %edi,%esi
c0023e5c:	0f af f2             	imul   %edx,%esi
c0023e5f:	01 ee                	add    %ebp,%esi
c0023e61:	f7 e2                	mul    %edx
c0023e63:	01 f2                	add    %esi,%edx
c0023e65:	89 c6                	mov    %eax,%esi
c0023e67:	89 d7                	mov    %edx,%edi
c0023e69:	85 d2                	test   %edx,%edx
c0023e6b:	78 11                	js     c0023e7e <fixed32_mul+0x3f>
c0023e6d:	0f ac fe 0e          	shrd   $0xe,%edi,%esi
c0023e71:	8b 44 24 14          	mov    0x14(%esp),%eax
c0023e75:	89 30                	mov    %esi,(%eax)
}
c0023e77:	5b                   	pop    %ebx
c0023e78:	5e                   	pop    %esi
c0023e79:	5f                   	pop    %edi
c0023e7a:	5d                   	pop    %ebp
c0023e7b:	c2 04 00             	ret    $0x4
  struct fixed32 res = {(int64_t)a.num * b.num / FLOAT_POINT};
c0023e7e:	05 ff 3f 00 00       	add    $0x3fff,%eax
c0023e83:	83 d2 00             	adc    $0x0,%edx
c0023e86:	89 c6                	mov    %eax,%esi
c0023e88:	89 d7                	mov    %edx,%edi
c0023e8a:	eb e1                	jmp    c0023e6d <fixed32_mul+0x2e>

c0023e8c <fixed32_mul_int>:
struct fixed32 fixed32_mul_int(struct fixed32 a, int32_t b) {
c0023e8c:	8b 44 24 04          	mov    0x4(%esp),%eax
  struct fixed32 res = {a.num * b};
c0023e90:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023e94:	0f af 54 24 08       	imul   0x8(%esp),%edx
  return res;
c0023e99:	89 10                	mov    %edx,(%eax)
}
c0023e9b:	c2 04 00             	ret    $0x4

c0023e9e <fixed32_div>:

struct fixed32 fixed32_div(struct fixed32 a, struct fixed32 b) {
c0023e9e:	57                   	push   %edi
c0023e9f:	56                   	push   %esi
c0023ea0:	53                   	push   %ebx
c0023ea1:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  struct fixed32 res = {(int64_t)a.num * FLOAT_POINT / b.num};
c0023ea5:	8b 44 24 14          	mov    0x14(%esp),%eax
c0023ea9:	99                   	cltd   
c0023eaa:	0f a4 c2 0e          	shld   $0xe,%eax,%edx
c0023eae:	c1 e0 0e             	shl    $0xe,%eax
c0023eb1:	8b 74 24 18          	mov    0x18(%esp),%esi
c0023eb5:	89 f7                	mov    %esi,%edi
c0023eb7:	c1 ff 1f             	sar    $0x1f,%edi
c0023eba:	57                   	push   %edi
c0023ebb:	56                   	push   %esi
c0023ebc:	52                   	push   %edx
c0023ebd:	50                   	push   %eax
c0023ebe:	e8 d4 41 00 00       	call   c0028097 <__divdi3>
c0023ec3:	83 c4 10             	add    $0x10,%esp
c0023ec6:	89 03                	mov    %eax,(%ebx)
  return res;
}
c0023ec8:	89 d8                	mov    %ebx,%eax
c0023eca:	5b                   	pop    %ebx
c0023ecb:	5e                   	pop    %esi
c0023ecc:	5f                   	pop    %edi
c0023ecd:	c2 04 00             	ret    $0x4

c0023ed0 <fixed32_div_int>:

struct fixed32 fixed32_div_int(struct fixed32 a, int32_t b) {
c0023ed0:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0023ed4:	8b 44 24 08          	mov    0x8(%esp),%eax
  struct fixed32 res = {a.num / b};
c0023ed8:	99                   	cltd   
c0023ed9:	f7 7c 24 0c          	idivl  0xc(%esp)
  return res;
c0023edd:	89 01                	mov    %eax,(%ecx)
}
c0023edf:	89 c8                	mov    %ecx,%eax
c0023ee1:	c2 04 00             	ret    $0x4

c0023ee4 <fixed32_div_int_int>:

struct fixed32 fixed32_div_int_int(int32_t a, int32_t b) {
c0023ee4:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  struct fixed32 res = {a * FLOAT_POINT / b};
c0023ee8:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023eec:	c1 e0 0e             	shl    $0xe,%eax
c0023eef:	99                   	cltd   
c0023ef0:	f7 7c 24 0c          	idivl  0xc(%esp)
  return res;
c0023ef4:	89 01                	mov    %eax,(%ecx)
}
c0023ef6:	89 c8                	mov    %ecx,%eax
c0023ef8:	c2 04 00             	ret    $0x4

c0023efb <fixed32_less_than>:

bool fixed32_less_than(struct fixed32 a, struct fixed32 b) {
  return a.num < b.num;
c0023efb:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023eff:	39 44 24 04          	cmp    %eax,0x4(%esp)
c0023f03:	0f 9c c0             	setl   %al
c0023f06:	c3                   	ret    

c0023f07 <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023f07:	57                   	push   %edi
c0023f08:	56                   	push   %esi
c0023f09:	53                   	push   %ebx
c0023f0a:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023f0e:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0023f12:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023f16:	f7 c6 fd ff ff ff    	test   $0xfffffffd,%esi
c0023f1c:	74 1e                	je     c0023f3c <pit_configure_channel+0x35>
c0023f1e:	83 ec 0c             	sub    $0xc,%esp
c0023f21:	68 e4 1a 03 c0       	push   $0xc0031ae4
c0023f26:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023f2b:	68 30 f8 02 c0       	push   $0xc002f830
c0023f30:	6a 33                	push   $0x33
c0023f32:	68 01 1b 03 c0       	push   $0xc0031b01
c0023f37:	e8 41 47 00 00       	call   c002867d <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023f3c:	8d 43 fe             	lea    -0x2(%ebx),%eax
c0023f3f:	83 f8 01             	cmp    $0x1,%eax
c0023f42:	77 22                	ja     c0023f66 <pit_configure_channel+0x5f>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023f44:	83 f9 12             	cmp    $0x12,%ecx
c0023f47:	7e 3b                	jle    c0023f84 <pit_configure_channel+0x7d>
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
    }
  else if (frequency > PIT_HZ)
c0023f49:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c0023f4f:	7f 6b                	jg     c0023fbc <pit_configure_channel+0xb5>
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023f51:	89 c8                	mov    %ecx,%eax
c0023f53:	c1 e8 1f             	shr    $0x1f,%eax
c0023f56:	01 c8                	add    %ecx,%eax
c0023f58:	d1 f8                	sar    %eax
c0023f5a:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023f5f:	99                   	cltd   
c0023f60:	f7 f9                	idiv   %ecx
c0023f62:	89 c7                	mov    %eax,%edi
c0023f64:	eb 23                	jmp    c0023f89 <pit_configure_channel+0x82>
  ASSERT (mode == 2 || mode == 3);
c0023f66:	83 ec 0c             	sub    $0xc,%esp
c0023f69:	68 15 1b 03 c0       	push   $0xc0031b15
c0023f6e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0023f73:	68 30 f8 02 c0       	push   $0xc002f830
c0023f78:	6a 34                	push   $0x34
c0023f7a:	68 01 1b 03 c0       	push   $0xc0031b01
c0023f7f:	e8 f9 46 00 00       	call   c002867d <debug_panic>
      count = 0;
c0023f84:	bf 00 00 00 00       	mov    $0x0,%edi

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023f89:	e8 cd da ff ff       	call   c0021a5b <intr_disable>
c0023f8e:	89 c1                	mov    %eax,%ecx
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023f90:	8d 04 1b             	lea    (%ebx,%ebx,1),%eax
c0023f93:	83 c8 30             	or     $0x30,%eax
c0023f96:	89 f3                	mov    %esi,%ebx
c0023f98:	c1 e3 06             	shl    $0x6,%ebx
c0023f9b:	09 d8                	or     %ebx,%eax
c0023f9d:	e6 43                	out    %al,$0x43
  outb (PIT_PORT_COUNTER (channel), count);
c0023f9f:	8d 56 40             	lea    0x40(%esi),%edx
c0023fa2:	89 f8                	mov    %edi,%eax
c0023fa4:	ee                   	out    %al,(%dx)
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023fa5:	89 f8                	mov    %edi,%eax
c0023fa7:	66 c1 e8 08          	shr    $0x8,%ax
c0023fab:	ee                   	out    %al,(%dx)
  intr_set_level (old_level);
c0023fac:	83 ec 0c             	sub    $0xc,%esp
c0023faf:	51                   	push   %ecx
c0023fb0:	e8 ad da ff ff       	call   c0021a62 <intr_set_level>
}
c0023fb5:	83 c4 10             	add    $0x10,%esp
c0023fb8:	5b                   	pop    %ebx
c0023fb9:	5e                   	pop    %esi
c0023fba:	5f                   	pop    %edi
c0023fbb:	c3                   	ret    
      count = 2;
c0023fbc:	bf 02 00 00 00       	mov    $0x2,%edi
c0023fc1:	eb c6                	jmp    c0023f89 <pit_configure_channel+0x82>

c0023fc3 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0023fc3:	53                   	push   %ebx
  while (loops-- > 0)
c0023fc4:	89 c1                	mov    %eax,%ecx
c0023fc6:	89 d3                	mov    %edx,%ebx
c0023fc8:	83 c1 ff             	add    $0xffffffff,%ecx
c0023fcb:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023fce:	85 d2                	test   %edx,%edx
c0023fd0:	78 13                	js     c0023fe5 <busy_wait+0x22>
c0023fd2:	85 d2                	test   %edx,%edx
c0023fd4:	7e 11                	jle    c0023fe7 <busy_wait+0x24>
c0023fd6:	83 c1 ff             	add    $0xffffffff,%ecx
c0023fd9:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023fdc:	89 d8                	mov    %ebx,%eax
c0023fde:	21 c8                	and    %ecx,%eax
c0023fe0:	83 f8 ff             	cmp    $0xffffffff,%eax
c0023fe3:	75 f1                	jne    c0023fd6 <busy_wait+0x13>
    barrier ();
}
c0023fe5:	5b                   	pop    %ebx
c0023fe6:	c3                   	ret    
  while (loops-- > 0)
c0023fe7:	83 f8 00             	cmp    $0x0,%eax
c0023fea:	76 f9                	jbe    c0023fe5 <busy_wait+0x22>
c0023fec:	eb e8                	jmp    c0023fd6 <busy_wait+0x13>

c0023fee <too_many_loops>:
{
c0023fee:	55                   	push   %ebp
c0023fef:	57                   	push   %edi
c0023ff0:	56                   	push   %esi
c0023ff1:	53                   	push   %ebx
c0023ff2:	83 ec 04             	sub    $0x4,%esp
  int64_t start = ticks;
c0023ff5:	8b 2d a0 e0 03 c0    	mov    0xc003e0a0,%ebp
c0023ffb:	8b 3d a4 e0 03 c0    	mov    0xc003e0a4,%edi
  while (ticks == start)
c0024001:	8b 35 a0 e0 03 c0    	mov    0xc003e0a0,%esi
c0024007:	8b 1d a4 e0 03 c0    	mov    0xc003e0a4,%ebx
c002400d:	89 ea                	mov    %ebp,%edx
c002400f:	31 f2                	xor    %esi,%edx
c0024011:	89 f9                	mov    %edi,%ecx
c0024013:	31 d9                	xor    %ebx,%ecx
c0024015:	09 d1                	or     %edx,%ecx
c0024017:	74 e8                	je     c0024001 <too_many_loops+0x13>
  busy_wait (loops);
c0024019:	ba 00 00 00 00       	mov    $0x0,%edx
c002401e:	e8 a0 ff ff ff       	call   c0023fc3 <busy_wait>
  return start != ticks;
c0024023:	33 35 a0 e0 03 c0    	xor    0xc003e0a0,%esi
c0024029:	33 1d a4 e0 03 c0    	xor    0xc003e0a4,%ebx
c002402f:	09 de                	or     %ebx,%esi
c0024031:	0f 95 c0             	setne  %al
}
c0024034:	83 c4 04             	add    $0x4,%esp
c0024037:	5b                   	pop    %ebx
c0024038:	5e                   	pop    %esi
c0024039:	5f                   	pop    %edi
c002403a:	5d                   	pop    %ebp
c002403b:	c3                   	ret    

c002403c <timer_interrupt>:
{
c002403c:	83 ec 0c             	sub    $0xc,%esp
  ticks++;
c002403f:	83 05 a0 e0 03 c0 01 	addl   $0x1,0xc003e0a0
c0024046:	83 15 a4 e0 03 c0 00 	adcl   $0x0,0xc003e0a4
  thread_tick ();
c002404d:	e8 2a cd ff ff       	call   c0020d7c <thread_tick>
  thread_tick_events(ticks % TIMER_FREQ == 0);
c0024052:	83 ec 10             	sub    $0x10,%esp
c0024055:	6a 00                	push   $0x0
c0024057:	6a 64                	push   $0x64
c0024059:	ff 35 a4 e0 03 c0    	pushl  0xc003e0a4
c002405f:	ff 35 a0 e0 03 c0    	pushl  0xc003e0a0
c0024065:	e8 49 40 00 00       	call   c00280b3 <__moddi3>
c002406a:	83 c4 14             	add    $0x14,%esp
c002406d:	09 d0                	or     %edx,%eax
c002406f:	0f 94 c0             	sete   %al
c0024072:	0f b6 c0             	movzbl %al,%eax
c0024075:	50                   	push   %eax
c0024076:	e8 4d d1 ff ff       	call   c00211c8 <thread_tick_events>
}
c002407b:	83 c4 1c             	add    $0x1c,%esp
c002407e:	c3                   	ret    

c002407f <real_time_delay>:
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c002407f:	57                   	push   %edi
c0024080:	56                   	push   %esi
c0024081:	53                   	push   %ebx
c0024082:	89 c6                	mov    %eax,%esi
c0024084:	89 d7                	mov    %edx,%edi
c0024086:	89 cb                	mov    %ecx,%ebx
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c0024088:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c002408d:	89 d8                	mov    %ebx,%eax
c002408f:	99                   	cltd   
c0024090:	f7 f9                	idiv   %ecx
c0024092:	85 d2                	test   %edx,%edx
c0024094:	75 5c                	jne    c00240f2 <real_time_delay+0x73>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c0024096:	a1 98 e0 03 c0       	mov    0xc003e098,%eax
c002409b:	0f af f8             	imul   %eax,%edi
c002409e:	f7 e6                	mul    %esi
c00240a0:	01 fa                	add    %edi,%edx
c00240a2:	6a 00                	push   $0x0
c00240a4:	68 e8 03 00 00       	push   $0x3e8
c00240a9:	52                   	push   %edx
c00240aa:	50                   	push   %eax
c00240ab:	e8 e7 3f 00 00       	call   c0028097 <__divdi3>
c00240b0:	83 c4 10             	add    $0x10,%esp
c00240b3:	89 c6                	mov    %eax,%esi
c00240b5:	6b ca 64             	imul   $0x64,%edx,%ecx
c00240b8:	bf 64 00 00 00       	mov    $0x64,%edi
c00240bd:	89 f8                	mov    %edi,%eax
c00240bf:	f7 e6                	mul    %esi
c00240c1:	89 c6                	mov    %eax,%esi
c00240c3:	89 d7                	mov    %edx,%edi
c00240c5:	01 cf                	add    %ecx,%edi
c00240c7:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
c00240cc:	89 c8                	mov    %ecx,%eax
c00240ce:	f7 eb                	imul   %ebx
c00240d0:	89 d1                	mov    %edx,%ecx
c00240d2:	89 c8                	mov    %ecx,%eax
c00240d4:	c1 f8 06             	sar    $0x6,%eax
c00240d7:	c1 fb 1f             	sar    $0x1f,%ebx
c00240da:	29 d8                	sub    %ebx,%eax
c00240dc:	99                   	cltd   
c00240dd:	52                   	push   %edx
c00240de:	50                   	push   %eax
c00240df:	57                   	push   %edi
c00240e0:	56                   	push   %esi
c00240e1:	e8 b1 3f 00 00       	call   c0028097 <__divdi3>
c00240e6:	83 c4 10             	add    $0x10,%esp
c00240e9:	e8 d5 fe ff ff       	call   c0023fc3 <busy_wait>
}
c00240ee:	5b                   	pop    %ebx
c00240ef:	5e                   	pop    %esi
c00240f0:	5f                   	pop    %edi
c00240f1:	c3                   	ret    
  ASSERT (denom % 1000 == 0);
c00240f2:	83 ec 0c             	sub    $0xc,%esp
c00240f5:	68 2c 1b 03 c0       	push   $0xc0031b2c
c00240fa:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00240ff:	68 48 f8 02 c0       	push   $0xc002f848
c0024104:	68 f9 00 00 00       	push   $0xf9
c0024109:	68 3e 1b 03 c0       	push   $0xc0031b3e
c002410e:	e8 6a 45 00 00       	call   c002867d <debug_panic>

c0024113 <timer_init>:
{
c0024113:	83 ec 10             	sub    $0x10,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c0024116:	6a 64                	push   $0x64
c0024118:	6a 02                	push   $0x2
c002411a:	6a 00                	push   $0x0
c002411c:	e8 e6 fd ff ff       	call   c0023f07 <pit_configure_channel>
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0024121:	83 c4 0c             	add    $0xc,%esp
c0024124:	68 54 1b 03 c0       	push   $0xc0031b54
c0024129:	68 3c 40 02 c0       	push   $0xc002403c
c002412e:	6a 20                	push   $0x20
c0024130:	e8 a7 da ff ff       	call   c0021bdc <intr_register_ext>
}
c0024135:	83 c4 1c             	add    $0x1c,%esp
c0024138:	c3                   	ret    

c0024139 <timer_calibrate>:
{
c0024139:	57                   	push   %edi
c002413a:	56                   	push   %esi
c002413b:	53                   	push   %ebx
  ASSERT (intr_get_level () == INTR_ON);
c002413c:	e8 dd d8 ff ff       	call   c0021a1e <intr_get_level>
c0024141:	83 f8 01             	cmp    $0x1,%eax
c0024144:	75 56                	jne    c002419c <timer_calibrate+0x63>
  printf ("Calibrating timer...  ");
c0024146:	83 ec 0c             	sub    $0xc,%esp
c0024149:	68 7c 1b 03 c0       	push   $0xc0031b7c
c002414e:	e8 7c 2a 00 00       	call   c0026bcf <printf>
  loops_per_tick = 1u << 10;
c0024153:	c7 05 98 e0 03 c0 00 	movl   $0x400,0xc003e098
c002415a:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c002415d:	83 c4 10             	add    $0x10,%esp
c0024160:	8b 35 98 e0 03 c0    	mov    0xc003e098,%esi
c0024166:	8d 1c 36             	lea    (%esi,%esi,1),%ebx
c0024169:	89 d8                	mov    %ebx,%eax
c002416b:	e8 7e fe ff ff       	call   c0023fee <too_many_loops>
c0024170:	84 c0                	test   %al,%al
c0024172:	75 46                	jne    c00241ba <timer_calibrate+0x81>
      loops_per_tick <<= 1;
c0024174:	89 1d 98 e0 03 c0    	mov    %ebx,0xc003e098
      ASSERT (loops_per_tick != 0);
c002417a:	85 db                	test   %ebx,%ebx
c002417c:	75 e2                	jne    c0024160 <timer_calibrate+0x27>
c002417e:	83 ec 0c             	sub    $0xc,%esp
c0024181:	68 93 1b 03 c0       	push   $0xc0031b93
c0024186:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002418b:	68 74 f8 02 c0       	push   $0xc002f874
c0024190:	6a 39                	push   $0x39
c0024192:	68 3e 1b 03 c0       	push   $0xc0031b3e
c0024197:	e8 e1 44 00 00       	call   c002867d <debug_panic>
  ASSERT (intr_get_level () == INTR_ON);
c002419c:	83 ec 0c             	sub    $0xc,%esp
c002419f:	68 5f 1b 03 c0       	push   $0xc0031b5f
c00241a4:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00241a9:	68 74 f8 02 c0       	push   $0xc002f874
c00241ae:	6a 30                	push   $0x30
c00241b0:	68 3e 1b 03 c0       	push   $0xc0031b3e
c00241b5:	e8 c3 44 00 00       	call   c002867d <debug_panic>
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00241ba:	89 f3                	mov    %esi,%ebx
c00241bc:	d1 eb                	shr    %ebx
c00241be:	89 f7                	mov    %esi,%edi
c00241c0:	c1 ef 0a             	shr    $0xa,%edi
c00241c3:	39 df                	cmp    %ebx,%edi
c00241c5:	75 27                	jne    c00241ee <timer_calibrate+0xb5>
  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c00241c7:	83 ec 04             	sub    $0x4,%esp
c00241ca:	b8 64 00 00 00       	mov    $0x64,%eax
c00241cf:	f7 25 98 e0 03 c0    	mull   0xc003e098
c00241d5:	52                   	push   %edx
c00241d6:	50                   	push   %eax
c00241d7:	68 a7 1b 03 c0       	push   $0xc0031ba7
c00241dc:	e8 ee 29 00 00       	call   c0026bcf <printf>
}
c00241e1:	83 c4 10             	add    $0x10,%esp
c00241e4:	5b                   	pop    %ebx
c00241e5:	5e                   	pop    %esi
c00241e6:	5f                   	pop    %edi
c00241e7:	c3                   	ret    
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00241e8:	d1 eb                	shr    %ebx
c00241ea:	39 df                	cmp    %ebx,%edi
c00241ec:	74 d9                	je     c00241c7 <timer_calibrate+0x8e>
    if (!too_many_loops (high_bit | test_bit))
c00241ee:	89 f0                	mov    %esi,%eax
c00241f0:	09 d8                	or     %ebx,%eax
c00241f2:	e8 f7 fd ff ff       	call   c0023fee <too_many_loops>
c00241f7:	84 c0                	test   %al,%al
c00241f9:	75 ed                	jne    c00241e8 <timer_calibrate+0xaf>
      loops_per_tick |= test_bit;
c00241fb:	09 1d 98 e0 03 c0    	or     %ebx,0xc003e098
c0024201:	eb e5                	jmp    c00241e8 <timer_calibrate+0xaf>

c0024203 <timer_ticks>:
{
c0024203:	57                   	push   %edi
c0024204:	56                   	push   %esi
c0024205:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level = intr_disable ();
c0024208:	e8 4e d8 ff ff       	call   c0021a5b <intr_disable>
  int64_t t = ticks;
c002420d:	8b 35 a0 e0 03 c0    	mov    0xc003e0a0,%esi
c0024213:	8b 3d a4 e0 03 c0    	mov    0xc003e0a4,%edi
  intr_set_level (old_level);
c0024219:	83 ec 0c             	sub    $0xc,%esp
c002421c:	50                   	push   %eax
c002421d:	e8 40 d8 ff ff       	call   c0021a62 <intr_set_level>
}
c0024222:	89 f0                	mov    %esi,%eax
c0024224:	89 fa                	mov    %edi,%edx
c0024226:	83 c4 14             	add    $0x14,%esp
c0024229:	5e                   	pop    %esi
c002422a:	5f                   	pop    %edi
c002422b:	c3                   	ret    

c002422c <timer_elapsed>:
{
c002422c:	57                   	push   %edi
c002422d:	56                   	push   %esi
c002422e:	83 ec 04             	sub    $0x4,%esp
c0024231:	8b 74 24 10          	mov    0x10(%esp),%esi
c0024235:	8b 7c 24 14          	mov    0x14(%esp),%edi
  return timer_ticks () - then;
c0024239:	e8 c5 ff ff ff       	call   c0024203 <timer_ticks>
c002423e:	29 f0                	sub    %esi,%eax
c0024240:	19 fa                	sbb    %edi,%edx
}
c0024242:	83 c4 04             	add    $0x4,%esp
c0024245:	5e                   	pop    %esi
c0024246:	5f                   	pop    %edi
c0024247:	c3                   	ret    

c0024248 <timer_sleep>:
{
c0024248:	56                   	push   %esi
c0024249:	53                   	push   %ebx
c002424a:	83 ec 04             	sub    $0x4,%esp
c002424d:	8b 74 24 10          	mov    0x10(%esp),%esi
c0024251:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (intr_get_level () == INTR_ON);  
c0024255:	e8 c4 d7 ff ff       	call   c0021a1e <intr_get_level>
c002425a:	83 f8 01             	cmp    $0x1,%eax
c002425d:	75 2e                	jne    c002428d <timer_sleep+0x45>
  if (ticks <= 0) return;
c002425f:	85 db                	test   %ebx,%ebx
c0024261:	78 24                	js     c0024287 <timer_sleep+0x3f>
c0024263:	85 db                	test   %ebx,%ebx
c0024265:	7e 44                	jle    c00242ab <timer_sleep+0x63>
  struct thread *t = thread_current();
c0024267:	e8 aa ca ff ff       	call   c0020d16 <thread_current>
  t->sleep_remain = ticks;
c002426c:	89 70 24             	mov    %esi,0x24(%eax)
  enum intr_level old_level = intr_disable();
c002426f:	e8 e7 d7 ff ff       	call   c0021a5b <intr_disable>
c0024274:	89 c3                	mov    %eax,%ebx
  thread_block();
c0024276:	e8 dc d1 ff ff       	call   c0021457 <thread_block>
  intr_set_level(old_level);
c002427b:	83 ec 0c             	sub    $0xc,%esp
c002427e:	53                   	push   %ebx
c002427f:	e8 de d7 ff ff       	call   c0021a62 <intr_set_level>
c0024284:	83 c4 10             	add    $0x10,%esp
}
c0024287:	83 c4 04             	add    $0x4,%esp
c002428a:	5b                   	pop    %ebx
c002428b:	5e                   	pop    %esi
c002428c:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);  
c002428d:	83 ec 0c             	sub    $0xc,%esp
c0024290:	68 5f 1b 03 c0       	push   $0xc0031b5f
c0024295:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002429a:	68 68 f8 02 c0       	push   $0xc002f868
c002429f:	6a 5c                	push   $0x5c
c00242a1:	68 3e 1b 03 c0       	push   $0xc0031b3e
c00242a6:	e8 d2 43 00 00       	call   c002867d <debug_panic>
  if (ticks <= 0) return;
c00242ab:	83 fe 00             	cmp    $0x0,%esi
c00242ae:	76 d7                	jbe    c0024287 <timer_sleep+0x3f>
c00242b0:	eb b5                	jmp    c0024267 <timer_sleep+0x1f>

c00242b2 <real_time_sleep>:
{
c00242b2:	55                   	push   %ebp
c00242b3:	57                   	push   %edi
c00242b4:	56                   	push   %esi
c00242b5:	53                   	push   %ebx
c00242b6:	83 ec 1c             	sub    $0x1c,%esp
c00242b9:	89 c6                	mov    %eax,%esi
c00242bb:	89 44 24 08          	mov    %eax,0x8(%esp)
c00242bf:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00242c3:	89 cd                	mov    %ecx,%ebp
  int64_t ticks = num * TIMER_FREQ / denom;
c00242c5:	6b fa 64             	imul   $0x64,%edx,%edi
c00242c8:	b9 64 00 00 00       	mov    $0x64,%ecx
c00242cd:	89 c8                	mov    %ecx,%eax
c00242cf:	f7 e6                	mul    %esi
c00242d1:	89 c1                	mov    %eax,%ecx
c00242d3:	89 d3                	mov    %edx,%ebx
c00242d5:	01 fb                	add    %edi,%ebx
c00242d7:	89 e8                	mov    %ebp,%eax
c00242d9:	99                   	cltd   
c00242da:	52                   	push   %edx
c00242db:	55                   	push   %ebp
c00242dc:	53                   	push   %ebx
c00242dd:	51                   	push   %ecx
c00242de:	e8 b4 3d 00 00       	call   c0028097 <__divdi3>
c00242e3:	83 c4 10             	add    $0x10,%esp
c00242e6:	89 c6                	mov    %eax,%esi
c00242e8:	89 d7                	mov    %edx,%edi
  ASSERT (intr_get_level () == INTR_ON);
c00242ea:	e8 2f d7 ff ff       	call   c0021a1e <intr_get_level>
c00242ef:	83 f8 01             	cmp    $0x1,%eax
c00242f2:	75 1d                	jne    c0024311 <real_time_sleep+0x5f>
  if (ticks > 0)
c00242f4:	85 ff                	test   %edi,%edi
c00242f6:	78 3f                	js     c0024337 <real_time_sleep+0x85>
c00242f8:	85 ff                	test   %edi,%edi
c00242fa:	7e 36                	jle    c0024332 <real_time_sleep+0x80>
      timer_sleep (ticks); 
c00242fc:	83 ec 08             	sub    $0x8,%esp
c00242ff:	57                   	push   %edi
c0024300:	56                   	push   %esi
c0024301:	e8 42 ff ff ff       	call   c0024248 <timer_sleep>
c0024306:	83 c4 10             	add    $0x10,%esp
}
c0024309:	83 c4 1c             	add    $0x1c,%esp
c002430c:	5b                   	pop    %ebx
c002430d:	5e                   	pop    %esi
c002430e:	5f                   	pop    %edi
c002430f:	5d                   	pop    %ebp
c0024310:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c0024311:	83 ec 0c             	sub    $0xc,%esp
c0024314:	68 5f 1b 03 c0       	push   $0xc0031b5f
c0024319:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002431e:	68 58 f8 02 c0       	push   $0xc002f858
c0024323:	68 e3 00 00 00       	push   $0xe3
c0024328:	68 3e 1b 03 c0       	push   $0xc0031b3e
c002432d:	e8 4b 43 00 00       	call   c002867d <debug_panic>
  if (ticks > 0)
c0024332:	83 fe 00             	cmp    $0x0,%esi
c0024335:	77 c5                	ja     c00242fc <real_time_sleep+0x4a>
      real_time_delay (num, denom); 
c0024337:	89 e9                	mov    %ebp,%ecx
c0024339:	8b 44 24 08          	mov    0x8(%esp),%eax
c002433d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0024341:	e8 39 fd ff ff       	call   c002407f <real_time_delay>
}
c0024346:	eb c1                	jmp    c0024309 <real_time_sleep+0x57>

c0024348 <timer_msleep>:
{
c0024348:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ms, 1000);
c002434b:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024350:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024354:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024358:	e8 55 ff ff ff       	call   c00242b2 <real_time_sleep>
}
c002435d:	83 c4 0c             	add    $0xc,%esp
c0024360:	c3                   	ret    

c0024361 <timer_usleep>:
{
c0024361:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (us, 1000 * 1000);
c0024364:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024369:	8b 44 24 10          	mov    0x10(%esp),%eax
c002436d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024371:	e8 3c ff ff ff       	call   c00242b2 <real_time_sleep>
}
c0024376:	83 c4 0c             	add    $0xc,%esp
c0024379:	c3                   	ret    

c002437a <timer_nsleep>:
{
c002437a:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ns, 1000 * 1000 * 1000);
c002437d:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024382:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024386:	8b 54 24 14          	mov    0x14(%esp),%edx
c002438a:	e8 23 ff ff ff       	call   c00242b2 <real_time_sleep>
}
c002438f:	83 c4 0c             	add    $0xc,%esp
c0024392:	c3                   	ret    

c0024393 <timer_mdelay>:
{
c0024393:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ms, 1000);
c0024396:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c002439b:	8b 44 24 10          	mov    0x10(%esp),%eax
c002439f:	8b 54 24 14          	mov    0x14(%esp),%edx
c00243a3:	e8 d7 fc ff ff       	call   c002407f <real_time_delay>
}
c00243a8:	83 c4 0c             	add    $0xc,%esp
c00243ab:	c3                   	ret    

c00243ac <timer_udelay>:
{
c00243ac:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (us, 1000 * 1000);
c00243af:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c00243b4:	8b 44 24 10          	mov    0x10(%esp),%eax
c00243b8:	8b 54 24 14          	mov    0x14(%esp),%edx
c00243bc:	e8 be fc ff ff       	call   c002407f <real_time_delay>
}
c00243c1:	83 c4 0c             	add    $0xc,%esp
c00243c4:	c3                   	ret    

c00243c5 <timer_ndelay>:
{
c00243c5:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ns, 1000 * 1000 * 1000);
c00243c8:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c00243cd:	8b 44 24 10          	mov    0x10(%esp),%eax
c00243d1:	8b 54 24 14          	mov    0x14(%esp),%edx
c00243d5:	e8 a5 fc ff ff       	call   c002407f <real_time_delay>
}
c00243da:	83 c4 0c             	add    $0xc,%esp
c00243dd:	c3                   	ret    

c00243de <timer_print_stats>:
{
c00243de:	83 ec 0c             	sub    $0xc,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c00243e1:	e8 1d fe ff ff       	call   c0024203 <timer_ticks>
c00243e6:	83 ec 04             	sub    $0x4,%esp
c00243e9:	52                   	push   %edx
c00243ea:	50                   	push   %eax
c00243eb:	68 b7 1b 03 c0       	push   $0xc0031bb7
c00243f0:	e8 da 27 00 00       	call   c0026bcf <printf>
}
c00243f5:	83 c4 1c             	add    $0x1c,%esp
c00243f8:	c3                   	ret    

c00243f9 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c00243f9:	55                   	push   %ebp
c00243fa:	57                   	push   %edi
c00243fb:	56                   	push   %esi
c00243fc:	53                   	push   %ebx
c00243fd:	83 ec 08             	sub    $0x8,%esp
c0024400:	89 0c 24             	mov    %ecx,(%esp)
  for (; k->first_scancode != 0; k++)
c0024403:	8a 18                	mov    (%eax),%bl
c0024405:	84 db                	test   %bl,%bl
c0024407:	74 49                	je     c0024452 <map_key+0x59>
c0024409:	89 c6                	mov    %eax,%esi
    if (scancode >= k->first_scancode
        && scancode < k->first_scancode + strlen (k->chars)) 
c002440b:	b0 00                	mov    $0x0,%al
c002440d:	eb 09                	jmp    c0024418 <map_key+0x1f>
  for (; k->first_scancode != 0; k++)
c002440f:	83 c6 08             	add    $0x8,%esi
c0024412:	8a 1e                	mov    (%esi),%bl
c0024414:	84 db                	test   %bl,%bl
c0024416:	74 30                	je     c0024448 <map_key+0x4f>
    if (scancode >= k->first_scancode
c0024418:	0f b6 db             	movzbl %bl,%ebx
c002441b:	39 d3                	cmp    %edx,%ebx
c002441d:	77 f0                	ja     c002440f <map_key+0x16>
        && scancode < k->first_scancode + strlen (k->chars)) 
c002441f:	8b 6e 04             	mov    0x4(%esi),%ebp
c0024422:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0024427:	89 ef                	mov    %ebp,%edi
c0024429:	f2 ae                	repnz scas %es:(%edi),%al
c002442b:	f7 d1                	not    %ecx
c002442d:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c0024431:	39 ca                	cmp    %ecx,%edx
c0024433:	73 da                	jae    c002440f <map_key+0x16>
      {
        *c = k->chars[scancode - k->first_scancode];
c0024435:	29 da                	sub    %ebx,%edx
c0024437:	8a 44 15 00          	mov    0x0(%ebp,%edx,1),%al
c002443b:	88 44 24 07          	mov    %al,0x7(%esp)
c002443f:	8b 3c 24             	mov    (%esp),%edi
c0024442:	88 07                	mov    %al,(%edi)
        return true; 
c0024444:	b0 01                	mov    $0x1,%al
c0024446:	eb 02                	jmp    c002444a <map_key+0x51>
      }

  return false;
c0024448:	b0 00                	mov    $0x0,%al
}
c002444a:	83 c4 08             	add    $0x8,%esp
c002444d:	5b                   	pop    %ebx
c002444e:	5e                   	pop    %esi
c002444f:	5f                   	pop    %edi
c0024450:	5d                   	pop    %ebp
c0024451:	c3                   	ret    
  return false;
c0024452:	b0 00                	mov    $0x0,%al
c0024454:	eb f4                	jmp    c002444a <map_key+0x51>

c0024456 <keyboard_interrupt>:
{
c0024456:	55                   	push   %ebp
c0024457:	57                   	push   %edi
c0024458:	56                   	push   %esi
c0024459:	53                   	push   %ebx
c002445a:	83 ec 2c             	sub    $0x2c,%esp
  bool shift = left_shift || right_shift;
c002445d:	a0 b6 e0 03 c0       	mov    0xc003e0b6,%al
c0024462:	89 c7                	mov    %eax,%edi
c0024464:	84 c0                	test   %al,%al
c0024466:	75 07                	jne    c002446f <keyboard_interrupt+0x19>
c0024468:	a0 b5 e0 03 c0       	mov    0xc003e0b5,%al
c002446d:	89 c7                	mov    %eax,%edi
  bool alt = left_alt || right_alt;
c002446f:	a0 b4 e0 03 c0       	mov    0xc003e0b4,%al
c0024474:	89 c5                	mov    %eax,%ebp
c0024476:	84 c0                	test   %al,%al
c0024478:	75 07                	jne    c0024481 <keyboard_interrupt+0x2b>
c002447a:	a0 b3 e0 03 c0       	mov    0xc003e0b3,%al
c002447f:	89 c5                	mov    %eax,%ebp
  bool ctrl = left_ctrl || right_ctrl;
c0024481:	a0 b2 e0 03 c0       	mov    0xc003e0b2,%al
c0024486:	88 44 24 0f          	mov    %al,0xf(%esp)
c002448a:	84 c0                	test   %al,%al
c002448c:	75 09                	jne    c0024497 <keyboard_interrupt+0x41>
c002448e:	a0 b1 e0 03 c0       	mov    0xc003e0b1,%al
c0024493:	88 44 24 0f          	mov    %al,0xf(%esp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024497:	e4 60                	in     $0x60,%al
  code = inb (DATA_REG);
c0024499:	0f b6 d8             	movzbl %al,%ebx
  if (code == 0xe0)
c002449c:	81 fb e0 00 00 00    	cmp    $0xe0,%ebx
c00244a2:	74 63                	je     c0024507 <keyboard_interrupt+0xb1>
  release = (code & 0x80) != 0;
c00244a4:	89 de                	mov    %ebx,%esi
c00244a6:	81 e6 80 00 00 00    	and    $0x80,%esi
  code &= ~0x80u;
c00244ac:	80 e3 7f             	and    $0x7f,%bl
  if (code == 0x3a) 
c00244af:	83 fb 3a             	cmp    $0x3a,%ebx
c00244b2:	74 5d                	je     c0024511 <keyboard_interrupt+0xbb>
  else if (map_key (invariant_keymap, code, &c)
c00244b4:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00244b8:	89 da                	mov    %ebx,%edx
c00244ba:	b8 60 f9 02 c0       	mov    $0xc002f960,%eax
c00244bf:	e8 35 ff ff ff       	call   c00243f9 <map_key>
c00244c4:	84 c0                	test   %al,%al
c00244c6:	75 70                	jne    c0024538 <keyboard_interrupt+0xe2>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00244c8:	89 f8                	mov    %edi,%eax
c00244ca:	84 c0                	test   %al,%al
c00244cc:	74 56                	je     c0024524 <keyboard_interrupt+0xce>
           || (shift && map_key (shifted_keymap, code, &c)))
c00244ce:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00244d2:	89 da                	mov    %ebx,%edx
c00244d4:	b8 e0 f8 02 c0       	mov    $0xc002f8e0,%eax
c00244d9:	e8 1b ff ff ff       	call   c00243f9 <map_key>
c00244de:	84 c0                	test   %al,%al
c00244e0:	75 56                	jne    c0024538 <keyboard_interrupt+0xe2>
        if (key->scancode == code)
c00244e2:	83 fb 2a             	cmp    $0x2a,%ebx
c00244e5:	0f 84 e2 00 00 00    	je     c00245cd <keyboard_interrupt+0x177>
c00244eb:	b8 a0 f8 02 c0       	mov    $0xc002f8a0,%eax
      for (key = shift_keys; key->scancode != 0; key++) 
c00244f0:	83 c0 08             	add    $0x8,%eax
c00244f3:	8b 10                	mov    (%eax),%edx
c00244f5:	85 d2                	test   %edx,%edx
c00244f7:	74 23                	je     c002451c <keyboard_interrupt+0xc6>
        if (key->scancode == code)
c00244f9:	39 d3                	cmp    %edx,%ebx
c00244fb:	75 f3                	jne    c00244f0 <keyboard_interrupt+0x9a>
            *key->state_var = !release;
c00244fd:	8b 40 04             	mov    0x4(%eax),%eax
c0024500:	85 f6                	test   %esi,%esi
c0024502:	0f 94 00             	sete   (%eax)
            break;
c0024505:	eb 15                	jmp    c002451c <keyboard_interrupt+0xc6>
c0024507:	e4 60                	in     $0x60,%al
    code = (code << 8) | inb (DATA_REG);
c0024509:	0f b6 d8             	movzbl %al,%ebx
c002450c:	80 cf e0             	or     $0xe0,%bh
c002450f:	eb 93                	jmp    c00244a4 <keyboard_interrupt+0x4e>
      if (!release)
c0024511:	85 f6                	test   %esi,%esi
c0024513:	75 07                	jne    c002451c <keyboard_interrupt+0xc6>
        caps_lock = !caps_lock;
c0024515:	80 35 b0 e0 03 c0 01 	xorb   $0x1,0xc003e0b0
}
c002451c:	83 c4 2c             	add    $0x2c,%esp
c002451f:	5b                   	pop    %ebx
c0024520:	5e                   	pop    %esi
c0024521:	5f                   	pop    %edi
c0024522:	5d                   	pop    %ebp
c0024523:	c3                   	ret    
           || (!shift && map_key (unshifted_keymap, code, &c))
c0024524:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024528:	89 da                	mov    %ebx,%edx
c002452a:	b8 20 f9 02 c0       	mov    $0xc002f920,%eax
c002452f:	e8 c5 fe ff ff       	call   c00243f9 <map_key>
c0024534:	84 c0                	test   %al,%al
c0024536:	74 aa                	je     c00244e2 <keyboard_interrupt+0x8c>
      if (!release) 
c0024538:	85 f6                	test   %esi,%esi
c002453a:	75 e0                	jne    c002451c <keyboard_interrupt+0xc6>
          if (c == 0177 && ctrl && alt)
c002453c:	8a 44 24 1f          	mov    0x1f(%esp),%al
c0024540:	3c 7f                	cmp    $0x7f,%al
c0024542:	74 4e                	je     c0024592 <keyboard_interrupt+0x13c>
          if (ctrl && c >= 0x40 && c < 0x60) 
c0024544:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0024549:	74 08                	je     c0024553 <keyboard_interrupt+0xfd>
c002454b:	8d 50 c0             	lea    -0x40(%eax),%edx
c002454e:	80 fa 1f             	cmp    $0x1f,%dl
c0024551:	76 60                	jbe    c00245b3 <keyboard_interrupt+0x15d>
          else if (shift == caps_lock)
c0024553:	89 f9                	mov    %edi,%ecx
c0024555:	38 0d b0 e0 03 c0    	cmp    %cl,0xc003e0b0
c002455b:	74 5c                	je     c00245b9 <keyboard_interrupt+0x163>
          if (alt)
c002455d:	89 e8                	mov    %ebp,%eax
c002455f:	84 c0                	test   %al,%al
c0024561:	74 05                	je     c0024568 <keyboard_interrupt+0x112>
            c += 0x80;
c0024563:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
          if (!input_full ())
c0024568:	e8 c3 18 00 00       	call   c0025e30 <input_full>
c002456d:	84 c0                	test   %al,%al
c002456f:	75 ab                	jne    c002451c <keyboard_interrupt+0xc6>
              key_cnt++;
c0024571:	83 05 a8 e0 03 c0 01 	addl   $0x1,0xc003e0a8
c0024578:	83 15 ac e0 03 c0 00 	adcl   $0x0,0xc003e0ac
              input_putc (c);
c002457f:	83 ec 0c             	sub    $0xc,%esp
c0024582:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c0024587:	50                   	push   %eax
c0024588:	e8 f7 17 00 00       	call   c0025d84 <input_putc>
c002458d:	83 c4 10             	add    $0x10,%esp
c0024590:	eb 8a                	jmp    c002451c <keyboard_interrupt+0xc6>
          if (c == 0177 && ctrl && alt)
c0024592:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0024597:	74 06                	je     c002459f <keyboard_interrupt+0x149>
c0024599:	89 e9                	mov    %ebp,%ecx
c002459b:	84 c9                	test   %cl,%cl
c002459d:	75 0f                	jne    c00245ae <keyboard_interrupt+0x158>
          else if (shift == caps_lock)
c002459f:	89 f9                	mov    %edi,%ecx
c00245a1:	38 0d b0 e0 03 c0    	cmp    %cl,0xc003e0b0
c00245a7:	75 b4                	jne    c002455d <keyboard_interrupt+0x107>
            c = tolower (c);
c00245a9:	0f b6 c0             	movzbl %al,%eax
c00245ac:	eb 19                	jmp    c00245c7 <keyboard_interrupt+0x171>
            shutdown_reboot ();
c00245ae:	e8 64 1e 00 00       	call   c0026417 <shutdown_reboot>
              c -= 0x40; 
c00245b3:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c00245b7:	eb a4                	jmp    c002455d <keyboard_interrupt+0x107>
            c = tolower (c);
c00245b9:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c00245bc:	8d 50 bf             	lea    -0x41(%eax),%edx
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c00245bf:	83 fa 19             	cmp    $0x19,%edx
c00245c2:	77 03                	ja     c00245c7 <keyboard_interrupt+0x171>
c00245c4:	83 c0 20             	add    $0x20,%eax
c00245c7:	88 44 24 1f          	mov    %al,0x1f(%esp)
c00245cb:	eb 90                	jmp    c002455d <keyboard_interrupt+0x107>
      for (key = shift_keys; key->scancode != 0; key++) 
c00245cd:	b8 a0 f8 02 c0       	mov    $0xc002f8a0,%eax
c00245d2:	e9 26 ff ff ff       	jmp    c00244fd <keyboard_interrupt+0xa7>

c00245d7 <kbd_init>:
{
c00245d7:	83 ec 10             	sub    $0x10,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c00245da:	68 ca 1b 03 c0       	push   $0xc0031bca
c00245df:	68 56 44 02 c0       	push   $0xc0024456
c00245e4:	6a 21                	push   $0x21
c00245e6:	e8 f1 d5 ff ff       	call   c0021bdc <intr_register_ext>
}
c00245eb:	83 c4 1c             	add    $0x1c,%esp
c00245ee:	c3                   	ret    

c00245ef <kbd_print_stats>:
{
c00245ef:	83 ec 10             	sub    $0x10,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c00245f2:	ff 35 ac e0 03 c0    	pushl  0xc003e0ac
c00245f8:	ff 35 a8 e0 03 c0    	pushl  0xc003e0a8
c00245fe:	68 d8 1b 03 c0       	push   $0xc0031bd8
c0024603:	e8 c7 25 00 00       	call   c0026bcf <printf>
}
c0024608:	83 c4 1c             	add    $0x1c,%esp
c002460b:	c3                   	ret    

c002460c <move_cursor>:
/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c002460c:	a1 c0 e0 03 c0       	mov    0xc003e0c0,%eax
c0024611:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0024618:	01 c1                	add    %eax,%ecx
c002461a:	c1 e1 04             	shl    $0x4,%ecx
c002461d:	03 0d c4 e0 03 c0    	add    0xc003e0c4,%ecx
  outw (0x3d4, 0x0e | (cp & 0xff00));
c0024623:	89 c8                	mov    %ecx,%eax
c0024625:	b0 00                	mov    $0x0,%al
c0024627:	83 c8 0e             	or     $0xe,%eax
/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c002462a:	ba d4 03 00 00       	mov    $0x3d4,%edx
c002462f:	66 ef                	out    %ax,(%dx)
  outw (0x3d4, 0x0f | (cp << 8));
c0024631:	89 c8                	mov    %ecx,%eax
c0024633:	c1 e0 08             	shl    $0x8,%eax
c0024636:	83 c8 0f             	or     $0xf,%eax
c0024639:	66 ef                	out    %ax,(%dx)
c002463b:	c3                   	ret    

c002463c <newline>:
  cx = 0;
c002463c:	c7 05 c4 e0 03 c0 00 	movl   $0x0,0xc003e0c4
c0024643:	00 00 00 
  cy++;
c0024646:	a1 c0 e0 03 c0       	mov    0xc003e0c0,%eax
c002464b:	40                   	inc    %eax
  if (cy >= ROW_CNT)
c002464c:	83 f8 18             	cmp    $0x18,%eax
c002464f:	77 06                	ja     c0024657 <newline+0x1b>
  cy++;
c0024651:	a3 c0 e0 03 c0       	mov    %eax,0xc003e0c0
c0024656:	c3                   	ret    
{
c0024657:	53                   	push   %ebx
c0024658:	83 ec 0c             	sub    $0xc,%esp
      cy = ROW_CNT - 1;
c002465b:	c7 05 c0 e0 03 c0 18 	movl   $0x18,0xc003e0c0
c0024662:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024665:	8b 1d bc e0 03 c0    	mov    0xc003e0bc,%ebx
c002466b:	68 00 0f 00 00       	push   $0xf00
c0024670:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0024676:	50                   	push   %eax
c0024677:	53                   	push   %ebx
c0024678:	e8 1b 33 00 00       	call   c0027998 <memmove>
c002467d:	8d 83 00 0f 00 00    	lea    0xf00(%ebx),%eax
c0024683:	8d 93 a0 0f 00 00    	lea    0xfa0(%ebx),%edx
c0024689:	83 c4 10             	add    $0x10,%esp
      fb[y][x][0] = ' ';
c002468c:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c002468f:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024693:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0024696:	39 d0                	cmp    %edx,%eax
c0024698:	75 f2                	jne    c002468c <newline+0x50>
}
c002469a:	83 c4 08             	add    $0x8,%esp
c002469d:	5b                   	pop    %ebx
c002469e:	c3                   	ret    

c002469f <vga_putc>:
{
c002469f:	56                   	push   %esi
c00246a0:	53                   	push   %ebx
c00246a1:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level = intr_disable ();
c00246a4:	e8 b2 d3 ff ff       	call   c0021a5b <intr_disable>
c00246a9:	89 c3                	mov    %eax,%ebx
  if (!inited)
c00246ab:	80 3d b8 e0 03 c0 00 	cmpb   $0x0,0xc003e0b8
c00246b2:	74 17                	je     c00246cb <vga_putc+0x2c>
  switch (c) 
c00246b4:	8b 44 24 10          	mov    0x10(%esp),%eax
c00246b8:	83 e8 07             	sub    $0x7,%eax
c00246bb:	83 f8 06             	cmp    $0x6,%eax
c00246be:	0f 87 23 01 00 00    	ja     c00247e7 <vga_putc+0x148>
c00246c4:	ff 24 85 b0 f9 02 c0 	jmp    *-0x3ffd0650(,%eax,4)
      fb = ptov (0xb8000);
c00246cb:	c7 05 bc e0 03 c0 00 	movl   $0xc00b8000,0xc003e0bc
c00246d2:	80 0b c0 
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00246d5:	ba d4 03 00 00       	mov    $0x3d4,%edx
c00246da:	b0 0e                	mov    $0xe,%al
c00246dc:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00246dd:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c00246e2:	89 ca                	mov    %ecx,%edx
c00246e4:	ec                   	in     (%dx),%al
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
  cp = inb (0x3d5) << 8;
c00246e5:	89 c6                	mov    %eax,%esi
c00246e7:	c1 e6 08             	shl    $0x8,%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00246ea:	ba d4 03 00 00       	mov    $0x3d4,%edx
c00246ef:	b0 0f                	mov    $0xf,%al
c00246f1:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00246f2:	89 ca                	mov    %ecx,%edx
c00246f4:	ec                   	in     (%dx),%al

  outb (0x3d4, 0x0f);
  cp |= inb (0x3d5);
c00246f5:	0f b6 c0             	movzbl %al,%eax
c00246f8:	09 f0                	or     %esi,%eax
c00246fa:	89 c1                	mov    %eax,%ecx

  *x = cp % COL_CNT;
c00246fc:	be 50 00 00 00       	mov    $0x50,%esi
c0024701:	ba 00 00 00 00       	mov    $0x0,%edx
c0024706:	66 f7 f6             	div    %si
c0024709:	0f b7 d2             	movzwl %dx,%edx
c002470c:	89 15 c4 e0 03 c0    	mov    %edx,0xc003e0c4
  *y = cp / COL_CNT;
c0024712:	0f b7 c1             	movzwl %cx,%eax
c0024715:	8d 14 80             	lea    (%eax,%eax,4),%edx
c0024718:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002471b:	01 d2                	add    %edx,%edx
c002471d:	01 c2                	add    %eax,%edx
c002471f:	89 d1                	mov    %edx,%ecx
c0024721:	c1 e1 08             	shl    $0x8,%ecx
c0024724:	01 ca                	add    %ecx,%edx
c0024726:	8d 04 90             	lea    (%eax,%edx,4),%eax
c0024729:	c1 e8 16             	shr    $0x16,%eax
c002472c:	a3 c0 e0 03 c0       	mov    %eax,0xc003e0c0
      inited = true; 
c0024731:	c6 05 b8 e0 03 c0 01 	movb   $0x1,0xc003e0b8
c0024738:	e9 77 ff ff ff       	jmp    c00246b4 <vga_putc+0x15>
      fb[y][x][0] = ' ';
c002473d:	a1 bc e0 03 c0       	mov    0xc003e0bc,%eax
c0024742:	8d 88 a0 0f 00 00    	lea    0xfa0(%eax),%ecx
c0024748:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c002474e:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c0024751:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024755:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0024758:	39 d0                	cmp    %edx,%eax
c002475a:	75 f2                	jne    c002474e <vga_putc+0xaf>
c002475c:	89 d0                	mov    %edx,%eax
  for (y = 0; y < ROW_CNT; y++)
c002475e:	39 d1                	cmp    %edx,%ecx
c0024760:	75 e6                	jne    c0024748 <vga_putc+0xa9>
  cx = cy = 0;
c0024762:	c7 05 c0 e0 03 c0 00 	movl   $0x0,0xc003e0c0
c0024769:	00 00 00 
c002476c:	c7 05 c4 e0 03 c0 00 	movl   $0x0,0xc003e0c4
c0024773:	00 00 00 
  move_cursor ();
c0024776:	e8 91 fe ff ff       	call   c002460c <move_cursor>
c002477b:	eb 05                	jmp    c0024782 <vga_putc+0xe3>
      newline ();
c002477d:	e8 ba fe ff ff       	call   c002463c <newline>
  move_cursor ();
c0024782:	e8 85 fe ff ff       	call   c002460c <move_cursor>
  intr_set_level (old_level);
c0024787:	83 ec 0c             	sub    $0xc,%esp
c002478a:	53                   	push   %ebx
c002478b:	e8 d2 d2 ff ff       	call   c0021a62 <intr_set_level>
}
c0024790:	83 c4 14             	add    $0x14,%esp
c0024793:	5b                   	pop    %ebx
c0024794:	5e                   	pop    %esi
c0024795:	c3                   	ret    
      if (cx > 0)
c0024796:	a1 c4 e0 03 c0       	mov    0xc003e0c4,%eax
c002479b:	85 c0                	test   %eax,%eax
c002479d:	74 e3                	je     c0024782 <vga_putc+0xe3>
        cx--;
c002479f:	48                   	dec    %eax
c00247a0:	a3 c4 e0 03 c0       	mov    %eax,0xc003e0c4
c00247a5:	eb db                	jmp    c0024782 <vga_putc+0xe3>
      cx = 0;
c00247a7:	c7 05 c4 e0 03 c0 00 	movl   $0x0,0xc003e0c4
c00247ae:	00 00 00 
      break;
c00247b1:	eb cf                	jmp    c0024782 <vga_putc+0xe3>
      cx = ROUND_UP (cx + 1, 8);
c00247b3:	a1 c4 e0 03 c0       	mov    0xc003e0c4,%eax
c00247b8:	83 c0 08             	add    $0x8,%eax
c00247bb:	83 e0 f8             	and    $0xfffffff8,%eax
c00247be:	a3 c4 e0 03 c0       	mov    %eax,0xc003e0c4
      if (cx >= COL_CNT)
c00247c3:	83 f8 4f             	cmp    $0x4f,%eax
c00247c6:	76 ba                	jbe    c0024782 <vga_putc+0xe3>
        newline ();
c00247c8:	e8 6f fe ff ff       	call   c002463c <newline>
c00247cd:	eb b3                	jmp    c0024782 <vga_putc+0xe3>
      intr_set_level (old_level);
c00247cf:	83 ec 0c             	sub    $0xc,%esp
c00247d2:	53                   	push   %ebx
c00247d3:	e8 8a d2 ff ff       	call   c0021a62 <intr_set_level>
      speaker_beep ();
c00247d8:	e8 b8 1d 00 00       	call   c0026595 <speaker_beep>
      intr_disable ();
c00247dd:	e8 79 d2 ff ff       	call   c0021a5b <intr_disable>
      break;
c00247e2:	83 c4 10             	add    $0x10,%esp
c00247e5:	eb 9b                	jmp    c0024782 <vga_putc+0xe3>
      fb[cy][cx][0] = c;
c00247e7:	8b 35 bc e0 03 c0    	mov    0xc003e0bc,%esi
c00247ed:	a1 c0 e0 03 c0       	mov    0xc003e0c0,%eax
c00247f2:	8d 04 80             	lea    (%eax,%eax,4),%eax
c00247f5:	c1 e0 05             	shl    $0x5,%eax
c00247f8:	01 f0                	add    %esi,%eax
c00247fa:	8b 0d c4 e0 03 c0    	mov    0xc003e0c4,%ecx
c0024800:	8a 54 24 10          	mov    0x10(%esp),%dl
c0024804:	88 14 48             	mov    %dl,(%eax,%ecx,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024807:	a1 c0 e0 03 c0       	mov    0xc003e0c0,%eax
c002480c:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002480f:	c1 e0 05             	shl    $0x5,%eax
c0024812:	8d 14 06             	lea    (%esi,%eax,1),%edx
c0024815:	a1 c4 e0 03 c0       	mov    0xc003e0c4,%eax
c002481a:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c002481f:	a1 c4 e0 03 c0       	mov    0xc003e0c4,%eax
c0024824:	40                   	inc    %eax
c0024825:	a3 c4 e0 03 c0       	mov    %eax,0xc003e0c4
c002482a:	83 f8 4f             	cmp    $0x4f,%eax
c002482d:	0f 86 4f ff ff ff    	jbe    c0024782 <vga_putc+0xe3>
        newline ();
c0024833:	e8 04 fe ff ff       	call   c002463c <newline>
c0024838:	e9 45 ff ff ff       	jmp    c0024782 <vga_putc+0xe3>

c002483d <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c002483d:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (mode == UNINIT);
c0024840:	83 3d 64 e1 03 c0 00 	cmpl   $0x0,0xc003e164
c0024847:	75 51                	jne    c002489a <init_poll+0x5d>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024849:	ba f9 03 00 00       	mov    $0x3f9,%edx
c002484e:	b0 00                	mov    $0x0,%al
c0024850:	ee                   	out    %al,(%dx)
c0024851:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024856:	ee                   	out    %al,(%dx)
c0024857:	ba fb 03 00 00       	mov    $0x3fb,%edx
c002485c:	b0 83                	mov    $0x83,%al
c002485e:	ee                   	out    %al,(%dx)
c002485f:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024864:	b0 0c                	mov    $0xc,%al
c0024866:	ee                   	out    %al,(%dx)
c0024867:	ba f9 03 00 00       	mov    $0x3f9,%edx
c002486c:	b0 00                	mov    $0x0,%al
c002486e:	ee                   	out    %al,(%dx)
c002486f:	ba fb 03 00 00       	mov    $0x3fb,%edx
c0024874:	b0 03                	mov    $0x3,%al
c0024876:	ee                   	out    %al,(%dx)
c0024877:	ba fc 03 00 00       	mov    $0x3fc,%edx
c002487c:	b0 08                	mov    $0x8,%al
c002487e:	ee                   	out    %al,(%dx)
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
  outb (FCR_REG, 0);                    /* Disable FIFO. */
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
  intq_init (&txq);
c002487f:	83 ec 0c             	sub    $0xc,%esp
c0024882:	68 e0 e0 03 c0       	push   $0xc003e0e0
c0024887:	e8 6b 16 00 00       	call   c0025ef7 <intq_init>
  mode = POLL;
c002488c:	c7 05 64 e1 03 c0 01 	movl   $0x1,0xc003e164
c0024893:	00 00 00 
} 
c0024896:	83 c4 1c             	add    $0x1c,%esp
c0024899:	c3                   	ret    
  ASSERT (mode == UNINIT);
c002489a:	83 ec 0c             	sub    $0xc,%esp
c002489d:	68 4f 1c 03 c0       	push   $0xc0031c4f
c00248a2:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00248a7:	68 f4 f9 02 c0       	push   $0xc002f9f4
c00248ac:	6a 45                	push   $0x45
c00248ae:	68 5e 1c 03 c0       	push   $0xc0031c5e
c00248b3:	e8 c5 3d 00 00       	call   c002867d <debug_panic>

c00248b8 <write_ier>:
}

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c00248b8:	53                   	push   %ebx
c00248b9:	83 ec 08             	sub    $0x8,%esp
  uint8_t ier = 0;

  ASSERT (intr_get_level () == INTR_OFF);
c00248bc:	e8 5d d1 ff ff       	call   c0021a1e <intr_get_level>
c00248c1:	85 c0                	test   %eax,%eax
c00248c3:	75 30                	jne    c00248f5 <write_ier+0x3d>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c00248c5:	83 ec 0c             	sub    $0xc,%esp
c00248c8:	68 e0 e0 03 c0       	push   $0xc003e0e0
c00248cd:	e8 57 16 00 00       	call   c0025f29 <intq_empty>
c00248d2:	83 c4 10             	add    $0x10,%esp
c00248d5:	84 c0                	test   %al,%al
    ier |= IER_XMIT;
c00248d7:	0f 94 c3             	sete   %bl
c00248da:	d1 e3                	shl    %ebx

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c00248dc:	e8 4f 15 00 00       	call   c0025e30 <input_full>
c00248e1:	84 c0                	test   %al,%al
c00248e3:	75 03                	jne    c00248e8 <write_ier+0x30>
    ier |= IER_RECV;
c00248e5:	83 cb 01             	or     $0x1,%ebx
c00248e8:	ba f9 03 00 00       	mov    $0x3f9,%edx
c00248ed:	88 d8                	mov    %bl,%al
c00248ef:	ee                   	out    %al,(%dx)
  
  outb (IER_REG, ier);
}
c00248f0:	83 c4 08             	add    $0x8,%esp
c00248f3:	5b                   	pop    %ebx
c00248f4:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00248f5:	83 ec 0c             	sub    $0xc,%esp
c00248f8:	68 f6 12 03 c0       	push   $0xc00312f6
c00248fd:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0024902:	68 e8 f9 02 c0       	push   $0xc002f9e8
c0024907:	68 b5 00 00 00       	push   $0xb5
c002490c:	68 5e 1c 03 c0       	push   $0xc0031c5e
c0024911:	e8 67 3d 00 00       	call   c002867d <debug_panic>

c0024916 <serial_interrupt>:
}

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0024916:	56                   	push   %esi
c0024917:	53                   	push   %ebx
c0024918:	83 ec 04             	sub    $0x4,%esp
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002491b:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024920:	ec                   	in     (%dx),%al
c0024921:	bb fd 03 00 00       	mov    $0x3fd,%ebx
c0024926:	be f8 03 00 00       	mov    $0x3f8,%esi
c002492b:	eb 12                	jmp    c002493f <serial_interrupt+0x29>
c002492d:	89 f2                	mov    %esi,%edx
c002492f:	ec                   	in     (%dx),%al
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));
c0024930:	83 ec 0c             	sub    $0xc,%esp
c0024933:	0f b6 c0             	movzbl %al,%eax
c0024936:	50                   	push   %eax
c0024937:	e8 48 14 00 00       	call   c0025d84 <input_putc>
c002493c:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c002493f:	e8 ec 14 00 00       	call   c0025e30 <input_full>
c0024944:	84 c0                	test   %al,%al
c0024946:	75 07                	jne    c002494f <serial_interrupt+0x39>
c0024948:	89 da                	mov    %ebx,%edx
c002494a:	ec                   	in     (%dx),%al
c002494b:	a8 01                	test   $0x1,%al
c002494d:	75 de                	jne    c002492d <serial_interrupt+0x17>
c002494f:	bb fd 03 00 00       	mov    $0x3fd,%ebx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024954:	be f8 03 00 00       	mov    $0x3f8,%esi
c0024959:	eb 13                	jmp    c002496e <serial_interrupt+0x58>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
    outb (THR_REG, intq_getc (&txq));
c002495b:	83 ec 0c             	sub    $0xc,%esp
c002495e:	68 e0 e0 03 c0       	push   $0xc003e0e0
c0024963:	e8 a3 17 00 00       	call   c002610b <intq_getc>
c0024968:	89 f2                	mov    %esi,%edx
c002496a:	ee                   	out    %al,(%dx)
c002496b:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c002496e:	83 ec 0c             	sub    $0xc,%esp
c0024971:	68 e0 e0 03 c0       	push   $0xc003e0e0
c0024976:	e8 ae 15 00 00       	call   c0025f29 <intq_empty>
c002497b:	83 c4 10             	add    $0x10,%esp
c002497e:	84 c0                	test   %al,%al
c0024980:	75 07                	jne    c0024989 <serial_interrupt+0x73>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024982:	89 da                	mov    %ebx,%edx
c0024984:	ec                   	in     (%dx),%al
c0024985:	a8 20                	test   $0x20,%al
c0024987:	75 d2                	jne    c002495b <serial_interrupt+0x45>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024989:	e8 2a ff ff ff       	call   c00248b8 <write_ier>
}
c002498e:	83 c4 04             	add    $0x4,%esp
c0024991:	5b                   	pop    %ebx
c0024992:	5e                   	pop    %esi
c0024993:	c3                   	ret    

c0024994 <putc_poll>:
{
c0024994:	53                   	push   %ebx
c0024995:	83 ec 08             	sub    $0x8,%esp
c0024998:	89 c3                	mov    %eax,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c002499a:	e8 7f d0 ff ff       	call   c0021a1e <intr_get_level>
c002499f:	85 c0                	test   %eax,%eax
c00249a1:	75 17                	jne    c00249ba <putc_poll+0x26>
c00249a3:	ba fd 03 00 00       	mov    $0x3fd,%edx
c00249a8:	ec                   	in     (%dx),%al
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c00249a9:	a8 20                	test   $0x20,%al
c00249ab:	74 fb                	je     c00249a8 <putc_poll+0x14>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00249ad:	ba f8 03 00 00       	mov    $0x3f8,%edx
c00249b2:	88 d8                	mov    %bl,%al
c00249b4:	ee                   	out    %al,(%dx)
}
c00249b5:	83 c4 08             	add    $0x8,%esp
c00249b8:	5b                   	pop    %ebx
c00249b9:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00249ba:	83 ec 0c             	sub    $0xc,%esp
c00249bd:	68 f6 12 03 c0       	push   $0xc00312f6
c00249c2:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00249c7:	68 dc f9 02 c0       	push   $0xc002f9dc
c00249cc:	68 c9 00 00 00       	push   $0xc9
c00249d1:	68 5e 1c 03 c0       	push   $0xc0031c5e
c00249d6:	e8 a2 3c 00 00       	call   c002867d <debug_panic>

c00249db <serial_init_queue>:
{
c00249db:	53                   	push   %ebx
c00249dc:	83 ec 08             	sub    $0x8,%esp
  if (mode == UNINIT)
c00249df:	83 3d 64 e1 03 c0 00 	cmpl   $0x0,0xc003e164
c00249e6:	74 40                	je     c0024a28 <serial_init_queue+0x4d>
  ASSERT (mode == POLL);
c00249e8:	83 3d 64 e1 03 c0 01 	cmpl   $0x1,0xc003e164
c00249ef:	75 3e                	jne    c0024a2f <serial_init_queue+0x54>
  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c00249f1:	83 ec 04             	sub    $0x4,%esp
c00249f4:	68 82 1c 03 c0       	push   $0xc0031c82
c00249f9:	68 16 49 02 c0       	push   $0xc0024916
c00249fe:	6a 24                	push   $0x24
c0024a00:	e8 d7 d1 ff ff       	call   c0021bdc <intr_register_ext>
  mode = QUEUE;
c0024a05:	c7 05 64 e1 03 c0 02 	movl   $0x2,0xc003e164
c0024a0c:	00 00 00 
  old_level = intr_disable ();
c0024a0f:	e8 47 d0 ff ff       	call   c0021a5b <intr_disable>
c0024a14:	89 c3                	mov    %eax,%ebx
  write_ier ();
c0024a16:	e8 9d fe ff ff       	call   c00248b8 <write_ier>
  intr_set_level (old_level);
c0024a1b:	89 1c 24             	mov    %ebx,(%esp)
c0024a1e:	e8 3f d0 ff ff       	call   c0021a62 <intr_set_level>
}
c0024a23:	83 c4 18             	add    $0x18,%esp
c0024a26:	5b                   	pop    %ebx
c0024a27:	c3                   	ret    
    init_poll ();
c0024a28:	e8 10 fe ff ff       	call   c002483d <init_poll>
c0024a2d:	eb b9                	jmp    c00249e8 <serial_init_queue+0xd>
  ASSERT (mode == POLL);
c0024a2f:	83 ec 0c             	sub    $0xc,%esp
c0024a32:	68 75 1c 03 c0       	push   $0xc0031c75
c0024a37:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0024a3c:	68 00 fa 02 c0       	push   $0xc002fa00
c0024a41:	6a 58                	push   $0x58
c0024a43:	68 5e 1c 03 c0       	push   $0xc0031c5e
c0024a48:	e8 30 3c 00 00       	call   c002867d <debug_panic>

c0024a4d <serial_putc>:
{
c0024a4d:	56                   	push   %esi
c0024a4e:	53                   	push   %ebx
c0024a4f:	83 ec 04             	sub    $0x4,%esp
c0024a52:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level = intr_disable ();
c0024a56:	e8 00 d0 ff ff       	call   c0021a5b <intr_disable>
c0024a5b:	89 c6                	mov    %eax,%esi
  if (mode != QUEUE)
c0024a5d:	a1 64 e1 03 c0       	mov    0xc003e164,%eax
c0024a62:	83 f8 02             	cmp    $0x2,%eax
c0024a65:	74 22                	je     c0024a89 <serial_putc+0x3c>
      if (mode == UNINIT)
c0024a67:	85 c0                	test   %eax,%eax
c0024a69:	74 17                	je     c0024a82 <serial_putc+0x35>
      putc_poll (byte); 
c0024a6b:	0f b6 c3             	movzbl %bl,%eax
c0024a6e:	e8 21 ff ff ff       	call   c0024994 <putc_poll>
  intr_set_level (old_level);
c0024a73:	83 ec 0c             	sub    $0xc,%esp
c0024a76:	56                   	push   %esi
c0024a77:	e8 e6 cf ff ff       	call   c0021a62 <intr_set_level>
}
c0024a7c:	83 c4 14             	add    $0x14,%esp
c0024a7f:	5b                   	pop    %ebx
c0024a80:	5e                   	pop    %esi
c0024a81:	c3                   	ret    
        init_poll ();
c0024a82:	e8 b6 fd ff ff       	call   c002483d <init_poll>
c0024a87:	eb e2                	jmp    c0024a6b <serial_putc+0x1e>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024a89:	85 f6                	test   %esi,%esi
c0024a8b:	74 1b                	je     c0024aa8 <serial_putc+0x5b>
      intq_putc (&txq, byte); 
c0024a8d:	83 ec 08             	sub    $0x8,%esp
c0024a90:	0f b6 db             	movzbl %bl,%ebx
c0024a93:	53                   	push   %ebx
c0024a94:	68 e0 e0 03 c0       	push   $0xc003e0e0
c0024a99:	e8 28 17 00 00       	call   c00261c6 <intq_putc>
      write_ier ();
c0024a9e:	e8 15 fe ff ff       	call   c00248b8 <write_ier>
c0024aa3:	83 c4 10             	add    $0x10,%esp
c0024aa6:	eb cb                	jmp    c0024a73 <serial_putc+0x26>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024aa8:	83 ec 0c             	sub    $0xc,%esp
c0024aab:	68 e0 e0 03 c0       	push   $0xc003e0e0
c0024ab0:	e8 b4 14 00 00       	call   c0025f69 <intq_full>
c0024ab5:	83 c4 10             	add    $0x10,%esp
c0024ab8:	84 c0                	test   %al,%al
c0024aba:	74 d1                	je     c0024a8d <serial_putc+0x40>
          putc_poll (intq_getc (&txq)); 
c0024abc:	83 ec 0c             	sub    $0xc,%esp
c0024abf:	68 e0 e0 03 c0       	push   $0xc003e0e0
c0024ac4:	e8 42 16 00 00       	call   c002610b <intq_getc>
c0024ac9:	0f b6 c0             	movzbl %al,%eax
c0024acc:	e8 c3 fe ff ff       	call   c0024994 <putc_poll>
c0024ad1:	83 c4 10             	add    $0x10,%esp
c0024ad4:	eb b7                	jmp    c0024a8d <serial_putc+0x40>

c0024ad6 <serial_flush>:
{
c0024ad6:	53                   	push   %ebx
c0024ad7:	83 ec 08             	sub    $0x8,%esp
  enum intr_level old_level = intr_disable ();
c0024ada:	e8 7c cf ff ff       	call   c0021a5b <intr_disable>
c0024adf:	89 c3                	mov    %eax,%ebx
  while (!intq_empty (&txq))
c0024ae1:	eb 18                	jmp    c0024afb <serial_flush+0x25>
    putc_poll (intq_getc (&txq));
c0024ae3:	83 ec 0c             	sub    $0xc,%esp
c0024ae6:	68 e0 e0 03 c0       	push   $0xc003e0e0
c0024aeb:	e8 1b 16 00 00       	call   c002610b <intq_getc>
c0024af0:	0f b6 c0             	movzbl %al,%eax
c0024af3:	e8 9c fe ff ff       	call   c0024994 <putc_poll>
c0024af8:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c0024afb:	83 ec 0c             	sub    $0xc,%esp
c0024afe:	68 e0 e0 03 c0       	push   $0xc003e0e0
c0024b03:	e8 21 14 00 00       	call   c0025f29 <intq_empty>
c0024b08:	83 c4 10             	add    $0x10,%esp
c0024b0b:	84 c0                	test   %al,%al
c0024b0d:	74 d4                	je     c0024ae3 <serial_flush+0xd>
  intr_set_level (old_level);
c0024b0f:	83 ec 0c             	sub    $0xc,%esp
c0024b12:	53                   	push   %ebx
c0024b13:	e8 4a cf ff ff       	call   c0021a62 <intr_set_level>
}
c0024b18:	83 c4 18             	add    $0x18,%esp
c0024b1b:	5b                   	pop    %ebx
c0024b1c:	c3                   	ret    

c0024b1d <serial_notify>:
{
c0024b1d:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0024b20:	e8 f9 ce ff ff       	call   c0021a1e <intr_get_level>
c0024b25:	85 c0                	test   %eax,%eax
c0024b27:	75 0d                	jne    c0024b36 <serial_notify+0x19>
  if (mode == QUEUE)
c0024b29:	83 3d 64 e1 03 c0 02 	cmpl   $0x2,0xc003e164
c0024b30:	74 25                	je     c0024b57 <serial_notify+0x3a>
}
c0024b32:	83 c4 0c             	add    $0xc,%esp
c0024b35:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024b36:	83 ec 0c             	sub    $0xc,%esp
c0024b39:	68 f6 12 03 c0       	push   $0xc00312f6
c0024b3e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0024b43:	68 cc f9 02 c0       	push   $0xc002f9cc
c0024b48:	68 96 00 00 00       	push   $0x96
c0024b4d:	68 5e 1c 03 c0       	push   $0xc0031c5e
c0024b52:	e8 26 3b 00 00       	call   c002867d <debug_panic>
    write_ier ();
c0024b57:	e8 5c fd ff ff       	call   c00248b8 <write_ier>
}
c0024b5c:	eb d4                	jmp    c0024b32 <serial_notify+0x15>

c0024b5e <check_sector>:
/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
  if (sector >= block->size)
c0024b5e:	8b 48 1c             	mov    0x1c(%eax),%ecx
c0024b61:	39 d1                	cmp    %edx,%ecx
c0024b63:	76 01                	jbe    c0024b66 <check_sector+0x8>
c0024b65:	c3                   	ret    
{
c0024b66:	83 ec 10             	sub    $0x10,%esp
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024b69:	51                   	push   %ecx
c0024b6a:	52                   	push   %edx

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
  return block->name;
c0024b6b:	83 c0 08             	add    $0x8,%eax
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024b6e:	50                   	push   %eax
c0024b6f:	68 8c 1c 03 c0       	push   $0xc0031c8c
c0024b74:	68 30 fa 02 c0       	push   $0xc002fa30
c0024b79:	6a 70                	push   $0x70
c0024b7b:	68 1a 1d 03 c0       	push   $0xc0031d1a
c0024b80:	e8 f8 3a 00 00       	call   c002867d <debug_panic>

c0024b85 <block_type_name>:
{
c0024b85:	83 ec 0c             	sub    $0xc,%esp
c0024b88:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (type < BLOCK_CNT);
c0024b8c:	83 f8 05             	cmp    $0x5,%eax
c0024b8f:	77 0b                	ja     c0024b9c <block_type_name+0x17>
  return block_type_names[type];
c0024b91:	8b 04 85 60 fa 02 c0 	mov    -0x3ffd05a0(,%eax,4),%eax
}
c0024b98:	83 c4 0c             	add    $0xc,%esp
c0024b9b:	c3                   	ret    
  ASSERT (type < BLOCK_CNT);
c0024b9c:	83 ec 0c             	sub    $0xc,%esp
c0024b9f:	68 30 1d 03 c0       	push   $0xc0031d30
c0024ba4:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0024ba9:	68 78 fa 02 c0       	push   $0xc002fa78
c0024bae:	6a 2f                	push   $0x2f
c0024bb0:	68 1a 1d 03 c0       	push   $0xc0031d1a
c0024bb5:	e8 c3 3a 00 00       	call   c002867d <debug_panic>

c0024bba <block_get_role>:
{
c0024bba:	83 ec 0c             	sub    $0xc,%esp
c0024bbd:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0024bc1:	83 f8 03             	cmp    $0x3,%eax
c0024bc4:	77 0b                	ja     c0024bd1 <block_get_role+0x17>
  return block_by_role[role];
c0024bc6:	8b 04 85 68 e1 03 c0 	mov    -0x3ffc1e98(,%eax,4),%eax
}
c0024bcd:	83 c4 0c             	add    $0xc,%esp
c0024bd0:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c0024bd1:	83 ec 0c             	sub    $0xc,%esp
c0024bd4:	68 41 1d 03 c0       	push   $0xc0031d41
c0024bd9:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0024bde:	68 50 fa 02 c0       	push   $0xc002fa50
c0024be3:	6a 38                	push   $0x38
c0024be5:	68 1a 1d 03 c0       	push   $0xc0031d1a
c0024bea:	e8 8e 3a 00 00       	call   c002867d <debug_panic>

c0024bef <block_set_role>:
{
c0024bef:	83 ec 0c             	sub    $0xc,%esp
c0024bf2:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0024bf6:	83 f8 03             	cmp    $0x3,%eax
c0024bf9:	77 0f                	ja     c0024c0a <block_set_role+0x1b>
  block_by_role[role] = block;
c0024bfb:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024bff:	89 14 85 68 e1 03 c0 	mov    %edx,-0x3ffc1e98(,%eax,4)
}
c0024c06:	83 c4 0c             	add    $0xc,%esp
c0024c09:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c0024c0a:	83 ec 0c             	sub    $0xc,%esp
c0024c0d:	68 41 1d 03 c0       	push   $0xc0031d41
c0024c12:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0024c17:	68 40 fa 02 c0       	push   $0xc002fa40
c0024c1c:	6a 40                	push   $0x40
c0024c1e:	68 1a 1d 03 c0       	push   $0xc0031d1a
c0024c23:	e8 55 3a 00 00       	call   c002867d <debug_panic>

c0024c28 <block_first>:
{
c0024c28:	53                   	push   %ebx
c0024c29:	83 ec 14             	sub    $0x14,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c0024c2c:	68 58 c6 03 c0       	push   $0xc003c658
c0024c31:	e8 31 3b 00 00       	call   c0028767 <list_begin>
c0024c36:	89 c3                	mov    %eax,%ebx
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c0024c38:	c7 04 24 58 c6 03 c0 	movl   $0xc003c658,(%esp)
c0024c3f:	e8 9b 3b 00 00       	call   c00287df <list_end>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0024c44:	83 c4 10             	add    $0x10,%esp
c0024c47:	39 c3                	cmp    %eax,%ebx
c0024c49:	74 07                	je     c0024c52 <block_first+0x2a>
c0024c4b:	89 d8                	mov    %ebx,%eax
}
c0024c4d:	83 c4 08             	add    $0x8,%esp
c0024c50:	5b                   	pop    %ebx
c0024c51:	c3                   	ret    
          : NULL);
c0024c52:	b8 00 00 00 00       	mov    $0x0,%eax
  return list_elem_to_block (list_begin (&all_blocks));
c0024c57:	eb f4                	jmp    c0024c4d <block_first+0x25>

c0024c59 <block_next>:
{
c0024c59:	53                   	push   %ebx
c0024c5a:	83 ec 14             	sub    $0x14,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0024c5d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024c61:	e8 31 3b 00 00       	call   c0028797 <list_next>
c0024c66:	89 c3                	mov    %eax,%ebx
  return (list_elem != list_end (&all_blocks)
c0024c68:	c7 04 24 58 c6 03 c0 	movl   $0xc003c658,(%esp)
c0024c6f:	e8 6b 3b 00 00       	call   c00287df <list_end>
          : NULL);
c0024c74:	83 c4 10             	add    $0x10,%esp
c0024c77:	39 c3                	cmp    %eax,%ebx
c0024c79:	74 07                	je     c0024c82 <block_next+0x29>
c0024c7b:	89 d8                	mov    %ebx,%eax
}
c0024c7d:	83 c4 08             	add    $0x8,%esp
c0024c80:	5b                   	pop    %ebx
c0024c81:	c3                   	ret    
          : NULL);
c0024c82:	b8 00 00 00 00       	mov    $0x0,%eax
  return list_elem_to_block (list_next (&block->list_elem));
c0024c87:	eb f4                	jmp    c0024c7d <block_next+0x24>

c0024c89 <block_get_by_name>:
{
c0024c89:	56                   	push   %esi
c0024c8a:	53                   	push   %ebx
c0024c8b:	83 ec 10             	sub    $0x10,%esp
c0024c8e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024c92:	68 58 c6 03 c0       	push   $0xc003c658
c0024c97:	e8 cb 3a 00 00       	call   c0028767 <list_begin>
c0024c9c:	89 c3                	mov    %eax,%ebx
c0024c9e:	83 c4 10             	add    $0x10,%esp
c0024ca1:	83 ec 0c             	sub    $0xc,%esp
c0024ca4:	68 58 c6 03 c0       	push   $0xc003c658
c0024ca9:	e8 31 3b 00 00       	call   c00287df <list_end>
c0024cae:	83 c4 10             	add    $0x10,%esp
c0024cb1:	39 c3                	cmp    %eax,%ebx
c0024cb3:	74 24                	je     c0024cd9 <block_get_by_name+0x50>
      if (!strcmp (name, block->name))
c0024cb5:	8d 43 08             	lea    0x8(%ebx),%eax
c0024cb8:	83 ec 08             	sub    $0x8,%esp
c0024cbb:	50                   	push   %eax
c0024cbc:	56                   	push   %esi
c0024cbd:	e8 70 2d 00 00       	call   c0027a32 <strcmp>
c0024cc2:	83 c4 10             	add    $0x10,%esp
c0024cc5:	85 c0                	test   %eax,%eax
c0024cc7:	74 1b                	je     c0024ce4 <block_get_by_name+0x5b>
       e = list_next (e))
c0024cc9:	83 ec 0c             	sub    $0xc,%esp
c0024ccc:	53                   	push   %ebx
c0024ccd:	e8 c5 3a 00 00       	call   c0028797 <list_next>
c0024cd2:	89 c3                	mov    %eax,%ebx
c0024cd4:	83 c4 10             	add    $0x10,%esp
c0024cd7:	eb c8                	jmp    c0024ca1 <block_get_by_name+0x18>
  return NULL;
c0024cd9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024cde:	83 c4 04             	add    $0x4,%esp
c0024ce1:	5b                   	pop    %ebx
c0024ce2:	5e                   	pop    %esi
c0024ce3:	c3                   	ret    
c0024ce4:	89 d8                	mov    %ebx,%eax
c0024ce6:	eb f6                	jmp    c0024cde <block_get_by_name+0x55>

c0024ce8 <block_read>:
{
c0024ce8:	56                   	push   %esi
c0024ce9:	53                   	push   %ebx
c0024cea:	83 ec 04             	sub    $0x4,%esp
c0024ced:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0024cf1:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c0024cf5:	89 f2                	mov    %esi,%edx
c0024cf7:	89 d8                	mov    %ebx,%eax
c0024cf9:	e8 60 fe ff ff       	call   c0024b5e <check_sector>
  block->ops->read (block->aux, sector, buffer);
c0024cfe:	83 ec 04             	sub    $0x4,%esp
c0024d01:	8b 43 20             	mov    0x20(%ebx),%eax
c0024d04:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024d08:	56                   	push   %esi
c0024d09:	ff 73 24             	pushl  0x24(%ebx)
c0024d0c:	ff 10                	call   *(%eax)
  block->read_cnt++;
c0024d0e:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c0024d12:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c0024d16:	83 c4 14             	add    $0x14,%esp
c0024d19:	5b                   	pop    %ebx
c0024d1a:	5e                   	pop    %esi
c0024d1b:	c3                   	ret    

c0024d1c <block_write>:
{
c0024d1c:	56                   	push   %esi
c0024d1d:	53                   	push   %ebx
c0024d1e:	83 ec 04             	sub    $0x4,%esp
c0024d21:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0024d25:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c0024d29:	89 f2                	mov    %esi,%edx
c0024d2b:	89 d8                	mov    %ebx,%eax
c0024d2d:	e8 2c fe ff ff       	call   c0024b5e <check_sector>
  ASSERT (block->type != BLOCK_FOREIGN);
c0024d32:	83 7b 18 05          	cmpl   $0x5,0x18(%ebx)
c0024d36:	74 1f                	je     c0024d57 <block_write+0x3b>
  block->ops->write (block->aux, sector, buffer);
c0024d38:	83 ec 04             	sub    $0x4,%esp
c0024d3b:	8b 43 20             	mov    0x20(%ebx),%eax
c0024d3e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024d42:	56                   	push   %esi
c0024d43:	ff 73 24             	pushl  0x24(%ebx)
c0024d46:	ff 50 04             	call   *0x4(%eax)
  block->write_cnt++;
c0024d49:	83 43 30 01          	addl   $0x1,0x30(%ebx)
c0024d4d:	83 53 34 00          	adcl   $0x0,0x34(%ebx)
}
c0024d51:	83 c4 14             	add    $0x14,%esp
c0024d54:	5b                   	pop    %ebx
c0024d55:	5e                   	pop    %esi
c0024d56:	c3                   	ret    
  ASSERT (block->type != BLOCK_FOREIGN);
c0024d57:	83 ec 0c             	sub    $0xc,%esp
c0024d5a:	68 57 1d 03 c0       	push   $0xc0031d57
c0024d5f:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0024d64:	68 24 fa 02 c0       	push   $0xc002fa24
c0024d69:	68 89 00 00 00       	push   $0x89
c0024d6e:	68 1a 1d 03 c0       	push   $0xc0031d1a
c0024d73:	e8 05 39 00 00       	call   c002867d <debug_panic>

c0024d78 <block_size>:
  return block->size;
c0024d78:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024d7c:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0024d7f:	c3                   	ret    

c0024d80 <block_name>:
  return block->name;
c0024d80:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024d84:	83 c0 08             	add    $0x8,%eax
}
c0024d87:	c3                   	ret    

c0024d88 <block_type>:
  return block->type;
c0024d88:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024d8c:	8b 40 18             	mov    0x18(%eax),%eax
}
c0024d8f:	c3                   	ret    

c0024d90 <block_print_stats>:
{
c0024d90:	57                   	push   %edi
c0024d91:	56                   	push   %esi
c0024d92:	53                   	push   %ebx
c0024d93:	be 68 e1 03 c0       	mov    $0xc003e168,%esi
c0024d98:	bf 78 e1 03 c0       	mov    $0xc003e178,%edi
c0024d9d:	eb 07                	jmp    c0024da6 <block_print_stats+0x16>
c0024d9f:	83 c6 04             	add    $0x4,%esi
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0024da2:	39 fe                	cmp    %edi,%esi
c0024da4:	74 34                	je     c0024dda <block_print_stats+0x4a>
      struct block *block = block_by_role[i];
c0024da6:	8b 1e                	mov    (%esi),%ebx
      if (block != NULL)
c0024da8:	85 db                	test   %ebx,%ebx
c0024daa:	74 f3                	je     c0024d9f <block_print_stats+0xf>
          printf ("%s (%s): %llu reads, %llu writes\n",
c0024dac:	83 ec 0c             	sub    $0xc,%esp
c0024daf:	ff 73 18             	pushl  0x18(%ebx)
c0024db2:	e8 ce fd ff ff       	call   c0024b85 <block_type_name>
c0024db7:	83 c4 0c             	add    $0xc,%esp
c0024dba:	ff 73 34             	pushl  0x34(%ebx)
c0024dbd:	ff 73 30             	pushl  0x30(%ebx)
c0024dc0:	ff 73 2c             	pushl  0x2c(%ebx)
c0024dc3:	ff 73 28             	pushl  0x28(%ebx)
c0024dc6:	50                   	push   %eax
c0024dc7:	83 c3 08             	add    $0x8,%ebx
c0024dca:	53                   	push   %ebx
c0024dcb:	68 c0 1c 03 c0       	push   $0xc0031cc0
c0024dd0:	e8 fa 1d 00 00       	call   c0026bcf <printf>
c0024dd5:	83 c4 20             	add    $0x20,%esp
c0024dd8:	eb c5                	jmp    c0024d9f <block_print_stats+0xf>
}
c0024dda:	5b                   	pop    %ebx
c0024ddb:	5e                   	pop    %esi
c0024ddc:	5f                   	pop    %edi
c0024ddd:	c3                   	ret    

c0024dde <block_register>:
{
c0024dde:	55                   	push   %ebp
c0024ddf:	57                   	push   %edi
c0024de0:	56                   	push   %esi
c0024de1:	53                   	push   %ebx
c0024de2:	83 ec 18             	sub    $0x18,%esp
c0024de5:	8b 74 24 34          	mov    0x34(%esp),%esi
c0024de9:	8b 7c 24 38          	mov    0x38(%esp),%edi
  struct block *block = malloc (sizeof *block);
c0024ded:	6a 38                	push   $0x38
c0024def:	e8 30 ec ff ff       	call   c0023a24 <malloc>
  if (block == NULL)
c0024df4:	83 c4 10             	add    $0x10,%esp
c0024df7:	85 c0                	test   %eax,%eax
c0024df9:	0f 84 b6 00 00 00    	je     c0024eb5 <block_register+0xd7>
c0024dff:	89 c3                	mov    %eax,%ebx
  list_push_back (&all_blocks, &block->list_elem);
c0024e01:	83 ec 08             	sub    $0x8,%esp
c0024e04:	50                   	push   %eax
c0024e05:	68 58 c6 03 c0       	push   $0xc003c658
c0024e0a:	e8 61 3d 00 00       	call   c0028b70 <list_push_back>
  strlcpy (block->name, name, sizeof block->name);
c0024e0f:	8d 6b 08             	lea    0x8(%ebx),%ebp
c0024e12:	83 c4 0c             	add    $0xc,%esp
c0024e15:	6a 10                	push   $0x10
c0024e17:	ff 74 24 28          	pushl  0x28(%esp)
c0024e1b:	55                   	push   %ebp
c0024e1c:	e8 56 2f 00 00       	call   c0027d77 <strlcpy>
  block->type = type;
c0024e21:	8b 44 24 34          	mov    0x34(%esp),%eax
c0024e25:	89 43 18             	mov    %eax,0x18(%ebx)
  block->size = size;
c0024e28:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  block->ops = ops;
c0024e2b:	8b 44 24 40          	mov    0x40(%esp),%eax
c0024e2f:	89 43 20             	mov    %eax,0x20(%ebx)
  block->aux = aux;
c0024e32:	8b 44 24 44          	mov    0x44(%esp),%eax
c0024e36:	89 43 24             	mov    %eax,0x24(%ebx)
  block->read_cnt = 0;
c0024e39:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
c0024e40:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  block->write_cnt = 0;
c0024e47:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
c0024e4e:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c0024e55:	83 c4 0c             	add    $0xc,%esp
c0024e58:	57                   	push   %edi
c0024e59:	55                   	push   %ebp
c0024e5a:	68 74 1d 03 c0       	push   $0xc0031d74
c0024e5f:	e8 6b 1d 00 00       	call   c0026bcf <printf>
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c0024e64:	83 c4 08             	add    $0x8,%esp
c0024e67:	8b 43 1c             	mov    0x1c(%ebx),%eax
c0024e6a:	ba 00 00 00 00       	mov    $0x0,%edx
c0024e6f:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c0024e73:	c1 e0 09             	shl    $0x9,%eax
c0024e76:	52                   	push   %edx
c0024e77:	50                   	push   %eax
c0024e78:	e8 f6 26 00 00       	call   c0027573 <print_human_readable_size>
  printf (")");
c0024e7d:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0024e84:	e8 47 53 00 00       	call   c002a1d0 <putchar>
  if (extra_info != NULL)
c0024e89:	83 c4 10             	add    $0x10,%esp
c0024e8c:	85 f6                	test   %esi,%esi
c0024e8e:	74 11                	je     c0024ea1 <block_register+0xc3>
    printf (", %s", extra_info);
c0024e90:	83 ec 08             	sub    $0x8,%esp
c0024e93:	56                   	push   %esi
c0024e94:	68 86 1d 03 c0       	push   $0xc0031d86
c0024e99:	e8 31 1d 00 00       	call   c0026bcf <printf>
c0024e9e:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0024ea1:	83 ec 0c             	sub    $0xc,%esp
c0024ea4:	6a 0a                	push   $0xa
c0024ea6:	e8 25 53 00 00       	call   c002a1d0 <putchar>
}
c0024eab:	89 d8                	mov    %ebx,%eax
c0024ead:	83 c4 1c             	add    $0x1c,%esp
c0024eb0:	5b                   	pop    %ebx
c0024eb1:	5e                   	pop    %esi
c0024eb2:	5f                   	pop    %edi
c0024eb3:	5d                   	pop    %ebp
c0024eb4:	c3                   	ret    
    PANIC ("Failed to allocate memory for block device descriptor");
c0024eb5:	68 e4 1c 03 c0       	push   $0xc0031ce4
c0024eba:	68 14 fa 02 c0       	push   $0xc002fa14
c0024ebf:	68 c1 00 00 00       	push   $0xc1
c0024ec4:	68 1a 1d 03 c0       	push   $0xc0031d1a
c0024ec9:	e8 af 37 00 00       	call   c002867d <debug_panic>

c0024ece <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0024ece:	83 ec 10             	sub    $0x10,%esp
c0024ed1:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_read (p->block, p->start + sector, buffer);
c0024ed5:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024ed9:	8b 42 04             	mov    0x4(%edx),%eax
c0024edc:	03 44 24 1c          	add    0x1c(%esp),%eax
c0024ee0:	50                   	push   %eax
c0024ee1:	ff 32                	pushl  (%edx)
c0024ee3:	e8 00 fe ff ff       	call   c0024ce8 <block_read>
}
c0024ee8:	83 c4 1c             	add    $0x1c,%esp
c0024eeb:	c3                   	ret    

c0024eec <read_partition_table>:
{
c0024eec:	55                   	push   %ebp
c0024eed:	57                   	push   %edi
c0024eee:	56                   	push   %esi
c0024eef:	53                   	push   %ebx
c0024ef0:	81 ec c8 00 00 00    	sub    $0xc8,%esp
c0024ef6:	89 c3                	mov    %eax,%ebx
c0024ef8:	89 d6                	mov    %edx,%esi
c0024efa:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  if (sector >= block_size (block))
c0024efe:	50                   	push   %eax
c0024eff:	e8 74 fe ff ff       	call   c0024d78 <block_size>
c0024f04:	83 c4 10             	add    $0x10,%esp
c0024f07:	39 f0                	cmp    %esi,%eax
c0024f09:	76 6b                	jbe    c0024f76 <read_partition_table+0x8a>
  pt = malloc (sizeof *pt);
c0024f0b:	83 ec 0c             	sub    $0xc,%esp
c0024f0e:	68 00 02 00 00       	push   $0x200
c0024f13:	e8 0c eb ff ff       	call   c0023a24 <malloc>
c0024f18:	89 c7                	mov    %eax,%edi
  if (pt == NULL)
c0024f1a:	83 c4 10             	add    $0x10,%esp
c0024f1d:	85 c0                	test   %eax,%eax
c0024f1f:	74 72                	je     c0024f93 <read_partition_table+0xa7>
  block_read (block, 0, pt);
c0024f21:	83 ec 04             	sub    $0x4,%esp
c0024f24:	50                   	push   %eax
c0024f25:	6a 00                	push   $0x0
c0024f27:	53                   	push   %ebx
c0024f28:	e8 bb fd ff ff       	call   c0024ce8 <block_read>
  if (pt->signature != 0xaa55)
c0024f2d:	83 c4 10             	add    $0x10,%esp
c0024f30:	66 81 bf fe 01 00 00 	cmpw   $0xaa55,0x1fe(%edi)
c0024f37:	55 aa 
c0024f39:	0f 84 87 00 00 00    	je     c0024fc6 <read_partition_table+0xda>
      if (primary_extended_sector == 0)
c0024f3f:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0024f43:	75 64                	jne    c0024fa9 <read_partition_table+0xbd>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c0024f45:	83 ec 0c             	sub    $0xc,%esp
c0024f48:	53                   	push   %ebx
c0024f49:	e8 32 fe ff ff       	call   c0024d80 <block_name>
c0024f4e:	83 c4 08             	add    $0x8,%esp
c0024f51:	50                   	push   %eax
c0024f52:	68 98 22 03 c0       	push   $0xc0032298
c0024f57:	e8 73 1c 00 00       	call   c0026bcf <printf>
c0024f5c:	83 c4 10             	add    $0x10,%esp
      free (pt);
c0024f5f:	83 ec 0c             	sub    $0xc,%esp
c0024f62:	57                   	push   %edi
c0024f63:	e8 5f ec ff ff       	call   c0023bc7 <free>
      return;
c0024f68:	83 c4 10             	add    $0x10,%esp
}
c0024f6b:	81 c4 bc 00 00 00    	add    $0xbc,%esp
c0024f71:	5b                   	pop    %ebx
c0024f72:	5e                   	pop    %esi
c0024f73:	5f                   	pop    %edi
c0024f74:	5d                   	pop    %ebp
c0024f75:	c3                   	ret    
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0024f76:	83 ec 0c             	sub    $0xc,%esp
c0024f79:	53                   	push   %ebx
c0024f7a:	e8 01 fe ff ff       	call   c0024d80 <block_name>
c0024f7f:	83 c4 0c             	add    $0xc,%esp
c0024f82:	56                   	push   %esi
c0024f83:	50                   	push   %eax
c0024f84:	68 30 22 03 c0       	push   $0xc0032230
c0024f89:	e8 41 1c 00 00       	call   c0026bcf <printf>
      return;
c0024f8e:	83 c4 10             	add    $0x10,%esp
c0024f91:	eb d8                	jmp    c0024f6b <read_partition_table+0x7f>
    PANIC ("Failed to allocate memory for partition table.");
c0024f93:	68 68 22 03 c0       	push   $0xc0032268
c0024f98:	68 b0 fe 02 c0       	push   $0xc002feb0
c0024f9d:	6a 5a                	push   $0x5a
c0024f9f:	68 9f 1d 03 c0       	push   $0xc0031d9f
c0024fa4:	e8 d4 36 00 00       	call   c002867d <debug_panic>
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c0024fa9:	83 ec 0c             	sub    $0xc,%esp
c0024fac:	53                   	push   %ebx
c0024fad:	e8 ce fd ff ff       	call   c0024d80 <block_name>
c0024fb2:	83 c4 0c             	add    $0xc,%esp
c0024fb5:	56                   	push   %esi
c0024fb6:	50                   	push   %eax
c0024fb7:	68 c0 22 03 c0       	push   $0xc00322c0
c0024fbc:	e8 0e 1c 00 00       	call   c0026bcf <printf>
c0024fc1:	83 c4 10             	add    $0x10,%esp
c0024fc4:	eb 99                	jmp    c0024f5f <read_partition_table+0x73>
c0024fc6:	8d af c2 01 00 00    	lea    0x1c2(%edi),%ebp
c0024fcc:	8d 87 02 02 00 00    	lea    0x202(%edi),%eax
c0024fd2:	89 44 24 04          	mov    %eax,0x4(%esp)
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0024fd6:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0024fda:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0024fde:	89 74 24 10          	mov    %esi,0x10(%esp)
c0024fe2:	eb 51                	jmp    c0025035 <read_partition_table+0x149>
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0024fe4:	83 ec 0c             	sub    $0xc,%esp
c0024fe7:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0024feb:	53                   	push   %ebx
c0024fec:	e8 8f fd ff ff       	call   c0024d80 <block_name>
c0024ff1:	83 c4 0c             	add    $0xc,%esp
c0024ff4:	8b 74 24 14          	mov    0x14(%esp),%esi
c0024ff8:	56                   	push   %esi
c0024ff9:	50                   	push   %eax
c0024ffa:	68 f4 22 03 c0       	push   $0xc00322f4
c0024fff:	e8 cb 1b 00 00       	call   c0026bcf <printf>
          if (sector == 0)
c0025004:	83 c4 10             	add    $0x10,%esp
c0025007:	85 f6                	test   %esi,%esi
c0025009:	0f 85 33 01 00 00    	jne    c0025142 <read_partition_table+0x256>
            read_partition_table (block, e->offset, e->offset, part_nr);
c002500f:	8b 57 04             	mov    0x4(%edi),%edx
c0025012:	83 ec 0c             	sub    $0xc,%esp
c0025015:	ff b4 24 dc 00 00 00 	pushl  0xdc(%esp)
c002501c:	89 d1                	mov    %edx,%ecx
c002501e:	89 d8                	mov    %ebx,%eax
c0025020:	e8 c7 fe ff ff       	call   c0024eec <read_partition_table>
c0025025:	83 c4 10             	add    $0x10,%esp
c0025028:	83 c5 10             	add    $0x10,%ebp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c002502b:	3b 6c 24 04          	cmp    0x4(%esp),%ebp
c002502f:	0f 84 b1 01 00 00    	je     c00251e6 <read_partition_table+0x2fa>
c0025035:	89 ef                	mov    %ebp,%edi
      if (e->size == 0 || e->type == 0)
c0025037:	8b 75 08             	mov    0x8(%ebp),%esi
c002503a:	85 f6                	test   %esi,%esi
c002503c:	74 ea                	je     c0025028 <read_partition_table+0x13c>
c002503e:	8a 5d 00             	mov    0x0(%ebp),%bl
c0025041:	84 db                	test   %bl,%bl
c0025043:	74 e3                	je     c0025028 <read_partition_table+0x13c>
      else if (e->type == 0x05       /* Extended partition. */
c0025045:	88 d8                	mov    %bl,%al
c0025047:	83 e0 7f             	and    $0x7f,%eax
c002504a:	3c 05                	cmp    $0x5,%al
c002504c:	74 96                	je     c0024fe4 <read_partition_table+0xf8>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c002504e:	80 fb 0f             	cmp    $0xf,%bl
c0025051:	74 91                	je     c0024fe4 <read_partition_table+0xf8>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025053:	80 fb c5             	cmp    $0xc5,%bl
c0025056:	74 8c                	je     c0024fe4 <read_partition_table+0xf8>
          ++*part_nr;
c0025058:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
c002505f:	8b 00                	mov    (%eax),%eax
c0025061:	40                   	inc    %eax
c0025062:	89 44 24 18          	mov    %eax,0x18(%esp)
c0025066:	8b 94 24 d0 00 00 00 	mov    0xd0(%esp),%edx
c002506d:	89 02                	mov    %eax,(%edx)
          found_partition (block, e->type, e->offset + sector,
c002506f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025073:	03 45 04             	add    0x4(%ebp),%eax
c0025076:	89 c7                	mov    %eax,%edi
c0025078:	89 44 24 14          	mov    %eax,0x14(%esp)
  if (start >= block_size (block))
c002507c:	83 ec 0c             	sub    $0xc,%esp
c002507f:	ff 74 24 14          	pushl  0x14(%esp)
c0025083:	e8 f0 fc ff ff       	call   c0024d78 <block_size>
c0025088:	83 c4 10             	add    $0x10,%esp
c002508b:	39 c7                	cmp    %eax,%edi
c002508d:	0f 83 d2 00 00 00    	jae    c0025165 <read_partition_table+0x279>
  else if (start + size < start || start + size > block_size (block))
c0025093:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0025097:	01 f7                	add    %esi,%edi
c0025099:	0f 82 ed 00 00 00    	jb     c002518c <read_partition_table+0x2a0>
c002509f:	83 ec 0c             	sub    $0xc,%esp
c00250a2:	ff 74 24 14          	pushl  0x14(%esp)
c00250a6:	e8 cd fc ff ff       	call   c0024d78 <block_size>
c00250ab:	83 c4 10             	add    $0x10,%esp
c00250ae:	39 c7                	cmp    %eax,%edi
c00250b0:	0f 87 d6 00 00 00    	ja     c002518c <read_partition_table+0x2a0>
          found_partition (block, e->type, e->offset + sector,
c00250b6:	0f b6 fb             	movzbl %bl,%edi
                              : part_type == 0x21 ? BLOCK_FILESYS
c00250b9:	80 fb 20             	cmp    $0x20,%bl
c00250bc:	0f 84 39 01 00 00    	je     c00251fb <read_partition_table+0x30f>
c00250c2:	80 fb 21             	cmp    $0x21,%bl
c00250c5:	0f 84 c2 01 00 00    	je     c002528d <read_partition_table+0x3a1>
c00250cb:	80 fb 22             	cmp    $0x22,%bl
c00250ce:	0f 84 c6 01 00 00    	je     c002529a <read_partition_table+0x3ae>
c00250d4:	80 fb 23             	cmp    $0x23,%bl
c00250d7:	0f 84 ca 01 00 00    	je     c00252a7 <read_partition_table+0x3bb>
      p = malloc (sizeof *p);
c00250dd:	83 ec 0c             	sub    $0xc,%esp
c00250e0:	6a 08                	push   $0x8
c00250e2:	e8 3d e9 ff ff       	call   c0023a24 <malloc>
c00250e7:	89 c3                	mov    %eax,%ebx
      if (p == NULL)
c00250e9:	83 c4 10             	add    $0x10,%esp
c00250ec:	85 c0                	test   %eax,%eax
c00250ee:	0f 84 ca 00 00 00    	je     c00251be <read_partition_table+0x2d2>
      p->block = block;
c00250f4:	8b 44 24 08          	mov    0x8(%esp),%eax
c00250f8:	89 03                	mov    %eax,(%ebx)
      p->start = start;
c00250fa:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00250fe:	89 4b 04             	mov    %ecx,0x4(%ebx)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025101:	83 ec 0c             	sub    $0xc,%esp
c0025104:	50                   	push   %eax
c0025105:	e8 76 fc ff ff       	call   c0024d80 <block_name>
c002510a:	83 c4 04             	add    $0x4,%esp
c002510d:	ff 74 24 24          	pushl  0x24(%esp)
c0025111:	50                   	push   %eax
c0025112:	68 b9 1d 03 c0       	push   $0xc0031db9
c0025117:	6a 10                	push   $0x10
c0025119:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c002511d:	50                   	push   %eax
c002511e:	e8 38 22 00 00       	call   c002735b <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025123:	8b 04 bd a0 fa 02 c0 	mov    -0x3ffd0560(,%edi,4),%eax
c002512a:	83 c4 20             	add    $0x20,%esp
c002512d:	85 c0                	test   %eax,%eax
c002512f:	0f 84 a2 00 00 00    	je     c00251d7 <read_partition_table+0x2eb>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025135:	c7 44 24 1c 05 00 00 	movl   $0x5,0x1c(%esp)
c002513c:	00 
c002513d:	e9 0d 01 00 00       	jmp    c002524f <read_partition_table+0x363>
            read_partition_table (block, e->offset + primary_extended_sector,
c0025142:	8b 0c 24             	mov    (%esp),%ecx
c0025145:	89 ca                	mov    %ecx,%edx
c0025147:	03 57 04             	add    0x4(%edi),%edx
c002514a:	83 ec 0c             	sub    $0xc,%esp
c002514d:	ff b4 24 dc 00 00 00 	pushl  0xdc(%esp)
c0025154:	8b 44 24 18          	mov    0x18(%esp),%eax
c0025158:	e8 8f fd ff ff       	call   c0024eec <read_partition_table>
c002515d:	83 c4 10             	add    $0x10,%esp
c0025160:	e9 c3 fe ff ff       	jmp    c0025028 <read_partition_table+0x13c>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025165:	83 ec 0c             	sub    $0xc,%esp
c0025168:	ff 74 24 14          	pushl  0x14(%esp)
c002516c:	e8 0f fc ff ff       	call   c0024d80 <block_name>
c0025171:	ff 74 24 24          	pushl  0x24(%esp)
c0025175:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025179:	50                   	push   %eax
c002517a:	68 1c 23 03 c0       	push   $0xc003231c
c002517f:	e8 4b 1a 00 00       	call   c0026bcf <printf>
c0025184:	83 c4 20             	add    $0x20,%esp
c0025187:	e9 9c fe ff ff       	jmp    c0025028 <read_partition_table+0x13c>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c002518c:	83 ec 0c             	sub    $0xc,%esp
c002518f:	8b 74 24 14          	mov    0x14(%esp),%esi
c0025193:	56                   	push   %esi
c0025194:	e8 df fb ff ff       	call   c0024d78 <block_size>
c0025199:	89 c3                	mov    %eax,%ebx
c002519b:	89 34 24             	mov    %esi,(%esp)
c002519e:	e8 dd fb ff ff       	call   c0024d80 <block_name>
c00251a3:	89 1c 24             	mov    %ebx,(%esp)
c00251a6:	57                   	push   %edi
c00251a7:	ff 74 24 2c          	pushl  0x2c(%esp)
c00251ab:	50                   	push   %eax
c00251ac:	68 54 23 03 c0       	push   $0xc0032354
c00251b1:	e8 19 1a 00 00       	call   c0026bcf <printf>
c00251b6:	83 c4 20             	add    $0x20,%esp
c00251b9:	e9 6a fe ff ff       	jmp    c0025028 <read_partition_table+0x13c>
        PANIC ("Failed to allocate memory for partition descriptor");
c00251be:	68 88 23 03 c0       	push   $0xc0032388
c00251c3:	68 a0 fe 02 c0       	push   $0xc002fea0
c00251c8:	68 b1 00 00 00       	push   $0xb1
c00251cd:	68 9f 1d 03 c0       	push   $0xc0031d9f
c00251d2:	e8 a6 34 00 00       	call   c002867d <debug_panic>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00251d7:	c7 44 24 1c 05 00 00 	movl   $0x5,0x1c(%esp)
c00251de:	00 
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c00251df:	b8 97 1d 03 c0       	mov    $0xc0031d97,%eax
c00251e4:	eb 69                	jmp    c002524f <read_partition_table+0x363>
c00251e6:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  free (pt);
c00251ea:	83 ec 0c             	sub    $0xc,%esp
c00251ed:	57                   	push   %edi
c00251ee:	e8 d4 e9 ff ff       	call   c0023bc7 <free>
c00251f3:	83 c4 10             	add    $0x10,%esp
c00251f6:	e9 70 fd ff ff       	jmp    c0024f6b <read_partition_table+0x7f>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00251fb:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c0025202:	00 
      p = malloc (sizeof *p);
c0025203:	83 ec 0c             	sub    $0xc,%esp
c0025206:	6a 08                	push   $0x8
c0025208:	e8 17 e8 ff ff       	call   c0023a24 <malloc>
c002520d:	89 c3                	mov    %eax,%ebx
      if (p == NULL)
c002520f:	83 c4 10             	add    $0x10,%esp
c0025212:	85 c0                	test   %eax,%eax
c0025214:	74 a8                	je     c00251be <read_partition_table+0x2d2>
      p->block = block;
c0025216:	8b 44 24 08          	mov    0x8(%esp),%eax
c002521a:	89 03                	mov    %eax,(%ebx)
      p->start = start;
c002521c:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0025220:	89 4b 04             	mov    %ecx,0x4(%ebx)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025223:	83 ec 0c             	sub    $0xc,%esp
c0025226:	50                   	push   %eax
c0025227:	e8 54 fb ff ff       	call   c0024d80 <block_name>
c002522c:	83 c4 04             	add    $0x4,%esp
c002522f:	ff 74 24 24          	pushl  0x24(%esp)
c0025233:	50                   	push   %eax
c0025234:	68 b9 1d 03 c0       	push   $0xc0031db9
c0025239:	6a 10                	push   $0x10
c002523b:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c002523f:	50                   	push   %eax
c0025240:	e8 16 21 00 00       	call   c002735b <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025245:	8b 04 bd a0 fa 02 c0 	mov    -0x3ffd0560(,%edi,4),%eax
c002524c:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c002524f:	83 ec 0c             	sub    $0xc,%esp
c0025252:	57                   	push   %edi
c0025253:	50                   	push   %eax
c0025254:	68 be 1d 03 c0       	push   $0xc0031dbe
c0025259:	68 80 00 00 00       	push   $0x80
c002525e:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025262:	50                   	push   %eax
c0025263:	e8 f3 20 00 00       	call   c002735b <snprintf>
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025268:	83 c4 18             	add    $0x18,%esp
c002526b:	53                   	push   %ebx
c002526c:	68 68 c6 03 c0       	push   $0xc003c668
c0025271:	56                   	push   %esi
c0025272:	8d 44 24 44          	lea    0x44(%esp),%eax
c0025276:	50                   	push   %eax
c0025277:	ff 74 24 34          	pushl  0x34(%esp)
c002527b:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c002527f:	50                   	push   %eax
c0025280:	e8 59 fb ff ff       	call   c0024dde <block_register>
c0025285:	83 c4 20             	add    $0x20,%esp
c0025288:	e9 9b fd ff ff       	jmp    c0025028 <read_partition_table+0x13c>
                              : part_type == 0x21 ? BLOCK_FILESYS
c002528d:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
c0025294:	00 
c0025295:	e9 69 ff ff ff       	jmp    c0025203 <read_partition_table+0x317>
c002529a:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
c00252a1:	00 
c00252a2:	e9 5c ff ff ff       	jmp    c0025203 <read_partition_table+0x317>
c00252a7:	c7 44 24 1c 03 00 00 	movl   $0x3,0x1c(%esp)
c00252ae:	00 
c00252af:	e9 4f ff ff ff       	jmp    c0025203 <read_partition_table+0x317>

c00252b4 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c00252b4:	83 ec 10             	sub    $0x10,%esp
c00252b7:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_write (p->block, p->start + sector, buffer);
c00252bb:	ff 74 24 1c          	pushl  0x1c(%esp)
c00252bf:	8b 42 04             	mov    0x4(%edx),%eax
c00252c2:	03 44 24 1c          	add    0x1c(%esp),%eax
c00252c6:	50                   	push   %eax
c00252c7:	ff 32                	pushl  (%edx)
c00252c9:	e8 4e fa ff ff       	call   c0024d1c <block_write>
}
c00252ce:	83 c4 1c             	add    $0x1c,%esp
c00252d1:	c3                   	ret    

c00252d2 <partition_scan>:
{
c00252d2:	83 ec 28             	sub    $0x28,%esp
  int part_nr = 0;
c00252d5:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c00252dc:	00 
  read_partition_table (block, 0, 0, &part_nr);
c00252dd:	8d 44 24 18          	lea    0x18(%esp),%eax
c00252e1:	50                   	push   %eax
c00252e2:	b9 00 00 00 00       	mov    $0x0,%ecx
c00252e7:	ba 00 00 00 00       	mov    $0x0,%edx
c00252ec:	8b 44 24 30          	mov    0x30(%esp),%eax
c00252f0:	e8 f7 fb ff ff       	call   c0024eec <read_partition_table>
  if (part_nr == 0)
c00252f5:	83 c4 10             	add    $0x10,%esp
c00252f8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c00252fd:	74 04                	je     c0025303 <partition_scan+0x31>
}
c00252ff:	83 c4 1c             	add    $0x1c,%esp
c0025302:	c3                   	ret    
    printf ("%s: Device contains no partitions\n", block_name (block));
c0025303:	83 ec 0c             	sub    $0xc,%esp
c0025306:	ff 74 24 2c          	pushl  0x2c(%esp)
c002530a:	e8 71 fa ff ff       	call   c0024d80 <block_name>
c002530f:	83 c4 08             	add    $0x8,%esp
c0025312:	50                   	push   %eax
c0025313:	68 bc 23 03 c0       	push   $0xc00323bc
c0025318:	e8 b2 18 00 00       	call   c0026bcf <printf>
c002531d:	83 c4 10             	add    $0x10,%esp
}
c0025320:	eb dd                	jmp    c00252ff <partition_scan+0x2d>

c0025322 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0025322:	57                   	push   %edi
c0025323:	56                   	push   %esi
c0025324:	53                   	push   %ebx
c0025325:	89 d7                	mov    %edx,%edi
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025327:	83 fa 01             	cmp    $0x1,%edx
c002532a:	7e 1d                	jle    c0025349 <descramble_ata_string+0x27>
c002532c:	89 c1                	mov    %eax,%ecx
c002532e:	8d 5a fe             	lea    -0x2(%edx),%ebx
c0025331:	83 e3 fe             	and    $0xfffffffe,%ebx
c0025334:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
    {
      char tmp = string[i];
c0025338:	8a 19                	mov    (%ecx),%bl
      string[i] = string[i + 1];
c002533a:	8a 51 01             	mov    0x1(%ecx),%dl
c002533d:	88 11                	mov    %dl,(%ecx)
      string[i + 1] = tmp;
c002533f:	88 59 01             	mov    %bl,0x1(%ecx)
c0025342:	83 c1 02             	add    $0x2,%ecx
  for (i = 0; i + 1 < size; i += 2)
c0025345:	39 f1                	cmp    %esi,%ecx
c0025347:	75 ef                	jne    c0025338 <descramble_ata_string+0x16>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025349:	8d 57 ff             	lea    -0x1(%edi),%edx
c002534c:	85 d2                	test   %edx,%edx
c002534e:	7f 05                	jg     c0025355 <descramble_ata_string+0x33>
c0025350:	eb 14                	jmp    c0025366 <descramble_ata_string+0x44>
c0025352:	4a                   	dec    %edx
c0025353:	74 11                	je     c0025366 <descramble_ata_string+0x44>
    {
      int c = string[size - 1];
c0025355:	8a 4c 10 ff          	mov    -0x1(%eax,%edx,1),%cl
      if (c != '\0' && !isspace (c))
c0025359:	f6 c1 df             	test   $0xdf,%cl
c002535c:	74 f4                	je     c0025352 <descramble_ata_string+0x30>
          || c == '\r' || c == '\t' || c == '\v');
c002535e:	83 e9 09             	sub    $0x9,%ecx
c0025361:	80 f9 04             	cmp    $0x4,%cl
c0025364:	76 ec                	jbe    c0025352 <descramble_ata_string+0x30>
        break; 
    }
  string[size] = '\0';
c0025366:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

  return string;
}
c002536a:	5b                   	pop    %ebx
c002536b:	5e                   	pop    %esi
c002536c:	5f                   	pop    %edi
c002536d:	c3                   	ret    

c002536e <interrupt_handler>:
}

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c002536e:	83 ec 0c             	sub    $0xc,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
    if (f->vec_no == c->irq)
c0025371:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025375:	8b 40 30             	mov    0x30(%eax),%eax
c0025378:	0f b6 15 8a e1 03 c0 	movzbl 0xc003e18a,%edx
c002537f:	39 d0                	cmp    %edx,%eax
c0025381:	74 29                	je     c00253ac <interrupt_handler+0x3e>
c0025383:	0f b6 15 0a e2 03 c0 	movzbl 0xc003e20a,%edx
c002538a:	b9 00 e2 03 c0       	mov    $0xc003e200,%ecx
c002538f:	39 c2                	cmp    %eax,%edx
c0025391:	74 1e                	je     c00253b1 <interrupt_handler+0x43>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c0025393:	68 54 14 03 c0       	push   $0xc0031454
c0025398:	68 18 ff 02 c0       	push   $0xc002ff18
c002539d:	68 0c 02 00 00       	push   $0x20c
c00253a2:	68 f9 23 03 c0       	push   $0xc00323f9
c00253a7:	e8 d1 32 00 00       	call   c002867d <debug_panic>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c00253ac:	b9 80 e1 03 c0       	mov    $0xc003e180,%ecx
        if (c->expecting_interrupt) 
c00253b1:	80 79 40 00          	cmpb   $0x0,0x40(%ecx)
c00253b5:	74 1a                	je     c00253d1 <interrupt_handler+0x63>
            inb (reg_status (c));               /* Acknowledge interrupt. */
c00253b7:	8b 41 08             	mov    0x8(%ecx),%eax
c00253ba:	8d 50 07             	lea    0x7(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00253bd:	ec                   	in     (%dx),%al
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c00253be:	83 ec 0c             	sub    $0xc,%esp
c00253c1:	83 c1 44             	add    $0x44,%ecx
c00253c4:	51                   	push   %ecx
c00253c5:	e8 0a d8 ff ff       	call   c0022bd4 <sema_up>
c00253ca:	83 c4 10             	add    $0x10,%esp
}
c00253cd:	83 c4 0c             	add    $0xc,%esp
c00253d0:	c3                   	ret    
          printf ("%s: unexpected interrupt\n", c->name);
c00253d1:	83 ec 08             	sub    $0x8,%esp
c00253d4:	51                   	push   %ecx
c00253d5:	68 df 23 03 c0       	push   $0xc00323df
c00253da:	e8 f0 17 00 00       	call   c0026bcf <printf>
c00253df:	83 c4 10             	add    $0x10,%esp
c00253e2:	eb e9                	jmp    c00253cd <interrupt_handler+0x5f>

c00253e4 <wait_until_idle>:
{
c00253e4:	56                   	push   %esi
c00253e5:	53                   	push   %ebx
c00253e6:	83 ec 04             	sub    $0x4,%esp
c00253e9:	89 c6                	mov    %eax,%esi
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c00253eb:	8b 40 08             	mov    0x8(%eax),%eax
c00253ee:	8b 40 08             	mov    0x8(%eax),%eax
c00253f1:	8d 50 07             	lea    0x7(%eax),%edx
c00253f4:	ec                   	in     (%dx),%al
c00253f5:	a8 88                	test   $0x88,%al
c00253f7:	74 45                	je     c002543e <wait_until_idle+0x5a>
      timer_usleep (10);
c00253f9:	83 ec 08             	sub    $0x8,%esp
c00253fc:	6a 00                	push   $0x0
c00253fe:	6a 0a                	push   $0xa
c0025400:	e8 5c ef ff ff       	call   c0024361 <timer_usleep>
c0025405:	83 c4 10             	add    $0x10,%esp
c0025408:	bb e7 03 00 00       	mov    $0x3e7,%ebx
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c002540d:	8b 46 08             	mov    0x8(%esi),%eax
c0025410:	8b 40 08             	mov    0x8(%eax),%eax
c0025413:	8d 50 07             	lea    0x7(%eax),%edx
c0025416:	ec                   	in     (%dx),%al
c0025417:	a8 88                	test   $0x88,%al
c0025419:	74 23                	je     c002543e <wait_until_idle+0x5a>
      timer_usleep (10);
c002541b:	83 ec 08             	sub    $0x8,%esp
c002541e:	6a 00                	push   $0x0
c0025420:	6a 0a                	push   $0xa
c0025422:	e8 3a ef ff ff       	call   c0024361 <timer_usleep>
  for (i = 0; i < 1000; i++) 
c0025427:	83 c4 10             	add    $0x10,%esp
c002542a:	4b                   	dec    %ebx
c002542b:	75 e0                	jne    c002540d <wait_until_idle+0x29>
  printf ("%s: idle timeout\n", d->name);
c002542d:	83 ec 08             	sub    $0x8,%esp
c0025430:	56                   	push   %esi
c0025431:	68 0d 24 03 c0       	push   $0xc003240d
c0025436:	e8 94 17 00 00       	call   c0026bcf <printf>
c002543b:	83 c4 10             	add    $0x10,%esp
}
c002543e:	83 c4 04             	add    $0x4,%esp
c0025441:	5b                   	pop    %ebx
c0025442:	5e                   	pop    %esi
c0025443:	c3                   	ret    

c0025444 <select_device>:
{
c0025444:	83 ec 0c             	sub    $0xc,%esp
  struct channel *c = d->channel;
c0025447:	8b 50 08             	mov    0x8(%eax),%edx
  if (d->dev_no == 1)
c002544a:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
c002544e:	74 23                	je     c0025473 <select_device+0x2f>
  uint8_t dev = DEV_MBS;
c0025450:	b0 a0                	mov    $0xa0,%al
  outb (reg_device (c), dev);
c0025452:	8b 4a 08             	mov    0x8(%edx),%ecx
c0025455:	8d 51 06             	lea    0x6(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025458:	ee                   	out    %al,(%dx)
  inb (reg_alt_status (c));
c0025459:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002545f:	ec                   	in     (%dx),%al
  timer_nsleep (400);
c0025460:	83 ec 08             	sub    $0x8,%esp
c0025463:	6a 00                	push   $0x0
c0025465:	68 90 01 00 00       	push   $0x190
c002546a:	e8 0b ef ff ff       	call   c002437a <timer_nsleep>
}
c002546f:	83 c4 1c             	add    $0x1c,%esp
c0025472:	c3                   	ret    
    dev |= DEV_DEV;
c0025473:	b0 b0                	mov    $0xb0,%al
c0025475:	eb db                	jmp    c0025452 <select_device+0xe>

c0025477 <check_device_type>:
{
c0025477:	56                   	push   %esi
c0025478:	53                   	push   %ebx
c0025479:	83 ec 14             	sub    $0x14,%esp
c002547c:	89 c6                	mov    %eax,%esi
  struct channel *c = d->channel;
c002547e:	8b 58 08             	mov    0x8(%eax),%ebx
  select_device (d);
c0025481:	e8 be ff ff ff       	call   c0025444 <select_device>
  error = inb (reg_error (c));
c0025486:	8b 5b 08             	mov    0x8(%ebx),%ebx
c0025489:	8d 53 01             	lea    0x1(%ebx),%edx
c002548c:	ec                   	in     (%dx),%al
c002548d:	88 c1                	mov    %al,%cl
  lbam = inb (reg_lbam (c));
c002548f:	8d 53 04             	lea    0x4(%ebx),%edx
c0025492:	ec                   	in     (%dx),%al
c0025493:	88 44 24 0e          	mov    %al,0xe(%esp)
  lbah = inb (reg_lbah (c));
c0025497:	8d 53 05             	lea    0x5(%ebx),%edx
c002549a:	ec                   	in     (%dx),%al
c002549b:	88 44 24 0f          	mov    %al,0xf(%esp)
  status = inb (reg_status (c));
c002549f:	8d 53 07             	lea    0x7(%ebx),%edx
c00254a2:	ec                   	in     (%dx),%al
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c00254a3:	80 f9 01             	cmp    $0x1,%cl
c00254a6:	74 1b                	je     c00254c3 <check_device_type+0x4c>
c00254a8:	80 f9 81             	cmp    $0x81,%cl
c00254ab:	74 10                	je     c00254bd <check_device_type+0x46>
      d->is_ata = false;
c00254ad:	c6 46 10 00          	movb   $0x0,0x10(%esi)
      return error != 0x81;      
c00254b1:	80 f9 81             	cmp    $0x81,%cl
c00254b4:	0f 95 c0             	setne  %al
}
c00254b7:	83 c4 14             	add    $0x14,%esp
c00254ba:	5b                   	pop    %ebx
c00254bb:	5e                   	pop    %esi
c00254bc:	c3                   	ret    
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c00254bd:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c00254c1:	74 ea                	je     c00254ad <check_device_type+0x36>
      || (status & STA_DRDY) == 0
c00254c3:	a8 40                	test   $0x40,%al
c00254c5:	74 e6                	je     c00254ad <check_device_type+0x36>
      || (status & STA_BSY) != 0)
c00254c7:	84 c0                	test   %al,%al
c00254c9:	78 e2                	js     c00254ad <check_device_type+0x36>
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c00254cb:	80 7c 24 0e 00       	cmpb   $0x0,0xe(%esp)
c00254d0:	75 16                	jne    c00254e8 <check_device_type+0x71>
c00254d2:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00254d7:	0f 94 c0             	sete   %al
c00254da:	0f b6 c0             	movzbl %al,%eax
c00254dd:	88 46 10             	mov    %al,0x10(%esi)
c00254e0:	80 66 10 01          	andb   $0x1,0x10(%esi)
      return true; 
c00254e4:	b0 01                	mov    $0x1,%al
c00254e6:	eb cf                	jmp    c00254b7 <check_device_type+0x40>
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c00254e8:	80 7c 24 0e 3c       	cmpb   $0x3c,0xe(%esp)
c00254ed:	74 07                	je     c00254f6 <check_device_type+0x7f>
c00254ef:	b8 00 00 00 00       	mov    $0x0,%eax
c00254f4:	eb e7                	jmp    c00254dd <check_device_type+0x66>
c00254f6:	80 7c 24 0f c3       	cmpb   $0xc3,0xf(%esp)
c00254fb:	0f 94 c0             	sete   %al
c00254fe:	0f b6 c0             	movzbl %al,%eax
c0025501:	eb da                	jmp    c00254dd <check_device_type+0x66>

c0025503 <select_sector>:
{
c0025503:	57                   	push   %edi
c0025504:	56                   	push   %esi
c0025505:	53                   	push   %ebx
  struct channel *c = d->channel;
c0025506:	8b 78 08             	mov    0x8(%eax),%edi
  ASSERT (sec_no < (1UL << 28));
c0025509:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c002550f:	77 4d                	ja     c002555e <select_sector+0x5b>
c0025511:	89 c6                	mov    %eax,%esi
c0025513:	89 d3                	mov    %edx,%ebx
  wait_until_idle (d);
c0025515:	e8 ca fe ff ff       	call   c00253e4 <wait_until_idle>
  select_device (d);
c002551a:	89 f0                	mov    %esi,%eax
c002551c:	e8 23 ff ff ff       	call   c0025444 <select_device>
  wait_until_idle (d);
c0025521:	89 f0                	mov    %esi,%eax
c0025523:	e8 bc fe ff ff       	call   c00253e4 <wait_until_idle>
  outb (reg_nsect (c), 1);
c0025528:	8b 4f 08             	mov    0x8(%edi),%ecx
c002552b:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002552e:	b0 01                	mov    $0x1,%al
c0025530:	ee                   	out    %al,(%dx)
  outb (reg_lbal (c), sec_no);
c0025531:	8d 51 03             	lea    0x3(%ecx),%edx
c0025534:	88 d8                	mov    %bl,%al
c0025536:	ee                   	out    %al,(%dx)
  outb (reg_lbam (c), sec_no >> 8);
c0025537:	89 d8                	mov    %ebx,%eax
c0025539:	c1 e8 08             	shr    $0x8,%eax
c002553c:	8d 51 04             	lea    0x4(%ecx),%edx
c002553f:	ee                   	out    %al,(%dx)
  outb (reg_lbah (c), (sec_no >> 16));
c0025540:	89 d8                	mov    %ebx,%eax
c0025542:	c1 e8 10             	shr    $0x10,%eax
c0025545:	8d 51 05             	lea    0x5(%ecx),%edx
c0025548:	ee                   	out    %al,(%dx)
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0025549:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c002554d:	74 30                	je     c002557f <select_sector+0x7c>
c002554f:	b0 e0                	mov    $0xe0,%al
c0025551:	c1 eb 18             	shr    $0x18,%ebx
c0025554:	09 d8                	or     %ebx,%eax
  outb (reg_device (c),
c0025556:	8d 51 06             	lea    0x6(%ecx),%edx
c0025559:	ee                   	out    %al,(%dx)
}
c002555a:	5b                   	pop    %ebx
c002555b:	5e                   	pop    %esi
c002555c:	5f                   	pop    %edi
c002555d:	c3                   	ret    
  ASSERT (sec_no < (1UL << 28));
c002555e:	83 ec 0c             	sub    $0xc,%esp
c0025561:	68 1f 24 03 c0       	push   $0xc003241f
c0025566:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002556b:	68 e8 fe 02 c0       	push   $0xc002fee8
c0025570:	68 89 01 00 00       	push   $0x189
c0025575:	68 f9 23 03 c0       	push   $0xc00323f9
c002557a:	e8 fe 30 00 00       	call   c002867d <debug_panic>
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c002557f:	b0 f0                	mov    $0xf0,%al
c0025581:	eb ce                	jmp    c0025551 <select_sector+0x4e>

c0025583 <wait_while_busy>:
{
c0025583:	57                   	push   %edi
c0025584:	56                   	push   %esi
c0025585:	53                   	push   %ebx
c0025586:	89 c7                	mov    %eax,%edi
  struct channel *c = d->channel;
c0025588:	8b 70 08             	mov    0x8(%eax),%esi
  for (i = 0; i < 3000; i++)
c002558b:	bb 00 00 00 00       	mov    $0x0,%ebx
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0025590:	8b 46 08             	mov    0x8(%esi),%eax
c0025593:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025599:	ec                   	in     (%dx),%al
c002559a:	84 c0                	test   %al,%al
c002559c:	79 33                	jns    c00255d1 <wait_while_busy+0x4e>
      timer_msleep (10);
c002559e:	83 ec 08             	sub    $0x8,%esp
c00255a1:	6a 00                	push   $0x0
c00255a3:	6a 0a                	push   $0xa
c00255a5:	e8 9e ed ff ff       	call   c0024348 <timer_msleep>
  for (i = 0; i < 3000; i++)
c00255aa:	43                   	inc    %ebx
c00255ab:	83 c4 10             	add    $0x10,%esp
c00255ae:	81 fb b8 0b 00 00    	cmp    $0xbb8,%ebx
c00255b4:	74 49                	je     c00255ff <wait_while_busy+0x7c>
      if (i == 700)
c00255b6:	81 fb bc 02 00 00    	cmp    $0x2bc,%ebx
c00255bc:	75 d2                	jne    c0025590 <wait_while_busy+0xd>
        printf ("%s: busy, waiting...", d->name);
c00255be:	83 ec 08             	sub    $0x8,%esp
c00255c1:	57                   	push   %edi
c00255c2:	68 34 24 03 c0       	push   $0xc0032434
c00255c7:	e8 03 16 00 00       	call   c0026bcf <printf>
c00255cc:	83 c4 10             	add    $0x10,%esp
c00255cf:	eb bf                	jmp    c0025590 <wait_while_busy+0xd>
          if (i >= 700)
c00255d1:	81 fb bb 02 00 00    	cmp    $0x2bb,%ebx
c00255d7:	7f 14                	jg     c00255ed <wait_while_busy+0x6a>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c00255d9:	8b 46 08             	mov    0x8(%esi),%eax
c00255dc:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c00255e2:	ec                   	in     (%dx),%al
c00255e3:	c0 e8 03             	shr    $0x3,%al
c00255e6:	83 e0 01             	and    $0x1,%eax
}
c00255e9:	5b                   	pop    %ebx
c00255ea:	5e                   	pop    %esi
c00255eb:	5f                   	pop    %edi
c00255ec:	c3                   	ret    
            printf ("ok\n");
c00255ed:	83 ec 0c             	sub    $0xc,%esp
c00255f0:	68 49 24 03 c0       	push   $0xc0032449
c00255f5:	e8 6a 4b 00 00       	call   c002a164 <puts>
c00255fa:	83 c4 10             	add    $0x10,%esp
c00255fd:	eb da                	jmp    c00255d9 <wait_while_busy+0x56>
  printf ("failed\n");
c00255ff:	83 ec 0c             	sub    $0xc,%esp
c0025602:	68 d8 32 03 c0       	push   $0xc00332d8
c0025607:	e8 58 4b 00 00       	call   c002a164 <puts>
  return false;
c002560c:	83 c4 10             	add    $0x10,%esp
c002560f:	b0 00                	mov    $0x0,%al
c0025611:	eb d6                	jmp    c00255e9 <wait_while_busy+0x66>

c0025613 <issue_pio_command>:
{
c0025613:	56                   	push   %esi
c0025614:	53                   	push   %ebx
c0025615:	83 ec 04             	sub    $0x4,%esp
c0025618:	89 c3                	mov    %eax,%ebx
c002561a:	89 d6                	mov    %edx,%esi
  ASSERT (intr_get_level () == INTR_ON);
c002561c:	e8 fd c3 ff ff       	call   c0021a1e <intr_get_level>
c0025621:	83 f8 01             	cmp    $0x1,%eax
c0025624:	75 13                	jne    c0025639 <issue_pio_command+0x26>
  c->expecting_interrupt = true;
c0025626:	c6 43 40 01          	movb   $0x1,0x40(%ebx)
  outb (reg_command (c), command);
c002562a:	8b 53 08             	mov    0x8(%ebx),%edx
c002562d:	83 c2 07             	add    $0x7,%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025630:	89 f0                	mov    %esi,%eax
c0025632:	ee                   	out    %al,(%dx)
}
c0025633:	83 c4 04             	add    $0x4,%esp
c0025636:	5b                   	pop    %ebx
c0025637:	5e                   	pop    %esi
c0025638:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c0025639:	83 ec 0c             	sub    $0xc,%esp
c002563c:	68 5f 1b 03 c0       	push   $0xc0031b5f
c0025641:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0025646:	68 c8 fe 02 c0       	push   $0xc002fec8
c002564b:	68 9b 01 00 00       	push   $0x19b
c0025650:	68 f9 23 03 c0       	push   $0xc00323f9
c0025655:	e8 23 30 00 00       	call   c002867d <debug_panic>

c002565a <ide_write>:
{
c002565a:	57                   	push   %edi
c002565b:	56                   	push   %esi
c002565c:	53                   	push   %ebx
c002565d:	8b 74 24 10          	mov    0x10(%esp),%esi
  struct channel *c = d->channel;
c0025661:	8b 5e 08             	mov    0x8(%esi),%ebx
  lock_acquire (&c->lock);
c0025664:	8d 7b 0c             	lea    0xc(%ebx),%edi
c0025667:	83 ec 0c             	sub    $0xc,%esp
c002566a:	57                   	push   %edi
c002566b:	e8 63 d8 ff ff       	call   c0022ed3 <lock_acquire>
  select_sector (d, sec_no);
c0025670:	8b 54 24 24          	mov    0x24(%esp),%edx
c0025674:	89 f0                	mov    %esi,%eax
c0025676:	e8 88 fe ff ff       	call   c0025503 <select_sector>
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c002567b:	ba 30 00 00 00       	mov    $0x30,%edx
c0025680:	89 d8                	mov    %ebx,%eax
c0025682:	e8 8c ff ff ff       	call   c0025613 <issue_pio_command>
  if (!wait_while_busy (d))
c0025687:	89 f0                	mov    %esi,%eax
c0025689:	e8 f5 fe ff ff       	call   c0025583 <wait_while_busy>
c002568e:	83 c4 10             	add    $0x10,%esp
c0025691:	84 c0                	test   %al,%al
c0025693:	74 2a                	je     c00256bf <ide_write+0x65>
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025695:	8b 53 08             	mov    0x8(%ebx),%edx
c0025698:	8b 74 24 18          	mov    0x18(%esp),%esi
c002569c:	b9 00 01 00 00       	mov    $0x100,%ecx
c00256a1:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
  sema_down (&c->completion_wait);
c00256a4:	83 ec 0c             	sub    $0xc,%esp
c00256a7:	83 c3 44             	add    $0x44,%ebx
c00256aa:	53                   	push   %ebx
c00256ab:	e8 43 d4 ff ff       	call   c0022af3 <sema_down>
  lock_release (&c->lock);
c00256b0:	89 3c 24             	mov    %edi,(%esp)
c00256b3:	e8 b8 d9 ff ff       	call   c0023070 <lock_release>
}
c00256b8:	83 c4 10             	add    $0x10,%esp
c00256bb:	5b                   	pop    %ebx
c00256bc:	5e                   	pop    %esi
c00256bd:	5f                   	pop    %edi
c00256be:	c3                   	ret    
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c00256bf:	83 ec 08             	sub    $0x8,%esp
c00256c2:	ff 74 24 1c          	pushl  0x1c(%esp)
c00256c6:	56                   	push   %esi
c00256c7:	68 98 24 03 c0       	push   $0xc0032498
c00256cc:	68 f8 fe 02 c0       	push   $0xc002fef8
c00256d1:	68 75 01 00 00       	push   $0x175
c00256d6:	68 f9 23 03 c0       	push   $0xc00323f9
c00256db:	e8 9d 2f 00 00       	call   c002867d <debug_panic>

c00256e0 <identify_ata_device>:
{
c00256e0:	57                   	push   %edi
c00256e1:	56                   	push   %esi
c00256e2:	53                   	push   %ebx
c00256e3:	81 ec 80 02 00 00    	sub    $0x280,%esp
  struct channel *c = d->channel;
c00256e9:	8b 70 08             	mov    0x8(%eax),%esi
  ASSERT (d->is_ata);
c00256ec:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c00256f0:	74 49                	je     c002573b <identify_ata_device+0x5b>
c00256f2:	89 c3                	mov    %eax,%ebx
  wait_until_idle (d);
c00256f4:	e8 eb fc ff ff       	call   c00253e4 <wait_until_idle>
  select_device (d);
c00256f9:	89 d8                	mov    %ebx,%eax
c00256fb:	e8 44 fd ff ff       	call   c0025444 <select_device>
  wait_until_idle (d);
c0025700:	89 d8                	mov    %ebx,%eax
c0025702:	e8 dd fc ff ff       	call   c00253e4 <wait_until_idle>
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0025707:	ba ec 00 00 00       	mov    $0xec,%edx
c002570c:	89 f0                	mov    %esi,%eax
c002570e:	e8 00 ff ff ff       	call   c0025613 <issue_pio_command>
  sema_down (&c->completion_wait);
c0025713:	83 ec 0c             	sub    $0xc,%esp
c0025716:	8d 46 44             	lea    0x44(%esi),%eax
c0025719:	50                   	push   %eax
c002571a:	e8 d4 d3 ff ff       	call   c0022af3 <sema_down>
  if (!wait_while_busy (d))
c002571f:	89 d8                	mov    %ebx,%eax
c0025721:	e8 5d fe ff ff       	call   c0025583 <wait_while_busy>
c0025726:	83 c4 10             	add    $0x10,%esp
c0025729:	84 c0                	test   %al,%al
c002572b:	75 2f                	jne    c002575c <identify_ata_device+0x7c>
      d->is_ata = false;
c002572d:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
}
c0025731:	81 c4 80 02 00 00    	add    $0x280,%esp
c0025737:	5b                   	pop    %ebx
c0025738:	5e                   	pop    %esi
c0025739:	5f                   	pop    %edi
c002573a:	c3                   	ret    
  ASSERT (d->is_ata);
c002573b:	83 ec 0c             	sub    $0xc,%esp
c002573e:	68 4c 24 03 c0       	push   $0xc003244c
c0025743:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0025748:	68 04 ff 02 c0       	push   $0xc002ff04
c002574d:	68 0d 01 00 00       	push   $0x10d
c0025752:	68 f9 23 03 c0       	push   $0xc00323f9
c0025757:	e8 21 2f 00 00       	call   c002867d <debug_panic>
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c002575c:	8b 56 08             	mov    0x8(%esi),%edx
c002575f:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0025766:	b9 00 01 00 00       	mov    $0x100,%ecx
c002576b:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  capacity = *(uint32_t *) &id[60 * 2];
c002576e:	8b b4 24 f8 00 00 00 	mov    0xf8(%esp),%esi
  model = descramble_ata_string (&id[10 * 2], 20);
c0025775:	ba 14 00 00 00       	mov    $0x14,%edx
c002577a:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0025781:	e8 9c fb ff ff       	call   c0025322 <descramble_ata_string>
c0025786:	89 c7                	mov    %eax,%edi
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025788:	ba 28 00 00 00       	mov    $0x28,%edx
c002578d:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c0025794:	e8 89 fb ff ff       	call   c0025322 <descramble_ata_string>
  snprintf (extra_info, sizeof extra_info,
c0025799:	83 ec 0c             	sub    $0xc,%esp
c002579c:	50                   	push   %eax
c002579d:	57                   	push   %edi
c002579e:	68 56 24 03 c0       	push   $0xc0032456
c00257a3:	68 80 00 00 00       	push   $0x80
c00257a8:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c00257ac:	50                   	push   %eax
c00257ad:	e8 a9 1b 00 00       	call   c002735b <snprintf>
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c00257b2:	83 c4 20             	add    $0x20,%esp
c00257b5:	81 fe ff ff 1f 00    	cmp    $0x1fffff,%esi
c00257bb:	76 3a                	jbe    c00257f7 <identify_ata_device+0x117>
      printf ("%s: ignoring ", d->name);
c00257bd:	83 ec 08             	sub    $0x8,%esp
c00257c0:	53                   	push   %ebx
c00257c1:	68 6e 24 03 c0       	push   $0xc003246e
c00257c6:	e8 04 14 00 00       	call   c0026bcf <printf>
      print_human_readable_size (capacity * 512);
c00257cb:	83 c4 08             	add    $0x8,%esp
c00257ce:	89 f0                	mov    %esi,%eax
c00257d0:	c1 e0 09             	shl    $0x9,%eax
c00257d3:	ba 00 00 00 00       	mov    $0x0,%edx
c00257d8:	52                   	push   %edx
c00257d9:	50                   	push   %eax
c00257da:	e8 94 1d 00 00       	call   c0027573 <print_human_readable_size>
      printf ("disk for safety\n");
c00257df:	c7 04 24 7c 24 03 c0 	movl   $0xc003247c,(%esp)
c00257e6:	e8 79 49 00 00       	call   c002a164 <puts>
      d->is_ata = false;
c00257eb:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
      return;
c00257ef:	83 c4 10             	add    $0x10,%esp
c00257f2:	e9 3a ff ff ff       	jmp    c0025731 <identify_ata_device+0x51>
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c00257f7:	83 ec 08             	sub    $0x8,%esp
c00257fa:	53                   	push   %ebx
c00257fb:	68 70 c6 03 c0       	push   $0xc003c670
c0025800:	56                   	push   %esi
c0025801:	8d 44 24 14          	lea    0x14(%esp),%eax
c0025805:	50                   	push   %eax
c0025806:	6a 04                	push   $0x4
c0025808:	53                   	push   %ebx
c0025809:	e8 d0 f5 ff ff       	call   c0024dde <block_register>
  partition_scan (block);
c002580e:	83 c4 14             	add    $0x14,%esp
c0025811:	50                   	push   %eax
c0025812:	e8 bb fa ff ff       	call   c00252d2 <partition_scan>
c0025817:	83 c4 10             	add    $0x10,%esp
c002581a:	e9 12 ff ff ff       	jmp    c0025731 <identify_ata_device+0x51>

c002581f <ide_read>:
{
c002581f:	55                   	push   %ebp
c0025820:	57                   	push   %edi
c0025821:	56                   	push   %esi
c0025822:	53                   	push   %ebx
c0025823:	83 ec 18             	sub    $0x18,%esp
c0025826:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  struct channel *c = d->channel;
c002582a:	8b 5e 08             	mov    0x8(%esi),%ebx
  lock_acquire (&c->lock);
c002582d:	8d 6b 0c             	lea    0xc(%ebx),%ebp
c0025830:	55                   	push   %ebp
c0025831:	e8 9d d6 ff ff       	call   c0022ed3 <lock_acquire>
  select_sector (d, sec_no);
c0025836:	8b 54 24 34          	mov    0x34(%esp),%edx
c002583a:	89 f0                	mov    %esi,%eax
c002583c:	e8 c2 fc ff ff       	call   c0025503 <select_sector>
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0025841:	ba 20 00 00 00       	mov    $0x20,%edx
c0025846:	89 d8                	mov    %ebx,%eax
c0025848:	e8 c6 fd ff ff       	call   c0025613 <issue_pio_command>
  sema_down (&c->completion_wait);
c002584d:	8d 43 44             	lea    0x44(%ebx),%eax
c0025850:	89 04 24             	mov    %eax,(%esp)
c0025853:	e8 9b d2 ff ff       	call   c0022af3 <sema_down>
  if (!wait_while_busy (d))
c0025858:	89 f0                	mov    %esi,%eax
c002585a:	e8 24 fd ff ff       	call   c0025583 <wait_while_busy>
c002585f:	83 c4 10             	add    $0x10,%esp
c0025862:	84 c0                	test   %al,%al
c0025864:	74 20                	je     c0025886 <ide_read+0x67>
c0025866:	8b 53 08             	mov    0x8(%ebx),%edx
c0025869:	8b 7c 24 28          	mov    0x28(%esp),%edi
c002586d:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025872:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  lock_release (&c->lock);
c0025875:	83 ec 0c             	sub    $0xc,%esp
c0025878:	55                   	push   %ebp
c0025879:	e8 f2 d7 ff ff       	call   c0023070 <lock_release>
}
c002587e:	83 c4 1c             	add    $0x1c,%esp
c0025881:	5b                   	pop    %ebx
c0025882:	5e                   	pop    %esi
c0025883:	5f                   	pop    %edi
c0025884:	5d                   	pop    %ebp
c0025885:	c3                   	ret    
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0025886:	83 ec 08             	sub    $0x8,%esp
c0025889:	ff 74 24 2c          	pushl  0x2c(%esp)
c002588d:	56                   	push   %esi
c002588e:	68 bc 24 03 c0       	push   $0xc00324bc
c0025893:	68 dc fe 02 c0       	push   $0xc002fedc
c0025898:	68 62 01 00 00       	push   $0x162
c002589d:	68 f9 23 03 c0       	push   $0xc00323f9
c00258a2:	e8 d6 2d 00 00       	call   c002867d <debug_panic>

c00258a7 <ide_init>:
{
c00258a7:	55                   	push   %ebp
c00258a8:	57                   	push   %edi
c00258a9:	56                   	push   %esi
c00258aa:	53                   	push   %ebx
c00258ab:	83 ec 1c             	sub    $0x1c,%esp
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c00258ae:	6a 00                	push   $0x0
c00258b0:	68 8c 24 03 c0       	push   $0xc003248c
c00258b5:	6a 08                	push   $0x8
c00258b7:	68 80 e1 03 c0       	push   $0xc003e180
c00258bc:	e8 9a 1a 00 00       	call   c002735b <snprintf>
          c->reg_base = 0x1f0;
c00258c1:	66 c7 05 88 e1 03 c0 	movw   $0x1f0,0xc003e188
c00258c8:	f0 01 
          c->irq = 14 + 0x20;
c00258ca:	c6 05 8a e1 03 c0 2e 	movb   $0x2e,0xc003e18a
      lock_init (&c->lock);
c00258d1:	c7 04 24 8c e1 03 c0 	movl   $0xc003e18c,(%esp)
c00258d8:	e8 82 d4 ff ff       	call   c0022d5f <lock_init>
      c->expecting_interrupt = false;
c00258dd:	c6 05 c0 e1 03 c0 00 	movb   $0x0,0xc003e1c0
      sema_init (&c->completion_wait, 0);
c00258e4:	83 c4 08             	add    $0x8,%esp
c00258e7:	6a 00                	push   $0x0
c00258e9:	68 c4 e1 03 c0       	push   $0xc003e1c4
c00258ee:	e8 92 d1 ff ff       	call   c0022a85 <sema_init>
          snprintf (d->name, sizeof d->name,
c00258f3:	6a 61                	push   $0x61
c00258f5:	68 93 24 03 c0       	push   $0xc0032493
c00258fa:	6a 08                	push   $0x8
c00258fc:	68 d8 e1 03 c0       	push   $0xc003e1d8
c0025901:	e8 55 1a 00 00       	call   c002735b <snprintf>
          d->channel = c;
c0025906:	c7 05 e0 e1 03 c0 80 	movl   $0xc003e180,0xc003e1e0
c002590d:	e1 03 c0 
          d->dev_no = dev_no;
c0025910:	c7 05 e4 e1 03 c0 00 	movl   $0x0,0xc003e1e4
c0025917:	00 00 00 
          d->is_ata = false;
c002591a:	c6 05 e8 e1 03 c0 00 	movb   $0x0,0xc003e1e8
          snprintf (d->name, sizeof d->name,
c0025921:	83 c4 20             	add    $0x20,%esp
c0025924:	6a 62                	push   $0x62
c0025926:	68 93 24 03 c0       	push   $0xc0032493
c002592b:	6a 08                	push   $0x8
c002592d:	68 ec e1 03 c0       	push   $0xc003e1ec
c0025932:	e8 24 1a 00 00       	call   c002735b <snprintf>
          d->channel = c;
c0025937:	c7 05 f4 e1 03 c0 80 	movl   $0xc003e180,0xc003e1f4
c002593e:	e1 03 c0 
          d->dev_no = dev_no;
c0025941:	c7 05 f8 e1 03 c0 01 	movl   $0x1,0xc003e1f8
c0025948:	00 00 00 
          d->is_ata = false;
c002594b:	c6 05 fc e1 03 c0 00 	movb   $0x0,0xc003e1fc
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025952:	83 c4 0c             	add    $0xc,%esp
c0025955:	68 80 e1 03 c0       	push   $0xc003e180
c002595a:	68 6e 53 02 c0       	push   $0xc002536e
c002595f:	0f b6 05 8a e1 03 c0 	movzbl 0xc003e18a,%eax
c0025966:	50                   	push   %eax
c0025967:	e8 70 c2 ff ff       	call   c0021bdc <intr_register_ext>
      select_device (d);
c002596c:	b8 d8 e1 03 c0       	mov    $0xc003e1d8,%eax
c0025971:	e8 ce fa ff ff       	call   c0025444 <select_device>
      outb (reg_nsect (c), 0x55);
c0025976:	8b 0d 88 e1 03 c0    	mov    0xc003e188,%ecx
c002597c:	8d 59 02             	lea    0x2(%ecx),%ebx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002597f:	b0 55                	mov    $0x55,%al
c0025981:	89 da                	mov    %ebx,%edx
c0025983:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025984:	83 c1 03             	add    $0x3,%ecx
c0025987:	b0 aa                	mov    $0xaa,%al
c0025989:	89 ca                	mov    %ecx,%edx
c002598b:	ee                   	out    %al,(%dx)
c002598c:	89 da                	mov    %ebx,%edx
c002598e:	ee                   	out    %al,(%dx)
c002598f:	b0 55                	mov    $0x55,%al
c0025991:	89 ca                	mov    %ecx,%edx
c0025993:	ee                   	out    %al,(%dx)
c0025994:	89 da                	mov    %ebx,%edx
c0025996:	ee                   	out    %al,(%dx)
c0025997:	b0 aa                	mov    $0xaa,%al
c0025999:	89 ca                	mov    %ecx,%edx
c002599b:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002599c:	89 da                	mov    %ebx,%edx
c002599e:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c002599f:	83 c4 10             	add    $0x10,%esp
c00259a2:	3c 55                	cmp    $0x55,%al
c00259a4:	0f 84 84 02 00 00    	je     c0025c2e <ide_init+0x387>
c00259aa:	b3 00                	mov    $0x0,%bl
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c00259ac:	88 5c 24 0e          	mov    %bl,0xe(%esp)
      select_device (d);
c00259b0:	b8 ec e1 03 c0       	mov    $0xc003e1ec,%eax
c00259b5:	e8 8a fa ff ff       	call   c0025444 <select_device>
      outb (reg_nsect (c), 0x55);
c00259ba:	8b 0d 88 e1 03 c0    	mov    0xc003e188,%ecx
c00259c0:	8d 71 02             	lea    0x2(%ecx),%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00259c3:	b0 55                	mov    $0x55,%al
c00259c5:	89 f2                	mov    %esi,%edx
c00259c7:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c00259c8:	8d 79 03             	lea    0x3(%ecx),%edi
c00259cb:	b0 aa                	mov    $0xaa,%al
c00259cd:	89 fa                	mov    %edi,%edx
c00259cf:	ee                   	out    %al,(%dx)
c00259d0:	89 f2                	mov    %esi,%edx
c00259d2:	ee                   	out    %al,(%dx)
c00259d3:	b0 55                	mov    $0x55,%al
c00259d5:	89 fa                	mov    %edi,%edx
c00259d7:	ee                   	out    %al,(%dx)
c00259d8:	89 f2                	mov    %esi,%edx
c00259da:	ee                   	out    %al,(%dx)
c00259db:	b0 aa                	mov    $0xaa,%al
c00259dd:	89 fa                	mov    %edi,%edx
c00259df:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00259e0:	89 f2                	mov    %esi,%edx
c00259e2:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c00259e3:	3c 55                	cmp    $0x55,%al
c00259e5:	0f 84 50 02 00 00    	je     c0025c3b <ide_init+0x394>
c00259eb:	be 00 00 00 00       	mov    $0x0,%esi
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c00259f0:	89 f0                	mov    %esi,%eax
c00259f2:	88 44 24 0f          	mov    %al,0xf(%esp)
  outb (reg_ctl (c), 0);
c00259f6:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00259fc:	b0 00                	mov    $0x0,%al
c00259fe:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c00259ff:	83 ec 08             	sub    $0x8,%esp
c0025a02:	6a 00                	push   $0x0
c0025a04:	6a 0a                	push   $0xa
c0025a06:	e8 56 e9 ff ff       	call   c0024361 <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c0025a0b:	a1 88 e1 03 c0       	mov    0xc003e188,%eax
c0025a10:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025a16:	b0 04                	mov    $0x4,%al
c0025a18:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0025a19:	83 c4 08             	add    $0x8,%esp
c0025a1c:	6a 00                	push   $0x0
c0025a1e:	6a 0a                	push   $0xa
c0025a20:	e8 3c e9 ff ff       	call   c0024361 <timer_usleep>
  outb (reg_ctl (c), 0);
c0025a25:	a1 88 e1 03 c0       	mov    0xc003e188,%eax
c0025a2a:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025a30:	b0 00                	mov    $0x0,%al
c0025a32:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c0025a33:	83 c4 08             	add    $0x8,%esp
c0025a36:	6a 00                	push   $0x0
c0025a38:	68 96 00 00 00       	push   $0x96
c0025a3d:	e8 06 e9 ff ff       	call   c0024348 <timer_msleep>
  if (present[0]) 
c0025a42:	83 c4 10             	add    $0x10,%esp
c0025a45:	84 db                	test   %bl,%bl
c0025a47:	0f 85 fd 01 00 00    	jne    c0025c4a <ide_init+0x3a3>
  if (present[1])
c0025a4d:	89 f0                	mov    %esi,%eax
c0025a4f:	84 c0                	test   %al,%al
c0025a51:	0f 85 0c 02 00 00    	jne    c0025c63 <ide_init+0x3bc>
      if (check_device_type (&c->devices[0]))
c0025a57:	b8 d8 e1 03 c0       	mov    $0xc003e1d8,%eax
c0025a5c:	e8 16 fa ff ff       	call   c0025477 <check_device_type>
c0025a61:	84 c0                	test   %al,%al
c0025a63:	0f 85 42 02 00 00    	jne    c0025cab <ide_init+0x404>
        if (c->devices[dev_no].is_ata)
c0025a69:	80 3d e8 e1 03 c0 00 	cmpb   $0x0,0xc003e1e8
c0025a70:	0f 85 44 02 00 00    	jne    c0025cba <ide_init+0x413>
c0025a76:	80 3d fc e1 03 c0 00 	cmpb   $0x0,0xc003e1fc
c0025a7d:	0f 85 46 02 00 00    	jne    c0025cc9 <ide_init+0x422>
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025a83:	6a 01                	push   $0x1
c0025a85:	68 8c 24 03 c0       	push   $0xc003248c
c0025a8a:	6a 08                	push   $0x8
c0025a8c:	68 00 e2 03 c0       	push   $0xc003e200
c0025a91:	e8 c5 18 00 00       	call   c002735b <snprintf>
          c->reg_base = 0x170;
c0025a96:	66 c7 05 08 e2 03 c0 	movw   $0x170,0xc003e208
c0025a9d:	70 01 
          c->irq = 15 + 0x20;
c0025a9f:	c6 05 0a e2 03 c0 2f 	movb   $0x2f,0xc003e20a
      lock_init (&c->lock);
c0025aa6:	c7 04 24 0c e2 03 c0 	movl   $0xc003e20c,(%esp)
c0025aad:	e8 ad d2 ff ff       	call   c0022d5f <lock_init>
      c->expecting_interrupt = false;
c0025ab2:	c6 05 40 e2 03 c0 00 	movb   $0x0,0xc003e240
      sema_init (&c->completion_wait, 0);
c0025ab9:	83 c4 08             	add    $0x8,%esp
c0025abc:	6a 00                	push   $0x0
c0025abe:	68 44 e2 03 c0       	push   $0xc003e244
c0025ac3:	e8 bd cf ff ff       	call   c0022a85 <sema_init>
          snprintf (d->name, sizeof d->name,
c0025ac8:	6a 63                	push   $0x63
c0025aca:	68 93 24 03 c0       	push   $0xc0032493
c0025acf:	6a 08                	push   $0x8
c0025ad1:	68 58 e2 03 c0       	push   $0xc003e258
c0025ad6:	e8 80 18 00 00       	call   c002735b <snprintf>
          d->channel = c;
c0025adb:	c7 05 60 e2 03 c0 00 	movl   $0xc003e200,0xc003e260
c0025ae2:	e2 03 c0 
          d->dev_no = dev_no;
c0025ae5:	c7 05 64 e2 03 c0 00 	movl   $0x0,0xc003e264
c0025aec:	00 00 00 
          d->is_ata = false;
c0025aef:	c6 05 68 e2 03 c0 00 	movb   $0x0,0xc003e268
          snprintf (d->name, sizeof d->name,
c0025af6:	83 c4 20             	add    $0x20,%esp
c0025af9:	6a 64                	push   $0x64
c0025afb:	68 93 24 03 c0       	push   $0xc0032493
c0025b00:	6a 08                	push   $0x8
c0025b02:	68 6c e2 03 c0       	push   $0xc003e26c
c0025b07:	e8 4f 18 00 00       	call   c002735b <snprintf>
          d->channel = c;
c0025b0c:	c7 05 74 e2 03 c0 00 	movl   $0xc003e200,0xc003e274
c0025b13:	e2 03 c0 
          d->dev_no = dev_no;
c0025b16:	c7 05 78 e2 03 c0 01 	movl   $0x1,0xc003e278
c0025b1d:	00 00 00 
          d->is_ata = false;
c0025b20:	c6 05 7c e2 03 c0 00 	movb   $0x0,0xc003e27c
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025b27:	83 c4 0c             	add    $0xc,%esp
c0025b2a:	68 00 e2 03 c0       	push   $0xc003e200
c0025b2f:	68 6e 53 02 c0       	push   $0xc002536e
c0025b34:	0f b6 05 0a e2 03 c0 	movzbl 0xc003e20a,%eax
c0025b3b:	50                   	push   %eax
c0025b3c:	e8 9b c0 ff ff       	call   c0021bdc <intr_register_ext>
c0025b41:	bf 58 e2 03 c0       	mov    $0xc003e258,%edi
c0025b46:	8d 74 24 1e          	lea    0x1e(%esp),%esi
c0025b4a:	83 c4 10             	add    $0x10,%esp
      select_device (d);
c0025b4d:	89 f8                	mov    %edi,%eax
c0025b4f:	e8 f0 f8 ff ff       	call   c0025444 <select_device>
      outb (reg_nsect (c), 0x55);
c0025b54:	8b 2d 08 e2 03 c0    	mov    0xc003e208,%ebp
c0025b5a:	8d 4d 02             	lea    0x2(%ebp),%ecx
c0025b5d:	b0 55                	mov    $0x55,%al
c0025b5f:	89 ca                	mov    %ecx,%edx
c0025b61:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025b62:	8d 5d 03             	lea    0x3(%ebp),%ebx
c0025b65:	b0 aa                	mov    $0xaa,%al
c0025b67:	89 da                	mov    %ebx,%edx
c0025b69:	ee                   	out    %al,(%dx)
c0025b6a:	89 ca                	mov    %ecx,%edx
c0025b6c:	ee                   	out    %al,(%dx)
c0025b6d:	b0 55                	mov    $0x55,%al
c0025b6f:	89 da                	mov    %ebx,%edx
c0025b71:	ee                   	out    %al,(%dx)
c0025b72:	89 ca                	mov    %ecx,%edx
c0025b74:	ee                   	out    %al,(%dx)
c0025b75:	b0 aa                	mov    $0xaa,%al
c0025b77:	89 da                	mov    %ebx,%edx
c0025b79:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025b7a:	89 ca                	mov    %ecx,%edx
c0025b7c:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025b7d:	3c 55                	cmp    $0x55,%al
c0025b7f:	0f 84 53 01 00 00    	je     c0025cd8 <ide_init+0x431>
c0025b85:	b0 00                	mov    $0x0,%al
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025b87:	88 06                	mov    %al,(%esi)
c0025b89:	83 c7 14             	add    $0x14,%edi
c0025b8c:	46                   	inc    %esi
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025b8d:	8d 44 24 10          	lea    0x10(%esp),%eax
c0025b91:	39 f0                	cmp    %esi,%eax
c0025b93:	75 b8                	jne    c0025b4d <ide_init+0x2a6>
  outb (reg_ctl (c), 0);
c0025b95:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025b9b:	b0 00                	mov    $0x0,%al
c0025b9d:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0025b9e:	83 ec 08             	sub    $0x8,%esp
c0025ba1:	6a 00                	push   $0x0
c0025ba3:	6a 0a                	push   $0xa
c0025ba5:	e8 b7 e7 ff ff       	call   c0024361 <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c0025baa:	a1 08 e2 03 c0       	mov    0xc003e208,%eax
c0025baf:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025bb5:	b0 04                	mov    $0x4,%al
c0025bb7:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0025bb8:	83 c4 08             	add    $0x8,%esp
c0025bbb:	6a 00                	push   $0x0
c0025bbd:	6a 0a                	push   $0xa
c0025bbf:	e8 9d e7 ff ff       	call   c0024361 <timer_usleep>
  outb (reg_ctl (c), 0);
c0025bc4:	a1 08 e2 03 c0       	mov    0xc003e208,%eax
c0025bc9:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025bcf:	b0 00                	mov    $0x0,%al
c0025bd1:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c0025bd2:	83 c4 08             	add    $0x8,%esp
c0025bd5:	6a 00                	push   $0x0
c0025bd7:	68 96 00 00 00       	push   $0x96
c0025bdc:	e8 67 e7 ff ff       	call   c0024348 <timer_msleep>
  if (present[0]) 
c0025be1:	83 c4 10             	add    $0x10,%esp
c0025be4:	80 7c 24 0e 00       	cmpb   $0x0,0xe(%esp)
c0025be9:	0f 85 f6 00 00 00    	jne    c0025ce5 <ide_init+0x43e>
  if (present[1])
c0025bef:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0025bf4:	0f 85 04 01 00 00    	jne    c0025cfe <ide_init+0x457>
      if (check_device_type (&c->devices[0]))
c0025bfa:	b8 58 e2 03 c0       	mov    $0xc003e258,%eax
c0025bff:	e8 73 f8 ff ff       	call   c0025477 <check_device_type>
c0025c04:	84 c0                	test   %al,%al
c0025c06:	0f 85 3a 01 00 00    	jne    c0025d46 <ide_init+0x49f>
        if (c->devices[dev_no].is_ata)
c0025c0c:	80 3d 68 e2 03 c0 00 	cmpb   $0x0,0xc003e268
c0025c13:	0f 85 3c 01 00 00    	jne    c0025d55 <ide_init+0x4ae>
c0025c19:	80 3d 7c e2 03 c0 00 	cmpb   $0x0,0xc003e27c
c0025c20:	0f 85 3e 01 00 00    	jne    c0025d64 <ide_init+0x4bd>
}
c0025c26:	83 c4 1c             	add    $0x1c,%esp
c0025c29:	5b                   	pop    %ebx
c0025c2a:	5e                   	pop    %esi
c0025c2b:	5f                   	pop    %edi
c0025c2c:	5d                   	pop    %ebp
c0025c2d:	c3                   	ret    
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025c2e:	89 ca                	mov    %ecx,%edx
c0025c30:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025c31:	3c aa                	cmp    $0xaa,%al
c0025c33:	0f 94 c3             	sete   %bl
c0025c36:	e9 71 fd ff ff       	jmp    c00259ac <ide_init+0x105>
c0025c3b:	89 fa                	mov    %edi,%edx
c0025c3d:	ec                   	in     (%dx),%al
c0025c3e:	3c aa                	cmp    $0xaa,%al
c0025c40:	0f 94 c0             	sete   %al
c0025c43:	89 c6                	mov    %eax,%esi
c0025c45:	e9 a6 fd ff ff       	jmp    c00259f0 <ide_init+0x149>
      select_device (&c->devices[0]);
c0025c4a:	b8 d8 e1 03 c0       	mov    $0xc003e1d8,%eax
c0025c4f:	e8 f0 f7 ff ff       	call   c0025444 <select_device>
      wait_while_busy (&c->devices[0]); 
c0025c54:	b8 d8 e1 03 c0       	mov    $0xc003e1d8,%eax
c0025c59:	e8 25 f9 ff ff       	call   c0025583 <wait_while_busy>
c0025c5e:	e9 ea fd ff ff       	jmp    c0025a4d <ide_init+0x1a6>
      select_device (&c->devices[1]);
c0025c63:	b8 ec e1 03 c0       	mov    $0xc003e1ec,%eax
c0025c68:	e8 d7 f7 ff ff       	call   c0025444 <select_device>
c0025c6d:	bb b8 0b 00 00       	mov    $0xbb8,%ebx
c0025c72:	eb 12                	jmp    c0025c86 <ide_init+0x3df>
          timer_msleep (10);
c0025c74:	83 ec 08             	sub    $0x8,%esp
c0025c77:	6a 00                	push   $0x0
c0025c79:	6a 0a                	push   $0xa
c0025c7b:	e8 c8 e6 ff ff       	call   c0024348 <timer_msleep>
      for (i = 0; i < 3000; i++) 
c0025c80:	83 c4 10             	add    $0x10,%esp
c0025c83:	4b                   	dec    %ebx
c0025c84:	74 16                	je     c0025c9c <ide_init+0x3f5>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025c86:	8b 0d 88 e1 03 c0    	mov    0xc003e188,%ecx
c0025c8c:	8d 51 02             	lea    0x2(%ecx),%edx
c0025c8f:	ec                   	in     (%dx),%al
c0025c90:	3c 01                	cmp    $0x1,%al
c0025c92:	75 e0                	jne    c0025c74 <ide_init+0x3cd>
c0025c94:	8d 51 03             	lea    0x3(%ecx),%edx
c0025c97:	ec                   	in     (%dx),%al
c0025c98:	3c 01                	cmp    $0x1,%al
c0025c9a:	75 d8                	jne    c0025c74 <ide_init+0x3cd>
      wait_while_busy (&c->devices[1]);
c0025c9c:	b8 ec e1 03 c0       	mov    $0xc003e1ec,%eax
c0025ca1:	e8 dd f8 ff ff       	call   c0025583 <wait_while_busy>
c0025ca6:	e9 ac fd ff ff       	jmp    c0025a57 <ide_init+0x1b0>
        check_device_type (&c->devices[1]);
c0025cab:	b8 ec e1 03 c0       	mov    $0xc003e1ec,%eax
c0025cb0:	e8 c2 f7 ff ff       	call   c0025477 <check_device_type>
c0025cb5:	e9 af fd ff ff       	jmp    c0025a69 <ide_init+0x1c2>
          identify_ata_device (&c->devices[dev_no]);
c0025cba:	b8 d8 e1 03 c0       	mov    $0xc003e1d8,%eax
c0025cbf:	e8 1c fa ff ff       	call   c00256e0 <identify_ata_device>
c0025cc4:	e9 ad fd ff ff       	jmp    c0025a76 <ide_init+0x1cf>
c0025cc9:	b8 ec e1 03 c0       	mov    $0xc003e1ec,%eax
c0025cce:	e8 0d fa ff ff       	call   c00256e0 <identify_ata_device>
c0025cd3:	e9 ab fd ff ff       	jmp    c0025a83 <ide_init+0x1dc>
c0025cd8:	89 da                	mov    %ebx,%edx
c0025cda:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025cdb:	3c aa                	cmp    $0xaa,%al
c0025cdd:	0f 94 c0             	sete   %al
c0025ce0:	e9 a2 fe ff ff       	jmp    c0025b87 <ide_init+0x2e0>
      select_device (&c->devices[0]);
c0025ce5:	b8 58 e2 03 c0       	mov    $0xc003e258,%eax
c0025cea:	e8 55 f7 ff ff       	call   c0025444 <select_device>
      wait_while_busy (&c->devices[0]); 
c0025cef:	b8 58 e2 03 c0       	mov    $0xc003e258,%eax
c0025cf4:	e8 8a f8 ff ff       	call   c0025583 <wait_while_busy>
c0025cf9:	e9 f1 fe ff ff       	jmp    c0025bef <ide_init+0x348>
      select_device (&c->devices[1]);
c0025cfe:	b8 6c e2 03 c0       	mov    $0xc003e26c,%eax
c0025d03:	e8 3c f7 ff ff       	call   c0025444 <select_device>
c0025d08:	bb b8 0b 00 00       	mov    $0xbb8,%ebx
c0025d0d:	eb 12                	jmp    c0025d21 <ide_init+0x47a>
          timer_msleep (10);
c0025d0f:	83 ec 08             	sub    $0x8,%esp
c0025d12:	6a 00                	push   $0x0
c0025d14:	6a 0a                	push   $0xa
c0025d16:	e8 2d e6 ff ff       	call   c0024348 <timer_msleep>
      for (i = 0; i < 3000; i++) 
c0025d1b:	83 c4 10             	add    $0x10,%esp
c0025d1e:	4b                   	dec    %ebx
c0025d1f:	74 16                	je     c0025d37 <ide_init+0x490>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025d21:	8b 0d 08 e2 03 c0    	mov    0xc003e208,%ecx
c0025d27:	8d 51 02             	lea    0x2(%ecx),%edx
c0025d2a:	ec                   	in     (%dx),%al
c0025d2b:	3c 01                	cmp    $0x1,%al
c0025d2d:	75 e0                	jne    c0025d0f <ide_init+0x468>
c0025d2f:	8d 51 03             	lea    0x3(%ecx),%edx
c0025d32:	ec                   	in     (%dx),%al
c0025d33:	3c 01                	cmp    $0x1,%al
c0025d35:	75 d8                	jne    c0025d0f <ide_init+0x468>
      wait_while_busy (&c->devices[1]);
c0025d37:	b8 6c e2 03 c0       	mov    $0xc003e26c,%eax
c0025d3c:	e8 42 f8 ff ff       	call   c0025583 <wait_while_busy>
c0025d41:	e9 b4 fe ff ff       	jmp    c0025bfa <ide_init+0x353>
        check_device_type (&c->devices[1]);
c0025d46:	b8 6c e2 03 c0       	mov    $0xc003e26c,%eax
c0025d4b:	e8 27 f7 ff ff       	call   c0025477 <check_device_type>
c0025d50:	e9 b7 fe ff ff       	jmp    c0025c0c <ide_init+0x365>
          identify_ata_device (&c->devices[dev_no]);
c0025d55:	b8 58 e2 03 c0       	mov    $0xc003e258,%eax
c0025d5a:	e8 81 f9 ff ff       	call   c00256e0 <identify_ata_device>
c0025d5f:	e9 b5 fe ff ff       	jmp    c0025c19 <ide_init+0x372>
c0025d64:	b8 6c e2 03 c0       	mov    $0xc003e26c,%eax
c0025d69:	e8 72 f9 ff ff       	call   c00256e0 <identify_ata_device>
}
c0025d6e:	e9 b3 fe ff ff       	jmp    c0025c26 <ide_init+0x37f>

c0025d73 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0025d73:	83 ec 18             	sub    $0x18,%esp
  intq_init (&buffer);
c0025d76:	68 80 e2 03 c0       	push   $0xc003e280
c0025d7b:	e8 77 01 00 00       	call   c0025ef7 <intq_init>
}
c0025d80:	83 c4 1c             	add    $0x1c,%esp
c0025d83:	c3                   	ret    

c0025d84 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0025d84:	53                   	push   %ebx
c0025d85:	83 ec 08             	sub    $0x8,%esp
c0025d88:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025d8c:	e8 8d bc ff ff       	call   c0021a1e <intr_get_level>
c0025d91:	85 c0                	test   %eax,%eax
c0025d93:	75 2f                	jne    c0025dc4 <input_putc+0x40>
  ASSERT (!intq_full (&buffer));
c0025d95:	83 ec 0c             	sub    $0xc,%esp
c0025d98:	68 80 e2 03 c0       	push   $0xc003e280
c0025d9d:	e8 c7 01 00 00       	call   c0025f69 <intq_full>
c0025da2:	83 c4 10             	add    $0x10,%esp
c0025da5:	84 c0                	test   %al,%al
c0025da7:	75 39                	jne    c0025de2 <input_putc+0x5e>

  intq_putc (&buffer, key);
c0025da9:	83 ec 08             	sub    $0x8,%esp
c0025dac:	0f b6 db             	movzbl %bl,%ebx
c0025daf:	53                   	push   %ebx
c0025db0:	68 80 e2 03 c0       	push   $0xc003e280
c0025db5:	e8 0c 04 00 00       	call   c00261c6 <intq_putc>
  serial_notify ();
c0025dba:	e8 5e ed ff ff       	call   c0024b1d <serial_notify>
}
c0025dbf:	83 c4 18             	add    $0x18,%esp
c0025dc2:	5b                   	pop    %ebx
c0025dc3:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025dc4:	83 ec 0c             	sub    $0xc,%esp
c0025dc7:	68 f6 12 03 c0       	push   $0xc00312f6
c0025dcc:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0025dd1:	68 38 ff 02 c0       	push   $0xc002ff38
c0025dd6:	6a 15                	push   $0x15
c0025dd8:	68 dc 24 03 c0       	push   $0xc00324dc
c0025ddd:	e8 9b 28 00 00       	call   c002867d <debug_panic>
  ASSERT (!intq_full (&buffer));
c0025de2:	83 ec 0c             	sub    $0xc,%esp
c0025de5:	68 f2 24 03 c0       	push   $0xc00324f2
c0025dea:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0025def:	68 38 ff 02 c0       	push   $0xc002ff38
c0025df4:	6a 16                	push   $0x16
c0025df6:	68 dc 24 03 c0       	push   $0xc00324dc
c0025dfb:	e8 7d 28 00 00       	call   c002867d <debug_panic>

c0025e00 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0025e00:	56                   	push   %esi
c0025e01:	53                   	push   %ebx
c0025e02:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0025e05:	e8 51 bc ff ff       	call   c0021a5b <intr_disable>
c0025e0a:	89 c6                	mov    %eax,%esi
  key = intq_getc (&buffer);
c0025e0c:	83 ec 0c             	sub    $0xc,%esp
c0025e0f:	68 80 e2 03 c0       	push   $0xc003e280
c0025e14:	e8 f2 02 00 00       	call   c002610b <intq_getc>
c0025e19:	88 c3                	mov    %al,%bl
  serial_notify ();
c0025e1b:	e8 fd ec ff ff       	call   c0024b1d <serial_notify>
  intr_set_level (old_level);
c0025e20:	89 34 24             	mov    %esi,(%esp)
c0025e23:	e8 3a bc ff ff       	call   c0021a62 <intr_set_level>
  
  return key;
}
c0025e28:	88 d8                	mov    %bl,%al
c0025e2a:	83 c4 14             	add    $0x14,%esp
c0025e2d:	5b                   	pop    %ebx
c0025e2e:	5e                   	pop    %esi
c0025e2f:	c3                   	ret    

c0025e30 <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0025e30:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0025e33:	e8 e6 bb ff ff       	call   c0021a1e <intr_get_level>
c0025e38:	85 c0                	test   %eax,%eax
c0025e3a:	75 11                	jne    c0025e4d <input_full+0x1d>
  return intq_full (&buffer);
c0025e3c:	83 ec 0c             	sub    $0xc,%esp
c0025e3f:	68 80 e2 03 c0       	push   $0xc003e280
c0025e44:	e8 20 01 00 00       	call   c0025f69 <intq_full>
}
c0025e49:	83 c4 1c             	add    $0x1c,%esp
c0025e4c:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025e4d:	83 ec 0c             	sub    $0xc,%esp
c0025e50:	68 f6 12 03 c0       	push   $0xc00312f6
c0025e55:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0025e5a:	68 2c ff 02 c0       	push   $0xc002ff2c
c0025e5f:	6a 32                	push   $0x32
c0025e61:	68 dc 24 03 c0       	push   $0xc00324dc
c0025e66:	e8 12 28 00 00       	call   c002867d <debug_panic>

c0025e6b <input_getline>:

/*
 * read a line from input
 */
void
input_getline(char *str, int max_len) {
c0025e6b:	55                   	push   %ebp
c0025e6c:	57                   	push   %edi
c0025e6d:	56                   	push   %esi
c0025e6e:	53                   	push   %ebx
c0025e6f:	83 ec 0c             	sub    $0xc,%esp
c0025e72:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025e76:	8b 7c 24 24          	mov    0x24(%esp),%edi
  int len = 0;
c0025e7a:	be 00 00 00 00       	mov    $0x0,%esi
c0025e7f:	eb 2d                	jmp    c0025eae <input_getline+0x43>
  do {
    char ch = input_getc();
    bool done = false;
    switch (ch) {
c0025e81:	3c 0d                	cmp    $0xd,%al
c0025e83:	74 3f                	je     c0025ec4 <input_getline+0x59>
          putbuf("\b \b", 3);
          len--;
        }
        break;
      default:
        if (ch == 0x09 || (ch >= 0x20 && ch <= 0x7E)) {
c0025e85:	80 fb 09             	cmp    $0x9,%bl
c0025e88:	74 07                	je     c0025e91 <input_getline+0x26>
c0025e8a:	8d 43 e0             	lea    -0x20(%ebx),%eax
c0025e8d:	3c 5e                	cmp    $0x5e,%al
c0025e8f:	77 16                	ja     c0025ea7 <input_getline+0x3c>
          putchar(ch);
c0025e91:	83 ec 0c             	sub    $0xc,%esp
    switch (ch) {
c0025e94:	0f be c3             	movsbl %bl,%eax
          putchar(ch);
c0025e97:	50                   	push   %eax
c0025e98:	e8 33 43 00 00       	call   c002a1d0 <putchar>
          str[len++] = ch;
c0025e9d:	88 5c 35 00          	mov    %bl,0x0(%ebp,%esi,1)
c0025ea1:	83 c4 10             	add    $0x10,%esp
c0025ea4:	8d 76 01             	lea    0x1(%esi),%esi
        }
        break;
    }
    if (done || len + 1 >= max_len) {
c0025ea7:	8d 46 01             	lea    0x1(%esi),%eax
c0025eaa:	39 f8                	cmp    %edi,%eax
c0025eac:	7d 16                	jge    c0025ec4 <input_getline+0x59>
    char ch = input_getc();
c0025eae:	e8 4d ff ff ff       	call   c0025e00 <input_getc>
c0025eb3:	88 c3                	mov    %al,%bl
    switch (ch) {
c0025eb5:	3c 08                	cmp    $0x8,%al
c0025eb7:	74 25                	je     c0025ede <input_getline+0x73>
c0025eb9:	3c 08                	cmp    $0x8,%al
c0025ebb:	77 c4                	ja     c0025e81 <input_getline+0x16>
c0025ebd:	8d 43 fd             	lea    -0x3(%ebx),%eax
c0025ec0:	3c 01                	cmp    $0x1,%al
c0025ec2:	77 c1                	ja     c0025e85 <input_getline+0x1a>
      putchar('\n');
c0025ec4:	83 ec 0c             	sub    $0xc,%esp
c0025ec7:	6a 0a                	push   $0xa
c0025ec9:	e8 02 43 00 00       	call   c002a1d0 <putchar>
      break;
    }
  } while (true);
  str[len] = '\0';
c0025ece:	c6 44 35 00 00       	movb   $0x0,0x0(%ebp,%esi,1)
c0025ed3:	83 c4 10             	add    $0x10,%esp
c0025ed6:	83 c4 0c             	add    $0xc,%esp
c0025ed9:	5b                   	pop    %ebx
c0025eda:	5e                   	pop    %esi
c0025edb:	5f                   	pop    %edi
c0025edc:	5d                   	pop    %ebp
c0025edd:	c3                   	ret    
        if (len > 0) {
c0025ede:	85 f6                	test   %esi,%esi
c0025ee0:	7e c5                	jle    c0025ea7 <input_getline+0x3c>
          putbuf("\b \b", 3);
c0025ee2:	83 ec 08             	sub    $0x8,%esp
c0025ee5:	6a 03                	push   $0x3
c0025ee7:	68 07 25 03 c0       	push   $0xc0032507
c0025eec:	e8 ae 42 00 00       	call   c002a19f <putbuf>
          len--;
c0025ef1:	4e                   	dec    %esi
c0025ef2:	83 c4 10             	add    $0x10,%esp
c0025ef5:	eb b0                	jmp    c0025ea7 <input_getline+0x3c>

c0025ef7 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c0025ef7:	53                   	push   %ebx
c0025ef8:	83 ec 14             	sub    $0x14,%esp
c0025efb:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_init (&q->lock);
c0025eff:	53                   	push   %ebx
c0025f00:	e8 5a ce ff ff       	call   c0022d5f <lock_init>
  q->not_full = q->not_empty = NULL;
c0025f05:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
c0025f0c:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  q->head = q->tail = 0;
c0025f13:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
c0025f1a:	00 00 00 
c0025f1d:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
}
c0025f24:	83 c4 18             	add    $0x18,%esp
c0025f27:	5b                   	pop    %ebx
c0025f28:	c3                   	ret    

c0025f29 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0025f29:	53                   	push   %ebx
c0025f2a:	83 ec 08             	sub    $0x8,%esp
c0025f2d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025f31:	e8 e8 ba ff ff       	call   c0021a1e <intr_get_level>
c0025f36:	85 c0                	test   %eax,%eax
c0025f38:	75 11                	jne    c0025f4b <intq_empty+0x22>
  return q->head == q->tail;
c0025f3a:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
c0025f40:	39 43 7c             	cmp    %eax,0x7c(%ebx)
c0025f43:	0f 94 c0             	sete   %al
}
c0025f46:	83 c4 08             	add    $0x8,%esp
c0025f49:	5b                   	pop    %ebx
c0025f4a:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025f4b:	83 ec 0c             	sub    $0xc,%esp
c0025f4e:	68 f6 12 03 c0       	push   $0xc00312f6
c0025f53:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0025f58:	68 78 ff 02 c0       	push   $0xc002ff78
c0025f5d:	6a 16                	push   $0x16
c0025f5f:	68 0b 25 03 c0       	push   $0xc003250b
c0025f64:	e8 14 27 00 00       	call   c002867d <debug_panic>

c0025f69 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c0025f69:	53                   	push   %ebx
c0025f6a:	83 ec 08             	sub    $0x8,%esp
c0025f6d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025f71:	e8 a8 ba ff ff       	call   c0021a1e <intr_get_level>
c0025f76:	85 c0                	test   %eax,%eax
c0025f78:	75 19                	jne    c0025f93 <intq_full+0x2a>

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
  return (pos + 1) % INTQ_BUFSIZE;
c0025f7a:	8b 43 7c             	mov    0x7c(%ebx),%eax
c0025f7d:	40                   	inc    %eax
c0025f7e:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0025f83:	78 2c                	js     c0025fb1 <intq_full+0x48>
  return next (q->head) == q->tail;
c0025f85:	3b 83 80 00 00 00    	cmp    0x80(%ebx),%eax
c0025f8b:	0f 94 c0             	sete   %al
}
c0025f8e:	83 c4 08             	add    $0x8,%esp
c0025f91:	5b                   	pop    %ebx
c0025f92:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0025f93:	83 ec 0c             	sub    $0xc,%esp
c0025f96:	68 f6 12 03 c0       	push   $0xc00312f6
c0025f9b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0025fa0:	68 6c ff 02 c0       	push   $0xc002ff6c
c0025fa5:	6a 1e                	push   $0x1e
c0025fa7:	68 0b 25 03 c0       	push   $0xc003250b
c0025fac:	e8 cc 26 00 00       	call   c002867d <debug_panic>
  return (pos + 1) % INTQ_BUFSIZE;
c0025fb1:	48                   	dec    %eax
c0025fb2:	83 c8 c0             	or     $0xffffffc0,%eax
c0025fb5:	40                   	inc    %eax
c0025fb6:	eb cd                	jmp    c0025f85 <intq_full+0x1c>

c0025fb8 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0025fb8:	56                   	push   %esi
c0025fb9:	53                   	push   %ebx
c0025fba:	83 ec 04             	sub    $0x4,%esp
c0025fbd:	89 c3                	mov    %eax,%ebx
c0025fbf:	89 d6                	mov    %edx,%esi
  ASSERT (!intr_context ());
c0025fc1:	e8 b6 bc ff ff       	call   c0021c7c <intr_context>
c0025fc6:	84 c0                	test   %al,%al
c0025fc8:	75 39                	jne    c0026003 <wait+0x4b>
  ASSERT (intr_get_level () == INTR_OFF);
c0025fca:	e8 4f ba ff ff       	call   c0021a1e <intr_get_level>
c0025fcf:	85 c0                	test   %eax,%eax
c0025fd1:	75 4e                	jne    c0026021 <wait+0x69>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0025fd3:	8d 43 38             	lea    0x38(%ebx),%eax
c0025fd6:	39 c6                	cmp    %eax,%esi
c0025fd8:	74 65                	je     c002603f <wait+0x87>
c0025fda:	8d 43 34             	lea    0x34(%ebx),%eax
c0025fdd:	39 c6                	cmp    %eax,%esi
c0025fdf:	75 70                	jne    c0026051 <wait+0x99>
c0025fe1:	83 ec 0c             	sub    $0xc,%esp
c0025fe4:	53                   	push   %ebx
c0025fe5:	e8 7f ff ff ff       	call   c0025f69 <intq_full>
c0025fea:	83 c4 10             	add    $0x10,%esp
c0025fed:	84 c0                	test   %al,%al
c0025fef:	74 60                	je     c0026051 <wait+0x99>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0025ff1:	e8 20 ad ff ff       	call   c0020d16 <thread_current>
c0025ff6:	89 06                	mov    %eax,(%esi)
  thread_block ();
c0025ff8:	e8 5a b4 ff ff       	call   c0021457 <thread_block>
}
c0025ffd:	83 c4 04             	add    $0x4,%esp
c0026000:	5b                   	pop    %ebx
c0026001:	5e                   	pop    %esi
c0026002:	c3                   	ret    
  ASSERT (!intr_context ());
c0026003:	83 ec 0c             	sub    $0xc,%esp
c0026006:	68 c0 13 03 c0       	push   $0xc00313c0
c002600b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0026010:	68 58 ff 02 c0       	push   $0xc002ff58
c0026015:	6a 59                	push   $0x59
c0026017:	68 0b 25 03 c0       	push   $0xc003250b
c002601c:	e8 5c 26 00 00       	call   c002867d <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0026021:	83 ec 0c             	sub    $0xc,%esp
c0026024:	68 f6 12 03 c0       	push   $0xc00312f6
c0026029:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002602e:	68 58 ff 02 c0       	push   $0xc002ff58
c0026033:	6a 5a                	push   $0x5a
c0026035:	68 0b 25 03 c0       	push   $0xc003250b
c002603a:	e8 3e 26 00 00       	call   c002867d <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c002603f:	83 ec 0c             	sub    $0xc,%esp
c0026042:	53                   	push   %ebx
c0026043:	e8 e1 fe ff ff       	call   c0025f29 <intq_empty>
c0026048:	83 c4 10             	add    $0x10,%esp
c002604b:	84 c0                	test   %al,%al
c002604d:	74 8b                	je     c0025fda <wait+0x22>
c002604f:	eb a0                	jmp    c0025ff1 <wait+0x39>
c0026051:	83 ec 0c             	sub    $0xc,%esp
c0026054:	68 20 25 03 c0       	push   $0xc0032520
c0026059:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002605e:	68 58 ff 02 c0       	push   $0xc002ff58
c0026063:	6a 5c                	push   $0x5c
c0026065:	68 0b 25 03 c0       	push   $0xc003250b
c002606a:	e8 0e 26 00 00       	call   c002867d <debug_panic>

c002606f <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c002606f:	56                   	push   %esi
c0026070:	53                   	push   %ebx
c0026071:	83 ec 04             	sub    $0x4,%esp
c0026074:	89 c6                	mov    %eax,%esi
c0026076:	89 d3                	mov    %edx,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0026078:	e8 a1 b9 ff ff       	call   c0021a1e <intr_get_level>
c002607d:	85 c0                	test   %eax,%eax
c002607f:	75 3c                	jne    c00260bd <signal+0x4e>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026081:	8d 46 38             	lea    0x38(%esi),%eax
c0026084:	39 c3                	cmp    %eax,%ebx
c0026086:	74 53                	je     c00260db <signal+0x6c>
c0026088:	8d 46 34             	lea    0x34(%esi),%eax
c002608b:	39 c3                	cmp    %eax,%ebx
c002608d:	75 5e                	jne    c00260ed <signal+0x7e>
c002608f:	83 ec 0c             	sub    $0xc,%esp
c0026092:	56                   	push   %esi
c0026093:	e8 d1 fe ff ff       	call   c0025f69 <intq_full>
c0026098:	83 c4 10             	add    $0x10,%esp
c002609b:	84 c0                	test   %al,%al
c002609d:	75 4e                	jne    c00260ed <signal+0x7e>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c002609f:	8b 03                	mov    (%ebx),%eax
c00260a1:	85 c0                	test   %eax,%eax
c00260a3:	74 12                	je     c00260b7 <signal+0x48>
    {
      thread_unblock (*waiter);
c00260a5:	83 ec 0c             	sub    $0xc,%esp
c00260a8:	50                   	push   %eax
c00260a9:	e8 25 ae ff ff       	call   c0020ed3 <thread_unblock>
      *waiter = NULL;
c00260ae:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
c00260b4:	83 c4 10             	add    $0x10,%esp
    }
}
c00260b7:	83 c4 04             	add    $0x4,%esp
c00260ba:	5b                   	pop    %ebx
c00260bb:	5e                   	pop    %esi
c00260bc:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00260bd:	83 ec 0c             	sub    $0xc,%esp
c00260c0:	68 f6 12 03 c0       	push   $0xc00312f6
c00260c5:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00260ca:	68 50 ff 02 c0       	push   $0xc002ff50
c00260cf:	6a 69                	push   $0x69
c00260d1:	68 0b 25 03 c0       	push   $0xc003250b
c00260d6:	e8 a2 25 00 00       	call   c002867d <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c00260db:	83 ec 0c             	sub    $0xc,%esp
c00260de:	56                   	push   %esi
c00260df:	e8 45 fe ff ff       	call   c0025f29 <intq_empty>
c00260e4:	83 c4 10             	add    $0x10,%esp
c00260e7:	84 c0                	test   %al,%al
c00260e9:	74 b4                	je     c002609f <signal+0x30>
c00260eb:	eb 9b                	jmp    c0026088 <signal+0x19>
c00260ed:	83 ec 0c             	sub    $0xc,%esp
c00260f0:	68 7c 25 03 c0       	push   $0xc003257c
c00260f5:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00260fa:	68 50 ff 02 c0       	push   $0xc002ff50
c00260ff:	6a 6b                	push   $0x6b
c0026101:	68 0b 25 03 c0       	push   $0xc003250b
c0026106:	e8 72 25 00 00       	call   c002867d <debug_panic>

c002610b <intq_getc>:
{
c002610b:	56                   	push   %esi
c002610c:	53                   	push   %ebx
c002610d:	83 ec 04             	sub    $0x4,%esp
c0026110:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0026114:	e8 05 b9 ff ff       	call   c0021a1e <intr_get_level>
c0026119:	85 c0                	test   %eax,%eax
c002611b:	75 3b                	jne    c0026158 <intq_getc+0x4d>
      wait (q, &q->not_empty);
c002611d:	8d 73 38             	lea    0x38(%ebx),%esi
  while (intq_empty (q)) 
c0026120:	83 ec 0c             	sub    $0xc,%esp
c0026123:	53                   	push   %ebx
c0026124:	e8 00 fe ff ff       	call   c0025f29 <intq_empty>
c0026129:	83 c4 10             	add    $0x10,%esp
c002612c:	84 c0                	test   %al,%al
c002612e:	74 64                	je     c0026194 <intq_getc+0x89>
      ASSERT (!intr_context ());
c0026130:	e8 47 bb ff ff       	call   c0021c7c <intr_context>
c0026135:	84 c0                	test   %al,%al
c0026137:	75 3d                	jne    c0026176 <intq_getc+0x6b>
      lock_acquire (&q->lock);
c0026139:	83 ec 0c             	sub    $0xc,%esp
c002613c:	53                   	push   %ebx
c002613d:	e8 91 cd ff ff       	call   c0022ed3 <lock_acquire>
      wait (q, &q->not_empty);
c0026142:	89 f2                	mov    %esi,%edx
c0026144:	89 d8                	mov    %ebx,%eax
c0026146:	e8 6d fe ff ff       	call   c0025fb8 <wait>
      lock_release (&q->lock);
c002614b:	89 1c 24             	mov    %ebx,(%esp)
c002614e:	e8 1d cf ff ff       	call   c0023070 <lock_release>
c0026153:	83 c4 10             	add    $0x10,%esp
c0026156:	eb c8                	jmp    c0026120 <intq_getc+0x15>
  ASSERT (intr_get_level () == INTR_OFF);
c0026158:	83 ec 0c             	sub    $0xc,%esp
c002615b:	68 f6 12 03 c0       	push   $0xc00312f6
c0026160:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0026165:	68 60 ff 02 c0       	push   $0xc002ff60
c002616a:	6a 2a                	push   $0x2a
c002616c:	68 0b 25 03 c0       	push   $0xc003250b
c0026171:	e8 07 25 00 00       	call   c002867d <debug_panic>
      ASSERT (!intr_context ());
c0026176:	83 ec 0c             	sub    $0xc,%esp
c0026179:	68 c0 13 03 c0       	push   $0xc00313c0
c002617e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0026183:	68 60 ff 02 c0       	push   $0xc002ff60
c0026188:	6a 2d                	push   $0x2d
c002618a:	68 0b 25 03 c0       	push   $0xc003250b
c002618f:	e8 e9 24 00 00       	call   c002867d <debug_panic>
  byte = q->buf[q->tail];
c0026194:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
c002619a:	0f b6 74 03 3c       	movzbl 0x3c(%ebx,%eax,1),%esi
  return (pos + 1) % INTQ_BUFSIZE;
c002619f:	40                   	inc    %eax
c00261a0:	25 3f 00 00 80       	and    $0x8000003f,%eax
c00261a5:	78 18                	js     c00261bf <intq_getc+0xb4>
  q->tail = next (q->tail);
c00261a7:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
  signal (q, &q->not_full);
c00261ad:	8d 53 34             	lea    0x34(%ebx),%edx
c00261b0:	89 d8                	mov    %ebx,%eax
c00261b2:	e8 b8 fe ff ff       	call   c002606f <signal>
}
c00261b7:	89 f0                	mov    %esi,%eax
c00261b9:	83 c4 04             	add    $0x4,%esp
c00261bc:	5b                   	pop    %ebx
c00261bd:	5e                   	pop    %esi
c00261be:	c3                   	ret    
  return (pos + 1) % INTQ_BUFSIZE;
c00261bf:	48                   	dec    %eax
c00261c0:	83 c8 c0             	or     $0xffffffc0,%eax
c00261c3:	40                   	inc    %eax
c00261c4:	eb e1                	jmp    c00261a7 <intq_getc+0x9c>

c00261c6 <intq_putc>:
{
c00261c6:	57                   	push   %edi
c00261c7:	56                   	push   %esi
c00261c8:	53                   	push   %ebx
c00261c9:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00261cd:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c00261d1:	e8 48 b8 ff ff       	call   c0021a1e <intr_get_level>
c00261d6:	85 c0                	test   %eax,%eax
c00261d8:	75 3b                	jne    c0026215 <intq_putc+0x4f>
      wait (q, &q->not_full);
c00261da:	8d 73 34             	lea    0x34(%ebx),%esi
  while (intq_full (q))
c00261dd:	83 ec 0c             	sub    $0xc,%esp
c00261e0:	53                   	push   %ebx
c00261e1:	e8 83 fd ff ff       	call   c0025f69 <intq_full>
c00261e6:	83 c4 10             	add    $0x10,%esp
c00261e9:	84 c0                	test   %al,%al
c00261eb:	74 64                	je     c0026251 <intq_putc+0x8b>
      ASSERT (!intr_context ());
c00261ed:	e8 8a ba ff ff       	call   c0021c7c <intr_context>
c00261f2:	84 c0                	test   %al,%al
c00261f4:	75 3d                	jne    c0026233 <intq_putc+0x6d>
      lock_acquire (&q->lock);
c00261f6:	83 ec 0c             	sub    $0xc,%esp
c00261f9:	53                   	push   %ebx
c00261fa:	e8 d4 cc ff ff       	call   c0022ed3 <lock_acquire>
      wait (q, &q->not_full);
c00261ff:	89 f2                	mov    %esi,%edx
c0026201:	89 d8                	mov    %ebx,%eax
c0026203:	e8 b0 fd ff ff       	call   c0025fb8 <wait>
      lock_release (&q->lock);
c0026208:	89 1c 24             	mov    %ebx,(%esp)
c002620b:	e8 60 ce ff ff       	call   c0023070 <lock_release>
c0026210:	83 c4 10             	add    $0x10,%esp
c0026213:	eb c8                	jmp    c00261dd <intq_putc+0x17>
  ASSERT (intr_get_level () == INTR_OFF);
c0026215:	83 ec 0c             	sub    $0xc,%esp
c0026218:	68 f6 12 03 c0       	push   $0xc00312f6
c002621d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0026222:	68 44 ff 02 c0       	push   $0xc002ff44
c0026227:	6a 3f                	push   $0x3f
c0026229:	68 0b 25 03 c0       	push   $0xc003250b
c002622e:	e8 4a 24 00 00       	call   c002867d <debug_panic>
      ASSERT (!intr_context ());
c0026233:	83 ec 0c             	sub    $0xc,%esp
c0026236:	68 c0 13 03 c0       	push   $0xc00313c0
c002623b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0026240:	68 44 ff 02 c0       	push   $0xc002ff44
c0026245:	6a 42                	push   $0x42
c0026247:	68 0b 25 03 c0       	push   $0xc003250b
c002624c:	e8 2c 24 00 00       	call   c002867d <debug_panic>
  q->buf[q->head] = byte;
c0026251:	8b 43 7c             	mov    0x7c(%ebx),%eax
c0026254:	89 f9                	mov    %edi,%ecx
c0026256:	88 4c 03 3c          	mov    %cl,0x3c(%ebx,%eax,1)
  return (pos + 1) % INTQ_BUFSIZE;
c002625a:	40                   	inc    %eax
c002625b:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0026260:	78 11                	js     c0026273 <intq_putc+0xad>
  q->head = next (q->head);
c0026262:	89 43 7c             	mov    %eax,0x7c(%ebx)
  signal (q, &q->not_empty);
c0026265:	8d 53 38             	lea    0x38(%ebx),%edx
c0026268:	89 d8                	mov    %ebx,%eax
c002626a:	e8 00 fe ff ff       	call   c002606f <signal>
}
c002626f:	5b                   	pop    %ebx
c0026270:	5e                   	pop    %esi
c0026271:	5f                   	pop    %edi
c0026272:	c3                   	ret    
  return (pos + 1) % INTQ_BUFSIZE;
c0026273:	48                   	dec    %eax
c0026274:	83 c8 c0             	or     $0xffffffc0,%eax
c0026277:	40                   	inc    %eax
c0026278:	eb e8                	jmp    c0026262 <intq_putc+0x9c>

c002627a <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c002627a:	55                   	push   %ebp
c002627b:	57                   	push   %edi
c002627c:	56                   	push   %esi
c002627d:	53                   	push   %ebx
c002627e:	83 ec 18             	sub    $0x18,%esp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026281:	bf 00 00 00 00       	mov    $0x0,%edi
c0026286:	89 f8                	mov    %edi,%eax
c0026288:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002628a:	e4 71                	in     $0x71,%al
c002628c:	88 c2                	mov    %al,%dl
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002628e:	b0 02                	mov    $0x2,%al
c0026290:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026292:	e4 71                	in     $0x71,%al
c0026294:	88 04 24             	mov    %al,(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026297:	b0 04                	mov    $0x4,%al
c0026299:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002629b:	e4 71                	in     $0x71,%al
c002629d:	88 44 24 13          	mov    %al,0x13(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00262a1:	b0 07                	mov    $0x7,%al
c00262a3:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00262a5:	e4 71                	in     $0x71,%al
c00262a7:	89 c5                	mov    %eax,%ebp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00262a9:	b0 08                	mov    $0x8,%al
c00262ab:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00262ad:	e4 71                	in     $0x71,%al
c00262af:	88 c3                	mov    %al,%bl
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00262b1:	b0 09                	mov    $0x9,%al
c00262b3:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00262b5:	e4 71                	in     $0x71,%al
c00262b7:	89 c6                	mov    %eax,%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00262b9:	89 f8                	mov    %edi,%eax
c00262bb:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00262bd:	e4 71                	in     $0x71,%al

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c00262bf:	88 c1                	mov    %al,%cl
c00262c1:	c0 e9 04             	shr    $0x4,%cl
c00262c4:	0f b6 c9             	movzbl %cl,%ecx
c00262c7:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c00262ca:	01 c9                	add    %ecx,%ecx
c00262cc:	83 e0 0f             	and    $0xf,%eax
c00262cf:	01 c8                	add    %ecx,%eax
c00262d1:	88 d1                	mov    %dl,%cl
c00262d3:	c0 e9 04             	shr    $0x4,%cl
c00262d6:	0f b6 c9             	movzbl %cl,%ecx
c00262d9:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c00262dc:	01 c9                	add    %ecx,%ecx
c00262de:	83 e2 0f             	and    $0xf,%edx
c00262e1:	01 ca                	add    %ecx,%edx
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c00262e3:	39 d0                	cmp    %edx,%eax
c00262e5:	75 9f                	jne    c0026286 <rtc_get_time+0xc>
  return (x & 0x0f) + ((x >> 4) * 10);
c00262e7:	89 f2                	mov    %esi,%edx
c00262e9:	c0 ea 04             	shr    $0x4,%dl
c00262ec:	0f b6 d2             	movzbl %dl,%edx
c00262ef:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00262f2:	01 d2                	add    %edx,%edx
c00262f4:	83 e6 0f             	and    $0xf,%esi
c00262f7:	01 d6                	add    %edx,%esi
  if (year < 70)
c00262f9:	83 fe 45             	cmp    $0x45,%esi
c00262fc:	7f 03                	jg     c0026301 <rtc_get_time+0x87>
    year += 100;
c00262fe:	83 c6 64             	add    $0x64,%esi
  return (x & 0x0f) + ((x >> 4) * 10);
c0026301:	88 da                	mov    %bl,%dl
c0026303:	c0 ea 04             	shr    $0x4,%dl
c0026306:	0f b6 d2             	movzbl %dl,%edx
c0026309:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002630c:	01 d2                	add    %edx,%edx
c002630e:	83 e3 0f             	and    $0xf,%ebx
c0026311:	01 d3                	add    %edx,%ebx
  year -= 70;
c0026313:	8d 7e ba             	lea    -0x46(%esi),%edi
c0026316:	89 7c 24 14          	mov    %edi,0x14(%esp)
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c002631a:	83 ee 47             	sub    $0x47,%esi
c002631d:	89 f2                	mov    %esi,%edx
c002631f:	85 f6                	test   %esi,%esi
c0026321:	0f 88 de 00 00 00    	js     c0026405 <rtc_get_time+0x18b>
c0026327:	c1 fa 02             	sar    $0x2,%edx
c002632a:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002632e:	8d 0c ff             	lea    (%edi,%edi,8),%ecx
c0026331:	8d 0c cf             	lea    (%edi,%ecx,8),%ecx
c0026334:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026337:	01 ca                	add    %ecx,%edx
c0026339:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c002633c:	8d 0c 8a             	lea    (%edx,%ecx,4),%ecx
c002633f:	8d 3c ca             	lea    (%edx,%ecx,8),%edi
c0026342:	c1 e7 02             	shl    $0x2,%edi
c0026345:	29 d7                	sub    %edx,%edi
c0026347:	c1 e7 07             	shl    $0x7,%edi
  for (i = 1; i <= mon; i++)
c002634a:	85 db                	test   %ebx,%ebx
c002634c:	7e 24                	jle    c0026372 <rtc_get_time+0xf8>
c002634e:	be 01 00 00 00       	mov    $0x1,%esi
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0026353:	8b 0c b5 9c ff 02 c0 	mov    -0x3ffd0064(,%esi,4),%ecx
c002635a:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
c002635d:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c0026360:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
c0026363:	c1 e2 02             	shl    $0x2,%edx
c0026366:	29 ca                	sub    %ecx,%edx
c0026368:	c1 e2 07             	shl    $0x7,%edx
c002636b:	01 d7                	add    %edx,%edi
  for (i = 1; i <= mon; i++)
c002636d:	46                   	inc    %esi
c002636e:	39 de                	cmp    %ebx,%esi
c0026370:	7e e1                	jle    c0026353 <rtc_get_time+0xd9>
  if (mon > 2 && year % 4 == 0)
c0026372:	83 fb 02             	cmp    $0x2,%ebx
c0026375:	7e 0d                	jle    c0026384 <rtc_get_time+0x10a>
c0026377:	f6 44 24 14 03       	testb  $0x3,0x14(%esp)
c002637c:	75 06                	jne    c0026384 <rtc_get_time+0x10a>
    time += 24 * 60 * 60;
c002637e:	81 c7 80 51 01 00    	add    $0x15180,%edi
  return (x & 0x0f) + ((x >> 4) * 10);
c0026384:	8a 5c 24 13          	mov    0x13(%esp),%bl
c0026388:	88 da                	mov    %bl,%dl
c002638a:	c0 ea 04             	shr    $0x4,%dl
c002638d:	0f b6 d2             	movzbl %dl,%edx
c0026390:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026393:	01 c9                	add    %ecx,%ecx
c0026395:	89 da                	mov    %ebx,%edx
c0026397:	83 e2 0f             	and    $0xf,%edx
c002639a:	01 ca                	add    %ecx,%edx
  time += hour * 60 * 60;
c002639c:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
c002639f:	01 d1                	add    %edx,%ecx
c00263a1:	01 c9                	add    %ecx,%ecx
c00263a3:	01 d1                	add    %edx,%ecx
c00263a5:	c1 e1 05             	shl    $0x5,%ecx
c00263a8:	01 d1                	add    %edx,%ecx
c00263aa:	c1 e1 04             	shl    $0x4,%ecx
  return (x & 0x0f) + ((x >> 4) * 10);
c00263ad:	8a 14 24             	mov    (%esp),%dl
c00263b0:	c0 ea 04             	shr    $0x4,%dl
c00263b3:	0f b6 d2             	movzbl %dl,%edx
c00263b6:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00263b9:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
c00263bc:	8b 14 24             	mov    (%esp),%edx
c00263bf:	83 e2 0f             	and    $0xf,%edx
c00263c2:	01 da                	add    %ebx,%edx
  time += min * 60;
c00263c4:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
c00263c7:	01 da                	add    %ebx,%edx
c00263c9:	8d 14 92             	lea    (%edx,%edx,4),%edx
  time += sec;
c00263cc:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c00263cf:	01 d0                	add    %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c00263d1:	89 ea                	mov    %ebp,%edx
c00263d3:	c0 ea 04             	shr    $0x4,%dl
c00263d6:	0f b6 d2             	movzbl %dl,%edx
c00263d9:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00263dc:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
c00263df:	89 ea                	mov    %ebp,%edx
c00263e1:	83 e2 0f             	and    $0xf,%edx
  time += (mday - 1) * 24 * 60 * 60;
c00263e4:	8d 4c 11 ff          	lea    -0x1(%ecx,%edx,1),%ecx
c00263e8:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
c00263eb:	8d 14 91             	lea    (%ecx,%edx,4),%edx
c00263ee:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
c00263f1:	c1 e2 02             	shl    $0x2,%edx
c00263f4:	29 ca                	sub    %ecx,%edx
c00263f6:	c1 e2 07             	shl    $0x7,%edx
  time += sec;
c00263f9:	01 d0                	add    %edx,%eax
c00263fb:	01 f8                	add    %edi,%eax
}
c00263fd:	83 c4 18             	add    $0x18,%esp
c0026400:	5b                   	pop    %ebx
c0026401:	5e                   	pop    %esi
c0026402:	5f                   	pop    %edi
c0026403:	5d                   	pop    %ebp
c0026404:	c3                   	ret    
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026405:	8d 56 03             	lea    0x3(%esi),%edx
c0026408:	e9 1a ff ff ff       	jmp    c0026327 <rtc_get_time+0xad>

c002640d <shutdown_configure>:
/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
  how = type;
c002640d:	8b 44 24 04          	mov    0x4(%esp),%eax
c0026411:	a3 04 e3 03 c0       	mov    %eax,0xc003e304
c0026416:	c3                   	ret    

c0026417 <shutdown_reboot>:
}

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0026417:	56                   	push   %esi
c0026418:	53                   	push   %ebx
c0026419:	83 ec 10             	sub    $0x10,%esp
  printf ("Rebooting...\n");
c002641c:	68 d7 25 03 c0       	push   $0xc00325d7
c0026421:	e8 3e 3d 00 00       	call   c002a164 <puts>
c0026426:	83 c4 10             	add    $0x10,%esp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026429:	be fe ff ff ff       	mov    $0xfffffffe,%esi
c002642e:	eb 1f                	jmp    c002644f <shutdown_reboot+0x38>
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
          timer_udelay (2);
        }

      timer_udelay (50);
c0026430:	83 ec 08             	sub    $0x8,%esp
c0026433:	6a 00                	push   $0x0
c0026435:	6a 32                	push   $0x32
c0026437:	e8 70 df ff ff       	call   c00243ac <timer_udelay>
c002643c:	89 f0                	mov    %esi,%eax
c002643e:	e6 64                	out    %al,$0x64

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
      timer_udelay (50);
c0026440:	83 c4 08             	add    $0x8,%esp
c0026443:	6a 00                	push   $0x0
c0026445:	6a 32                	push   $0x32
c0026447:	e8 60 df ff ff       	call   c00243ac <timer_udelay>
    {
c002644c:	83 c4 10             	add    $0x10,%esp
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002644f:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026451:	a8 02                	test   $0x2,%al
c0026453:	74 db                	je     c0026430 <shutdown_reboot+0x19>
          timer_udelay (2);
c0026455:	83 ec 08             	sub    $0x8,%esp
c0026458:	6a 00                	push   $0x0
c002645a:	6a 02                	push   $0x2
c002645c:	e8 4b df ff ff       	call   c00243ac <timer_udelay>
c0026461:	83 c4 10             	add    $0x10,%esp
c0026464:	bb ff ff 00 00       	mov    $0xffff,%ebx
c0026469:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c002646b:	a8 02                	test   $0x2,%al
c002646d:	74 c1                	je     c0026430 <shutdown_reboot+0x19>
          timer_udelay (2);
c002646f:	83 ec 08             	sub    $0x8,%esp
c0026472:	6a 00                	push   $0x0
c0026474:	6a 02                	push   $0x2
c0026476:	e8 31 df ff ff       	call   c00243ac <timer_udelay>
      for (i = 0; i < 0x10000; i++)
c002647b:	83 c4 10             	add    $0x10,%esp
c002647e:	4b                   	dec    %ebx
c002647f:	75 e8                	jne    c0026469 <shutdown_reboot+0x52>
c0026481:	eb ad                	jmp    c0026430 <shutdown_reboot+0x19>

c0026483 <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026483:	57                   	push   %edi
c0026484:	56                   	push   %esi
c0026485:	83 ec 14             	sub    $0x14,%esp
  const char s[] = "Shutdown";
c0026488:	8d 7c 24 07          	lea    0x7(%esp),%edi
c002648c:	be 05 26 03 c0       	mov    $0xc0032605,%esi
c0026491:	b9 09 00 00 00       	mov    $0x9,%ecx
c0026496:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  const char *p;

#ifdef FILESYS
  filesys_done ();
c0026498:	e8 96 60 00 00       	call   c002c533 <filesys_done>

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
  timer_print_stats ();
c002649d:	e8 3c df ff ff       	call   c00243de <timer_print_stats>
  thread_print_stats ();
c00264a2:	e8 3a a8 ff ff       	call   c0020ce1 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
c00264a7:	e8 e4 e8 ff ff       	call   c0024d90 <block_print_stats>
#endif
  console_print_stats ();
c00264ac:	e8 62 3c 00 00       	call   c002a113 <console_print_stats>
  kbd_print_stats ();
c00264b1:	e8 39 e1 ff ff       	call   c00245ef <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
c00264b6:	e8 a0 50 00 00       	call   c002b55b <exception_print_stats>
  printf ("Powering off...\n");
c00264bb:	83 ec 0c             	sub    $0xc,%esp
c00264be:	68 e4 25 03 c0       	push   $0xc00325e4
c00264c3:	e8 9c 3c 00 00       	call   c002a164 <puts>
  serial_flush ();
c00264c8:	e8 09 e6 ff ff       	call   c0024ad6 <serial_flush>
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00264cd:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c00264d2:	b8 00 20 00 00       	mov    $0x2000,%eax
c00264d7:	66 ef                	out    %ax,(%dx)
  for (p = s; *p != '\0'; p++)
c00264d9:	8a 44 24 17          	mov    0x17(%esp),%al
c00264dd:	83 c4 10             	add    $0x10,%esp
c00264e0:	84 c0                	test   %al,%al
c00264e2:	74 11                	je     c00264f5 <shutdown_power_off+0x72>
c00264e4:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00264e8:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c00264ed:	ee                   	out    %al,(%dx)
c00264ee:	41                   	inc    %ecx
c00264ef:	8a 01                	mov    (%ecx),%al
c00264f1:	84 c0                	test   %al,%al
c00264f3:	75 f8                	jne    c00264ed <shutdown_power_off+0x6a>
c00264f5:	ba 01 05 00 00       	mov    $0x501,%edx
c00264fa:	b0 31                	mov    $0x31,%al
c00264fc:	ee                   	out    %al,(%dx)
  asm volatile ("cli; hlt" : : : "memory");
c00264fd:	fa                   	cli    
c00264fe:	f4                   	hlt    
  printf ("still running...\n");
c00264ff:	83 ec 0c             	sub    $0xc,%esp
c0026502:	68 f4 25 03 c0       	push   $0xc00325f4
c0026507:	e8 58 3c 00 00       	call   c002a164 <puts>
c002650c:	83 c4 10             	add    $0x10,%esp
c002650f:	eb fe                	jmp    c002650f <shutdown_power_off+0x8c>

c0026511 <shutdown>:
{
c0026511:	83 ec 0c             	sub    $0xc,%esp
  switch (how)
c0026514:	a1 04 e3 03 c0       	mov    0xc003e304,%eax
c0026519:	83 f8 01             	cmp    $0x1,%eax
c002651c:	74 09                	je     c0026527 <shutdown+0x16>
c002651e:	83 f8 02             	cmp    $0x2,%eax
c0026521:	74 09                	je     c002652c <shutdown+0x1b>
}
c0026523:	83 c4 0c             	add    $0xc,%esp
c0026526:	c3                   	ret    
      shutdown_power_off ();
c0026527:	e8 57 ff ff ff       	call   c0026483 <shutdown_power_off>
      shutdown_reboot ();
c002652c:	e8 e6 fe ff ff       	call   c0026417 <shutdown_reboot>

c0026531 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0026531:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_disable ();
c0026534:	e8 22 b5 ff ff       	call   c0021a5b <intr_disable>
c0026539:	89 c2                	mov    %eax,%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002653b:	e4 61                	in     $0x61,%al
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002653d:	83 e0 fc             	and    $0xfffffffc,%eax
c0026540:	e6 61                	out    %al,$0x61
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
  intr_set_level (old_level);
c0026542:	83 ec 0c             	sub    $0xc,%esp
c0026545:	52                   	push   %edx
c0026546:	e8 17 b5 ff ff       	call   c0021a62 <intr_set_level>
}
c002654b:	83 c4 1c             	add    $0x1c,%esp
c002654e:	c3                   	ret    

c002654f <speaker_on>:
{
c002654f:	56                   	push   %esi
c0026550:	53                   	push   %ebx
c0026551:	83 ec 04             	sub    $0x4,%esp
c0026554:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (frequency >= 20 && frequency <= 20000)
c0026558:	8d 43 ec             	lea    -0x14(%ebx),%eax
c002655b:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c0026560:	76 0b                	jbe    c002656d <speaker_on+0x1e>
      speaker_off ();
c0026562:	e8 ca ff ff ff       	call   c0026531 <speaker_off>
}
c0026567:	83 c4 04             	add    $0x4,%esp
c002656a:	5b                   	pop    %ebx
c002656b:	5e                   	pop    %esi
c002656c:	c3                   	ret    
      enum intr_level old_level = intr_disable ();
c002656d:	e8 e9 b4 ff ff       	call   c0021a5b <intr_disable>
c0026572:	89 c6                	mov    %eax,%esi
      pit_configure_channel (2, 3, frequency);
c0026574:	83 ec 04             	sub    $0x4,%esp
c0026577:	53                   	push   %ebx
c0026578:	6a 03                	push   $0x3
c002657a:	6a 02                	push   $0x2
c002657c:	e8 86 d9 ff ff       	call   c0023f07 <pit_configure_channel>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026581:	e4 61                	in     $0x61,%al
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026583:	83 c8 03             	or     $0x3,%eax
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026586:	e6 61                	out    %al,$0x61
      intr_set_level (old_level);
c0026588:	89 34 24             	mov    %esi,(%esp)
c002658b:	e8 d2 b4 ff ff       	call   c0021a62 <intr_set_level>
c0026590:	83 c4 10             	add    $0x10,%esp
c0026593:	eb d2                	jmp    c0026567 <speaker_on+0x18>

c0026595 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0026595:	83 ec 0c             	sub    $0xc,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026598:	e8 81 b4 ff ff       	call   c0021a1e <intr_get_level>
c002659d:	83 f8 01             	cmp    $0x1,%eax
c00265a0:	74 04                	je     c00265a6 <speaker_beep+0x11>
    {
      speaker_on (440);
      timer_msleep (250);
      speaker_off ();
    }
}
c00265a2:	83 c4 0c             	add    $0xc,%esp
c00265a5:	c3                   	ret    
      speaker_on (440);
c00265a6:	83 ec 0c             	sub    $0xc,%esp
c00265a9:	68 b8 01 00 00       	push   $0x1b8
c00265ae:	e8 9c ff ff ff       	call   c002654f <speaker_on>
      timer_msleep (250);
c00265b3:	83 c4 08             	add    $0x8,%esp
c00265b6:	6a 00                	push   $0x0
c00265b8:	68 fa 00 00 00       	push   $0xfa
c00265bd:	e8 86 dd ff ff       	call   c0024348 <timer_msleep>
      speaker_off ();
c00265c2:	e8 6a ff ff ff       	call   c0026531 <speaker_off>
c00265c7:	83 c4 10             	add    $0x10,%esp
}
c00265ca:	eb d6                	jmp    c00265a2 <speaker_beep+0xd>

c00265cc <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c00265cc:	55                   	push   %ebp
c00265cd:	89 e5                	mov    %esp,%ebp
c00265cf:	53                   	push   %ebx
c00265d0:	83 ec 0c             	sub    $0xc,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c00265d3:	ff 75 04             	pushl  0x4(%ebp)
c00265d6:	68 0e 26 03 c0       	push   $0xc003260e
c00265db:	e8 ef 05 00 00       	call   c0026bcf <printf>
  for (frame = __builtin_frame_address (1);
c00265e0:	8b 5d 00             	mov    0x0(%ebp),%ebx
c00265e3:	83 c4 10             	add    $0x10,%esp
c00265e6:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c00265ec:	76 27                	jbe    c0026615 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c00265ee:	83 3b 00             	cmpl   $0x0,(%ebx)
c00265f1:	74 22                	je     c0026615 <debug_backtrace+0x49>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c00265f3:	83 ec 08             	sub    $0x8,%esp
c00265f6:	ff 73 04             	pushl  0x4(%ebx)
c00265f9:	68 19 26 03 c0       	push   $0xc0032619
c00265fe:	e8 cc 05 00 00       	call   c0026bcf <printf>
       frame = frame[0]) 
c0026603:	8b 1b                	mov    (%ebx),%ebx
  for (frame = __builtin_frame_address (1);
c0026605:	83 c4 10             	add    $0x10,%esp
c0026608:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c002660e:	76 05                	jbe    c0026615 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026610:	83 3b 00             	cmpl   $0x0,(%ebx)
c0026613:	75 de                	jne    c00265f3 <debug_backtrace+0x27>
  printf (".\n");
c0026615:	83 ec 0c             	sub    $0xc,%esp
c0026618:	68 a3 21 03 c0       	push   $0xc00321a3
c002661d:	e8 42 3b 00 00       	call   c002a164 <puts>

  if (!explained) 
c0026622:	83 c4 10             	add    $0x10,%esp
c0026625:	80 3d 08 e3 03 c0 00 	cmpb   $0x0,0xc003e308
c002662c:	74 05                	je     c0026633 <debug_backtrace+0x67>
      explained = true;
      printf ("The `backtrace' program can make call stacks useful.\n"
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c002662e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026631:	c9                   	leave  
c0026632:	c3                   	ret    
      explained = true;
c0026633:	c6 05 08 e3 03 c0 01 	movb   $0x1,0xc003e308
      printf ("The `backtrace' program can make call stacks useful.\n"
c002663a:	83 ec 0c             	sub    $0xc,%esp
c002663d:	68 20 26 03 c0       	push   $0xc0032620
c0026642:	e8 1d 3b 00 00       	call   c002a164 <puts>
c0026647:	83 c4 10             	add    $0x10,%esp
}
c002664a:	eb e2                	jmp    c002662e <debug_backtrace+0x62>

c002664c <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c002664c:	56                   	push   %esi
c002664d:	53                   	push   %ebx
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c002664e:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c0026653:	88 80 40 e3 03 c0    	mov    %al,-0x3ffc1cc0(%eax)
  for (i = 0; i < 256; i++) 
c0026659:	40                   	inc    %eax
c002665a:	3d 00 01 00 00       	cmp    $0x100,%eax
c002665f:	75 f2                	jne    c0026653 <random_init+0x7>
c0026661:	be 00 00 00 00       	mov    $0x0,%esi
c0026666:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = j = 0; i < 256; i++) 
    {
      j += s[i] + seedp[i % sizeof seed];
c002666b:	89 c1                	mov    %eax,%ecx
c002666d:	83 e1 03             	and    $0x3,%ecx
c0026670:	8a 98 40 e3 03 c0    	mov    -0x3ffc1cc0(%eax),%bl
c0026676:	88 da                	mov    %bl,%dl
c0026678:	02 54 0c 0c          	add    0xc(%esp,%ecx,1),%dl
c002667c:	88 d1                	mov    %dl,%cl
c002667e:	01 ce                	add    %ecx,%esi
      swap_byte (s + i, s + j);
c0026680:	89 f2                	mov    %esi,%edx
c0026682:	0f b6 ca             	movzbl %dl,%ecx
  *a = *b;
c0026685:	8a 91 40 e3 03 c0    	mov    -0x3ffc1cc0(%ecx),%dl
c002668b:	88 90 40 e3 03 c0    	mov    %dl,-0x3ffc1cc0(%eax)
  *b = t;
c0026691:	88 99 40 e3 03 c0    	mov    %bl,-0x3ffc1cc0(%ecx)
  for (i = j = 0; i < 256; i++) 
c0026697:	40                   	inc    %eax
c0026698:	3d 00 01 00 00       	cmp    $0x100,%eax
c002669d:	75 cc                	jne    c002666b <random_init+0x1f>
    }

  s_i = s_j = 0;
c002669f:	c6 05 21 e3 03 c0 00 	movb   $0x0,0xc003e321
c00266a6:	c6 05 22 e3 03 c0 00 	movb   $0x0,0xc003e322
  inited = true;
c00266ad:	c6 05 20 e3 03 c0 01 	movb   $0x1,0xc003e320
}
c00266b4:	5b                   	pop    %ebx
c00266b5:	5e                   	pop    %esi
c00266b6:	c3                   	ret    

c00266b7 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c00266b7:	55                   	push   %ebp
c00266b8:	57                   	push   %edi
c00266b9:	56                   	push   %esi
c00266ba:	53                   	push   %ebx
c00266bb:	83 ec 04             	sub    $0x4,%esp
c00266be:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint8_t *buf;

  if (!inited)
c00266c2:	80 3d 20 e3 03 c0 00 	cmpb   $0x0,0xc003e320
c00266c9:	0f 84 8c 00 00 00    	je     c002675b <random_bytes+0xa4>
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c00266cf:	8d 6f ff             	lea    -0x1(%edi),%ebp
c00266d2:	85 ff                	test   %edi,%edi
c00266d4:	74 7d                	je     c0026753 <random_bytes+0x9c>
c00266d6:	0f b6 35 21 e3 03 c0 	movzbl 0xc003e321,%esi
c00266dd:	a0 22 e3 03 c0       	mov    0xc003e322,%al
c00266e2:	40                   	inc    %eax
c00266e3:	88 44 24 03          	mov    %al,0x3(%esp)
c00266e7:	03 7c 24 18          	add    0x18(%esp),%edi
c00266eb:	88 44 24 01          	mov    %al,0x1(%esp)
c00266ef:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    {
      uint8_t s_k;
      
      s_i++;
      s_j += s[s_i];
c00266f3:	0f b6 54 24 01       	movzbl 0x1(%esp),%edx
c00266f8:	89 f3                	mov    %esi,%ebx
c00266fa:	02 9a 40 e3 03 c0    	add    -0x3ffc1cc0(%edx),%bl
c0026700:	89 de                	mov    %ebx,%esi
      swap_byte (s + s_i, s + s_j);
c0026702:	0f b6 c3             	movzbl %bl,%eax
  uint8_t t = *a;
c0026705:	8a 9a 40 e3 03 c0    	mov    -0x3ffc1cc0(%edx),%bl
c002670b:	88 5c 24 02          	mov    %bl,0x2(%esp)
  *a = *b;
c002670f:	8a 98 40 e3 03 c0    	mov    -0x3ffc1cc0(%eax),%bl
c0026715:	88 9a 40 e3 03 c0    	mov    %bl,-0x3ffc1cc0(%edx)
  *b = t;
c002671b:	8a 5c 24 02          	mov    0x2(%esp),%bl
c002671f:	88 98 40 e3 03 c0    	mov    %bl,-0x3ffc1cc0(%eax)

      s_k = s[s_i] + s[s_j];
c0026725:	88 d8                	mov    %bl,%al
c0026727:	02 82 40 e3 03 c0    	add    -0x3ffc1cc0(%edx),%al
      *buf = s[s_k];
c002672d:	0f b6 c0             	movzbl %al,%eax
c0026730:	8a 90 40 e3 03 c0    	mov    -0x3ffc1cc0(%eax),%dl
c0026736:	88 11                	mov    %dl,(%ecx)
  for (buf = buf_; size-- > 0; buf++)
c0026738:	41                   	inc    %ecx
c0026739:	fe 44 24 01          	incb   0x1(%esp)
c002673d:	39 f9                	cmp    %edi,%ecx
c002673f:	75 b2                	jne    c00266f3 <random_bytes+0x3c>
c0026741:	8a 44 24 03          	mov    0x3(%esp),%al
c0026745:	01 e8                	add    %ebp,%eax
c0026747:	a2 22 e3 03 c0       	mov    %al,0xc003e322
c002674c:	89 f0                	mov    %esi,%eax
c002674e:	a2 21 e3 03 c0       	mov    %al,0xc003e321
    }
}
c0026753:	83 c4 04             	add    $0x4,%esp
c0026756:	5b                   	pop    %ebx
c0026757:	5e                   	pop    %esi
c0026758:	5f                   	pop    %edi
c0026759:	5d                   	pop    %ebp
c002675a:	c3                   	ret    
    random_init (0);
c002675b:	6a 00                	push   $0x0
c002675d:	e8 ea fe ff ff       	call   c002664c <random_init>
c0026762:	83 c4 04             	add    $0x4,%esp
c0026765:	e9 65 ff ff ff       	jmp    c00266cf <random_bytes+0x18>

c002676a <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c002676a:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c002676d:	6a 04                	push   $0x4
c002676f:	8d 44 24 10          	lea    0x10(%esp),%eax
c0026773:	50                   	push   %eax
c0026774:	e8 3e ff ff ff       	call   c00266b7 <random_bytes>
  return ul;
}
c0026779:	8b 44 24 14          	mov    0x14(%esp),%eax
c002677d:	83 c4 18             	add    $0x18,%esp
c0026780:	c3                   	ret    

c0026781 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0026781:	53                   	push   %ebx
c0026782:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0026786:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c002678a:	8b 50 04             	mov    0x4(%eax),%edx
c002678d:	8d 4a 01             	lea    0x1(%edx),%ecx
c0026790:	89 48 04             	mov    %ecx,0x4(%eax)
c0026793:	3b 50 08             	cmp    0x8(%eax),%edx
c0026796:	7d 09                	jge    c00267a1 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c0026798:	8b 10                	mov    (%eax),%edx
c002679a:	8d 4a 01             	lea    0x1(%edx),%ecx
c002679d:	89 08                	mov    %ecx,(%eax)
c002679f:	88 1a                	mov    %bl,(%edx)
}
c00267a1:	5b                   	pop    %ebx
c00267a2:	c3                   	ret    

c00267a3 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c00267a3:	55                   	push   %ebp
c00267a4:	57                   	push   %edi
c00267a5:	56                   	push   %esi
c00267a6:	53                   	push   %ebx
c00267a7:	83 ec 0c             	sub    $0xc,%esp
c00267aa:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c00267ae:	85 d2                	test   %edx,%edx
c00267b0:	74 18                	je     c00267ca <output_dup+0x27>
c00267b2:	8d 5a ff             	lea    -0x1(%edx),%ebx
c00267b5:	89 cd                	mov    %ecx,%ebp
    output (ch, aux);
c00267b7:	0f be f0             	movsbl %al,%esi
c00267ba:	83 ec 08             	sub    $0x8,%esp
c00267bd:	57                   	push   %edi
c00267be:	56                   	push   %esi
c00267bf:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c00267c1:	4b                   	dec    %ebx
c00267c2:	83 c4 10             	add    $0x10,%esp
c00267c5:	83 fb ff             	cmp    $0xffffffff,%ebx
c00267c8:	75 f0                	jne    c00267ba <output_dup+0x17>
}
c00267ca:	83 c4 0c             	add    $0xc,%esp
c00267cd:	5b                   	pop    %ebx
c00267ce:	5e                   	pop    %esi
c00267cf:	5f                   	pop    %edi
c00267d0:	5d                   	pop    %ebp
c00267d1:	c3                   	ret    

c00267d2 <format_integer>:
{
c00267d2:	55                   	push   %ebp
c00267d3:	57                   	push   %edi
c00267d4:	56                   	push   %esi
c00267d5:	53                   	push   %ebx
c00267d6:	83 ec 7c             	sub    $0x7c,%esp
c00267d9:	89 c6                	mov    %eax,%esi
c00267db:	89 d7                	mov    %edx,%edi
c00267dd:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  if (is_signed) 
c00267e4:	84 c9                	test   %cl,%cl
c00267e6:	74 42                	je     c002682a <format_integer+0x58>
      if (c->flags & PLUS)
c00267e8:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c00267ef:	8b 11                	mov    (%ecx),%edx
c00267f1:	f6 c2 02             	test   $0x2,%dl
c00267f4:	74 10                	je     c0026806 <format_integer+0x34>
        sign = negative ? '-' : '+';
c00267f6:	3c 01                	cmp    $0x1,%al
c00267f8:	19 c0                	sbb    %eax,%eax
c00267fa:	83 e0 fe             	and    $0xfffffffe,%eax
c00267fd:	83 c0 2d             	add    $0x2d,%eax
c0026800:	89 44 24 24          	mov    %eax,0x24(%esp)
c0026804:	eb 2c                	jmp    c0026832 <format_integer+0x60>
      else if (c->flags & SPACE)
c0026806:	f6 c2 04             	test   $0x4,%dl
c0026809:	74 10                	je     c002681b <format_integer+0x49>
        sign = negative ? '-' : ' ';
c002680b:	3c 01                	cmp    $0x1,%al
c002680d:	19 c0                	sbb    %eax,%eax
c002680f:	83 e0 f3             	and    $0xfffffff3,%eax
c0026812:	83 c0 2d             	add    $0x2d,%eax
c0026815:	89 44 24 24          	mov    %eax,0x24(%esp)
c0026819:	eb 17                	jmp    c0026832 <format_integer+0x60>
        sign = '-';
c002681b:	3c 01                	cmp    $0x1,%al
c002681d:	19 c0                	sbb    %eax,%eax
c002681f:	f7 d0                	not    %eax
c0026821:	83 e0 2d             	and    $0x2d,%eax
c0026824:	89 44 24 24          	mov    %eax,0x24(%esp)
c0026828:	eb 08                	jmp    c0026832 <format_integer+0x60>
  sign = 0;
c002682a:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0026831:	00 
  x = (c->flags & POUND) && value ? b->x : 0;
c0026832:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0026839:	8b 00                	mov    (%eax),%eax
c002683b:	89 44 24 28          	mov    %eax,0x28(%esp)
c002683f:	83 e0 08             	and    $0x8,%eax
c0026842:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0026846:	74 1a                	je     c0026862 <format_integer+0x90>
c0026848:	89 fa                	mov    %edi,%edx
c002684a:	09 f2                	or     %esi,%edx
c002684c:	0f 84 cc 00 00 00    	je     c002691e <format_integer+0x14c>
c0026852:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026859:	8b 40 08             	mov    0x8(%eax),%eax
c002685c:	89 44 24 20          	mov    %eax,0x20(%esp)
c0026860:	eb 12                	jmp    c0026874 <format_integer+0xa2>
  while (value > 0) 
c0026862:	89 fa                	mov    %edi,%edx
c0026864:	09 f2                	or     %esi,%edx
c0026866:	0f 84 c3 01 00 00    	je     c0026a2f <format_integer+0x25d>
  x = (c->flags & POUND) && value ? b->x : 0;
c002686c:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0026873:	00 
      *cp++ = b->digits[value % b->base];
c0026874:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c002687b:	8b 40 04             	mov    0x4(%eax),%eax
c002687e:	89 44 24 18          	mov    %eax,0x18(%esp)
c0026882:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026889:	8b 00                	mov    (%eax),%eax
c002688b:	89 44 24 08          	mov    %eax,0x8(%esp)
c002688f:	89 c1                	mov    %eax,%ecx
c0026891:	c1 f9 1f             	sar    $0x1f,%ecx
c0026894:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0026898:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c002689f:	00 
c00268a0:	8d 5c 24 30          	lea    0x30(%esp),%ebx
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c00268a4:	8b 44 24 28          	mov    0x28(%esp),%eax
c00268a8:	83 e0 20             	and    $0x20,%eax
c00268ab:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c00268af:	eb 3f                	jmp    c00268f0 <format_integer+0x11e>
c00268b1:	89 dd                	mov    %ebx,%ebp
      *cp++ = b->digits[value % b->base];
c00268b3:	8d 5d 01             	lea    0x1(%ebp),%ebx
c00268b6:	ff 74 24 0c          	pushl  0xc(%esp)
c00268ba:	ff 74 24 0c          	pushl  0xc(%esp)
c00268be:	57                   	push   %edi
c00268bf:	56                   	push   %esi
c00268c0:	e8 35 18 00 00       	call   c00280fa <__umoddi3>
c00268c5:	83 c4 10             	add    $0x10,%esp
c00268c8:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c00268cc:	8a 04 01             	mov    (%ecx,%eax,1),%al
c00268cf:	88 45 00             	mov    %al,0x0(%ebp)
      value /= b->base;
c00268d2:	ff 74 24 0c          	pushl  0xc(%esp)
c00268d6:	ff 74 24 0c          	pushl  0xc(%esp)
c00268da:	57                   	push   %edi
c00268db:	56                   	push   %esi
c00268dc:	e8 fd 17 00 00       	call   c00280de <__udivdi3>
c00268e1:	83 c4 10             	add    $0x10,%esp
c00268e4:	89 c6                	mov    %eax,%esi
c00268e6:	89 d7                	mov    %edx,%edi
      digit_cnt++;
c00268e8:	ff 44 24 14          	incl   0x14(%esp)
  while (value > 0) 
c00268ec:	09 c2                	or     %eax,%edx
c00268ee:	74 3a                	je     c002692a <format_integer+0x158>
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c00268f0:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c00268f5:	74 ba                	je     c00268b1 <format_integer+0xdf>
c00268f7:	8b 44 24 14          	mov    0x14(%esp),%eax
c00268fb:	85 c0                	test   %eax,%eax
c00268fd:	7e 17                	jle    c0026916 <format_integer+0x144>
c00268ff:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c0026906:	99                   	cltd   
c0026907:	f7 79 0c             	idivl  0xc(%ecx)
c002690a:	85 d2                	test   %edx,%edx
c002690c:	75 0c                	jne    c002691a <format_integer+0x148>
        *cp++ = ',';
c002690e:	8d 6b 01             	lea    0x1(%ebx),%ebp
c0026911:	c6 03 2c             	movb   $0x2c,(%ebx)
c0026914:	eb 9d                	jmp    c00268b3 <format_integer+0xe1>
c0026916:	89 dd                	mov    %ebx,%ebp
c0026918:	eb 99                	jmp    c00268b3 <format_integer+0xe1>
c002691a:	89 dd                	mov    %ebx,%ebp
c002691c:	eb 95                	jmp    c00268b3 <format_integer+0xe1>
  x = (c->flags & POUND) && value ? b->x : 0;
c002691e:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0026925:	00 
  cp = buf;
c0026926:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  precision = c->precision < 0 ? 1 : c->precision;
c002692a:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0026931:	8b 50 08             	mov    0x8(%eax),%edx
c0026934:	85 d2                	test   %edx,%edx
c0026936:	0f 88 04 01 00 00    	js     c0026a40 <format_integer+0x26e>
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c002693c:	8d 7c 24 30          	lea    0x30(%esp),%edi
c0026940:	89 d8                	mov    %ebx,%eax
c0026942:	29 f8                	sub    %edi,%eax
c0026944:	39 c2                	cmp    %eax,%edx
c0026946:	7e 21                	jle    c0026969 <format_integer+0x197>
c0026948:	8d 44 24 6f          	lea    0x6f(%esp),%eax
c002694c:	39 c3                	cmp    %eax,%ebx
c002694e:	73 19                	jae    c0026969 <format_integer+0x197>
c0026950:	89 f9                	mov    %edi,%ecx
c0026952:	89 c6                	mov    %eax,%esi
    *cp++ = '0';
c0026954:	43                   	inc    %ebx
c0026955:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0026959:	89 d8                	mov    %ebx,%eax
c002695b:	29 c8                	sub    %ecx,%eax
c002695d:	39 d0                	cmp    %edx,%eax
c002695f:	7d 08                	jge    c0026969 <format_integer+0x197>
c0026961:	39 f3                	cmp    %esi,%ebx
c0026963:	75 ef                	jne    c0026954 <format_integer+0x182>
    *cp++ = '0';
c0026965:	8d 5c 24 6f          	lea    0x6f(%esp),%ebx
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0026969:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c002696e:	74 10                	je     c0026980 <format_integer+0x1ae>
c0026970:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026977:	83 38 08             	cmpl   $0x8,(%eax)
c002697a:	0f 84 ca 00 00 00    	je     c0026a4a <format_integer+0x278>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0026980:	29 df                	sub    %ebx,%edi
c0026982:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c0026989:	89 f8                	mov    %edi,%eax
c002698b:	03 41 04             	add    0x4(%ecx),%eax
c002698e:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0026993:	0f 95 c2             	setne  %dl
c0026996:	0f b6 d2             	movzbl %dl,%edx
c0026999:	d1 e2                	shl    %edx
c002699b:	29 d0                	sub    %edx,%eax
c002699d:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c00269a2:	0f 95 c2             	setne  %dl
c00269a5:	0f b6 d2             	movzbl %dl,%edx
c00269a8:	29 d0                	sub    %edx,%eax
c00269aa:	89 c7                	mov    %eax,%edi
c00269ac:	85 c0                	test   %eax,%eax
c00269ae:	0f 88 b3 00 00 00    	js     c0026a67 <format_integer+0x295>
  if ((c->flags & (MINUS | ZERO)) == 0)
c00269b4:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c00269b9:	0f 84 b2 00 00 00    	je     c0026a71 <format_integer+0x29f>
  if (sign)
c00269bf:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c00269c4:	0f 85 cc 00 00 00    	jne    c0026a96 <format_integer+0x2c4>
  if (x) 
c00269ca:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c00269cf:	0f 85 de 00 00 00    	jne    c0026ab3 <format_integer+0x2e1>
  if (c->flags & ZERO)
c00269d5:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00269dc:	f6 00 10             	testb  $0x10,(%eax)
c00269df:	0f 85 00 01 00 00    	jne    c0026ae5 <format_integer+0x313>
  while (cp > buf)
c00269e5:	8d 44 24 30          	lea    0x30(%esp),%eax
c00269e9:	39 c3                	cmp    %eax,%ebx
c00269eb:	76 2a                	jbe    c0026a17 <format_integer+0x245>
c00269ed:	89 c6                	mov    %eax,%esi
c00269ef:	89 7c 24 08          	mov    %edi,0x8(%esp)
c00269f3:	8b bc 24 9c 00 00 00 	mov    0x9c(%esp),%edi
c00269fa:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
    output (*--cp, aux);
c0026a01:	4b                   	dec    %ebx
c0026a02:	83 ec 08             	sub    $0x8,%esp
c0026a05:	55                   	push   %ebp
c0026a06:	0f be 03             	movsbl (%ebx),%eax
c0026a09:	50                   	push   %eax
c0026a0a:	ff d7                	call   *%edi
  while (cp > buf)
c0026a0c:	83 c4 10             	add    $0x10,%esp
c0026a0f:	39 f3                	cmp    %esi,%ebx
c0026a11:	75 ee                	jne    c0026a01 <format_integer+0x22f>
c0026a13:	8b 7c 24 08          	mov    0x8(%esp),%edi
  if (c->flags & MINUS)
c0026a17:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0026a1e:	f6 00 01             	testb  $0x1,(%eax)
c0026a21:	0f 85 e3 00 00 00    	jne    c0026b0a <format_integer+0x338>
}
c0026a27:	83 c4 7c             	add    $0x7c,%esp
c0026a2a:	5b                   	pop    %ebx
c0026a2b:	5e                   	pop    %esi
c0026a2c:	5f                   	pop    %edi
c0026a2d:	5d                   	pop    %ebp
c0026a2e:	c3                   	ret    
  x = (c->flags & POUND) && value ? b->x : 0;
c0026a2f:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0026a36:	00 
  cp = buf;
c0026a37:	8d 5c 24 30          	lea    0x30(%esp),%ebx
c0026a3b:	e9 ea fe ff ff       	jmp    c002692a <format_integer+0x158>
  precision = c->precision < 0 ? 1 : c->precision;
c0026a40:	ba 01 00 00 00       	mov    $0x1,%edx
c0026a45:	e9 f2 fe ff ff       	jmp    c002693c <format_integer+0x16a>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0026a4a:	8d 44 24 30          	lea    0x30(%esp),%eax
c0026a4e:	39 c3                	cmp    %eax,%ebx
c0026a50:	74 0a                	je     c0026a5c <format_integer+0x28a>
c0026a52:	80 7b ff 30          	cmpb   $0x30,-0x1(%ebx)
c0026a56:	0f 84 24 ff ff ff    	je     c0026980 <format_integer+0x1ae>
    *cp++ = '0';
c0026a5c:	c6 03 30             	movb   $0x30,(%ebx)
c0026a5f:	8d 5b 01             	lea    0x1(%ebx),%ebx
c0026a62:	e9 19 ff ff ff       	jmp    c0026980 <format_integer+0x1ae>
c0026a67:	bf 00 00 00 00       	mov    $0x0,%edi
c0026a6c:	e9 43 ff ff ff       	jmp    c00269b4 <format_integer+0x1e2>
    output_dup (' ', pad_cnt, output, aux);
c0026a71:	83 ec 0c             	sub    $0xc,%esp
c0026a74:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0026a7b:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0026a82:	89 fa                	mov    %edi,%edx
c0026a84:	b8 20 00 00 00       	mov    $0x20,%eax
c0026a89:	e8 15 fd ff ff       	call   c00267a3 <output_dup>
c0026a8e:	83 c4 10             	add    $0x10,%esp
c0026a91:	e9 29 ff ff ff       	jmp    c00269bf <format_integer+0x1ed>
    output (sign, aux);
c0026a96:	83 ec 08             	sub    $0x8,%esp
c0026a99:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0026aa0:	ff 74 24 30          	pushl  0x30(%esp)
c0026aa4:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0026aab:	83 c4 10             	add    $0x10,%esp
c0026aae:	e9 17 ff ff ff       	jmp    c00269ca <format_integer+0x1f8>
      output ('0', aux);
c0026ab3:	83 ec 08             	sub    $0x8,%esp
c0026ab6:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0026abd:	6a 30                	push   $0x30
c0026abf:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c0026ac6:	83 c4 08             	add    $0x8,%esp
c0026ac9:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0026ad0:	0f be 44 24 2c       	movsbl 0x2c(%esp),%eax
c0026ad5:	50                   	push   %eax
c0026ad6:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0026add:	83 c4 10             	add    $0x10,%esp
c0026ae0:	e9 f0 fe ff ff       	jmp    c00269d5 <format_integer+0x203>
    output_dup ('0', pad_cnt, output, aux);
c0026ae5:	83 ec 0c             	sub    $0xc,%esp
c0026ae8:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0026aef:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0026af6:	89 fa                	mov    %edi,%edx
c0026af8:	b8 30 00 00 00       	mov    $0x30,%eax
c0026afd:	e8 a1 fc ff ff       	call   c00267a3 <output_dup>
c0026b02:	83 c4 10             	add    $0x10,%esp
c0026b05:	e9 db fe ff ff       	jmp    c00269e5 <format_integer+0x213>
    output_dup (' ', pad_cnt, output, aux);
c0026b0a:	83 ec 0c             	sub    $0xc,%esp
c0026b0d:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0026b14:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0026b1b:	89 fa                	mov    %edi,%edx
c0026b1d:	b8 20 00 00 00       	mov    $0x20,%eax
c0026b22:	e8 7c fc ff ff       	call   c00267a3 <output_dup>
c0026b27:	83 c4 10             	add    $0x10,%esp
}
c0026b2a:	e9 f8 fe ff ff       	jmp    c0026a27 <format_integer+0x255>

c0026b2f <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0026b2f:	55                   	push   %ebp
c0026b30:	57                   	push   %edi
c0026b31:	56                   	push   %esi
c0026b32:	53                   	push   %ebx
c0026b33:	83 ec 1c             	sub    $0x1c,%esp
c0026b36:	89 c5                	mov    %eax,%ebp
c0026b38:	89 d3                	mov    %edx,%ebx
c0026b3a:	89 54 24 08          	mov    %edx,0x8(%esp)
c0026b3e:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0026b42:	8b 74 24 30          	mov    0x30(%esp),%esi
c0026b46:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0026b4a:	8b 51 04             	mov    0x4(%ecx),%edx
c0026b4d:	39 da                	cmp    %ebx,%edx
c0026b4f:	7e 42                	jle    c0026b93 <format_string+0x64>
c0026b51:	89 c8                	mov    %ecx,%eax
c0026b53:	f6 00 01             	testb  $0x1,(%eax)
c0026b56:	74 20                	je     c0026b78 <format_string+0x49>
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0026b58:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0026b5d:	7f 3b                	jg     c0026b9a <format_string+0x6b>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
c0026b5f:	2b 54 24 08          	sub    0x8(%esp),%edx
c0026b63:	83 ec 0c             	sub    $0xc,%esp
c0026b66:	57                   	push   %edi
c0026b67:	89 f1                	mov    %esi,%ecx
c0026b69:	b8 20 00 00 00       	mov    $0x20,%eax
c0026b6e:	e8 30 fc ff ff       	call   c00267a3 <output_dup>
c0026b73:	83 c4 10             	add    $0x10,%esp
}
c0026b76:	eb 4f                	jmp    c0026bc7 <format_string+0x98>
    output_dup (' ', c->width - length, output, aux);
c0026b78:	29 da                	sub    %ebx,%edx
c0026b7a:	83 ec 0c             	sub    $0xc,%esp
c0026b7d:	57                   	push   %edi
c0026b7e:	89 f1                	mov    %esi,%ecx
c0026b80:	b8 20 00 00 00       	mov    $0x20,%eax
c0026b85:	e8 19 fc ff ff       	call   c00267a3 <output_dup>
  for (i = 0; i < length; i++)
c0026b8a:	83 c4 10             	add    $0x10,%esp
c0026b8d:	85 db                	test   %ebx,%ebx
c0026b8f:	7f 09                	jg     c0026b9a <format_string+0x6b>
c0026b91:	eb 22                	jmp    c0026bb5 <format_string+0x86>
c0026b93:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0026b98:	7e 2d                	jle    c0026bc7 <format_string+0x98>
{
c0026b9a:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
c0026b9f:	83 ec 08             	sub    $0x8,%esp
c0026ba2:	57                   	push   %edi
c0026ba3:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c0026ba8:	50                   	push   %eax
c0026ba9:	ff d6                	call   *%esi
  for (i = 0; i < length; i++)
c0026bab:	43                   	inc    %ebx
c0026bac:	83 c4 10             	add    $0x10,%esp
c0026baf:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
c0026bb3:	7f ea                	jg     c0026b9f <format_string+0x70>
  if (c->width > length && (c->flags & MINUS) != 0)
c0026bb5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0026bb9:	8b 50 04             	mov    0x4(%eax),%edx
c0026bbc:	39 54 24 08          	cmp    %edx,0x8(%esp)
c0026bc0:	7d 05                	jge    c0026bc7 <format_string+0x98>
c0026bc2:	f6 00 01             	testb  $0x1,(%eax)
c0026bc5:	75 98                	jne    c0026b5f <format_string+0x30>
}
c0026bc7:	83 c4 1c             	add    $0x1c,%esp
c0026bca:	5b                   	pop    %ebx
c0026bcb:	5e                   	pop    %esi
c0026bcc:	5f                   	pop    %edi
c0026bcd:	5d                   	pop    %ebp
c0026bce:	c3                   	ret    

c0026bcf <printf>:
{
c0026bcf:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0026bd2:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c0026bd6:	83 ec 08             	sub    $0x8,%esp
c0026bd9:	50                   	push   %eax
c0026bda:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026bde:	e8 4d 35 00 00       	call   c002a130 <vprintf>
}
c0026be3:	83 c4 1c             	add    $0x1c,%esp
c0026be6:	c3                   	ret    

c0026be7 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0026be7:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c0026bea:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c0026bee:	ff 74 24 18          	pushl  0x18(%esp)
c0026bf2:	ff 74 24 18          	pushl  0x18(%esp)
c0026bf6:	50                   	push   %eax
c0026bf7:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026bfb:	e8 04 00 00 00       	call   c0026c04 <__vprintf>
  va_end (args);
}
c0026c00:	83 c4 1c             	add    $0x1c,%esp
c0026c03:	c3                   	ret    

c0026c04 <__vprintf>:
{
c0026c04:	55                   	push   %ebp
c0026c05:	57                   	push   %edi
c0026c06:	56                   	push   %esi
c0026c07:	53                   	push   %ebx
c0026c08:	83 ec 3c             	sub    $0x3c,%esp
c0026c0b:	8b 74 24 50          	mov    0x50(%esp),%esi
  for (; *format != '\0'; format++)
c0026c0f:	8a 06                	mov    (%esi),%al
c0026c11:	84 c0                	test   %al,%al
c0026c13:	75 44                	jne    c0026c59 <__vprintf+0x55>
}
c0026c15:	83 c4 3c             	add    $0x3c,%esp
c0026c18:	5b                   	pop    %ebx
c0026c19:	5e                   	pop    %esi
c0026c1a:	5f                   	pop    %edi
c0026c1b:	5d                   	pop    %ebp
c0026c1c:	c3                   	ret    
      format++;
c0026c1d:	8d 5e 01             	lea    0x1(%esi),%ebx
      if (*format == '%') 
c0026c20:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c0026c24:	74 19                	je     c0026c3f <__vprintf+0x3b>
  c->flags = 0;
c0026c26:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0026c2d:	00 
c0026c2e:	bf 00 00 00 00       	mov    $0x0,%edi
c0026c33:	be 00 00 00 00       	mov    $0x0,%esi
c0026c38:	bd 01 00 00 00       	mov    $0x1,%ebp
c0026c3d:	eb 3b                	jmp    c0026c7a <__vprintf+0x76>
          output ('%', aux);
c0026c3f:	83 ec 08             	sub    $0x8,%esp
c0026c42:	ff 74 24 64          	pushl  0x64(%esp)
c0026c46:	6a 25                	push   $0x25
c0026c48:	ff 54 24 68          	call   *0x68(%esp)
          continue;
c0026c4c:	83 c4 10             	add    $0x10,%esp
  for (; *format != '\0'; format++)
c0026c4f:	8d 73 01             	lea    0x1(%ebx),%esi
c0026c52:	8a 43 01             	mov    0x1(%ebx),%al
c0026c55:	84 c0                	test   %al,%al
c0026c57:	74 bc                	je     c0026c15 <__vprintf+0x11>
      if (*format != '%') 
c0026c59:	3c 25                	cmp    $0x25,%al
c0026c5b:	74 c0                	je     c0026c1d <__vprintf+0x19>
          output (*format, aux);
c0026c5d:	83 ec 08             	sub    $0x8,%esp
c0026c60:	ff 74 24 64          	pushl  0x64(%esp)
c0026c64:	0f be c0             	movsbl %al,%eax
c0026c67:	50                   	push   %eax
c0026c68:	ff 54 24 68          	call   *0x68(%esp)
          continue;
c0026c6c:	83 c4 10             	add    $0x10,%esp
c0026c6f:	89 f3                	mov    %esi,%ebx
c0026c71:	eb dc                	jmp    c0026c4f <__vprintf+0x4b>
          c->flags |= MINUS;
c0026c73:	83 ce 01             	or     $0x1,%esi
c0026c76:	89 ef                	mov    %ebp,%edi
      switch (*format++) 
c0026c78:	89 cb                	mov    %ecx,%ebx
c0026c7a:	8d 4b 01             	lea    0x1(%ebx),%ecx
c0026c7d:	8a 41 ff             	mov    -0x1(%ecx),%al
c0026c80:	8d 50 e0             	lea    -0x20(%eax),%edx
c0026c83:	80 fa 10             	cmp    $0x10,%dl
c0026c86:	77 23                	ja     c0026cab <__vprintf+0xa7>
c0026c88:	0f b6 d2             	movzbl %dl,%edx
c0026c8b:	ff 24 95 d0 ff 02 c0 	jmp    *-0x3ffd0030(,%edx,4)
          c->flags |= PLUS;
c0026c92:	83 ce 02             	or     $0x2,%esi
c0026c95:	eb df                	jmp    c0026c76 <__vprintf+0x72>
          c->flags |= SPACE;
c0026c97:	83 ce 04             	or     $0x4,%esi
c0026c9a:	eb da                	jmp    c0026c76 <__vprintf+0x72>
          c->flags |= POUND;
c0026c9c:	83 ce 08             	or     $0x8,%esi
c0026c9f:	eb d5                	jmp    c0026c76 <__vprintf+0x72>
          c->flags |= ZERO;
c0026ca1:	83 ce 10             	or     $0x10,%esi
c0026ca4:	eb d0                	jmp    c0026c76 <__vprintf+0x72>
          c->flags |= GROUP;
c0026ca6:	83 ce 20             	or     $0x20,%esi
c0026ca9:	eb cb                	jmp    c0026c76 <__vprintf+0x72>
c0026cab:	89 fa                	mov    %edi,%edx
c0026cad:	84 d2                	test   %dl,%dl
c0026caf:	0f 85 85 00 00 00    	jne    c0026d3a <__vprintf+0x136>
  if (c->flags & PLUS)
c0026cb5:	8b 54 24 20          	mov    0x20(%esp),%edx
c0026cb9:	f6 c2 02             	test   $0x2,%dl
c0026cbc:	74 07                	je     c0026cc5 <__vprintf+0xc1>
    c->flags &= ~SPACE;
c0026cbe:	83 e2 fb             	and    $0xfffffffb,%edx
c0026cc1:	89 54 24 20          	mov    %edx,0x20(%esp)
  c->width = 0;
c0026cc5:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0026ccc:	00 
  if (*format == '*')
c0026ccd:	3c 2a                	cmp    $0x2a,%al
c0026ccf:	0f 84 81 00 00 00    	je     c0026d56 <__vprintf+0x152>
      for (; isdigit (*format); format++)
c0026cd5:	0f be c0             	movsbl %al,%eax
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0026cd8:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0026cdb:	ba 00 00 00 00       	mov    $0x0,%edx
c0026ce0:	83 f9 09             	cmp    $0x9,%ecx
c0026ce3:	77 21                	ja     c0026d06 <__vprintf+0x102>
        c->width = c->width * 10 + *format - '0';
c0026ce5:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026ce8:	01 d2                	add    %edx,%edx
c0026cea:	8d 54 10 d0          	lea    -0x30(%eax,%edx,1),%edx
      for (; isdigit (*format); format++)
c0026cee:	43                   	inc    %ebx
c0026cef:	0f be 03             	movsbl (%ebx),%eax
c0026cf2:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0026cf5:	83 f9 09             	cmp    $0x9,%ecx
c0026cf8:	76 eb                	jbe    c0026ce5 <__vprintf+0xe1>
c0026cfa:	89 54 24 24          	mov    %edx,0x24(%esp)
  if (c->width < 0) 
c0026cfe:	8b 44 24 24          	mov    0x24(%esp),%eax
c0026d02:	85 c0                	test   %eax,%eax
c0026d04:	78 69                	js     c0026d6f <__vprintf+0x16b>
  c->precision = -1;
c0026d06:	c7 44 24 28 ff ff ff 	movl   $0xffffffff,0x28(%esp)
c0026d0d:	ff 
  if (*format == '.') 
c0026d0e:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c0026d11:	74 69                	je     c0026d7c <__vprintf+0x178>
  if (c->precision >= 0)
c0026d13:	8b 54 24 28          	mov    0x28(%esp),%edx
  c->type = INT;
c0026d17:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c0026d1e:	00 
  switch (*format++) 
c0026d1f:	8d 7b 01             	lea    0x1(%ebx),%edi
c0026d22:	8a 03                	mov    (%ebx),%al
c0026d24:	8d 48 98             	lea    -0x68(%eax),%ecx
c0026d27:	80 f9 12             	cmp    $0x12,%cl
c0026d2a:	0f 87 d5 01 00 00    	ja     c0026f05 <__vprintf+0x301>
c0026d30:	0f b6 c9             	movzbl %cl,%ecx
c0026d33:	ff 24 8d 14 00 03 c0 	jmp    *-0x3ffcffec(,%ecx,4)
c0026d3a:	89 74 24 20          	mov    %esi,0x20(%esp)
  if (c->flags & MINUS)
c0026d3e:	f7 c6 01 00 00 00    	test   $0x1,%esi
c0026d44:	0f 84 6b ff ff ff    	je     c0026cb5 <__vprintf+0xb1>
    c->flags &= ~ZERO;
c0026d4a:	83 e6 ef             	and    $0xffffffef,%esi
c0026d4d:	89 74 24 20          	mov    %esi,0x20(%esp)
c0026d51:	e9 5f ff ff ff       	jmp    c0026cb5 <__vprintf+0xb1>
      c->width = va_arg (*args, int);
c0026d56:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026d5a:	8b 00                	mov    (%eax),%eax
c0026d5c:	89 44 24 24          	mov    %eax,0x24(%esp)
c0026d60:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026d64:	8d 40 04             	lea    0x4(%eax),%eax
c0026d67:	89 44 24 54          	mov    %eax,0x54(%esp)
      switch (*format++) 
c0026d6b:	89 cb                	mov    %ecx,%ebx
c0026d6d:	eb 8f                	jmp    c0026cfe <__vprintf+0xfa>
      c->width = -c->width;
c0026d6f:	f7 d8                	neg    %eax
c0026d71:	89 44 24 24          	mov    %eax,0x24(%esp)
      c->flags |= MINUS;
c0026d75:	83 4c 24 20 01       	orl    $0x1,0x20(%esp)
c0026d7a:	eb 8a                	jmp    c0026d06 <__vprintf+0x102>
      format++;
c0026d7c:	8d 53 01             	lea    0x1(%ebx),%edx
      if (*format == '*') 
c0026d7f:	8a 43 01             	mov    0x1(%ebx),%al
c0026d82:	3c 2a                	cmp    $0x2a,%al
c0026d84:	74 45                	je     c0026dcb <__vprintf+0x1c7>
          c->precision = 0;
c0026d86:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
c0026d8d:	00 
          for (; isdigit (*format); format++)
c0026d8e:	0f be c0             	movsbl %al,%eax
c0026d91:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0026d94:	83 f9 09             	cmp    $0x9,%ecx
c0026d97:	77 59                	ja     c0026df2 <__vprintf+0x1ee>
c0026d99:	b9 00 00 00 00       	mov    $0x0,%ecx
            c->precision = c->precision * 10 + *format - '0';
c0026d9e:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026da1:	01 c9                	add    %ecx,%ecx
c0026da3:	8d 4c 08 d0          	lea    -0x30(%eax,%ecx,1),%ecx
          for (; isdigit (*format); format++)
c0026da7:	42                   	inc    %edx
c0026da8:	0f be 02             	movsbl (%edx),%eax
c0026dab:	8d 58 d0             	lea    -0x30(%eax),%ebx
c0026dae:	83 fb 09             	cmp    $0x9,%ebx
c0026db1:	76 eb                	jbe    c0026d9e <__vprintf+0x19a>
c0026db3:	89 4c 24 28          	mov    %ecx,0x28(%esp)
c0026db7:	89 d3                	mov    %edx,%ebx
      if (c->precision < 0) 
c0026db9:	8b 54 24 28          	mov    0x28(%esp),%edx
c0026dbd:	85 d2                	test   %edx,%edx
c0026dbf:	78 24                	js     c0026de5 <__vprintf+0x1e1>
    c->flags &= ~ZERO;
c0026dc1:	83 64 24 20 ef       	andl   $0xffffffef,0x20(%esp)
c0026dc6:	e9 4c ff ff ff       	jmp    c0026d17 <__vprintf+0x113>
          format++;
c0026dcb:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c0026dce:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026dd2:	8b 00                	mov    (%eax),%eax
c0026dd4:	89 44 24 28          	mov    %eax,0x28(%esp)
c0026dd8:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026ddc:	8d 40 04             	lea    0x4(%eax),%eax
c0026ddf:	89 44 24 54          	mov    %eax,0x54(%esp)
c0026de3:	eb d4                	jmp    c0026db9 <__vprintf+0x1b5>
        c->precision = -1;
c0026de5:	c7 44 24 28 ff ff ff 	movl   $0xffffffff,0x28(%esp)
c0026dec:	ff 
c0026ded:	e9 21 ff ff ff       	jmp    c0026d13 <__vprintf+0x10f>
      format++;
c0026df2:	89 d3                	mov    %edx,%ebx
  if (c->precision >= 0)
c0026df4:	ba 00 00 00 00       	mov    $0x0,%edx
c0026df9:	eb c6                	jmp    c0026dc1 <__vprintf+0x1bd>
      if (*format == 'h') 
c0026dfb:	8a 43 01             	mov    0x1(%ebx),%al
c0026dfe:	3c 68                	cmp    $0x68,%al
c0026e00:	74 21                	je     c0026e23 <__vprintf+0x21f>
        c->type = SHORT;
c0026e02:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c0026e09:	00 
      switch (*format) 
c0026e0a:	0f be e8             	movsbl %al,%ebp
c0026e0d:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e10:	80 fb 33             	cmp    $0x33,%bl
c0026e13:	0f 87 ba 04 00 00    	ja     c00272d3 <__vprintf+0x6cf>
c0026e19:	0f b6 db             	movzbl %bl,%ebx
c0026e1c:	ff 24 9d 60 00 03 c0 	jmp    *-0x3ffcffa0(,%ebx,4)
          format++;
c0026e23:	8d 7b 02             	lea    0x2(%ebx),%edi
          c->type = CHAR;
c0026e26:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c0026e2d:	00 
      switch (*format) 
c0026e2e:	8a 43 02             	mov    0x2(%ebx),%al
c0026e31:	0f be e8             	movsbl %al,%ebp
c0026e34:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e37:	80 fb 33             	cmp    $0x33,%bl
c0026e3a:	0f 87 93 04 00 00    	ja     c00272d3 <__vprintf+0x6cf>
c0026e40:	0f b6 db             	movzbl %bl,%ebx
c0026e43:	ff 24 9d 30 01 03 c0 	jmp    *-0x3ffcfed0(,%ebx,4)
      c->type = INTMAX;
c0026e4a:	c7 44 24 2c 04 00 00 	movl   $0x4,0x2c(%esp)
c0026e51:	00 
      switch (*format) 
c0026e52:	8a 43 01             	mov    0x1(%ebx),%al
c0026e55:	0f be e8             	movsbl %al,%ebp
c0026e58:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e5b:	80 fb 33             	cmp    $0x33,%bl
c0026e5e:	0f 87 6f 04 00 00    	ja     c00272d3 <__vprintf+0x6cf>
c0026e64:	0f b6 db             	movzbl %bl,%ebx
c0026e67:	ff 24 9d 00 02 03 c0 	jmp    *-0x3ffcfe00(,%ebx,4)
      if (*format == 'l')
c0026e6e:	8a 43 01             	mov    0x1(%ebx),%al
c0026e71:	3c 6c                	cmp    $0x6c,%al
c0026e73:	74 21                	je     c0026e96 <__vprintf+0x292>
        c->type = LONG;
c0026e75:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c0026e7c:	00 
      switch (*format) 
c0026e7d:	0f be e8             	movsbl %al,%ebp
c0026e80:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026e83:	80 fb 33             	cmp    $0x33,%bl
c0026e86:	0f 87 47 04 00 00    	ja     c00272d3 <__vprintf+0x6cf>
c0026e8c:	0f b6 db             	movzbl %bl,%ebx
c0026e8f:	ff 24 9d d0 02 03 c0 	jmp    *-0x3ffcfd30(,%ebx,4)
          format++;
c0026e96:	8d 7b 02             	lea    0x2(%ebx),%edi
          c->type = LONGLONG;
c0026e99:	c7 44 24 2c 06 00 00 	movl   $0x6,0x2c(%esp)
c0026ea0:	00 
      switch (*format) 
c0026ea1:	8a 43 02             	mov    0x2(%ebx),%al
c0026ea4:	0f be e8             	movsbl %al,%ebp
c0026ea7:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026eaa:	80 fb 33             	cmp    $0x33,%bl
c0026ead:	0f 87 20 04 00 00    	ja     c00272d3 <__vprintf+0x6cf>
c0026eb3:	0f b6 db             	movzbl %bl,%ebx
c0026eb6:	ff 24 9d a0 03 03 c0 	jmp    *-0x3ffcfc60(,%ebx,4)
      c->type = PTRDIFFT;
c0026ebd:	c7 44 24 2c 07 00 00 	movl   $0x7,0x2c(%esp)
c0026ec4:	00 
      switch (*format) 
c0026ec5:	8a 43 01             	mov    0x1(%ebx),%al
c0026ec8:	0f be e8             	movsbl %al,%ebp
c0026ecb:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026ece:	80 fb 33             	cmp    $0x33,%bl
c0026ed1:	0f 87 fc 03 00 00    	ja     c00272d3 <__vprintf+0x6cf>
c0026ed7:	0f b6 db             	movzbl %bl,%ebx
c0026eda:	ff 24 9d 70 04 03 c0 	jmp    *-0x3ffcfb90(,%ebx,4)
      c->type = SIZET;
c0026ee1:	c7 44 24 2c 08 00 00 	movl   $0x8,0x2c(%esp)
c0026ee8:	00 
      switch (*format) 
c0026ee9:	8a 43 01             	mov    0x1(%ebx),%al
c0026eec:	0f be e8             	movsbl %al,%ebp
c0026eef:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0026ef2:	80 fb 33             	cmp    $0x33,%bl
c0026ef5:	0f 87 d8 03 00 00    	ja     c00272d3 <__vprintf+0x6cf>
c0026efb:	0f b6 db             	movzbl %bl,%ebx
c0026efe:	ff 24 9d 40 05 03 c0 	jmp    *-0x3ffcfac0(,%ebx,4)
c0026f05:	0f be e8             	movsbl %al,%ebp
c0026f08:	8d 70 bb             	lea    -0x45(%eax),%esi
c0026f0b:	89 f1                	mov    %esi,%ecx
c0026f0d:	80 f9 33             	cmp    $0x33,%cl
c0026f10:	0f 87 bb 03 00 00    	ja     c00272d1 <__vprintf+0x6cd>
c0026f16:	0f b6 f1             	movzbl %cl,%esi
c0026f19:	ff 24 b5 10 06 03 c0 	jmp    *-0x3ffcf9f0(,%esi,4)
c0026f20:	89 df                	mov    %ebx,%edi
            switch (c.type) 
c0026f22:	83 7c 24 2c 08       	cmpl   $0x8,0x2c(%esp)
c0026f27:	0f 87 fb 00 00 00    	ja     c0027028 <__vprintf+0x424>
c0026f2d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0026f31:	ff 24 85 e0 06 03 c0 	jmp    *-0x3ffcf920(,%eax,4)
                value = (signed char) va_arg (args, int);
c0026f38:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f3c:	0f be 08             	movsbl (%eax),%ecx
c0026f3f:	89 cb                	mov    %ecx,%ebx
c0026f41:	c1 fb 1f             	sar    $0x1f,%ebx
c0026f44:	8d 40 04             	lea    0x4(%eax),%eax
c0026f47:	89 44 24 54          	mov    %eax,0x54(%esp)
            format_integer (value < 0 ? -value : value,
c0026f4b:	89 c8                	mov    %ecx,%eax
c0026f4d:	89 da                	mov    %ebx,%edx
c0026f4f:	85 db                	test   %ebx,%ebx
c0026f51:	0f 88 f3 00 00 00    	js     c002704a <__vprintf+0x446>
c0026f57:	83 ec 0c             	sub    $0xc,%esp
c0026f5a:	ff 74 24 68          	pushl  0x68(%esp)
c0026f5e:	ff 74 24 68          	pushl  0x68(%esp)
c0026f62:	8d 74 24 34          	lea    0x34(%esp),%esi
c0026f66:	56                   	push   %esi
c0026f67:	68 40 07 03 c0       	push   $0xc0030740
c0026f6c:	89 d9                	mov    %ebx,%ecx
c0026f6e:	c1 e9 1f             	shr    $0x1f,%ecx
c0026f71:	51                   	push   %ecx
c0026f72:	b9 01 00 00 00       	mov    $0x1,%ecx
c0026f77:	e8 56 f8 ff ff       	call   c00267d2 <format_integer>
          break;
c0026f7c:	83 c4 20             	add    $0x20,%esp
c0026f7f:	89 fb                	mov    %edi,%ebx
c0026f81:	e9 c9 fc ff ff       	jmp    c0026c4f <__vprintf+0x4b>
                value = (short) va_arg (args, int);
c0026f86:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f8a:	0f bf 08             	movswl (%eax),%ecx
c0026f8d:	89 cb                	mov    %ecx,%ebx
c0026f8f:	c1 fb 1f             	sar    $0x1f,%ebx
c0026f92:	8d 40 04             	lea    0x4(%eax),%eax
c0026f95:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026f99:	eb b0                	jmp    c0026f4b <__vprintf+0x347>
                value = va_arg (args, int);
c0026f9b:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026f9f:	8b 08                	mov    (%eax),%ecx
c0026fa1:	89 cb                	mov    %ecx,%ebx
c0026fa3:	c1 fb 1f             	sar    $0x1f,%ebx
c0026fa6:	8d 40 04             	lea    0x4(%eax),%eax
c0026fa9:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026fad:	eb 9c                	jmp    c0026f4b <__vprintf+0x347>
                value = va_arg (args, intmax_t);
c0026faf:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026fb3:	8b 08                	mov    (%eax),%ecx
c0026fb5:	8b 58 04             	mov    0x4(%eax),%ebx
c0026fb8:	8d 40 08             	lea    0x8(%eax),%eax
c0026fbb:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026fbf:	eb 8a                	jmp    c0026f4b <__vprintf+0x347>
                value = va_arg (args, long);
c0026fc1:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026fc5:	8b 08                	mov    (%eax),%ecx
c0026fc7:	89 cb                	mov    %ecx,%ebx
c0026fc9:	c1 fb 1f             	sar    $0x1f,%ebx
c0026fcc:	8d 40 04             	lea    0x4(%eax),%eax
c0026fcf:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026fd3:	e9 73 ff ff ff       	jmp    c0026f4b <__vprintf+0x347>
                value = va_arg (args, long long);
c0026fd8:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026fdc:	8b 08                	mov    (%eax),%ecx
c0026fde:	8b 58 04             	mov    0x4(%eax),%ebx
c0026fe1:	8d 40 08             	lea    0x8(%eax),%eax
c0026fe4:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026fe8:	e9 5e ff ff ff       	jmp    c0026f4b <__vprintf+0x347>
                value = va_arg (args, ptrdiff_t);
c0026fed:	8b 44 24 54          	mov    0x54(%esp),%eax
c0026ff1:	8b 08                	mov    (%eax),%ecx
c0026ff3:	89 cb                	mov    %ecx,%ebx
c0026ff5:	c1 fb 1f             	sar    $0x1f,%ebx
c0026ff8:	8d 40 04             	lea    0x4(%eax),%eax
c0026ffb:	89 44 24 54          	mov    %eax,0x54(%esp)
                break;
c0026fff:	e9 47 ff ff ff       	jmp    c0026f4b <__vprintf+0x347>
                value = va_arg (args, size_t);
c0027004:	8b 44 24 54          	mov    0x54(%esp),%eax
c0027008:	83 c0 04             	add    $0x4,%eax
c002700b:	8b 74 24 54          	mov    0x54(%esp),%esi
c002700f:	8b 0e                	mov    (%esi),%ecx
c0027011:	bb 00 00 00 00       	mov    $0x0,%ebx
                if (value > SIZE_MAX / 2)
c0027016:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
c002701c:	76 23                	jbe    c0027041 <__vprintf+0x43d>
                  value = value - SIZE_MAX - 1;
c002701e:	4b                   	dec    %ebx
                value = va_arg (args, size_t);
c002701f:	89 44 24 54          	mov    %eax,0x54(%esp)
c0027023:	e9 23 ff ff ff       	jmp    c0026f4b <__vprintf+0x347>
                NOT_REACHED ();
c0027028:	68 54 14 03 c0       	push   $0xc0031454
c002702d:	68 04 07 03 c0       	push   $0xc0030704
c0027032:	68 dc 00 00 00       	push   $0xdc
c0027037:	68 c1 26 03 c0       	push   $0xc00326c1
c002703c:	e8 3c 16 00 00       	call   c002867d <debug_panic>
                value = va_arg (args, size_t);
c0027041:	89 44 24 54          	mov    %eax,0x54(%esp)
c0027045:	e9 01 ff ff ff       	jmp    c0026f4b <__vprintf+0x347>
            format_integer (value < 0 ? -value : value,
c002704a:	f7 d8                	neg    %eax
c002704c:	83 d2 00             	adc    $0x0,%edx
c002704f:	f7 da                	neg    %edx
c0027051:	e9 01 ff ff ff       	jmp    c0026f57 <__vprintf+0x353>
                value = va_arg (args, unsigned);
c0027056:	8b 7c 24 54          	mov    0x54(%esp),%edi
c002705a:	8b 3f                	mov    (%edi),%edi
c002705c:	bd 00 00 00 00       	mov    $0x0,%ebp
c0027061:	89 7c 24 08          	mov    %edi,0x8(%esp)
c0027065:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
c0027069:	8b 7c 24 54          	mov    0x54(%esp),%edi
c002706d:	8d 7f 04             	lea    0x4(%edi),%edi
c0027070:	89 7c 24 54          	mov    %edi,0x54(%esp)
            switch (*format) 
c0027074:	3c 6f                	cmp    $0x6f,%al
c0027076:	0f 84 68 01 00 00    	je     c00271e4 <__vprintf+0x5e0>
c002707c:	3c 6f                	cmp    $0x6f,%al
c002707e:	0f 8e 0a 01 00 00    	jle    c002718e <__vprintf+0x58a>
c0027084:	3c 75                	cmp    $0x75,%al
c0027086:	0f 84 0d 01 00 00    	je     c0027199 <__vprintf+0x595>
c002708c:	3c 78                	cmp    $0x78,%al
c002708e:	0f 85 37 01 00 00    	jne    c00271cb <__vprintf+0x5c7>
              case 'x': b = &base_x; break;
c0027094:	b8 20 07 03 c0       	mov    $0xc0030720,%eax
c0027099:	e9 00 01 00 00       	jmp    c002719e <__vprintf+0x59a>
                value = (unsigned char) va_arg (args, unsigned);
c002709e:	8b 74 24 54          	mov    0x54(%esp),%esi
c00270a2:	0f b6 16             	movzbl (%esi),%edx
c00270a5:	89 54 24 08          	mov    %edx,0x8(%esp)
c00270a9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c00270b0:	00 
                break;
c00270b1:	89 fb                	mov    %edi,%ebx
                value = (unsigned char) va_arg (args, unsigned);
c00270b3:	8d 7e 04             	lea    0x4(%esi),%edi
c00270b6:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c00270ba:	eb b8                	jmp    c0027074 <__vprintf+0x470>
                value = (unsigned short) va_arg (args, unsigned);
c00270bc:	8b 74 24 54          	mov    0x54(%esp),%esi
c00270c0:	0f b7 16             	movzwl (%esi),%edx
c00270c3:	89 54 24 08          	mov    %edx,0x8(%esp)
c00270c7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c00270ce:	00 
                break;
c00270cf:	89 fb                	mov    %edi,%ebx
                value = (unsigned short) va_arg (args, unsigned);
c00270d1:	8d 7e 04             	lea    0x4(%esi),%edi
c00270d4:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c00270d8:	eb 9a                	jmp    c0027074 <__vprintf+0x470>
                value = va_arg (args, uintmax_t);
c00270da:	8b 74 24 54          	mov    0x54(%esp),%esi
c00270de:	8b 1e                	mov    (%esi),%ebx
c00270e0:	8b 76 04             	mov    0x4(%esi),%esi
c00270e3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c00270e7:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c00270eb:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, uintmax_t);
c00270ed:	8b 7c 24 54          	mov    0x54(%esp),%edi
c00270f1:	8d 7f 08             	lea    0x8(%edi),%edi
c00270f4:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c00270f8:	e9 77 ff ff ff       	jmp    c0027074 <__vprintf+0x470>
                value = va_arg (args, unsigned long);
c00270fd:	8b 74 24 54          	mov    0x54(%esp),%esi
c0027101:	8b 1e                	mov    (%esi),%ebx
c0027103:	be 00 00 00 00       	mov    $0x0,%esi
c0027108:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c002710c:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c0027110:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, unsigned long);
c0027112:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0027116:	8d 7f 04             	lea    0x4(%edi),%edi
c0027119:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c002711d:	e9 52 ff ff ff       	jmp    c0027074 <__vprintf+0x470>
                value = va_arg (args, unsigned long long);
c0027122:	8b 74 24 54          	mov    0x54(%esp),%esi
c0027126:	8b 1e                	mov    (%esi),%ebx
c0027128:	8b 76 04             	mov    0x4(%esi),%esi
c002712b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c002712f:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c0027133:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, unsigned long long);
c0027135:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0027139:	8d 7f 08             	lea    0x8(%edi),%edi
c002713c:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0027140:	e9 2f ff ff ff       	jmp    c0027074 <__vprintf+0x470>
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0027145:	8b 74 24 54          	mov    0x54(%esp),%esi
c0027149:	8b 36                	mov    (%esi),%esi
c002714b:	89 74 24 08          	mov    %esi,0x8(%esp)
c002714f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027156:	00 
                break;
c0027157:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, ptrdiff_t);
c0027159:	8b 7c 24 54          	mov    0x54(%esp),%edi
c002715d:	8d 7f 04             	lea    0x4(%edi),%edi
c0027160:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0027164:	e9 0b ff ff ff       	jmp    c0027074 <__vprintf+0x470>
                value = va_arg (args, size_t);
c0027169:	8b 74 24 54          	mov    0x54(%esp),%esi
c002716d:	8b 1e                	mov    (%esi),%ebx
c002716f:	be 00 00 00 00       	mov    $0x0,%esi
c0027174:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0027178:	89 74 24 0c          	mov    %esi,0xc(%esp)
                break;
c002717c:	89 fb                	mov    %edi,%ebx
                value = va_arg (args, size_t);
c002717e:	8b 7c 24 54          	mov    0x54(%esp),%edi
c0027182:	8d 7f 04             	lea    0x4(%edi),%edi
c0027185:	89 7c 24 54          	mov    %edi,0x54(%esp)
                break;
c0027189:	e9 e6 fe ff ff       	jmp    c0027074 <__vprintf+0x470>
            switch (*format) 
c002718e:	3c 58                	cmp    $0x58,%al
c0027190:	75 39                	jne    c00271cb <__vprintf+0x5c7>
              case 'X': b = &base_X; break;
c0027192:	b8 10 07 03 c0       	mov    $0xc0030710,%eax
c0027197:	eb 05                	jmp    c002719e <__vprintf+0x59a>
              case 'u': b = &base_d; break;
c0027199:	b8 40 07 03 c0       	mov    $0xc0030740,%eax
            format_integer (value, false, false, b, &c, output, aux);
c002719e:	83 ec 0c             	sub    $0xc,%esp
c00271a1:	ff 74 24 68          	pushl  0x68(%esp)
c00271a5:	ff 74 24 68          	pushl  0x68(%esp)
c00271a9:	8d 7c 24 34          	lea    0x34(%esp),%edi
c00271ad:	57                   	push   %edi
c00271ae:	50                   	push   %eax
c00271af:	6a 00                	push   $0x0
c00271b1:	b9 00 00 00 00       	mov    $0x0,%ecx
c00271b6:	8b 44 24 28          	mov    0x28(%esp),%eax
c00271ba:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c00271be:	e8 0f f6 ff ff       	call   c00267d2 <format_integer>
          break;
c00271c3:	83 c4 20             	add    $0x20,%esp
c00271c6:	e9 84 fa ff ff       	jmp    c0026c4f <__vprintf+0x4b>
              default: NOT_REACHED ();
c00271cb:	68 54 14 03 c0       	push   $0xc0031454
c00271d0:	68 04 07 03 c0       	push   $0xc0030704
c00271d5:	68 14 01 00 00       	push   $0x114
c00271da:	68 c1 26 03 c0       	push   $0xc00326c1
c00271df:	e8 99 14 00 00       	call   c002867d <debug_panic>
              case 'o': b = &base_o; break;
c00271e4:	b8 30 07 03 c0       	mov    $0xc0030730,%eax
c00271e9:	eb b3                	jmp    c002719e <__vprintf+0x59a>
      switch (*format) 
c00271eb:	89 df                	mov    %ebx,%edi
            char ch = va_arg (args, int);
c00271ed:	8b 44 24 54          	mov    0x54(%esp),%eax
c00271f1:	8d 70 04             	lea    0x4(%eax),%esi
c00271f4:	8b 00                	mov    (%eax),%eax
c00271f6:	88 44 24 1f          	mov    %al,0x1f(%esp)
            format_string (&ch, 1, &c, output, aux);
c00271fa:	83 ec 08             	sub    $0x8,%esp
c00271fd:	ff 74 24 64          	pushl  0x64(%esp)
c0027201:	ff 74 24 64          	pushl  0x64(%esp)
c0027205:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c0027209:	ba 01 00 00 00       	mov    $0x1,%edx
c002720e:	8d 44 24 2f          	lea    0x2f(%esp),%eax
c0027212:	e8 18 f9 ff ff       	call   c0026b2f <format_string>
          break;
c0027217:	83 c4 10             	add    $0x10,%esp
c002721a:	89 fb                	mov    %edi,%ebx
            char ch = va_arg (args, int);
c002721c:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c0027220:	e9 2a fa ff ff       	jmp    c0026c4f <__vprintf+0x4b>
      switch (*format) 
c0027225:	89 df                	mov    %ebx,%edi
            const char *s = va_arg (args, char *);
c0027227:	8b 44 24 54          	mov    0x54(%esp),%eax
c002722b:	8d 70 04             	lea    0x4(%eax),%esi
c002722e:	8b 18                	mov    (%eax),%ebx
            if (s == NULL)
c0027230:	85 db                	test   %ebx,%ebx
c0027232:	74 30                	je     c0027264 <__vprintf+0x660>
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027234:	83 ec 08             	sub    $0x8,%esp
c0027237:	52                   	push   %edx
c0027238:	53                   	push   %ebx
c0027239:	e8 0e 0b 00 00       	call   c0027d4c <strnlen>
c002723e:	83 c4 08             	add    $0x8,%esp
c0027241:	ff 74 24 64          	pushl  0x64(%esp)
c0027245:	ff 74 24 64          	pushl  0x64(%esp)
c0027249:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c002724d:	89 c2                	mov    %eax,%edx
c002724f:	89 d8                	mov    %ebx,%eax
c0027251:	e8 d9 f8 ff ff       	call   c0026b2f <format_string>
          break;
c0027256:	83 c4 10             	add    $0x10,%esp
c0027259:	89 fb                	mov    %edi,%ebx
            const char *s = va_arg (args, char *);
c002725b:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c002725f:	e9 eb f9 ff ff       	jmp    c0026c4f <__vprintf+0x4b>
              s = "(null)";
c0027264:	bb ba 26 03 c0       	mov    $0xc00326ba,%ebx
c0027269:	eb c9                	jmp    c0027234 <__vprintf+0x630>
      switch (*format) 
c002726b:	89 df                	mov    %ebx,%edi
            void *p = va_arg (args, void *);
c002726d:	8b 44 24 54          	mov    0x54(%esp),%eax
c0027271:	8d 70 04             	lea    0x4(%eax),%esi
c0027274:	8b 00                	mov    (%eax),%eax
            c.flags = POUND;
c0027276:	c7 44 24 20 08 00 00 	movl   $0x8,0x20(%esp)
c002727d:	00 
            format_integer ((uintptr_t) p, false, false,
c002727e:	83 ec 0c             	sub    $0xc,%esp
c0027281:	ff 74 24 68          	pushl  0x68(%esp)
c0027285:	ff 74 24 68          	pushl  0x68(%esp)
c0027289:	8d 5c 24 34          	lea    0x34(%esp),%ebx
c002728d:	53                   	push   %ebx
c002728e:	68 20 07 03 c0       	push   $0xc0030720
c0027293:	6a 00                	push   $0x0
c0027295:	b9 00 00 00 00       	mov    $0x0,%ecx
c002729a:	ba 00 00 00 00       	mov    $0x0,%edx
c002729f:	e8 2e f5 ff ff       	call   c00267d2 <format_integer>
          break;
c00272a4:	83 c4 20             	add    $0x20,%esp
c00272a7:	89 fb                	mov    %edi,%ebx
            void *p = va_arg (args, void *);
c00272a9:	89 74 24 54          	mov    %esi,0x54(%esp)
          break;
c00272ad:	e9 9d f9 ff ff       	jmp    c0026c4f <__vprintf+0x4b>
      switch (*format) 
c00272b2:	89 df                	mov    %ebx,%edi
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c00272b4:	55                   	push   %ebp
c00272b5:	ff 74 24 60          	pushl  0x60(%esp)
c00272b9:	ff 74 24 60          	pushl  0x60(%esp)
c00272bd:	68 d3 26 03 c0       	push   $0xc00326d3
c00272c2:	e8 20 f9 ff ff       	call   c0026be7 <__printf>
          break;
c00272c7:	83 c4 10             	add    $0x10,%esp
c00272ca:	89 fb                	mov    %edi,%ebx
c00272cc:	e9 7e f9 ff ff       	jmp    c0026c4f <__vprintf+0x4b>
      switch (*format) 
c00272d1:	89 df                	mov    %ebx,%edi
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c00272d3:	55                   	push   %ebp
c00272d4:	ff 74 24 60          	pushl  0x60(%esp)
c00272d8:	ff 74 24 60          	pushl  0x60(%esp)
c00272dc:	68 e9 26 03 c0       	push   $0xc00326e9
c00272e1:	e8 01 f9 ff ff       	call   c0026be7 <__printf>
          break;
c00272e6:	83 c4 10             	add    $0x10,%esp
c00272e9:	89 fb                	mov    %edi,%ebx
c00272eb:	e9 5f f9 ff ff       	jmp    c0026c4f <__vprintf+0x4b>

c00272f0 <vsnprintf>:
{
c00272f0:	53                   	push   %ebx
c00272f1:	83 ec 18             	sub    $0x18,%esp
c00272f4:	8b 44 24 24          	mov    0x24(%esp),%eax
c00272f8:	8b 54 24 28          	mov    0x28(%esp),%edx
c00272fc:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c0027300:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0027304:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  aux.length = 0;
c0027308:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002730f:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027310:	85 c0                	test   %eax,%eax
c0027312:	74 29                	je     c002733d <vsnprintf+0x4d>
c0027314:	48                   	dec    %eax
c0027315:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027319:	8d 44 24 04          	lea    0x4(%esp),%eax
c002731d:	50                   	push   %eax
c002731e:	68 81 67 02 c0       	push   $0xc0026781
c0027323:	51                   	push   %ecx
c0027324:	52                   	push   %edx
c0027325:	e8 da f8 ff ff       	call   c0026c04 <__vprintf>
    *aux.p = '\0';
c002732a:	8b 44 24 14          	mov    0x14(%esp),%eax
c002732e:	c6 00 00             	movb   $0x0,(%eax)
c0027331:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c0027334:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c0027338:	83 c4 18             	add    $0x18,%esp
c002733b:	5b                   	pop    %ebx
c002733c:	c3                   	ret    
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c002733d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027344:	00 
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027345:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027349:	50                   	push   %eax
c002734a:	68 81 67 02 c0       	push   $0xc0026781
c002734f:	51                   	push   %ecx
c0027350:	52                   	push   %edx
c0027351:	e8 ae f8 ff ff       	call   c0026c04 <__vprintf>
c0027356:	83 c4 10             	add    $0x10,%esp
c0027359:	eb d9                	jmp    c0027334 <vsnprintf+0x44>

c002735b <snprintf>:
{
c002735b:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c002735e:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c0027362:	50                   	push   %eax
c0027363:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027367:	ff 74 24 1c          	pushl  0x1c(%esp)
c002736b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002736f:	e8 7c ff ff ff       	call   c00272f0 <vsnprintf>
}
c0027374:	83 c4 1c             	add    $0x1c,%esp
c0027377:	c3                   	ret    

c0027378 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027378:	55                   	push   %ebp
c0027379:	57                   	push   %edi
c002737a:	56                   	push   %esi
c002737b:	53                   	push   %ebx
c002737c:	83 ec 1c             	sub    $0x1c,%esp
c002737f:	8a 44 24 3c          	mov    0x3c(%esp),%al
c0027383:	88 44 24 0f          	mov    %al,0xf(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027387:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002738c:	0f 84 d9 01 00 00    	je     c002756b <hex_dump+0x1f3>
c0027392:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027396:	89 44 24 08          	mov    %eax,0x8(%esp)
c002739a:	e9 87 00 00 00       	jmp    c0027426 <hex_dump+0xae>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
c002739f:	8b 44 24 38          	mov    0x38(%esp),%eax
c00273a3:	89 44 24 04          	mov    %eax,0x4(%esp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c00273a7:	89 f3                	mov    %esi,%ebx
c00273a9:	e9 e2 00 00 00       	jmp    c0027490 <hex_dump+0x118>
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c00273ae:	b8 2d 00 00 00       	mov    $0x2d,%eax
c00273b3:	e9 f0 00 00 00       	jmp    c00274a8 <hex_dump+0x130>
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c00273b8:	83 ec 0c             	sub    $0xc,%esp
c00273bb:	0f b6 c0             	movzbl %al,%eax
c00273be:	50                   	push   %eax
c00273bf:	e8 0c 2e 00 00       	call   c002a1d0 <putchar>
          for (; i < end; i++)
c00273c4:	43                   	inc    %ebx
c00273c5:	83 c4 10             	add    $0x10,%esp
c00273c8:	39 fb                	cmp    %edi,%ebx
c00273ca:	73 12                	jae    c00273de <hex_dump+0x66>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c00273cc:	8a 04 1e             	mov    (%esi,%ebx,1),%al
static inline int isprint (int c) { return c >= 32 && c < 127; }
c00273cf:	0f b6 d0             	movzbl %al,%edx
c00273d2:	83 ea 20             	sub    $0x20,%edx
            printf ("%c",
c00273d5:	83 fa 5e             	cmp    $0x5e,%edx
c00273d8:	76 de                	jbe    c00273b8 <hex_dump+0x40>
c00273da:	89 e8                	mov    %ebp,%eax
c00273dc:	eb da                	jmp    c00273b8 <hex_dump+0x40>
          for (; i < per_line; i++)
c00273de:	83 fb 0f             	cmp    $0xf,%ebx
c00273e1:	77 13                	ja     c00273f6 <hex_dump+0x7e>
            printf (" ");
c00273e3:	83 ec 0c             	sub    $0xc,%esp
c00273e6:	6a 20                	push   $0x20
c00273e8:	e8 e3 2d 00 00       	call   c002a1d0 <putchar>
          for (; i < per_line; i++)
c00273ed:	43                   	inc    %ebx
c00273ee:	83 c4 10             	add    $0x10,%esp
c00273f1:	83 fb 0f             	cmp    $0xf,%ebx
c00273f4:	76 ed                	jbe    c00273e3 <hex_dump+0x6b>
          printf ("|");
c00273f6:	83 ec 0c             	sub    $0xc,%esp
c00273f9:	6a 7c                	push   $0x7c
c00273fb:	e8 d0 2d 00 00       	call   c002a1d0 <putchar>
c0027400:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027403:	83 ec 0c             	sub    $0xc,%esp
c0027406:	6a 0a                	push   $0xa
c0027408:	e8 c3 2d 00 00       	call   c002a1d0 <putchar>

      ofs += n;
c002740d:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027411:	01 44 24 40          	add    %eax,0x40(%esp)
      buf += n;
c0027415:	01 44 24 18          	add    %eax,0x18(%esp)
  while (size > 0)
c0027419:	83 c4 10             	add    $0x10,%esp
c002741c:	29 44 24 38          	sub    %eax,0x38(%esp)
c0027420:	0f 84 45 01 00 00    	je     c002756b <hex_dump+0x1f3>
      start = ofs % per_line;
c0027426:	8b 74 24 30          	mov    0x30(%esp),%esi
c002742a:	83 e6 0f             	and    $0xf,%esi
      if (end - start > size)
c002742d:	b8 10 00 00 00       	mov    $0x10,%eax
c0027432:	29 f0                	sub    %esi,%eax
c0027434:	89 44 24 04          	mov    %eax,0x4(%esp)
c0027438:	3b 44 24 38          	cmp    0x38(%esp),%eax
c002743c:	0f 86 ea 00 00 00    	jbe    c002752c <hex_dump+0x1b4>
        end = start + size;
c0027442:	89 f7                	mov    %esi,%edi
c0027444:	03 7c 24 38          	add    0x38(%esp),%edi
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027448:	83 ec 04             	sub    $0x4,%esp
c002744b:	8b 44 24 34          	mov    0x34(%esp),%eax
c002744f:	83 e0 f0             	and    $0xfffffff0,%eax
c0027452:	ba 00 00 00 00       	mov    $0x0,%edx
c0027457:	52                   	push   %edx
c0027458:	50                   	push   %eax
c0027459:	68 00 27 03 c0       	push   $0xc0032700
c002745e:	e8 6c f7 ff ff       	call   c0026bcf <printf>
      for (i = 0; i < start; i++)
c0027463:	83 c4 10             	add    $0x10,%esp
c0027466:	85 f6                	test   %esi,%esi
c0027468:	0f 84 31 ff ff ff    	je     c002739f <hex_dump+0x27>
      n = end - start;
c002746e:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027472:	89 44 24 04          	mov    %eax,0x4(%esp)
      end = per_line;
c0027476:	bb 00 00 00 00       	mov    $0x0,%ebx
        printf ("   ");
c002747b:	83 ec 0c             	sub    $0xc,%esp
c002747e:	68 08 27 03 c0       	push   $0xc0032708
c0027483:	e8 47 f7 ff ff       	call   c0026bcf <printf>
      for (i = 0; i < start; i++)
c0027488:	43                   	inc    %ebx
c0027489:	83 c4 10             	add    $0x10,%esp
c002748c:	39 de                	cmp    %ebx,%esi
c002748e:	77 eb                	ja     c002747b <hex_dump+0x103>
      for (; i < end; i++) 
c0027490:	39 fb                	cmp    %edi,%ebx
c0027492:	73 30                	jae    c00274c4 <hex_dump+0x14c>
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027494:	8b 6c 24 08          	mov    0x8(%esp),%ebp
c0027498:	29 f5                	sub    %esi,%ebp
        printf ("%02hhx%c",
c002749a:	83 fb 07             	cmp    $0x7,%ebx
c002749d:	0f 84 0b ff ff ff    	je     c00273ae <hex_dump+0x36>
c00274a3:	b8 20 00 00 00       	mov    $0x20,%eax
c00274a8:	83 ec 04             	sub    $0x4,%esp
c00274ab:	50                   	push   %eax
c00274ac:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
c00274b1:	50                   	push   %eax
c00274b2:	68 0c 27 03 c0       	push   $0xc003270c
c00274b7:	e8 13 f7 ff ff       	call   c0026bcf <printf>
      for (; i < end; i++) 
c00274bc:	43                   	inc    %ebx
c00274bd:	83 c4 10             	add    $0x10,%esp
c00274c0:	39 fb                	cmp    %edi,%ebx
c00274c2:	72 d6                	jb     c002749a <hex_dump+0x122>
      if (ascii) 
c00274c4:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00274c9:	0f 84 34 ff ff ff    	je     c0027403 <hex_dump+0x8b>
          for (; i < per_line; i++)
c00274cf:	83 fb 0f             	cmp    $0xf,%ebx
c00274d2:	77 16                	ja     c00274ea <hex_dump+0x172>
            printf ("   ");
c00274d4:	83 ec 0c             	sub    $0xc,%esp
c00274d7:	68 08 27 03 c0       	push   $0xc0032708
c00274dc:	e8 ee f6 ff ff       	call   c0026bcf <printf>
          for (; i < per_line; i++)
c00274e1:	43                   	inc    %ebx
c00274e2:	83 c4 10             	add    $0x10,%esp
c00274e5:	83 fb 10             	cmp    $0x10,%ebx
c00274e8:	75 ea                	jne    c00274d4 <hex_dump+0x15c>
          printf ("|");
c00274ea:	83 ec 0c             	sub    $0xc,%esp
c00274ed:	6a 7c                	push   $0x7c
c00274ef:	e8 dc 2c 00 00       	call   c002a1d0 <putchar>
          for (i = 0; i < start; i++)
c00274f4:	83 c4 10             	add    $0x10,%esp
c00274f7:	85 f6                	test   %esi,%esi
c00274f9:	74 63                	je     c002755e <hex_dump+0x1e6>
c00274fb:	bb 00 00 00 00       	mov    $0x0,%ebx
            printf (" ");
c0027500:	83 ec 0c             	sub    $0xc,%esp
c0027503:	6a 20                	push   $0x20
c0027505:	e8 c6 2c 00 00       	call   c002a1d0 <putchar>
          for (i = 0; i < start; i++)
c002750a:	43                   	inc    %ebx
c002750b:	83 c4 10             	add    $0x10,%esp
c002750e:	39 de                	cmp    %ebx,%esi
c0027510:	75 ee                	jne    c0027500 <hex_dump+0x188>
          for (; i < end; i++)
c0027512:	39 fb                	cmp    %edi,%ebx
c0027514:	0f 83 c4 fe ff ff    	jae    c00273de <hex_dump+0x66>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c002751a:	8b 44 24 08          	mov    0x8(%esp),%eax
c002751e:	29 f0                	sub    %esi,%eax
c0027520:	89 c6                	mov    %eax,%esi
c0027522:	bd 2e 00 00 00       	mov    $0x2e,%ebp
c0027527:	e9 a0 fe ff ff       	jmp    c00273cc <hex_dump+0x54>
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c002752c:	83 ec 04             	sub    $0x4,%esp
c002752f:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027533:	83 e0 f0             	and    $0xfffffff0,%eax
c0027536:	ba 00 00 00 00       	mov    $0x0,%edx
c002753b:	52                   	push   %edx
c002753c:	50                   	push   %eax
c002753d:	68 00 27 03 c0       	push   $0xc0032700
c0027542:	e8 88 f6 ff ff       	call   c0026bcf <printf>
      for (i = 0; i < start; i++)
c0027547:	83 c4 10             	add    $0x10,%esp
      end = per_line;
c002754a:	bf 10 00 00 00       	mov    $0x10,%edi
      for (i = 0; i < start; i++)
c002754f:	89 f3                	mov    %esi,%ebx
c0027551:	85 f6                	test   %esi,%esi
c0027553:	0f 85 1d ff ff ff    	jne    c0027476 <hex_dump+0xfe>
c0027559:	e9 36 ff ff ff       	jmp    c0027494 <hex_dump+0x11c>
          for (i = 0; i < start; i++)
c002755e:	89 f3                	mov    %esi,%ebx
          for (; i < end; i++)
c0027560:	85 ff                	test   %edi,%edi
c0027562:	75 b6                	jne    c002751a <hex_dump+0x1a2>
          for (i = 0; i < start; i++)
c0027564:	89 fb                	mov    %edi,%ebx
c0027566:	e9 78 fe ff ff       	jmp    c00273e3 <hex_dump+0x6b>
      size -= n;
    }
}
c002756b:	83 c4 1c             	add    $0x1c,%esp
c002756e:	5b                   	pop    %ebx
c002756f:	5e                   	pop    %esi
c0027570:	5f                   	pop    %edi
c0027571:	5d                   	pop    %ebp
c0027572:	c3                   	ret    

c0027573 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027573:	57                   	push   %edi
c0027574:	56                   	push   %esi
c0027575:	83 ec 04             	sub    $0x4,%esp
c0027578:	8b 74 24 10          	mov    0x10(%esp),%esi
c002757c:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
c0027580:	89 f0                	mov    %esi,%eax
c0027582:	83 f0 01             	xor    $0x1,%eax
c0027585:	89 fa                	mov    %edi,%edx
c0027587:	09 c2                	or     %eax,%edx
c0027589:	74 1d                	je     c00275a8 <print_human_readable_size+0x35>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002758b:	83 ff 00             	cmp    $0x0,%edi
c002758e:	77 08                	ja     c0027598 <print_human_readable_size+0x25>
c0027590:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0027596:	76 5d                	jbe    c00275f5 <print_human_readable_size+0x82>
c0027598:	b9 78 c6 03 c0       	mov    $0xc003c678,%ecx
c002759d:	83 3d 7c c6 03 c0 00 	cmpl   $0x0,0xc003c67c
c00275a4:	75 1a                	jne    c00275c0 <print_human_readable_size+0x4d>
c00275a6:	eb 36                	jmp    c00275de <print_human_readable_size+0x6b>
    printf ("1 byte");
c00275a8:	83 ec 0c             	sub    $0xc,%esp
c00275ab:	68 15 27 03 c0       	push   $0xc0032715
c00275b0:	e8 1a f6 ff ff       	call   c0026bcf <printf>
c00275b5:	83 c4 10             	add    $0x10,%esp
c00275b8:	eb 35                	jmp    c00275ef <print_human_readable_size+0x7c>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c00275ba:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
c00275be:	74 1e                	je     c00275de <print_human_readable_size+0x6b>
        size /= 1024;
c00275c0:	89 f0                	mov    %esi,%eax
c00275c2:	89 fa                	mov    %edi,%edx
c00275c4:	0f ac f8 0a          	shrd   $0xa,%edi,%eax
c00275c8:	c1 ea 0a             	shr    $0xa,%edx
c00275cb:	89 c6                	mov    %eax,%esi
c00275cd:	89 d7                	mov    %edx,%edi
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c00275cf:	83 c1 04             	add    $0x4,%ecx
c00275d2:	83 fa 00             	cmp    $0x0,%edx
c00275d5:	77 e3                	ja     c00275ba <print_human_readable_size+0x47>
c00275d7:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c00275dc:	77 dc                	ja     c00275ba <print_human_readable_size+0x47>
      printf ("%"PRIu64" %s", size, *fp);
c00275de:	ff 31                	pushl  (%ecx)
c00275e0:	57                   	push   %edi
c00275e1:	56                   	push   %esi
c00275e2:	68 1c 27 03 c0       	push   $0xc003271c
c00275e7:	e8 e3 f5 ff ff       	call   c0026bcf <printf>
c00275ec:	83 c4 10             	add    $0x10,%esp
    }
}
c00275ef:	83 c4 04             	add    $0x4,%esp
c00275f2:	5e                   	pop    %esi
c00275f3:	5f                   	pop    %edi
c00275f4:	c3                   	ret    
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c00275f5:	b9 78 c6 03 c0       	mov    $0xc003c678,%ecx
c00275fa:	eb e2                	jmp    c00275de <print_human_readable_size+0x6b>

c00275fc <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c00275fc:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c00275ff:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027603:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027607:	8b 44 24 28          	mov    0x28(%esp),%eax
c002760b:	ff 10                	call   *(%eax)
}
c002760d:	83 c4 1c             	add    $0x1c,%esp
c0027610:	c3                   	ret    

c0027611 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0027611:	55                   	push   %ebp
c0027612:	57                   	push   %edi
c0027613:	56                   	push   %esi
c0027614:	53                   	push   %ebx
c0027615:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c0027619:	8d 72 ff             	lea    -0x1(%edx),%esi
c002761c:	0f af f7             	imul   %edi,%esi
  unsigned char *b = array + (b_idx - 1) * size;
c002761f:	8d 59 ff             	lea    -0x1(%ecx),%ebx
c0027622:	0f af df             	imul   %edi,%ebx
  size_t i;

  for (i = 0; i < size; i++)
c0027625:	85 ff                	test   %edi,%edi
c0027627:	74 1d                	je     c0027646 <do_swap+0x35>
c0027629:	8d 14 30             	lea    (%eax,%esi,1),%edx
c002762c:	01 f7                	add    %esi,%edi
c002762e:	01 c7                	add    %eax,%edi
    {
      unsigned char t = a[i];
c0027630:	0f b6 2a             	movzbl (%edx),%ebp
c0027633:	89 d1                	mov    %edx,%ecx
c0027635:	29 f1                	sub    %esi,%ecx
      a[i] = b[i];
c0027637:	8a 04 19             	mov    (%ecx,%ebx,1),%al
c002763a:	88 02                	mov    %al,(%edx)
      b[i] = t;
c002763c:	89 e8                	mov    %ebp,%eax
c002763e:	88 04 19             	mov    %al,(%ecx,%ebx,1)
c0027641:	42                   	inc    %edx
  for (i = 0; i < size; i++)
c0027642:	39 fa                	cmp    %edi,%edx
c0027644:	75 ea                	jne    c0027630 <do_swap+0x1f>
    }
}
c0027646:	5b                   	pop    %ebx
c0027647:	5e                   	pop    %esi
c0027648:	5f                   	pop    %edi
c0027649:	5d                   	pop    %ebp
c002764a:	c3                   	ret    

c002764b <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c002764b:	55                   	push   %ebp
c002764c:	57                   	push   %edi
c002764d:	56                   	push   %esi
c002764e:	53                   	push   %ebx
c002764f:	83 ec 1c             	sub    $0x1c,%esp
c0027652:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027656:	89 d6                	mov    %edx,%esi
c0027658:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c002765c:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0027660:	eb 4a                	jmp    c00276ac <heapify+0x61>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027662:	83 ec 04             	sub    $0x4,%esp
c0027665:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027669:	8d 46 ff             	lea    -0x1(%esi),%eax
c002766c:	0f af c5             	imul   %ebp,%eax
c002766f:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0027673:	01 c8                	add    %ecx,%eax
c0027675:	50                   	push   %eax
c0027676:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027679:	0f af c5             	imul   %ebp,%eax
c002767c:	01 c8                	add    %ecx,%eax
c002767e:	50                   	push   %eax
c002767f:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027683:	83 c4 10             	add    $0x10,%esp
c0027686:	85 c0                	test   %eax,%eax
c0027688:	7e 2e                	jle    c00276b8 <heapify+0x6d>
        max = left;
      if (right <= cnt
c002768a:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002768e:	76 5b                	jbe    c00276eb <heapify+0xa0>
        max = left;
c0027690:	89 df                	mov    %ebx,%edi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0027692:	39 fe                	cmp    %edi,%esi
c0027694:	74 4d                	je     c00276e3 <heapify+0x98>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0027696:	83 ec 0c             	sub    $0xc,%esp
c0027699:	55                   	push   %ebp
c002769a:	89 f9                	mov    %edi,%ecx
c002769c:	89 f2                	mov    %esi,%edx
c002769e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c00276a2:	e8 6a ff ff ff       	call   c0027611 <do_swap>
c00276a7:	89 fe                	mov    %edi,%esi
    {
c00276a9:	83 c4 10             	add    $0x10,%esp
      size_t left = 2 * i;
c00276ac:	8d 1c 36             	lea    (%esi,%esi,1),%ebx
      size_t right = 2 * i + 1;
c00276af:	8d 7b 01             	lea    0x1(%ebx),%edi
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c00276b2:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c00276b6:	76 aa                	jbe    c0027662 <heapify+0x17>
      if (right <= cnt
c00276b8:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c00276bc:	77 25                	ja     c00276e3 <heapify+0x98>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c00276be:	83 ec 04             	sub    $0x4,%esp
c00276c1:	ff 74 24 3c          	pushl  0x3c(%esp)
c00276c5:	8d 46 ff             	lea    -0x1(%esi),%eax
c00276c8:	0f af c5             	imul   %ebp,%eax
c00276cb:	8b 54 24 14          	mov    0x14(%esp),%edx
c00276cf:	01 d0                	add    %edx,%eax
c00276d1:	50                   	push   %eax
c00276d2:	0f af dd             	imul   %ebp,%ebx
c00276d5:	01 d3                	add    %edx,%ebx
c00276d7:	53                   	push   %ebx
c00276d8:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c00276dc:	83 c4 10             	add    $0x10,%esp
c00276df:	85 c0                	test   %eax,%eax
c00276e1:	7f af                	jg     c0027692 <heapify+0x47>
      i = max;
    }
}
c00276e3:	83 c4 1c             	add    $0x1c,%esp
c00276e6:	5b                   	pop    %ebx
c00276e7:	5e                   	pop    %esi
c00276e8:	5f                   	pop    %edi
c00276e9:	5d                   	pop    %ebp
c00276ea:	c3                   	ret    
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c00276eb:	83 ec 04             	sub    $0x4,%esp
c00276ee:	ff 74 24 3c          	pushl  0x3c(%esp)
c00276f2:	8d 43 ff             	lea    -0x1(%ebx),%eax
c00276f5:	0f af c5             	imul   %ebp,%eax
c00276f8:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00276fc:	01 c8                	add    %ecx,%eax
c00276fe:	50                   	push   %eax
c00276ff:	89 d8                	mov    %ebx,%eax
c0027701:	0f af c5             	imul   %ebp,%eax
c0027704:	01 c8                	add    %ecx,%eax
c0027706:	50                   	push   %eax
c0027707:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c002770b:	83 c4 10             	add    $0x10,%esp
c002770e:	85 c0                	test   %eax,%eax
c0027710:	7f 80                	jg     c0027692 <heapify+0x47>
        max = left;
c0027712:	89 df                	mov    %ebx,%edi
c0027714:	e9 79 ff ff ff       	jmp    c0027692 <heapify+0x47>

c0027719 <atoi>:
{
c0027719:	56                   	push   %esi
c002771a:	53                   	push   %ebx
c002771b:	83 ec 04             	sub    $0x4,%esp
c002771e:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (s != NULL);
c0027722:	85 d2                	test   %edx,%edx
c0027724:	75 1f                	jne    c0027745 <atoi+0x2c>
c0027726:	83 ec 0c             	sub    $0xc,%esp
c0027729:	68 bb 27 03 c0       	push   $0xc00327bb
c002772e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027733:	68 58 07 03 c0       	push   $0xc0030758
c0027738:	6a 0f                	push   $0xf
c002773a:	68 6c 27 03 c0       	push   $0xc003276c
c002773f:	e8 39 0f 00 00       	call   c002867d <debug_panic>
    s++;
c0027744:	42                   	inc    %edx
  while (isspace ((unsigned char) *s))
c0027745:	8a 02                	mov    (%edx),%al
          || c == '\r' || c == '\t' || c == '\v');
c0027747:	3c 20                	cmp    $0x20,%al
c0027749:	74 f9                	je     c0027744 <atoi+0x2b>
c002774b:	8d 48 f7             	lea    -0x9(%eax),%ecx
c002774e:	80 f9 04             	cmp    $0x4,%cl
c0027751:	76 f1                	jbe    c0027744 <atoi+0x2b>
  if (*s == '+')
c0027753:	3c 2b                	cmp    $0x2b,%al
c0027755:	74 3e                	je     c0027795 <atoi+0x7c>
  else if (*s == '-')
c0027757:	3c 2d                	cmp    $0x2d,%al
c0027759:	74 3d                	je     c0027798 <atoi+0x7f>
  for (value = 0; isdigit (*s); s++)
c002775b:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c002775e:	8d 41 d0             	lea    -0x30(%ecx),%eax
c0027761:	be 00 00 00 00       	mov    $0x0,%esi
c0027766:	83 f8 09             	cmp    $0x9,%eax
c0027769:	77 4c                	ja     c00277b7 <atoi+0x9e>
      negative = true;
c002776b:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c0027770:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0027773:	89 c3                	mov    %eax,%ebx
c0027775:	29 cb                	sub    %ecx,%ebx
c0027777:	8d 44 03 30          	lea    0x30(%ebx,%eax,1),%eax
  for (value = 0; isdigit (*s); s++)
c002777b:	42                   	inc    %edx
c002777c:	0f be 0a             	movsbl (%edx),%ecx
c002777f:	8d 59 d0             	lea    -0x30(%ecx),%ebx
c0027782:	83 fb 09             	cmp    $0x9,%ebx
c0027785:	76 e9                	jbe    c0027770 <atoi+0x57>
  if (!negative)
c0027787:	89 f3                	mov    %esi,%ebx
c0027789:	84 db                	test   %bl,%bl
c002778b:	75 02                	jne    c002778f <atoi+0x76>
    value = -value;
c002778d:	f7 d8                	neg    %eax
}
c002778f:	83 c4 04             	add    $0x4,%esp
c0027792:	5b                   	pop    %ebx
c0027793:	5e                   	pop    %esi
c0027794:	c3                   	ret    
    s++;
c0027795:	42                   	inc    %edx
c0027796:	eb c3                	jmp    c002775b <atoi+0x42>
      s++;
c0027798:	8d 42 01             	lea    0x1(%edx),%eax
  for (value = 0; isdigit (*s); s++)
c002779b:	0f be 4a 01          	movsbl 0x1(%edx),%ecx
c002779f:	8d 51 d0             	lea    -0x30(%ecx),%edx
c00277a2:	83 fa 09             	cmp    $0x9,%edx
c00277a5:	77 09                	ja     c00277b0 <atoi+0x97>
      s++;
c00277a7:	89 c2                	mov    %eax,%edx
      negative = true;
c00277a9:	be 01 00 00 00       	mov    $0x1,%esi
c00277ae:	eb bb                	jmp    c002776b <atoi+0x52>
  for (value = 0; isdigit (*s); s++)
c00277b0:	b8 00 00 00 00       	mov    $0x0,%eax
  return value;
c00277b5:	eb d8                	jmp    c002778f <atoi+0x76>
  for (value = 0; isdigit (*s); s++)
c00277b7:	b8 00 00 00 00       	mov    $0x0,%eax
c00277bc:	eb cf                	jmp    c002778d <atoi+0x74>

c00277be <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c00277be:	55                   	push   %ebp
c00277bf:	57                   	push   %edi
c00277c0:	56                   	push   %esi
c00277c1:	53                   	push   %ebx
c00277c2:	83 ec 0c             	sub    $0xc,%esp
c00277c5:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c00277c9:	8b 7c 24 28          	mov    0x28(%esp),%edi
c00277cd:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c00277d1:	8b 74 24 30          	mov    0x30(%esp),%esi
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c00277d5:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c00277da:	74 7b                	je     c0027857 <sort+0x99>
  ASSERT (compare != NULL);
c00277dc:	85 ed                	test   %ebp,%ebp
c00277de:	0f 84 98 00 00 00    	je     c002787c <sort+0xbe>
  ASSERT (size > 0);
c00277e4:	85 ff                	test   %edi,%edi
c00277e6:	0f 84 b1 00 00 00    	je     c002789d <sort+0xdf>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c00277ec:	89 d8                	mov    %ebx,%eax
c00277ee:	d1 e8                	shr    %eax
c00277f0:	74 25                	je     c0027817 <sort+0x59>
c00277f2:	89 5c 24 24          	mov    %ebx,0x24(%esp)
c00277f6:	89 c3                	mov    %eax,%ebx
    heapify (array, i, cnt, size, compare, aux);
c00277f8:	83 ec 04             	sub    $0x4,%esp
c00277fb:	56                   	push   %esi
c00277fc:	55                   	push   %ebp
c00277fd:	57                   	push   %edi
c00277fe:	8b 4c 24 34          	mov    0x34(%esp),%ecx
c0027802:	89 da                	mov    %ebx,%edx
c0027804:	8b 44 24 30          	mov    0x30(%esp),%eax
c0027808:	e8 3e fe ff ff       	call   c002764b <heapify>
  for (i = cnt / 2; i > 0; i--)
c002780d:	83 c4 10             	add    $0x10,%esp
c0027810:	4b                   	dec    %ebx
c0027811:	75 e5                	jne    c00277f8 <sort+0x3a>
c0027813:	8b 5c 24 24          	mov    0x24(%esp),%ebx

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0027817:	83 fb 01             	cmp    $0x1,%ebx
c002781a:	76 33                	jbe    c002784f <sort+0x91>
    {
      do_swap (array, 1, i, size);
c002781c:	83 ec 0c             	sub    $0xc,%esp
c002781f:	57                   	push   %edi
c0027820:	89 d9                	mov    %ebx,%ecx
c0027822:	ba 01 00 00 00       	mov    $0x1,%edx
c0027827:	8b 44 24 30          	mov    0x30(%esp),%eax
c002782b:	e8 e1 fd ff ff       	call   c0027611 <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c0027830:	4b                   	dec    %ebx
c0027831:	83 c4 0c             	add    $0xc,%esp
c0027834:	56                   	push   %esi
c0027835:	55                   	push   %ebp
c0027836:	57                   	push   %edi
c0027837:	89 d9                	mov    %ebx,%ecx
c0027839:	ba 01 00 00 00       	mov    $0x1,%edx
c002783e:	8b 44 24 30          	mov    0x30(%esp),%eax
c0027842:	e8 04 fe ff ff       	call   c002764b <heapify>
  for (i = cnt; i > 1; i--) 
c0027847:	83 c4 10             	add    $0x10,%esp
c002784a:	83 fb 01             	cmp    $0x1,%ebx
c002784d:	75 cd                	jne    c002781c <sort+0x5e>
    }
}
c002784f:	83 c4 0c             	add    $0xc,%esp
c0027852:	5b                   	pop    %ebx
c0027853:	5e                   	pop    %esi
c0027854:	5f                   	pop    %edi
c0027855:	5d                   	pop    %ebp
c0027856:	c3                   	ret    
  ASSERT (array != NULL || cnt == 0);
c0027857:	85 db                	test   %ebx,%ebx
c0027859:	74 81                	je     c00277dc <sort+0x1e>
c002785b:	83 ec 0c             	sub    $0xc,%esp
c002785e:	68 7f 27 03 c0       	push   $0xc003277f
c0027863:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027868:	68 50 07 03 c0       	push   $0xc0030750
c002786d:	68 8a 00 00 00       	push   $0x8a
c0027872:	68 6c 27 03 c0       	push   $0xc003276c
c0027877:	e8 01 0e 00 00       	call   c002867d <debug_panic>
  ASSERT (compare != NULL);
c002787c:	83 ec 0c             	sub    $0xc,%esp
c002787f:	68 99 27 03 c0       	push   $0xc0032799
c0027884:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027889:	68 50 07 03 c0       	push   $0xc0030750
c002788e:	68 8b 00 00 00       	push   $0x8b
c0027893:	68 6c 27 03 c0       	push   $0xc003276c
c0027898:	e8 e0 0d 00 00       	call   c002867d <debug_panic>
  ASSERT (size > 0);
c002789d:	83 ec 0c             	sub    $0xc,%esp
c00278a0:	68 a9 27 03 c0       	push   $0xc00327a9
c00278a5:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00278aa:	68 50 07 03 c0       	push   $0xc0030750
c00278af:	68 8c 00 00 00       	push   $0x8c
c00278b4:	68 6c 27 03 c0       	push   $0xc003276c
c00278b9:	e8 bf 0d 00 00       	call   c002867d <debug_panic>

c00278be <qsort>:
{
c00278be:	83 ec 18             	sub    $0x18,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c00278c1:	8d 44 24 28          	lea    0x28(%esp),%eax
c00278c5:	50                   	push   %eax
c00278c6:	68 fc 75 02 c0       	push   $0xc00275fc
c00278cb:	ff 74 24 2c          	pushl  0x2c(%esp)
c00278cf:	ff 74 24 2c          	pushl  0x2c(%esp)
c00278d3:	ff 74 24 2c          	pushl  0x2c(%esp)
c00278d7:	e8 e2 fe ff ff       	call   c00277be <sort>
}
c00278dc:	83 c4 2c             	add    $0x2c,%esp
c00278df:	c3                   	ret    

c00278e0 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c00278e0:	55                   	push   %ebp
c00278e1:	57                   	push   %edi
c00278e2:	56                   	push   %esi
c00278e3:	53                   	push   %ebx
c00278e4:	83 ec 0c             	sub    $0xc,%esp
c00278e7:	8b 74 24 24          	mov    0x24(%esp),%esi
c00278eb:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c00278ef:	89 fd                	mov    %edi,%ebp
c00278f1:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c00278f6:	01 f5                	add    %esi,%ebp

  while (first < last) 
c00278f8:	39 ee                	cmp    %ebp,%esi
c00278fa:	72 0d                	jb     c0027909 <binary_search+0x29>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c00278fc:	b8 00 00 00 00       	mov    $0x0,%eax
c0027901:	eb 3e                	jmp    c0027941 <binary_search+0x61>
      const unsigned char *middle = first + (range / 2) * size;
c0027903:	89 dd                	mov    %ebx,%ebp
  while (first < last) 
c0027905:	39 ee                	cmp    %ebp,%esi
c0027907:	73 33                	jae    c002793c <binary_search+0x5c>
      size_t range = (last - first) / size;
c0027909:	89 e8                	mov    %ebp,%eax
c002790b:	29 f0                	sub    %esi,%eax
c002790d:	ba 00 00 00 00       	mov    $0x0,%edx
c0027912:	f7 f7                	div    %edi
      const unsigned char *middle = first + (range / 2) * size;
c0027914:	d1 e8                	shr    %eax
c0027916:	0f af c7             	imul   %edi,%eax
c0027919:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c002791c:	83 ec 04             	sub    $0x4,%esp
c002791f:	ff 74 24 38          	pushl  0x38(%esp)
c0027923:	53                   	push   %ebx
c0027924:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027928:	ff 54 24 40          	call   *0x40(%esp)
      if (cmp < 0) 
c002792c:	83 c4 10             	add    $0x10,%esp
c002792f:	85 c0                	test   %eax,%eax
c0027931:	78 d0                	js     c0027903 <binary_search+0x23>
      else if (cmp > 0) 
c0027933:	85 c0                	test   %eax,%eax
c0027935:	7e 12                	jle    c0027949 <binary_search+0x69>
        first = middle + size;
c0027937:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c002793a:	eb c9                	jmp    c0027905 <binary_search+0x25>
  return NULL;
c002793c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0027941:	83 c4 0c             	add    $0xc,%esp
c0027944:	5b                   	pop    %ebx
c0027945:	5e                   	pop    %esi
c0027946:	5f                   	pop    %edi
c0027947:	5d                   	pop    %ebp
c0027948:	c3                   	ret    
      const unsigned char *middle = first + (range / 2) * size;
c0027949:	89 d8                	mov    %ebx,%eax
c002794b:	eb f4                	jmp    c0027941 <binary_search+0x61>

c002794d <bsearch>:
{
c002794d:	83 ec 14             	sub    $0x14,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c0027950:	8d 44 24 28          	lea    0x28(%esp),%eax
c0027954:	50                   	push   %eax
c0027955:	68 fc 75 02 c0       	push   $0xc00275fc
c002795a:	ff 74 24 2c          	pushl  0x2c(%esp)
c002795e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027962:	ff 74 24 2c          	pushl  0x2c(%esp)
c0027966:	ff 74 24 2c          	pushl  0x2c(%esp)
c002796a:	e8 71 ff ff ff       	call   c00278e0 <binary_search>
}
c002796f:	83 c4 2c             	add    $0x2c,%esp
c0027972:	c3                   	ret    

c0027973 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0027973:	56                   	push   %esi
c0027974:	53                   	push   %ebx
c0027975:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027979:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002797d:	8b 74 24 14          	mov    0x14(%esp),%esi
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c0027981:	85 f6                	test   %esi,%esi
c0027983:	74 10                	je     c0027995 <memcpy+0x22>
c0027985:	ba 00 00 00 00       	mov    $0x0,%edx
    *dst++ = *src++;
c002798a:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
c002798d:	88 0c 10             	mov    %cl,(%eax,%edx,1)
c0027990:	42                   	inc    %edx
  while (size-- > 0)
c0027991:	39 f2                	cmp    %esi,%edx
c0027993:	75 f5                	jne    c002798a <memcpy+0x17>

  return dst_;
}
c0027995:	5b                   	pop    %ebx
c0027996:	5e                   	pop    %esi
c0027997:	c3                   	ret    

c0027998 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c0027998:	57                   	push   %edi
c0027999:	56                   	push   %esi
c002799a:	53                   	push   %ebx
c002799b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002799f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c00279a3:	8b 74 24 18          	mov    0x18(%esp),%esi
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
c00279a7:	39 d9                	cmp    %ebx,%ecx
c00279a9:	73 1d                	jae    c00279c8 <memmove+0x30>
    {
      while (size-- > 0)
c00279ab:	85 f6                	test   %esi,%esi
c00279ad:	74 35                	je     c00279e4 <memmove+0x4c>
c00279af:	b8 00 00 00 00       	mov    $0x0,%eax
        *dst++ = *src++;
c00279b4:	8a 14 03             	mov    (%ebx,%eax,1),%dl
c00279b7:	88 14 01             	mov    %dl,(%ecx,%eax,1)
c00279ba:	40                   	inc    %eax
      while (size-- > 0)
c00279bb:	39 f0                	cmp    %esi,%eax
c00279bd:	75 f5                	jne    c00279b4 <memmove+0x1c>
c00279bf:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c00279c2:	89 f8                	mov    %edi,%eax
c00279c4:	5b                   	pop    %ebx
c00279c5:	5e                   	pop    %esi
c00279c6:	5f                   	pop    %edi
c00279c7:	c3                   	ret    
      dst += size;
c00279c8:	8d 3c 31             	lea    (%ecx,%esi,1),%edi
      while (size-- > 0)
c00279cb:	8d 56 ff             	lea    -0x1(%esi),%edx
c00279ce:	85 f6                	test   %esi,%esi
c00279d0:	74 f0                	je     c00279c2 <memmove+0x2a>
c00279d2:	89 ce                	mov    %ecx,%esi
c00279d4:	89 f7                	mov    %esi,%edi
        *--dst = *--src;
c00279d6:	8a 04 13             	mov    (%ebx,%edx,1),%al
c00279d9:	88 04 11             	mov    %al,(%ecx,%edx,1)
      while (size-- > 0)
c00279dc:	4a                   	dec    %edx
c00279dd:	83 fa ff             	cmp    $0xffffffff,%edx
c00279e0:	75 f2                	jne    c00279d4 <memmove+0x3c>
c00279e2:	eb de                	jmp    c00279c2 <memmove+0x2a>
      while (size-- > 0)
c00279e4:	89 cf                	mov    %ecx,%edi
c00279e6:	eb da                	jmp    c00279c2 <memmove+0x2a>

c00279e8 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c00279e8:	57                   	push   %edi
c00279e9:	56                   	push   %esi
c00279ea:	53                   	push   %ebx
c00279eb:	8b 74 24 10          	mov    0x10(%esp),%esi
c00279ef:	8b 7c 24 14          	mov    0x14(%esp),%edi
c00279f3:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c00279f7:	85 db                	test   %ebx,%ebx
c00279f9:	74 30                	je     c0027a2b <memcmp+0x43>
    if (*a != *b)
c00279fb:	8a 16                	mov    (%esi),%dl
c00279fd:	8a 0f                	mov    (%edi),%cl
c00279ff:	38 ca                	cmp    %cl,%dl
c0027a01:	75 15                	jne    c0027a18 <memcmp+0x30>
c0027a03:	b8 01 00 00 00       	mov    $0x1,%eax
  for (; size-- > 0; a++, b++)
c0027a08:	39 d8                	cmp    %ebx,%eax
c0027a0a:	74 18                	je     c0027a24 <memcmp+0x3c>
    if (*a != *b)
c0027a0c:	8a 14 06             	mov    (%esi,%eax,1),%dl
c0027a0f:	40                   	inc    %eax
c0027a10:	8a 4c 07 ff          	mov    -0x1(%edi,%eax,1),%cl
c0027a14:	38 ca                	cmp    %cl,%dl
c0027a16:	74 f0                	je     c0027a08 <memcmp+0x20>
      return *a > *b ? +1 : -1;
c0027a18:	38 d1                	cmp    %dl,%cl
c0027a1a:	19 c0                	sbb    %eax,%eax
c0027a1c:	83 e0 02             	and    $0x2,%eax
c0027a1f:	48                   	dec    %eax
  return 0;
}
c0027a20:	5b                   	pop    %ebx
c0027a21:	5e                   	pop    %esi
c0027a22:	5f                   	pop    %edi
c0027a23:	c3                   	ret    
  return 0;
c0027a24:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a29:	eb f5                	jmp    c0027a20 <memcmp+0x38>
c0027a2b:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a30:	eb ee                	jmp    c0027a20 <memcmp+0x38>

c0027a32 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0027a32:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0027a36:	8b 44 24 08          	mov    0x8(%esp),%eax
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c0027a3a:	8a 11                	mov    (%ecx),%dl
c0027a3c:	84 d2                	test   %dl,%dl
c0027a3e:	74 10                	je     c0027a50 <strcmp+0x1e>
c0027a40:	3a 10                	cmp    (%eax),%dl
c0027a42:	75 0c                	jne    c0027a50 <strcmp+0x1e>
    {
      a++;
c0027a44:	41                   	inc    %ecx
      b++;
c0027a45:	40                   	inc    %eax
  while (*a != '\0' && *a == *b) 
c0027a46:	8a 11                	mov    (%ecx),%dl
c0027a48:	84 d2                	test   %dl,%dl
c0027a4a:	74 04                	je     c0027a50 <strcmp+0x1e>
c0027a4c:	3a 10                	cmp    (%eax),%dl
c0027a4e:	74 f4                	je     c0027a44 <strcmp+0x12>
    }

  return *a < *b ? -1 : *a > *b;
c0027a50:	8a 00                	mov    (%eax),%al
c0027a52:	38 d0                	cmp    %dl,%al
c0027a54:	77 07                	ja     c0027a5d <strcmp+0x2b>
c0027a56:	0f 92 c0             	setb   %al
c0027a59:	0f b6 c0             	movzbl %al,%eax
c0027a5c:	c3                   	ret    
c0027a5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0027a62:	c3                   	ret    

c0027a63 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0027a63:	53                   	push   %ebx
c0027a64:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027a68:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027a6c:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0027a70:	85 d2                	test   %edx,%edx
c0027a72:	74 1a                	je     c0027a8e <memchr+0x2b>
c0027a74:	88 d9                	mov    %bl,%cl
    if (*block == ch)
c0027a76:	3a 18                	cmp    (%eax),%bl
c0027a78:	74 12                	je     c0027a8c <memchr+0x29>
c0027a7a:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c0027a7c:	40                   	inc    %eax
c0027a7d:	39 c2                	cmp    %eax,%edx
c0027a7f:	74 06                	je     c0027a87 <memchr+0x24>
    if (*block == ch)
c0027a81:	3a 08                	cmp    (%eax),%cl
c0027a83:	75 f7                	jne    c0027a7c <memchr+0x19>
c0027a85:	eb 05                	jmp    c0027a8c <memchr+0x29>
      return (void *) block;

  return NULL;
c0027a87:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0027a8c:	5b                   	pop    %ebx
c0027a8d:	c3                   	ret    
  return NULL;
c0027a8e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a93:	eb f7                	jmp    c0027a8c <memchr+0x29>

c0027a95 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c0027a95:	53                   	push   %ebx
c0027a96:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027a9a:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c0027a9e:	8a 18                	mov    (%eax),%bl
c0027aa0:	38 da                	cmp    %bl,%dl
c0027aa2:	74 16                	je     c0027aba <strchr+0x25>
c0027aa4:	88 d1                	mov    %dl,%cl
      return (char *) string;
    else if (*string == '\0')
c0027aa6:	84 db                	test   %bl,%bl
c0027aa8:	74 12                	je     c0027abc <strchr+0x27>
      return NULL;
    else
      string++;
c0027aaa:	40                   	inc    %eax
    if (*string == c)
c0027aab:	8a 10                	mov    (%eax),%dl
c0027aad:	38 d1                	cmp    %dl,%cl
c0027aaf:	74 09                	je     c0027aba <strchr+0x25>
    else if (*string == '\0')
c0027ab1:	84 d2                	test   %dl,%dl
c0027ab3:	75 f5                	jne    c0027aaa <strchr+0x15>
      return NULL;
c0027ab5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0027aba:	5b                   	pop    %ebx
c0027abb:	c3                   	ret    
      return NULL;
c0027abc:	b8 00 00 00 00       	mov    $0x0,%eax
c0027ac1:	eb f7                	jmp    c0027aba <strchr+0x25>

c0027ac3 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c0027ac3:	57                   	push   %edi
c0027ac4:	56                   	push   %esi
c0027ac5:	53                   	push   %ebx
c0027ac6:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027aca:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0027ace:	8a 06                	mov    (%esi),%al
c0027ad0:	84 c0                	test   %al,%al
c0027ad2:	74 24                	je     c0027af8 <strcspn+0x35>
c0027ad4:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c0027ad9:	0f be c0             	movsbl %al,%eax
c0027adc:	50                   	push   %eax
c0027add:	57                   	push   %edi
c0027ade:	e8 b2 ff ff ff       	call   c0027a95 <strchr>
c0027ae3:	83 c4 08             	add    $0x8,%esp
c0027ae6:	85 c0                	test   %eax,%eax
c0027ae8:	75 08                	jne    c0027af2 <strcspn+0x2f>
  for (length = 0; string[length] != '\0'; length++)
c0027aea:	43                   	inc    %ebx
c0027aeb:	8a 04 1e             	mov    (%esi,%ebx,1),%al
c0027aee:	84 c0                	test   %al,%al
c0027af0:	75 e7                	jne    c0027ad9 <strcspn+0x16>
      break;
  return length;
}
c0027af2:	89 d8                	mov    %ebx,%eax
c0027af4:	5b                   	pop    %ebx
c0027af5:	5e                   	pop    %esi
c0027af6:	5f                   	pop    %edi
c0027af7:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0027af8:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0027afd:	eb f3                	jmp    c0027af2 <strcspn+0x2f>

c0027aff <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c0027aff:	56                   	push   %esi
c0027b00:	53                   	push   %ebx
c0027b01:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027b05:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c0027b09:	8a 13                	mov    (%ebx),%dl
c0027b0b:	84 d2                	test   %dl,%dl
c0027b0d:	74 1a                	je     c0027b29 <strpbrk+0x2a>
    if (strchr (stop, *string) != NULL)
c0027b0f:	0f be d2             	movsbl %dl,%edx
c0027b12:	52                   	push   %edx
c0027b13:	56                   	push   %esi
c0027b14:	e8 7c ff ff ff       	call   c0027a95 <strchr>
c0027b19:	83 c4 08             	add    $0x8,%esp
c0027b1c:	85 c0                	test   %eax,%eax
c0027b1e:	75 10                	jne    c0027b30 <strpbrk+0x31>
  for (; *string != '\0'; string++)
c0027b20:	43                   	inc    %ebx
c0027b21:	8a 13                	mov    (%ebx),%dl
c0027b23:	84 d2                	test   %dl,%dl
c0027b25:	75 e8                	jne    c0027b0f <strpbrk+0x10>
c0027b27:	eb 09                	jmp    c0027b32 <strpbrk+0x33>
      return (char *) string;
  return NULL;
c0027b29:	b8 00 00 00 00       	mov    $0x0,%eax
c0027b2e:	eb 02                	jmp    c0027b32 <strpbrk+0x33>
c0027b30:	89 d8                	mov    %ebx,%eax
}
c0027b32:	5b                   	pop    %ebx
c0027b33:	5e                   	pop    %esi
c0027b34:	c3                   	ret    

c0027b35 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0027b35:	53                   	push   %ebx
c0027b36:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c0027b3a:	8a 5c 24 0c          	mov    0xc(%esp),%bl
  const char *p = NULL;

  for (; *string != '\0'; string++)
c0027b3e:	8a 0a                	mov    (%edx),%cl
c0027b40:	84 c9                	test   %cl,%cl
c0027b42:	74 16                	je     c0027b5a <strrchr+0x25>
c0027b44:	b8 00 00 00 00       	mov    $0x0,%eax
c0027b49:	eb 07                	jmp    c0027b52 <strrchr+0x1d>
c0027b4b:	42                   	inc    %edx
c0027b4c:	8a 0a                	mov    (%edx),%cl
c0027b4e:	84 c9                	test   %cl,%cl
c0027b50:	74 0d                	je     c0027b5f <strrchr+0x2a>
    if (*string == c)
c0027b52:	38 cb                	cmp    %cl,%bl
c0027b54:	75 f5                	jne    c0027b4b <strrchr+0x16>
c0027b56:	89 d0                	mov    %edx,%eax
c0027b58:	eb f1                	jmp    c0027b4b <strrchr+0x16>
  const char *p = NULL;
c0027b5a:	b8 00 00 00 00       	mov    $0x0,%eax
      p = string;
  return (char *) p;
}
c0027b5f:	5b                   	pop    %ebx
c0027b60:	c3                   	ret    

c0027b61 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0027b61:	57                   	push   %edi
c0027b62:	56                   	push   %esi
c0027b63:	53                   	push   %ebx
c0027b64:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027b68:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0027b6c:	8a 06                	mov    (%esi),%al
c0027b6e:	84 c0                	test   %al,%al
c0027b70:	74 24                	je     c0027b96 <strspn+0x35>
c0027b72:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c0027b77:	0f be c0             	movsbl %al,%eax
c0027b7a:	50                   	push   %eax
c0027b7b:	57                   	push   %edi
c0027b7c:	e8 14 ff ff ff       	call   c0027a95 <strchr>
c0027b81:	83 c4 08             	add    $0x8,%esp
c0027b84:	85 c0                	test   %eax,%eax
c0027b86:	74 08                	je     c0027b90 <strspn+0x2f>
  for (length = 0; string[length] != '\0'; length++)
c0027b88:	43                   	inc    %ebx
c0027b89:	8a 04 1e             	mov    (%esi,%ebx,1),%al
c0027b8c:	84 c0                	test   %al,%al
c0027b8e:	75 e7                	jne    c0027b77 <strspn+0x16>
      break;
  return length;
}
c0027b90:	89 d8                	mov    %ebx,%eax
c0027b92:	5b                   	pop    %ebx
c0027b93:	5e                   	pop    %esi
c0027b94:	5f                   	pop    %edi
c0027b95:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0027b96:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0027b9b:	eb f3                	jmp    c0027b90 <strspn+0x2f>

c0027b9d <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0027b9d:	55                   	push   %ebp
c0027b9e:	57                   	push   %edi
c0027b9f:	56                   	push   %esi
c0027ba0:	53                   	push   %ebx
c0027ba1:	83 ec 1c             	sub    $0x1c,%esp
c0027ba4:	8b 74 24 30          	mov    0x30(%esp),%esi
c0027ba8:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
c0027bac:	85 ff                	test   %edi,%edi
c0027bae:	74 2c                	je     c0027bdc <strtok_r+0x3f>
  ASSERT (save_ptr != NULL);
c0027bb0:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0027bb5:	74 46                	je     c0027bfd <strtok_r+0x60>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0027bb7:	85 f6                	test   %esi,%esi
c0027bb9:	74 63                	je     c0027c1e <strtok_r+0x81>
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c0027bbb:	8a 1e                	mov    (%esi),%bl
c0027bbd:	83 ec 08             	sub    $0x8,%esp
c0027bc0:	0f be c3             	movsbl %bl,%eax
c0027bc3:	50                   	push   %eax
c0027bc4:	57                   	push   %edi
c0027bc5:	e8 cb fe ff ff       	call   c0027a95 <strchr>
c0027bca:	83 c4 10             	add    $0x10,%esp
c0027bcd:	85 c0                	test   %eax,%eax
c0027bcf:	0f 84 87 00 00 00    	je     c0027c5c <strtok_r+0xbf>
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0027bd5:	84 db                	test   %bl,%bl
c0027bd7:	74 70                	je     c0027c49 <strtok_r+0xac>
        {
          *save_ptr = s;
          return NULL;
        }

      s++;
c0027bd9:	46                   	inc    %esi
c0027bda:	eb df                	jmp    c0027bbb <strtok_r+0x1e>
  ASSERT (delimiters != NULL);
c0027bdc:	83 ec 0c             	sub    $0xc,%esp
c0027bdf:	68 b2 27 03 c0       	push   $0xc00327b2
c0027be4:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027be9:	68 70 07 03 c0       	push   $0xc0030770
c0027bee:	68 ef 00 00 00       	push   $0xef
c0027bf3:	68 c5 27 03 c0       	push   $0xc00327c5
c0027bf8:	e8 80 0a 00 00       	call   c002867d <debug_panic>
  ASSERT (save_ptr != NULL);
c0027bfd:	83 ec 0c             	sub    $0xc,%esp
c0027c00:	68 d8 27 03 c0       	push   $0xc00327d8
c0027c05:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027c0a:	68 70 07 03 c0       	push   $0xc0030770
c0027c0f:	68 f0 00 00 00       	push   $0xf0
c0027c14:	68 c5 27 03 c0       	push   $0xc00327c5
c0027c19:	e8 5f 0a 00 00       	call   c002867d <debug_panic>
    s = *save_ptr;
c0027c1e:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027c22:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
c0027c24:	85 f6                	test   %esi,%esi
c0027c26:	75 93                	jne    c0027bbb <strtok_r+0x1e>
c0027c28:	83 ec 0c             	sub    $0xc,%esp
c0027c2b:	68 bb 27 03 c0       	push   $0xc00327bb
c0027c30:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027c35:	68 70 07 03 c0       	push   $0xc0030770
c0027c3a:	68 f6 00 00 00       	push   $0xf6
c0027c3f:	68 c5 27 03 c0       	push   $0xc00327c5
c0027c44:	e8 34 0a 00 00       	call   c002867d <debug_panic>
          *save_ptr = s;
c0027c49:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027c4d:	89 30                	mov    %esi,(%eax)
          return NULL;
c0027c4f:	b8 00 00 00 00       	mov    $0x0,%eax
      *save_ptr = s + 1;
    }
  else 
    *save_ptr = s;
  return token;
}
c0027c54:	83 c4 1c             	add    $0x1c,%esp
c0027c57:	5b                   	pop    %ebx
c0027c58:	5e                   	pop    %esi
c0027c59:	5f                   	pop    %edi
c0027c5a:	5d                   	pop    %ebp
c0027c5b:	c3                   	ret    
c0027c5c:	89 f5                	mov    %esi,%ebp
c0027c5e:	eb 04                	jmp    c0027c64 <strtok_r+0xc7>
    s++;
c0027c60:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c0027c64:	8d 45 01             	lea    0x1(%ebp),%eax
c0027c67:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (strchr (delimiters, *s) == NULL)
c0027c6b:	8a 5d 01             	mov    0x1(%ebp),%bl
c0027c6e:	83 ec 08             	sub    $0x8,%esp
c0027c71:	0f be c3             	movsbl %bl,%eax
c0027c74:	50                   	push   %eax
c0027c75:	57                   	push   %edi
c0027c76:	e8 1a fe ff ff       	call   c0027a95 <strchr>
c0027c7b:	83 c4 10             	add    $0x10,%esp
c0027c7e:	85 c0                	test   %eax,%eax
c0027c80:	74 de                	je     c0027c60 <strtok_r+0xc3>
  if (*s != '\0') 
c0027c82:	84 db                	test   %bl,%bl
c0027c84:	75 0e                	jne    c0027c94 <strtok_r+0xf7>
    *save_ptr = s;
c0027c86:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027c8a:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027c8e:	89 10                	mov    %edx,(%eax)
c0027c90:	89 f0                	mov    %esi,%eax
c0027c92:	eb c0                	jmp    c0027c54 <strtok_r+0xb7>
      *s = '\0';
c0027c94:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027c98:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0027c9b:	83 c5 02             	add    $0x2,%ebp
c0027c9e:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027ca2:	89 28                	mov    %ebp,(%eax)
c0027ca4:	89 f0                	mov    %esi,%eax
c0027ca6:	eb ac                	jmp    c0027c54 <strtok_r+0xb7>

c0027ca8 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0027ca8:	53                   	push   %ebx
c0027ca9:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027cad:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027cb1:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0027cb5:	85 c9                	test   %ecx,%ecx
c0027cb7:	74 0c                	je     c0027cc5 <memset+0x1d>
c0027cb9:	01 c1                	add    %eax,%ecx
c0027cbb:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c0027cbd:	42                   	inc    %edx
c0027cbe:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c0027cc1:	39 d1                	cmp    %edx,%ecx
c0027cc3:	75 f8                	jne    c0027cbd <memset+0x15>

  return dst_;
}
c0027cc5:	5b                   	pop    %ebx
c0027cc6:	c3                   	ret    

c0027cc7 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0027cc7:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT (string != NULL);

  for (p = string; *p != '\0'; p++)
c0027ccb:	80 3a 00             	cmpb   $0x0,(%edx)
c0027cce:	74 0b                	je     c0027cdb <strlen+0x14>
c0027cd0:	89 d0                	mov    %edx,%eax
c0027cd2:	40                   	inc    %eax
c0027cd3:	80 38 00             	cmpb   $0x0,(%eax)
c0027cd6:	75 fa                	jne    c0027cd2 <strlen+0xb>
    continue;
  return p - string;
c0027cd8:	29 d0                	sub    %edx,%eax
}
c0027cda:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c0027cdb:	89 d0                	mov    %edx,%eax
c0027cdd:	eb f9                	jmp    c0027cd8 <strlen+0x11>

c0027cdf <strstr>:
{
c0027cdf:	55                   	push   %ebp
c0027ce0:	57                   	push   %edi
c0027ce1:	56                   	push   %esi
c0027ce2:	53                   	push   %ebx
c0027ce3:	83 ec 04             	sub    $0x4,%esp
c0027ce6:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c0027cea:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0027cef:	b0 00                	mov    $0x0,%al
c0027cf1:	89 d9                	mov    %ebx,%ecx
c0027cf3:	8b 7c 24 18          	mov    0x18(%esp),%edi
c0027cf7:	f2 ae                	repnz scas %es:(%edi),%al
c0027cf9:	f7 d1                	not    %ecx
c0027cfb:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c0027cfe:	89 d9                	mov    %ebx,%ecx
c0027d00:	89 ef                	mov    %ebp,%edi
c0027d02:	f2 ae                	repnz scas %es:(%edi),%al
c0027d04:	89 c8                	mov    %ecx,%eax
c0027d06:	f7 d0                	not    %eax
c0027d08:	8d 78 ff             	lea    -0x1(%eax),%edi
  if (haystack_len >= needle_len) 
c0027d0b:	39 fa                	cmp    %edi,%edx
c0027d0d:	72 2c                	jb     c0027d3b <strstr+0x5c>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0027d0f:	29 fa                	sub    %edi,%edx
c0027d11:	89 14 24             	mov    %edx,(%esp)
c0027d14:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027d19:	89 de                	mov    %ebx,%esi
c0027d1b:	03 74 24 18          	add    0x18(%esp),%esi
        if (!memcmp (haystack + i, needle, needle_len))
c0027d1f:	57                   	push   %edi
c0027d20:	55                   	push   %ebp
c0027d21:	56                   	push   %esi
c0027d22:	e8 c1 fc ff ff       	call   c00279e8 <memcmp>
c0027d27:	83 c4 0c             	add    $0xc,%esp
c0027d2a:	85 c0                	test   %eax,%eax
c0027d2c:	74 14                	je     c0027d42 <strstr+0x63>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0027d2e:	43                   	inc    %ebx
c0027d2f:	3b 1c 24             	cmp    (%esp),%ebx
c0027d32:	76 e5                	jbe    c0027d19 <strstr+0x3a>
  return NULL;
c0027d34:	b8 00 00 00 00       	mov    $0x0,%eax
c0027d39:	eb 09                	jmp    c0027d44 <strstr+0x65>
c0027d3b:	b8 00 00 00 00       	mov    $0x0,%eax
c0027d40:	eb 02                	jmp    c0027d44 <strstr+0x65>
        if (!memcmp (haystack + i, needle, needle_len))
c0027d42:	89 f0                	mov    %esi,%eax
}
c0027d44:	83 c4 04             	add    $0x4,%esp
c0027d47:	5b                   	pop    %ebx
c0027d48:	5e                   	pop    %esi
c0027d49:	5f                   	pop    %edi
c0027d4a:	5d                   	pop    %ebp
c0027d4b:	c3                   	ret    

c0027d4c <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c0027d4c:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0027d50:	8b 54 24 08          	mov    0x8(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0027d54:	80 39 00             	cmpb   $0x0,(%ecx)
c0027d57:	74 15                	je     c0027d6e <strnlen+0x22>
c0027d59:	85 d2                	test   %edx,%edx
c0027d5b:	74 17                	je     c0027d74 <strnlen+0x28>
c0027d5d:	b8 00 00 00 00       	mov    $0x0,%eax
c0027d62:	40                   	inc    %eax
c0027d63:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
c0027d67:	74 0d                	je     c0027d76 <strnlen+0x2a>
c0027d69:	39 c2                	cmp    %eax,%edx
c0027d6b:	75 f5                	jne    c0027d62 <strnlen+0x16>
c0027d6d:	c3                   	ret    
c0027d6e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027d73:	c3                   	ret    
c0027d74:	89 d0                	mov    %edx,%eax
    continue;
  return length;
}
c0027d76:	c3                   	ret    

c0027d77 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0027d77:	55                   	push   %ebp
c0027d78:	57                   	push   %edi
c0027d79:	56                   	push   %esi
c0027d7a:	53                   	push   %ebx
c0027d7b:	83 ec 0c             	sub    $0xc,%esp
c0027d7e:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0027d82:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027d86:	8b 54 24 28          	mov    0x28(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c0027d8a:	85 db                	test   %ebx,%ebx
c0027d8c:	74 33                	je     c0027dc1 <strlcpy+0x4a>
  ASSERT (src != NULL);
c0027d8e:	85 f6                	test   %esi,%esi
c0027d90:	74 50                	je     c0027de2 <strlcpy+0x6b>

  src_len = strlen (src);
c0027d92:	b0 00                	mov    $0x0,%al
c0027d94:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0027d99:	89 f7                	mov    %esi,%edi
c0027d9b:	f2 ae                	repnz scas %es:(%edi),%al
c0027d9d:	89 c8                	mov    %ecx,%eax
c0027d9f:	f7 d0                	not    %eax
c0027da1:	48                   	dec    %eax
  if (size > 0) 
c0027da2:	85 d2                	test   %edx,%edx
c0027da4:	74 13                	je     c0027db9 <strlcpy+0x42>
    {
      size_t dst_len = size - 1;
c0027da6:	4a                   	dec    %edx
c0027da7:	89 c5                	mov    %eax,%ebp
c0027da9:	39 d0                	cmp    %edx,%eax
c0027dab:	76 02                	jbe    c0027daf <strlcpy+0x38>
c0027dad:	89 d5                	mov    %edx,%ebp
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c0027daf:	89 df                	mov    %ebx,%edi
c0027db1:	89 e9                	mov    %ebp,%ecx
c0027db3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
      dst[dst_len] = '\0';
c0027db5:	c6 04 2b 00          	movb   $0x0,(%ebx,%ebp,1)
    }
  return src_len;
}
c0027db9:	83 c4 0c             	add    $0xc,%esp
c0027dbc:	5b                   	pop    %ebx
c0027dbd:	5e                   	pop    %esi
c0027dbe:	5f                   	pop    %edi
c0027dbf:	5d                   	pop    %ebp
c0027dc0:	c3                   	ret    
  ASSERT (dst != NULL);
c0027dc1:	83 ec 0c             	sub    $0xc,%esp
c0027dc4:	68 e9 27 03 c0       	push   $0xc00327e9
c0027dc9:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027dce:	68 68 07 03 c0       	push   $0xc0030768
c0027dd3:	68 4a 01 00 00       	push   $0x14a
c0027dd8:	68 c5 27 03 c0       	push   $0xc00327c5
c0027ddd:	e8 9b 08 00 00       	call   c002867d <debug_panic>
  ASSERT (src != NULL);
c0027de2:	83 ec 0c             	sub    $0xc,%esp
c0027de5:	68 f5 27 03 c0       	push   $0xc00327f5
c0027dea:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027def:	68 68 07 03 c0       	push   $0xc0030768
c0027df4:	68 4b 01 00 00       	push   $0x14b
c0027df9:	68 c5 27 03 c0       	push   $0xc00327c5
c0027dfe:	e8 7a 08 00 00       	call   c002867d <debug_panic>

c0027e03 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0027e03:	55                   	push   %ebp
c0027e04:	57                   	push   %edi
c0027e05:	56                   	push   %esi
c0027e06:	53                   	push   %ebx
c0027e07:	83 ec 0c             	sub    $0xc,%esp
c0027e0a:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027e0e:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0027e12:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0027e17:	74 4f                	je     c0027e68 <strlcat+0x65>
  ASSERT (src != NULL);
c0027e19:	85 f6                	test   %esi,%esi
c0027e1b:	74 6c                	je     c0027e89 <strlcat+0x86>

  src_len = strlen (src);
c0027e1d:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c0027e22:	b0 00                	mov    $0x0,%al
c0027e24:	89 e9                	mov    %ebp,%ecx
c0027e26:	89 f7                	mov    %esi,%edi
c0027e28:	f2 ae                	repnz scas %es:(%edi),%al
c0027e2a:	f7 d1                	not    %ecx
c0027e2c:	8d 51 ff             	lea    -0x1(%ecx),%edx
  dst_len = strlen (dst);
c0027e2f:	89 e9                	mov    %ebp,%ecx
c0027e31:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0027e35:	f2 ae                	repnz scas %es:(%edi),%al
c0027e37:	89 c8                	mov    %ecx,%eax
c0027e39:	f7 d0                	not    %eax
c0027e3b:	48                   	dec    %eax
  if (size > 0 && dst_len < size) 
c0027e3c:	85 db                	test   %ebx,%ebx
c0027e3e:	74 1e                	je     c0027e5e <strlcat+0x5b>
c0027e40:	39 d8                	cmp    %ebx,%eax
c0027e42:	73 1a                	jae    c0027e5e <strlcat+0x5b>
    {
      size_t copy_cnt = size - dst_len - 1;
c0027e44:	8d 6b ff             	lea    -0x1(%ebx),%ebp
c0027e47:	29 c5                	sub    %eax,%ebp
c0027e49:	89 d1                	mov    %edx,%ecx
c0027e4b:	39 ea                	cmp    %ebp,%edx
c0027e4d:	76 02                	jbe    c0027e51 <strlcat+0x4e>
c0027e4f:	89 e9                	mov    %ebp,%ecx
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c0027e51:	89 c3                	mov    %eax,%ebx
c0027e53:	03 5c 24 20          	add    0x20(%esp),%ebx
c0027e57:	89 df                	mov    %ebx,%edi
c0027e59:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
      dst[dst_len + copy_cnt] = '\0';
c0027e5b:	c6 07 00             	movb   $0x0,(%edi)
    }
  return src_len + dst_len;
c0027e5e:	01 d0                	add    %edx,%eax
}
c0027e60:	83 c4 0c             	add    $0xc,%esp
c0027e63:	5b                   	pop    %ebx
c0027e64:	5e                   	pop    %esi
c0027e65:	5f                   	pop    %edi
c0027e66:	5d                   	pop    %ebp
c0027e67:	c3                   	ret    
  ASSERT (dst != NULL);
c0027e68:	83 ec 0c             	sub    $0xc,%esp
c0027e6b:	68 e9 27 03 c0       	push   $0xc00327e9
c0027e70:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027e75:	68 60 07 03 c0       	push   $0xc0030760
c0027e7a:	68 68 01 00 00       	push   $0x168
c0027e7f:	68 c5 27 03 c0       	push   $0xc00327c5
c0027e84:	e8 f4 07 00 00       	call   c002867d <debug_panic>
  ASSERT (src != NULL);
c0027e89:	83 ec 0c             	sub    $0xc,%esp
c0027e8c:	68 f5 27 03 c0       	push   $0xc00327f5
c0027e91:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0027e96:	68 60 07 03 c0       	push   $0xc0030760
c0027e9b:	68 69 01 00 00       	push   $0x169
c0027ea0:	68 c5 27 03 c0       	push   $0xc00327c5
c0027ea5:	e8 d3 07 00 00       	call   c002867d <debug_panic>

c0027eaa <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0027eaa:	55                   	push   %ebp
c0027eab:	57                   	push   %edi
c0027eac:	56                   	push   %esi
c0027ead:	53                   	push   %ebx
c0027eae:	83 ec 1c             	sub    $0x1c,%esp
c0027eb1:	89 04 24             	mov    %eax,(%esp)
c0027eb4:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027eb8:	8b 74 24 30          	mov    0x30(%esp),%esi
c0027ebc:	8b 7c 24 34          	mov    0x34(%esp),%edi
  if ((d >> 32) == 0) 
c0027ec0:	85 ff                	test   %edi,%edi
c0027ec2:	74 2f                	je     c0027ef3 <udiv64+0x49>
c0027ec4:	89 fa                	mov    %edi,%edx
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0027ec6:	8b 0c 24             	mov    (%esp),%ecx
c0027ec9:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0027ecd:	39 df                	cmp    %ebx,%edi
c0027ecf:	0f 87 43 01 00 00    	ja     c0028018 <udiv64+0x16e>
c0027ed5:	72 08                	jb     c0027edf <udiv64+0x35>
c0027ed7:	39 ce                	cmp    %ecx,%esi
c0027ed9:	0f 87 39 01 00 00    	ja     c0028018 <udiv64+0x16e>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
c0027edf:	89 d0                	mov    %edx,%eax
  if (x <= 0x0000FFFF)
c0027ee1:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
c0027ee7:	77 56                	ja     c0027f3f <udiv64+0x95>
      x <<= 16; 
c0027ee9:	c1 e0 10             	shl    $0x10,%eax
      n += 16;
c0027eec:	b9 10 00 00 00       	mov    $0x10,%ecx
c0027ef1:	eb 51                	jmp    c0027f44 <udiv64+0x9a>
      uint32_t n1 = n >> 32;
c0027ef3:	8b 44 24 04          	mov    0x4(%esp),%eax
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0027ef7:	ba 00 00 00 00       	mov    $0x0,%edx
c0027efc:	f7 f6                	div    %esi
c0027efe:	89 d1                	mov    %edx,%ecx
c0027f00:	89 c5                	mov    %eax,%ebp
c0027f02:	b8 00 00 00 00       	mov    $0x0,%eax
c0027f07:	89 ca                	mov    %ecx,%edx
c0027f09:	8b 0c 24             	mov    (%esp),%ecx
c0027f0c:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027f11:	01 c8                	add    %ecx,%eax
c0027f13:	11 da                	adc    %ebx,%edx
  asm ("divl %4"
c0027f15:	f7 f6                	div    %esi
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0027f17:	be 00 00 00 00       	mov    $0x0,%esi
c0027f1c:	89 c1                	mov    %eax,%ecx
c0027f1e:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027f23:	01 f1                	add    %esi,%ecx
c0027f25:	11 eb                	adc    %ebp,%ebx
c0027f27:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027f2b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
          return n - (q - 1) * d < d ? q - 1 : q; 
        }
    }
}
c0027f2f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027f33:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027f37:	83 c4 1c             	add    $0x1c,%esp
c0027f3a:	5b                   	pop    %ebx
c0027f3b:	5e                   	pop    %esi
c0027f3c:	5f                   	pop    %edi
c0027f3d:	5d                   	pop    %ebp
c0027f3e:	c3                   	ret    
  int n = 0;
c0027f3f:	b9 00 00 00 00       	mov    $0x0,%ecx
  if (x <= 0x00FFFFFF)
c0027f44:	3d ff ff ff 00       	cmp    $0xffffff,%eax
c0027f49:	77 06                	ja     c0027f51 <udiv64+0xa7>
      n += 8;
c0027f4b:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
c0027f4e:	c1 e0 08             	shl    $0x8,%eax
  if (x <= 0x0FFFFFFF)
c0027f51:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
c0027f56:	77 06                	ja     c0027f5e <udiv64+0xb4>
      n += 4;
c0027f58:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
c0027f5b:	c1 e0 04             	shl    $0x4,%eax
  if (x <= 0x3FFFFFFF)
c0027f5e:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
c0027f63:	77 06                	ja     c0027f6b <udiv64+0xc1>
      n += 2;
c0027f65:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
c0027f68:	c1 e0 02             	shl    $0x2,%eax
    n++;
c0027f6b:	3d 00 00 00 80       	cmp    $0x80000000,%eax
c0027f70:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c0027f73:	8b 04 24             	mov    (%esp),%eax
c0027f76:	8b 54 24 04          	mov    0x4(%esp),%edx
c0027f7a:	89 d3                	mov    %edx,%ebx
c0027f7c:	d1 eb                	shr    %ebx
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0027f7e:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0027f82:	d1 ea                	shr    %edx
c0027f84:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027f88:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0027f8c:	89 f0                	mov    %esi,%eax
c0027f8e:	89 fa                	mov    %edi,%edx
c0027f90:	0f a5 f2             	shld   %cl,%esi,%edx
c0027f93:	d3 e0                	shl    %cl,%eax
c0027f95:	f6 c1 20             	test   $0x20,%cl
c0027f98:	74 02                	je     c0027f9c <udiv64+0xf2>
c0027f9a:	89 c2                	mov    %eax,%edx
c0027f9c:	89 54 24 14          	mov    %edx,0x14(%esp)
  asm ("divl %4"
c0027fa0:	89 da                	mov    %ebx,%edx
c0027fa2:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027fa6:	f7 74 24 14          	divl   0x14(%esp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0027faa:	ba 1f 00 00 00       	mov    $0x1f,%edx
c0027faf:	29 ca                	sub    %ecx,%edx
c0027fb1:	89 d1                	mov    %edx,%ecx
c0027fb3:	d3 e8                	shr    %cl,%eax
c0027fb5:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027fba:	89 44 24 10          	mov    %eax,0x10(%esp)
c0027fbe:	89 4c 24 14          	mov    %ecx,0x14(%esp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0027fc2:	89 cb                	mov    %ecx,%ebx
c0027fc4:	89 c1                	mov    %eax,%ecx
c0027fc6:	83 c1 ff             	add    $0xffffffff,%ecx
c0027fc9:	83 d3 ff             	adc    $0xffffffff,%ebx
c0027fcc:	89 fd                	mov    %edi,%ebp
c0027fce:	0f af e9             	imul   %ecx,%ebp
c0027fd1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027fd5:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0027fd9:	0f af de             	imul   %esi,%ebx
c0027fdc:	01 dd                	add    %ebx,%ebp
c0027fde:	89 f0                	mov    %esi,%eax
c0027fe0:	f7 64 24 08          	mull   0x8(%esp)
c0027fe4:	01 ea                	add    %ebp,%edx
c0027fe6:	8b 0c 24             	mov    (%esp),%ecx
c0027fe9:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0027fed:	29 c1                	sub    %eax,%ecx
c0027fef:	19 d3                	sbb    %edx,%ebx
c0027ff1:	39 df                	cmp    %ebx,%edi
c0027ff3:	0f 87 36 ff ff ff    	ja     c0027f2f <udiv64+0x85>
c0027ff9:	72 08                	jb     c0028003 <udiv64+0x159>
c0027ffb:	39 ce                	cmp    %ecx,%esi
c0027ffd:	0f 87 2c ff ff ff    	ja     c0027f2f <udiv64+0x85>
c0028003:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028007:	8b 54 24 14          	mov    0x14(%esp),%edx
c002800b:	89 44 24 08          	mov    %eax,0x8(%esp)
c002800f:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0028013:	e9 17 ff ff ff       	jmp    c0027f2f <udiv64+0x85>
        return 0;
c0028018:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002801f:	00 
c0028020:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0028027:	00 
c0028028:	e9 02 ff ff ff       	jmp    c0027f2f <udiv64+0x85>

c002802d <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c002802d:	57                   	push   %edi
c002802e:	56                   	push   %esi
c002802f:	53                   	push   %ebx
c0028030:	83 ec 08             	sub    $0x8,%esp
c0028033:	89 04 24             	mov    %eax,(%esp)
c0028036:	89 54 24 04          	mov    %edx,0x4(%esp)
c002803a:	8b 74 24 18          	mov    0x18(%esp),%esi
c002803e:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028042:	85 d2                	test   %edx,%edx
c0028044:	78 32                	js     c0028078 <sdiv64+0x4b>
c0028046:	8b 04 24             	mov    (%esp),%eax
c0028049:	8b 54 24 04          	mov    0x4(%esp),%edx
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c002804d:	85 ff                	test   %edi,%edi
c002804f:	78 30                	js     c0028081 <sdiv64+0x54>
c0028051:	89 f1                	mov    %esi,%ecx
c0028053:	89 fb                	mov    %edi,%ebx
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028055:	53                   	push   %ebx
c0028056:	51                   	push   %ecx
c0028057:	e8 4e fe ff ff       	call   c0027eaa <udiv64>
c002805c:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c002805f:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028063:	f7 d1                	not    %ecx
c0028065:	c1 e9 1f             	shr    $0x1f,%ecx
c0028068:	89 fb                	mov    %edi,%ebx
c002806a:	c1 eb 1f             	shr    $0x1f,%ebx
c002806d:	38 d9                	cmp    %bl,%cl
c002806f:	74 1d                	je     c002808e <sdiv64+0x61>
}
c0028071:	83 c4 08             	add    $0x8,%esp
c0028074:	5b                   	pop    %ebx
c0028075:	5e                   	pop    %esi
c0028076:	5f                   	pop    %edi
c0028077:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028078:	f7 d8                	neg    %eax
c002807a:	83 d2 00             	adc    $0x0,%edx
c002807d:	f7 da                	neg    %edx
c002807f:	eb cc                	jmp    c002804d <sdiv64+0x20>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028081:	89 f1                	mov    %esi,%ecx
c0028083:	89 fb                	mov    %edi,%ebx
c0028085:	f7 d9                	neg    %ecx
c0028087:	83 d3 00             	adc    $0x0,%ebx
c002808a:	f7 db                	neg    %ebx
c002808c:	eb c7                	jmp    c0028055 <sdiv64+0x28>
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c002808e:	f7 d8                	neg    %eax
c0028090:	83 d2 00             	adc    $0x0,%edx
c0028093:	f7 da                	neg    %edx
c0028095:	eb da                	jmp    c0028071 <sdiv64+0x44>

c0028097 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0028097:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c002809a:	ff 74 24 14          	pushl  0x14(%esp)
c002809e:	ff 74 24 14          	pushl  0x14(%esp)
c00280a2:	8b 44 24 10          	mov    0x10(%esp),%eax
c00280a6:	8b 54 24 14          	mov    0x14(%esp),%edx
c00280aa:	e8 7e ff ff ff       	call   c002802d <sdiv64>
}
c00280af:	83 c4 0c             	add    $0xc,%esp
c00280b2:	c3                   	ret    

c00280b3 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c00280b3:	57                   	push   %edi
c00280b4:	56                   	push   %esi
c00280b5:	53                   	push   %ebx
c00280b6:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00280ba:	8b 74 24 18          	mov    0x18(%esp),%esi
c00280be:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64 (n, d);
c00280c2:	57                   	push   %edi
c00280c3:	56                   	push   %esi
c00280c4:	89 d8                	mov    %ebx,%eax
c00280c6:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c00280ca:	e8 5e ff ff ff       	call   c002802d <sdiv64>
c00280cf:	83 c4 08             	add    $0x8,%esp
c00280d2:	0f af c6             	imul   %esi,%eax
c00280d5:	29 c3                	sub    %eax,%ebx
c00280d7:	89 d8                	mov    %ebx,%eax
  return smod64 (n, d);
c00280d9:	99                   	cltd   
}
c00280da:	5b                   	pop    %ebx
c00280db:	5e                   	pop    %esi
c00280dc:	5f                   	pop    %edi
c00280dd:	c3                   	ret    

c00280de <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c00280de:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c00280e1:	ff 74 24 14          	pushl  0x14(%esp)
c00280e5:	ff 74 24 14          	pushl  0x14(%esp)
c00280e9:	8b 44 24 10          	mov    0x10(%esp),%eax
c00280ed:	8b 54 24 14          	mov    0x14(%esp),%edx
c00280f1:	e8 b4 fd ff ff       	call   c0027eaa <udiv64>
}
c00280f6:	83 c4 0c             	add    $0xc,%esp
c00280f9:	c3                   	ret    

c00280fa <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c00280fa:	57                   	push   %edi
c00280fb:	56                   	push   %esi
c00280fc:	53                   	push   %ebx
c00280fd:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028101:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028105:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64 (n, d);
c0028109:	57                   	push   %edi
c002810a:	56                   	push   %esi
c002810b:	89 d8                	mov    %ebx,%eax
c002810d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028111:	e8 94 fd ff ff       	call   c0027eaa <udiv64>
c0028116:	83 c4 08             	add    $0x8,%esp
c0028119:	0f af c6             	imul   %esi,%eax
c002811c:	29 c3                	sub    %eax,%ebx
c002811e:	89 d8                	mov    %ebx,%eax
  return umod64 (n, d);
}
c0028120:	ba 00 00 00 00       	mov    $0x0,%edx
c0028125:	5b                   	pop    %ebx
c0028126:	5e                   	pop    %esi
c0028127:	5f                   	pop    %edi
c0028128:	c3                   	ret    

c0028129 <parse_octal_field>:
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
c0028129:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c002812f:	85 d2                	test   %edx,%edx
c0028131:	74 46                	je     c0028179 <parse_octal_field+0x50>
{
c0028133:	55                   	push   %ebp
c0028134:	57                   	push   %edi
c0028135:	56                   	push   %esi
c0028136:	53                   	push   %ebx
c0028137:	89 d5                	mov    %edx,%ebp
    {
      char c = s[ofs];
c0028139:	8a 18                	mov    (%eax),%bl
      if (c >= '0' && c <= '7')
c002813b:	8d 73 d0             	lea    -0x30(%ebx),%esi
c002813e:	89 f2                	mov    %esi,%edx
  for (ofs = 0; ofs < size; ofs++)
c0028140:	be 00 00 00 00       	mov    $0x0,%esi
      if (c >= '0' && c <= '7')
c0028145:	80 fa 07             	cmp    $0x7,%dl
c0028148:	77 39                	ja     c0028183 <parse_octal_field+0x5a>
c002814a:	bf 00 00 00 00       	mov    $0x0,%edi
c002814f:	be 00 00 00 00       	mov    $0x0,%esi
          if (*value > ULONG_MAX / 8)
            {
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
c0028154:	0f be db             	movsbl %bl,%ebx
c0028157:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c002815b:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c002815d:	46                   	inc    %esi
c002815e:	39 f5                	cmp    %esi,%ebp
c0028160:	74 1a                	je     c002817c <parse_octal_field+0x53>
      char c = s[ofs];
c0028162:	8a 1c 30             	mov    (%eax,%esi,1),%bl
      if (c >= '0' && c <= '7')
c0028165:	8d 53 d0             	lea    -0x30(%ebx),%edx
c0028168:	80 fa 07             	cmp    $0x7,%dl
c002816b:	77 16                	ja     c0028183 <parse_octal_field+0x5a>
          if (*value > ULONG_MAX / 8)
c002816d:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c0028173:	76 df                	jbe    c0028154 <parse_octal_field+0x2b>
              return false;
c0028175:	b0 00                	mov    $0x0,%al
c0028177:	eb 05                	jmp    c002817e <parse_octal_field+0x55>
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0028179:	b0 00                	mov    $0x0,%al
c002817b:	c3                   	ret    
c002817c:	b0 00                	mov    $0x0,%al
}
c002817e:	5b                   	pop    %ebx
c002817f:	5e                   	pop    %esi
c0028180:	5f                   	pop    %edi
c0028181:	5d                   	pop    %ebp
c0028182:	c3                   	ret    
      else if (c == ' ' || c == '\0')
c0028183:	f6 c3 df             	test   $0xdf,%bl
c0028186:	75 07                	jne    c002818f <parse_octal_field+0x66>
          return ofs > 0;
c0028188:	85 f6                	test   %esi,%esi
c002818a:	0f 95 c0             	setne  %al
c002818d:	eb ef                	jmp    c002817e <parse_octal_field+0x55>
          return false;
c002818f:	b0 00                	mov    $0x0,%al
c0028191:	eb eb                	jmp    c002817e <parse_octal_field+0x55>

c0028193 <strip_antisocial_prefixes>:
{
c0028193:	55                   	push   %ebp
c0028194:	57                   	push   %edi
c0028195:	56                   	push   %esi
c0028196:	53                   	push   %ebx
c0028197:	83 ec 0c             	sub    $0xc,%esp
c002819a:	89 c5                	mov    %eax,%ebp
  while (*file_name == '/'
c002819c:	eb 11                	jmp    c00281af <strip_antisocial_prefixes+0x1c>
    file_name = strchr (file_name, '/') + 1;
c002819e:	83 ec 08             	sub    $0x8,%esp
c00281a1:	6a 2f                	push   $0x2f
c00281a3:	55                   	push   %ebp
c00281a4:	e8 ec f8 ff ff       	call   c0027a95 <strchr>
c00281a9:	83 c4 10             	add    $0x10,%esp
c00281ac:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/'
c00281af:	8a 5d 00             	mov    0x0(%ebp),%bl
c00281b2:	80 fb 2f             	cmp    $0x2f,%bl
c00281b5:	74 e7                	je     c002819e <strip_antisocial_prefixes+0xb>
         || !memcmp (file_name, "./", 2)
c00281b7:	83 ec 04             	sub    $0x4,%esp
c00281ba:	6a 02                	push   $0x2
c00281bc:	68 26 1c 03 c0       	push   $0xc0031c26
c00281c1:	55                   	push   %ebp
c00281c2:	e8 21 f8 ff ff       	call   c00279e8 <memcmp>
c00281c7:	83 c4 10             	add    $0x10,%esp
c00281ca:	85 c0                	test   %eax,%eax
c00281cc:	74 d0                	je     c002819e <strip_antisocial_prefixes+0xb>
         || !memcmp (file_name, "../", 3))
c00281ce:	83 ec 04             	sub    $0x4,%esp
c00281d1:	6a 03                	push   $0x3
c00281d3:	68 01 28 03 c0       	push   $0xc0032801
c00281d8:	55                   	push   %ebp
c00281d9:	e8 0a f8 ff ff       	call   c00279e8 <memcmp>
c00281de:	83 c4 10             	add    $0x10,%esp
c00281e1:	85 c0                	test   %eax,%eax
c00281e3:	74 b9                	je     c002819e <strip_antisocial_prefixes+0xb>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c00281e5:	84 db                	test   %bl,%bl
c00281e7:	74 23                	je     c002820c <strip_antisocial_prefixes+0x79>
c00281e9:	bf a2 21 03 c0       	mov    $0xc00321a2,%edi
c00281ee:	b9 03 00 00 00       	mov    $0x3,%ecx
c00281f3:	89 ee                	mov    %ebp,%esi
c00281f5:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00281f7:	0f 97 c2             	seta   %dl
c00281fa:	0f 92 c0             	setb   %al
c00281fd:	38 c2                	cmp    %al,%dl
c00281ff:	75 07                	jne    c0028208 <strip_antisocial_prefixes+0x75>
c0028201:	b8 a3 21 03 c0       	mov    $0xc00321a3,%eax
c0028206:	eb 09                	jmp    c0028211 <strip_antisocial_prefixes+0x7e>
c0028208:	89 e8                	mov    %ebp,%eax
c002820a:	eb 05                	jmp    c0028211 <strip_antisocial_prefixes+0x7e>
c002820c:	b8 a3 21 03 c0       	mov    $0xc00321a3,%eax
}
c0028211:	83 c4 0c             	add    $0xc,%esp
c0028214:	5b                   	pop    %ebx
c0028215:	5e                   	pop    %esi
c0028216:	5f                   	pop    %edi
c0028217:	5d                   	pop    %ebp
c0028218:	c3                   	ret    

c0028219 <ustar_make_header>:
{
c0028219:	57                   	push   %edi
c002821a:	56                   	push   %esi
c002821b:	53                   	push   %ebx
c002821c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028220:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0028224:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028228:	83 fb 30             	cmp    $0x30,%ebx
c002822b:	0f 84 83 01 00 00    	je     c00283b4 <ustar_make_header+0x19b>
c0028231:	83 fb 35             	cmp    $0x35,%ebx
c0028234:	0f 85 3e 01 00 00    	jne    c0028378 <ustar_make_header+0x15f>
  file_name = strip_antisocial_prefixes (file_name);
c002823a:	e8 54 ff ff ff       	call   c0028193 <strip_antisocial_prefixes>
c002823f:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c0028241:	b0 00                	mov    $0x0,%al
c0028243:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028248:	89 d7                	mov    %edx,%edi
c002824a:	f2 ae                	repnz scas %es:(%edi),%al
c002824c:	89 c8                	mov    %ecx,%eax
c002824e:	f7 d0                	not    %eax
c0028250:	48                   	dec    %eax
c0028251:	83 f8 63             	cmp    $0x63,%eax
c0028254:	0f 87 3c 01 00 00    	ja     c0028396 <ustar_make_header+0x17d>
  memset (h, 0, sizeof *h);
c002825a:	b9 80 00 00 00       	mov    $0x80,%ecx
c002825f:	b8 00 00 00 00       	mov    $0x0,%eax
c0028264:	89 f7                	mov    %esi,%edi
c0028266:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0028268:	83 ec 04             	sub    $0x4,%esp
c002826b:	6a 64                	push   $0x64
c002826d:	52                   	push   %edx
c002826e:	56                   	push   %esi
c002826f:	e8 03 fb ff ff       	call   c0027d77 <strlcpy>
c0028274:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c0028277:	b8 ed 01 00 00       	mov    $0x1ed,%eax
c002827c:	50                   	push   %eax
c002827d:	68 2f 28 03 c0       	push   $0xc003282f
c0028282:	6a 08                	push   $0x8
c0028284:	8d 46 64             	lea    0x64(%esi),%eax
c0028287:	50                   	push   %eax
c0028288:	e8 ce f0 ff ff       	call   c002735b <snprintf>
  strlcpy (h->uid, "0000000", sizeof h->uid);
c002828d:	83 c4 0c             	add    $0xc,%esp
c0028290:	6a 08                	push   $0x8
c0028292:	68 34 28 03 c0       	push   $0xc0032834
c0028297:	8d 46 6c             	lea    0x6c(%esi),%eax
c002829a:	50                   	push   %eax
c002829b:	e8 d7 fa ff ff       	call   c0027d77 <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c00282a0:	83 c4 0c             	add    $0xc,%esp
c00282a3:	6a 08                	push   $0x8
c00282a5:	68 34 28 03 c0       	push   $0xc0032834
c00282aa:	8d 46 74             	lea    0x74(%esi),%eax
c00282ad:	50                   	push   %eax
c00282ae:	e8 c4 fa ff ff       	call   c0027d77 <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c00282b3:	ff 74 24 28          	pushl  0x28(%esp)
c00282b7:	68 3c 28 03 c0       	push   $0xc003283c
c00282bc:	6a 0c                	push   $0xc
c00282be:	8d 46 7c             	lea    0x7c(%esi),%eax
c00282c1:	50                   	push   %eax
c00282c2:	e8 94 f0 ff ff       	call   c002735b <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c00282c7:	83 c4 20             	add    $0x20,%esp
c00282ca:	68 00 8c b7 43       	push   $0x43b78c00
c00282cf:	68 3c 28 03 c0       	push   $0xc003283c
c00282d4:	6a 0c                	push   $0xc
c00282d6:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c00282dc:	50                   	push   %eax
c00282dd:	e8 79 f0 ff ff       	call   c002735b <snprintf>
  h->typeflag = type;
c00282e2:	88 9e 9c 00 00 00    	mov    %bl,0x9c(%esi)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c00282e8:	83 c4 0c             	add    $0xc,%esp
c00282eb:	6a 06                	push   $0x6
c00282ed:	68 42 28 03 c0       	push   $0xc0032842
c00282f2:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c00282f8:	50                   	push   %eax
c00282f9:	e8 79 fa ff ff       	call   c0027d77 <strlcpy>
  h->version[0] = h->version[1] = '0';
c00282fe:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c0028305:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy (h->gname, "root", sizeof h->gname);
c002830c:	83 c4 0c             	add    $0xc,%esp
c002830f:	6a 20                	push   $0x20
c0028311:	68 d4 1d 03 c0       	push   $0xc0031dd4
c0028316:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c002831c:	50                   	push   %eax
c002831d:	e8 55 fa ff ff       	call   c0027d77 <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c0028322:	83 c4 0c             	add    $0xc,%esp
c0028325:	6a 20                	push   $0x20
c0028327:	68 d4 1d 03 c0       	push   $0xc0031dd4
c002832c:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c0028332:	50                   	push   %eax
c0028333:	e8 3f fa ff ff       	call   c0027d77 <strlcpy>
c0028338:	83 c4 10             	add    $0x10,%esp
c002833b:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028340:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c0028345:	b3 20                	mov    $0x20,%bl
c0028347:	83 f8 07             	cmp    $0x7,%eax
c002834a:	77 5f                	ja     c00283ab <ustar_make_header+0x192>
c002834c:	88 da                	mov    %bl,%dl
c002834e:	0f b6 d2             	movzbl %dl,%edx
c0028351:	01 d1                	add    %edx,%ecx
c0028353:	40                   	inc    %eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028354:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028359:	75 ec                	jne    c0028347 <ustar_make_header+0x12e>
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c002835b:	51                   	push   %ecx
c002835c:	68 2f 28 03 c0       	push   $0xc003282f
c0028361:	6a 08                	push   $0x8
c0028363:	81 c6 94 00 00 00    	add    $0x94,%esi
c0028369:	56                   	push   %esi
c002836a:	e8 ec ef ff ff       	call   c002735b <snprintf>
  return true;
c002836f:	83 c4 10             	add    $0x10,%esp
c0028372:	b0 01                	mov    $0x1,%al
}
c0028374:	5b                   	pop    %ebx
c0028375:	5e                   	pop    %esi
c0028376:	5f                   	pop    %edi
c0028377:	c3                   	ret    
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028378:	83 ec 0c             	sub    $0xc,%esp
c002837b:	68 ec 28 03 c0       	push   $0xc00328ec
c0028380:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028385:	68 7c 07 03 c0       	push   $0xc003077c
c002838a:	6a 59                	push   $0x59
c002838c:	68 05 28 03 c0       	push   $0xc0032805
c0028391:	e8 e7 02 00 00       	call   c002867d <debug_panic>
      printf ("%s: file name too long\n", file_name);
c0028396:	83 ec 08             	sub    $0x8,%esp
c0028399:	52                   	push   %edx
c002839a:	68 17 28 03 c0       	push   $0xc0032817
c002839f:	e8 2b e8 ff ff       	call   c0026bcf <printf>
      return false;
c00283a4:	83 c4 10             	add    $0x10,%esp
c00283a7:	b0 00                	mov    $0x0,%al
c00283a9:	eb c9                	jmp    c0028374 <ustar_make_header+0x15b>
      chksum += in_chksum_field ? ' ' : header[i];
c00283ab:	8a 94 06 94 00 00 00 	mov    0x94(%esi,%eax,1),%dl
c00283b2:	eb 9a                	jmp    c002834e <ustar_make_header+0x135>
  file_name = strip_antisocial_prefixes (file_name);
c00283b4:	e8 da fd ff ff       	call   c0028193 <strip_antisocial_prefixes>
c00283b9:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c00283bb:	b0 00                	mov    $0x0,%al
c00283bd:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00283c2:	89 d7                	mov    %edx,%edi
c00283c4:	f2 ae                	repnz scas %es:(%edi),%al
c00283c6:	89 c8                	mov    %ecx,%eax
c00283c8:	f7 d0                	not    %eax
c00283ca:	48                   	dec    %eax
c00283cb:	83 f8 63             	cmp    $0x63,%eax
c00283ce:	77 c6                	ja     c0028396 <ustar_make_header+0x17d>
  memset (h, 0, sizeof *h);
c00283d0:	b9 80 00 00 00       	mov    $0x80,%ecx
c00283d5:	b8 00 00 00 00       	mov    $0x0,%eax
c00283da:	89 f7                	mov    %esi,%edi
c00283dc:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c00283de:	83 ec 04             	sub    $0x4,%esp
c00283e1:	6a 64                	push   $0x64
c00283e3:	52                   	push   %edx
c00283e4:	56                   	push   %esi
c00283e5:	e8 8d f9 ff ff       	call   c0027d77 <strlcpy>
c00283ea:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c00283ed:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c00283f2:	e9 85 fe ff ff       	jmp    c002827c <ustar_make_header+0x63>

c00283f7 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c00283f7:	56                   	push   %esi
c00283f8:	53                   	push   %ebx
c00283f9:	83 ec 14             	sub    $0x14,%esp
c00283fc:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0028400:	8d 93 00 02 00 00    	lea    0x200(%ebx),%edx
c0028406:	89 d8                	mov    %ebx,%eax
    if (*block++ != 0)
c0028408:	40                   	inc    %eax
c0028409:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c002840d:	0f 85 47 01 00 00    	jne    c002855a <ustar_parse_header+0x163>
  while (cnt-- > 0)
c0028413:	39 c2                	cmp    %eax,%edx
c0028415:	75 f1                	jne    c0028408 <ustar_parse_header+0x11>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c0028417:	8b 44 24 24          	mov    0x24(%esp),%eax
c002841b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0028421:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028425:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c002842b:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002842f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0028435:	b8 00 00 00 00       	mov    $0x0,%eax
  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
  *type = h->typeflag;
  *size = size_ul;
  return NULL;
}
c002843a:	83 c4 14             	add    $0x14,%esp
c002843d:	5b                   	pop    %ebx
c002843e:	5e                   	pop    %esi
c002843f:	c3                   	ret    
  else if (h->version[0] != '0' || h->version[1] != '0')
c0028440:	80 bb 08 01 00 00 30 	cmpb   $0x30,0x108(%ebx)
c0028447:	74 07                	je     c0028450 <ustar_parse_header+0x59>
    return "invalid ustar version";
c0028449:	b8 5c 28 03 c0       	mov    $0xc003285c,%eax
c002844e:	eb ea                	jmp    c002843a <ustar_parse_header+0x43>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028450:	8d 83 94 00 00 00    	lea    0x94(%ebx),%eax
c0028456:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002845a:	ba 08 00 00 00       	mov    $0x8,%edx
c002845f:	e8 c5 fc ff ff       	call   c0028129 <parse_octal_field>
c0028464:	84 c0                	test   %al,%al
c0028466:	0f 84 b2 00 00 00    	je     c002851e <ustar_parse_header+0x127>
c002846c:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
c0028471:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c0028476:	be 20 00 00 00       	mov    $0x20,%esi
c002847b:	83 f8 07             	cmp    $0x7,%eax
c002847e:	77 1c                	ja     c002849c <ustar_parse_header+0xa5>
c0028480:	89 f2                	mov    %esi,%edx
c0028482:	0f b6 d2             	movzbl %dl,%edx
c0028485:	01 d1                	add    %edx,%ecx
c0028487:	40                   	inc    %eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028488:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c002848d:	75 ec                	jne    c002847b <ustar_parse_header+0x84>
  else if (chksum != calculate_chksum (h))
c002848f:	39 4c 24 0c          	cmp    %ecx,0xc(%esp)
c0028493:	74 10                	je     c00284a5 <ustar_parse_header+0xae>
    return "checksum mismatch";
c0028495:	b8 87 28 03 c0       	mov    $0xc0032887,%eax
c002849a:	eb 9e                	jmp    c002843a <ustar_parse_header+0x43>
      chksum += in_chksum_field ? ' ' : header[i];
c002849c:	8a 94 03 94 00 00 00 	mov    0x94(%ebx,%eax,1),%dl
c00284a3:	eb dd                	jmp    c0028482 <ustar_parse_header+0x8b>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c00284a5:	80 7b 63 00          	cmpb   $0x0,0x63(%ebx)
c00284a9:	75 7d                	jne    c0028528 <ustar_parse_header+0x131>
c00284ab:	80 bb 59 01 00 00 00 	cmpb   $0x0,0x159(%ebx)
c00284b2:	75 7e                	jne    c0028532 <ustar_parse_header+0x13b>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c00284b4:	8a 83 9c 00 00 00    	mov    0x9c(%ebx),%al
c00284ba:	3c 30                	cmp    $0x30,%al
c00284bc:	74 3a                	je     c00284f8 <ustar_parse_header+0x101>
c00284be:	3c 35                	cmp    $0x35,%al
c00284c0:	75 7a                	jne    c002853c <ustar_parse_header+0x145>
    size_ul = 0;
c00284c2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c00284c9:	00 
  *file_name = strip_antisocial_prefixes (h->name);
c00284ca:	89 d8                	mov    %ebx,%eax
c00284cc:	e8 c2 fc ff ff       	call   c0028193 <strip_antisocial_prefixes>
c00284d1:	8b 74 24 24          	mov    0x24(%esp),%esi
c00284d5:	89 06                	mov    %eax,(%esi)
  *type = h->typeflag;
c00284d7:	0f be 83 9c 00 00 00 	movsbl 0x9c(%ebx),%eax
c00284de:	8b 74 24 28          	mov    0x28(%esp),%esi
c00284e2:	89 06                	mov    %eax,(%esi)
  *size = size_ul;
c00284e4:	8b 44 24 08          	mov    0x8(%esp),%eax
c00284e8:	8b 74 24 2c          	mov    0x2c(%esp),%esi
c00284ec:	89 06                	mov    %eax,(%esi)
  return NULL;
c00284ee:	b8 00 00 00 00       	mov    $0x0,%eax
c00284f3:	e9 42 ff ff ff       	jmp    c002843a <ustar_parse_header+0x43>
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c00284f8:	8d 43 7c             	lea    0x7c(%ebx),%eax
c00284fb:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c00284ff:	ba 0c 00 00 00       	mov    $0xc,%edx
c0028504:	e8 20 fc ff ff       	call   c0028129 <parse_octal_field>
c0028509:	84 c0                	test   %al,%al
c002850b:	74 39                	je     c0028546 <ustar_parse_header+0x14f>
      else if (size_ul > INT_MAX)
c002850d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028512:	79 b6                	jns    c00284ca <ustar_parse_header+0xd3>
        return "file too large";
c0028514:	b8 dc 28 03 c0       	mov    $0xc00328dc,%eax
c0028519:	e9 1c ff ff ff       	jmp    c002843a <ustar_parse_header+0x43>
    return "corrupt chksum field";
c002851e:	b8 72 28 03 c0       	mov    $0xc0032872,%eax
c0028523:	e9 12 ff ff ff       	jmp    c002843a <ustar_parse_header+0x43>
    return "file name too long";
c0028528:	b8 99 28 03 c0       	mov    $0xc0032899,%eax
c002852d:	e9 08 ff ff ff       	jmp    c002843a <ustar_parse_header+0x43>
c0028532:	b8 99 28 03 c0       	mov    $0xc0032899,%eax
c0028537:	e9 fe fe ff ff       	jmp    c002843a <ustar_parse_header+0x43>
    return "unimplemented file type";
c002853c:	b8 ac 28 03 c0       	mov    $0xc00328ac,%eax
c0028541:	e9 f4 fe ff ff       	jmp    c002843a <ustar_parse_header+0x43>
        return "corrupt file size field";
c0028546:	b8 c4 28 03 c0       	mov    $0xc00328c4,%eax
c002854b:	e9 ea fe ff ff       	jmp    c002843a <ustar_parse_header+0x43>
    return "not a ustar archive";
c0028550:	b8 48 28 03 c0       	mov    $0xc0032848,%eax
c0028555:	e9 e0 fe ff ff       	jmp    c002843a <ustar_parse_header+0x43>
  if (memcmp (h->magic, "ustar", 6))
c002855a:	83 ec 04             	sub    $0x4,%esp
c002855d:	6a 06                	push   $0x6
c002855f:	68 42 28 03 c0       	push   $0xc0032842
c0028564:	8d 83 01 01 00 00    	lea    0x101(%ebx),%eax
c002856a:	50                   	push   %eax
c002856b:	e8 78 f4 ff ff       	call   c00279e8 <memcmp>
c0028570:	83 c4 10             	add    $0x10,%esp
c0028573:	85 c0                	test   %eax,%eax
c0028575:	75 d9                	jne    c0028550 <ustar_parse_header+0x159>
  else if (h->version[0] != '0' || h->version[1] != '0')
c0028577:	80 bb 07 01 00 00 30 	cmpb   $0x30,0x107(%ebx)
c002857e:	0f 84 bc fe ff ff    	je     c0028440 <ustar_parse_header+0x49>
    return "invalid ustar version";
c0028584:	b8 5c 28 03 c0       	mov    $0xc003285c,%eax
c0028589:	e9 ac fe ff ff       	jmp    c002843a <ustar_parse_header+0x43>

c002858e <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c002858e:	55                   	push   %ebp
c002858f:	89 e5                	mov    %esp,%ebp
c0028591:	53                   	push   %ebx
c0028592:	83 ec 04             	sub    $0x4,%esp
c0028595:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0028598:	8b 43 08             	mov    0x8(%ebx),%eax
c002859b:	83 f8 01             	cmp    $0x1,%eax
c002859e:	0f 84 ab 00 00 00    	je     c002864f <print_stacktrace+0xc1>
c00285a4:	83 f8 01             	cmp    $0x1,%eax
c00285a7:	72 10                	jb     c00285b9 <print_stacktrace+0x2b>
c00285a9:	83 f8 02             	cmp    $0x2,%eax
c00285ac:	0f 84 a7 00 00 00    	je     c0028659 <print_stacktrace+0xcb>
  const char *status = "UNKNOWN";
c00285b2:	b8 23 29 03 c0       	mov    $0xc0032923,%eax
c00285b7:	eb 05                	jmp    c00285be <print_stacktrace+0x30>
    case THREAD_RUNNING:  
      status = "RUNNING";
c00285b9:	b8 a7 13 03 c0       	mov    $0xc00313a7,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c00285be:	83 ec 04             	sub    $0x4,%esp
c00285c1:	50                   	push   %eax
c00285c2:	8d 43 0c             	lea    0xc(%ebx),%eax
c00285c5:	50                   	push   %eax
c00285c6:	68 48 29 03 c0       	push   $0xc0032948
c00285cb:	e8 ff e5 ff ff       	call   c0026bcf <printf>

  if (t == thread_current()) 
c00285d0:	e8 41 87 ff ff       	call   c0020d16 <thread_current>
c00285d5:	83 c4 10             	add    $0x10,%esp
c00285d8:	39 c3                	cmp    %eax,%ebx
c00285da:	0f 84 83 00 00 00    	je     c0028663 <print_stacktrace+0xd5>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c00285e0:	8b 53 1c             	mov    0x1c(%ebx),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c00285e3:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c00285e9:	39 da                	cmp    %ebx,%edx
c00285eb:	74 7e                	je     c002866b <print_stacktrace+0xdd>
c00285ed:	8b 42 10             	mov    0x10(%edx),%eax
c00285f0:	3d ea 18 02 c0       	cmp    $0xc00218ea,%eax
c00285f5:	74 74                	je     c002866b <print_stacktrace+0xdd>
        {
          printf (" thread was never scheduled.\n");
          return;
        }

      frame = (void **) saved_frame->ebp;
c00285f7:	8b 5a 08             	mov    0x8(%edx),%ebx
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c00285fa:	83 ec 08             	sub    $0x8,%esp
c00285fd:	50                   	push   %eax
c00285fe:	68 19 26 03 c0       	push   $0xc0032619
c0028603:	e8 c7 e5 ff ff       	call   c0026bcf <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0028608:	83 c4 10             	add    $0x10,%esp
c002860b:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c0028611:	76 27                	jbe    c002863a <print_stacktrace+0xac>
c0028613:	83 3b 00             	cmpl   $0x0,(%ebx)
c0028616:	74 22                	je     c002863a <print_stacktrace+0xac>
    printf (" %p", frame[1]);
c0028618:	83 ec 08             	sub    $0x8,%esp
c002861b:	ff 73 04             	pushl  0x4(%ebx)
c002861e:	68 19 26 03 c0       	push   $0xc0032619
c0028623:	e8 a7 e5 ff ff       	call   c0026bcf <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0028628:	8b 1b                	mov    (%ebx),%ebx
c002862a:	83 c4 10             	add    $0x10,%esp
c002862d:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c0028633:	76 05                	jbe    c002863a <print_stacktrace+0xac>
c0028635:	83 3b 00             	cmpl   $0x0,(%ebx)
c0028638:	75 de                	jne    c0028618 <print_stacktrace+0x8a>
  printf (".\n");
c002863a:	83 ec 0c             	sub    $0xc,%esp
c002863d:	68 a3 21 03 c0       	push   $0xc00321a3
c0028642:	e8 1d 1b 00 00       	call   c002a164 <puts>
c0028647:	83 c4 10             	add    $0x10,%esp
}
c002864a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002864d:	c9                   	leave  
c002864e:	c3                   	ret    
      status = "READY";
c002864f:	b8 1d 29 03 c0       	mov    $0xc003291d,%eax
      break;
c0028654:	e9 65 ff ff ff       	jmp    c00285be <print_stacktrace+0x30>
      status = "BLOCKED";
c0028659:	b8 63 13 03 c0       	mov    $0xc0031363,%eax
      break;
c002865e:	e9 5b ff ff ff       	jmp    c00285be <print_stacktrace+0x30>
      frame = __builtin_frame_address (1);
c0028663:	8b 5d 00             	mov    0x0(%ebp),%ebx
      retaddr = __builtin_return_address (0);
c0028666:	8b 45 04             	mov    0x4(%ebp),%eax
c0028669:	eb 8f                	jmp    c00285fa <print_stacktrace+0x6c>
          printf (" thread was never scheduled.\n");
c002866b:	83 ec 0c             	sub    $0xc,%esp
c002866e:	68 2b 29 03 c0       	push   $0xc003292b
c0028673:	e8 ec 1a 00 00       	call   c002a164 <puts>
          return;
c0028678:	83 c4 10             	add    $0x10,%esp
c002867b:	eb cd                	jmp    c002864a <print_stacktrace+0xbc>

c002867d <debug_panic>:
{
c002867d:	57                   	push   %edi
c002867e:	56                   	push   %esi
c002867f:	53                   	push   %ebx
c0028680:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028684:	8b 74 24 14          	mov    0x14(%esp),%esi
c0028688:	8b 7c 24 18          	mov    0x18(%esp),%edi
  intr_disable ();
c002868c:	e8 ca 93 ff ff       	call   c0021a5b <intr_disable>
  console_panic ();
c0028691:	e8 75 1a 00 00       	call   c002a10b <console_panic>
  level++;
c0028696:	a1 40 e4 03 c0       	mov    0xc003e440,%eax
c002869b:	40                   	inc    %eax
c002869c:	a3 40 e4 03 c0       	mov    %eax,0xc003e440
  if (level == 1) 
c00286a1:	83 f8 01             	cmp    $0x1,%eax
c00286a4:	74 11                	je     c00286b7 <debug_panic+0x3a>
  else if (level == 2)
c00286a6:	83 f8 02             	cmp    $0x2,%eax
c00286a9:	74 40                	je     c00286eb <debug_panic+0x6e>
  serial_flush ();
c00286ab:	e8 26 c4 ff ff       	call   c0024ad6 <serial_flush>
  shutdown ();
c00286b0:	e8 5c de ff ff       	call   c0026511 <shutdown>
c00286b5:	eb fe                	jmp    c00286b5 <debug_panic+0x38>
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c00286b7:	57                   	push   %edi
c00286b8:	56                   	push   %esi
c00286b9:	53                   	push   %ebx
c00286ba:	68 70 29 03 c0       	push   $0xc0032970
c00286bf:	e8 0b e5 ff ff       	call   c0026bcf <printf>
      va_start (args, message);
c00286c4:	8d 44 24 30          	lea    0x30(%esp),%eax
      vprintf (message, args);
c00286c8:	83 c4 08             	add    $0x8,%esp
c00286cb:	50                   	push   %eax
c00286cc:	ff 74 24 28          	pushl  0x28(%esp)
c00286d0:	e8 5b 1a 00 00       	call   c002a130 <vprintf>
      printf ("\n");
c00286d5:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c00286dc:	e8 ef 1a 00 00       	call   c002a1d0 <putchar>
      debug_backtrace ();
c00286e1:	e8 e6 de ff ff       	call   c00265cc <debug_backtrace>
c00286e6:	83 c4 10             	add    $0x10,%esp
c00286e9:	eb c0                	jmp    c00286ab <debug_panic+0x2e>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c00286eb:	57                   	push   %edi
c00286ec:	56                   	push   %esi
c00286ed:	53                   	push   %ebx
c00286ee:	68 90 29 03 c0       	push   $0xc0032990
c00286f3:	e8 d7 e4 ff ff       	call   c0026bcf <printf>
c00286f8:	83 c4 10             	add    $0x10,%esp
c00286fb:	eb ae                	jmp    c00286ab <debug_panic+0x2e>

c00286fd <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c00286fd:	53                   	push   %ebx
c00286fe:	83 ec 08             	sub    $0x8,%esp
  enum intr_level oldlevel = intr_disable ();
c0028701:	e8 55 93 ff ff       	call   c0021a5b <intr_disable>
c0028706:	89 c3                	mov    %eax,%ebx

  thread_foreach (print_stacktrace, 0);
c0028708:	83 ec 08             	sub    $0x8,%esp
c002870b:	6a 00                	push   $0x0
c002870d:	68 8e 85 02 c0       	push   $0xc002858e
c0028712:	e8 e2 86 ff ff       	call   c0020df9 <thread_foreach>
  intr_set_level (oldlevel);
c0028717:	89 1c 24             	mov    %ebx,(%esp)
c002871a:	e8 43 93 ff ff       	call   c0021a62 <intr_set_level>
}
c002871f:	83 c4 18             	add    $0x18,%esp
c0028722:	5b                   	pop    %ebx
c0028723:	c3                   	ret    

c0028724 <list_init>:
}

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c0028724:	83 ec 0c             	sub    $0xc,%esp
c0028727:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002872b:	85 c0                	test   %eax,%eax
c002872d:	74 1a                	je     c0028749 <list_init+0x25>
  list->head.prev = NULL;
c002872f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c0028735:	8d 50 08             	lea    0x8(%eax),%edx
c0028738:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c002873b:	89 40 08             	mov    %eax,0x8(%eax)
  list->tail.next = NULL;
c002873e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0028745:	83 c4 0c             	add    $0xc,%esp
c0028748:	c3                   	ret    
  ASSERT (list != NULL);
c0028749:	83 ec 0c             	sub    $0xc,%esp
c002874c:	68 ba 29 03 c0       	push   $0xc00329ba
c0028751:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028756:	68 78 08 03 c0       	push   $0xc0030878
c002875b:	6a 3d                	push   $0x3d
c002875d:	68 c7 29 03 c0       	push   $0xc00329c7
c0028762:	e8 16 ff ff ff       	call   c002867d <debug_panic>

c0028767 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c0028767:	83 ec 0c             	sub    $0xc,%esp
c002876a:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002876e:	85 c0                	test   %eax,%eax
c0028770:	74 07                	je     c0028779 <list_begin+0x12>
  return list->head.next;
c0028772:	8b 40 04             	mov    0x4(%eax),%eax
}
c0028775:	83 c4 0c             	add    $0xc,%esp
c0028778:	c3                   	ret    
  ASSERT (list != NULL);
c0028779:	83 ec 0c             	sub    $0xc,%esp
c002877c:	68 ba 29 03 c0       	push   $0xc00329ba
c0028781:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028786:	68 6c 08 03 c0       	push   $0xc003086c
c002878b:	6a 48                	push   $0x48
c002878d:	68 c7 29 03 c0       	push   $0xc00329c7
c0028792:	e8 e6 fe ff ff       	call   c002867d <debug_panic>

c0028797 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0028797:	83 ec 0c             	sub    $0xc,%esp
c002879a:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c002879e:	85 c0                	test   %eax,%eax
c00287a0:	74 1f                	je     c00287c1 <list_next+0x2a>
c00287a2:	83 38 00             	cmpl   $0x0,(%eax)
c00287a5:	74 12                	je     c00287b9 <list_next+0x22>
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00287a7:	83 38 00             	cmpl   $0x0,(%eax)
c00287aa:	74 15                	je     c00287c1 <list_next+0x2a>
c00287ac:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00287b0:	74 0f                	je     c00287c1 <list_next+0x2a>
  ASSERT (is_head (elem) || is_interior (elem));
  return elem->next;
c00287b2:	8b 40 04             	mov    0x4(%eax),%eax
}
c00287b5:	83 c4 0c             	add    $0xc,%esp
c00287b8:	c3                   	ret    
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c00287b9:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00287bd:	75 f3                	jne    c00287b2 <list_next+0x1b>
c00287bf:	eb e6                	jmp    c00287a7 <list_next+0x10>
  ASSERT (is_head (elem) || is_interior (elem));
c00287c1:	83 ec 0c             	sub    $0xc,%esp
c00287c4:	68 7c 2a 03 c0       	push   $0xc0032a7c
c00287c9:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00287ce:	68 60 08 03 c0       	push   $0xc0030860
c00287d3:	6a 52                	push   $0x52
c00287d5:	68 c7 29 03 c0       	push   $0xc00329c7
c00287da:	e8 9e fe ff ff       	call   c002867d <debug_panic>

c00287df <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c00287df:	83 ec 0c             	sub    $0xc,%esp
c00287e2:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00287e6:	85 c0                	test   %eax,%eax
c00287e8:	74 07                	je     c00287f1 <list_end+0x12>
  return &list->tail;
c00287ea:	83 c0 08             	add    $0x8,%eax
}
c00287ed:	83 c4 0c             	add    $0xc,%esp
c00287f0:	c3                   	ret    
  ASSERT (list != NULL);
c00287f1:	83 ec 0c             	sub    $0xc,%esp
c00287f4:	68 ba 29 03 c0       	push   $0xc00329ba
c00287f9:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00287fe:	68 54 08 03 c0       	push   $0xc0030854
c0028803:	6a 5e                	push   $0x5e
c0028805:	68 c7 29 03 c0       	push   $0xc00329c7
c002880a:	e8 6e fe ff ff       	call   c002867d <debug_panic>

c002880f <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c002880f:	83 ec 0c             	sub    $0xc,%esp
c0028812:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0028816:	85 c0                	test   %eax,%eax
c0028818:	74 07                	je     c0028821 <list_rbegin+0x12>
  return list->tail.prev;
c002881a:	8b 40 08             	mov    0x8(%eax),%eax
}
c002881d:	83 c4 0c             	add    $0xc,%esp
c0028820:	c3                   	ret    
  ASSERT (list != NULL);
c0028821:	83 ec 0c             	sub    $0xc,%esp
c0028824:	68 ba 29 03 c0       	push   $0xc00329ba
c0028829:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002882e:	68 48 08 03 c0       	push   $0xc0030848
c0028833:	6a 67                	push   $0x67
c0028835:	68 c7 29 03 c0       	push   $0xc00329c7
c002883a:	e8 3e fe ff ff       	call   c002867d <debug_panic>

c002883f <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c002883f:	83 ec 0c             	sub    $0xc,%esp
c0028842:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028846:	85 c0                	test   %eax,%eax
c0028848:	74 1c                	je     c0028866 <list_prev+0x27>
c002884a:	83 38 00             	cmpl   $0x0,(%eax)
c002884d:	74 0c                	je     c002885b <list_prev+0x1c>
c002884f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0028853:	74 06                	je     c002885b <list_prev+0x1c>
  ASSERT (is_interior (elem) || is_tail (elem));
  return elem->prev;
c0028855:	8b 00                	mov    (%eax),%eax
}
c0028857:	83 c4 0c             	add    $0xc,%esp
c002885a:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002885b:	83 38 00             	cmpl   $0x0,(%eax)
c002885e:	74 06                	je     c0028866 <list_prev+0x27>
c0028860:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0028864:	74 ef                	je     c0028855 <list_prev+0x16>
  ASSERT (is_interior (elem) || is_tail (elem));
c0028866:	83 ec 0c             	sub    $0xc,%esp
c0028869:	68 a4 2a 03 c0       	push   $0xc0032aa4
c002886e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028873:	68 3c 08 03 c0       	push   $0xc003083c
c0028878:	6a 71                	push   $0x71
c002887a:	68 c7 29 03 c0       	push   $0xc00329c7
c002887f:	e8 f9 fd ff ff       	call   c002867d <debug_panic>

c0028884 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c0028884:	55                   	push   %ebp
c0028885:	57                   	push   %edi
c0028886:	56                   	push   %esi
c0028887:	53                   	push   %ebx
c0028888:	83 ec 0c             	sub    $0xc,%esp
c002888b:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  ASSERT (a != NULL);
c002888f:	85 c0                	test   %eax,%eax
c0028891:	74 50                	je     c00288e3 <find_end_of_run+0x5f>
c0028893:	89 c3                	mov    %eax,%ebx
c0028895:	89 d6                	mov    %edx,%esi
c0028897:	89 cf                	mov    %ecx,%edi
  ASSERT (b != NULL);
c0028899:	85 d2                	test   %edx,%edx
c002889b:	74 67                	je     c0028904 <find_end_of_run+0x80>
  ASSERT (less != NULL);
c002889d:	85 c9                	test   %ecx,%ecx
c002889f:	0f 84 80 00 00 00    	je     c0028925 <find_end_of_run+0xa1>
  ASSERT (a != b);
c00288a5:	39 d0                	cmp    %edx,%eax
c00288a7:	0f 84 99 00 00 00    	je     c0028946 <find_end_of_run+0xc2>
  
  do 
    {
      a = list_next (a);
c00288ad:	83 ec 0c             	sub    $0xc,%esp
c00288b0:	53                   	push   %ebx
c00288b1:	e8 e1 fe ff ff       	call   c0028797 <list_next>
c00288b6:	83 c4 10             	add    $0x10,%esp
c00288b9:	89 c3                	mov    %eax,%ebx
    }
  while (a != b && !less (a, list_prev (a), aux));
c00288bb:	39 c6                	cmp    %eax,%esi
c00288bd:	74 1a                	je     c00288d9 <find_end_of_run+0x55>
c00288bf:	83 ec 0c             	sub    $0xc,%esp
c00288c2:	50                   	push   %eax
c00288c3:	e8 77 ff ff ff       	call   c002883f <list_prev>
c00288c8:	83 c4 0c             	add    $0xc,%esp
c00288cb:	55                   	push   %ebp
c00288cc:	50                   	push   %eax
c00288cd:	53                   	push   %ebx
c00288ce:	ff d7                	call   *%edi
c00288d0:	83 c4 10             	add    $0x10,%esp
c00288d3:	84 c0                	test   %al,%al
c00288d5:	74 d6                	je     c00288ad <find_end_of_run+0x29>
      a = list_next (a);
c00288d7:	89 de                	mov    %ebx,%esi
  return a;
}
c00288d9:	89 f0                	mov    %esi,%eax
c00288db:	83 c4 0c             	add    $0xc,%esp
c00288de:	5b                   	pop    %ebx
c00288df:	5e                   	pop    %esi
c00288e0:	5f                   	pop    %edi
c00288e1:	5d                   	pop    %ebp
c00288e2:	c3                   	ret    
  ASSERT (a != NULL);
c00288e3:	83 ec 0c             	sub    $0xc,%esp
c00288e6:	68 21 18 03 c0       	push   $0xc0031821
c00288eb:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00288f0:	68 c0 07 03 c0       	push   $0xc00307c0
c00288f5:	68 67 01 00 00       	push   $0x167
c00288fa:	68 c7 29 03 c0       	push   $0xc00329c7
c00288ff:	e8 79 fd ff ff       	call   c002867d <debug_panic>
  ASSERT (b != NULL);
c0028904:	83 ec 0c             	sub    $0xc,%esp
c0028907:	68 df 29 03 c0       	push   $0xc00329df
c002890c:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028911:	68 c0 07 03 c0       	push   $0xc00307c0
c0028916:	68 68 01 00 00       	push   $0x168
c002891b:	68 c7 29 03 c0       	push   $0xc00329c7
c0028920:	e8 58 fd ff ff       	call   c002867d <debug_panic>
  ASSERT (less != NULL);
c0028925:	83 ec 0c             	sub    $0xc,%esp
c0028928:	68 e9 29 03 c0       	push   $0xc00329e9
c002892d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028932:	68 c0 07 03 c0       	push   $0xc00307c0
c0028937:	68 69 01 00 00       	push   $0x169
c002893c:	68 c7 29 03 c0       	push   $0xc00329c7
c0028941:	e8 37 fd ff ff       	call   c002867d <debug_panic>
  ASSERT (a != b);
c0028946:	83 ec 0c             	sub    $0xc,%esp
c0028949:	68 f6 29 03 c0       	push   $0xc00329f6
c002894e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028953:	68 c0 07 03 c0       	push   $0xc00307c0
c0028958:	68 6a 01 00 00       	push   $0x16a
c002895d:	68 c7 29 03 c0       	push   $0xc00329c7
c0028962:	e8 16 fd ff ff       	call   c002867d <debug_panic>

c0028967 <list_rend>:
{
c0028967:	83 ec 0c             	sub    $0xc,%esp
c002896a:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002896e:	85 c0                	test   %eax,%eax
c0028970:	74 04                	je     c0028976 <list_rend+0xf>
}
c0028972:	83 c4 0c             	add    $0xc,%esp
c0028975:	c3                   	ret    
  ASSERT (list != NULL);
c0028976:	83 ec 0c             	sub    $0xc,%esp
c0028979:	68 ba 29 03 c0       	push   $0xc00329ba
c002897e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028983:	68 30 08 03 c0       	push   $0xc0030830
c0028988:	68 85 00 00 00       	push   $0x85
c002898d:	68 c7 29 03 c0       	push   $0xc00329c7
c0028992:	e8 e6 fc ff ff       	call   c002867d <debug_panic>

c0028997 <list_head>:
{
c0028997:	83 ec 0c             	sub    $0xc,%esp
c002899a:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002899e:	85 c0                	test   %eax,%eax
c00289a0:	74 04                	je     c00289a6 <list_head+0xf>
}
c00289a2:	83 c4 0c             	add    $0xc,%esp
c00289a5:	c3                   	ret    
  ASSERT (list != NULL);
c00289a6:	83 ec 0c             	sub    $0xc,%esp
c00289a9:	68 ba 29 03 c0       	push   $0xc00329ba
c00289ae:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00289b3:	68 24 08 03 c0       	push   $0xc0030824
c00289b8:	68 97 00 00 00       	push   $0x97
c00289bd:	68 c7 29 03 c0       	push   $0xc00329c7
c00289c2:	e8 b6 fc ff ff       	call   c002867d <debug_panic>

c00289c7 <list_tail>:
{
c00289c7:	83 ec 0c             	sub    $0xc,%esp
c00289ca:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00289ce:	85 c0                	test   %eax,%eax
c00289d0:	74 07                	je     c00289d9 <list_tail+0x12>
  return &list->tail;
c00289d2:	83 c0 08             	add    $0x8,%eax
}
c00289d5:	83 c4 0c             	add    $0xc,%esp
c00289d8:	c3                   	ret    
  ASSERT (list != NULL);
c00289d9:	83 ec 0c             	sub    $0xc,%esp
c00289dc:	68 ba 29 03 c0       	push   $0xc00329ba
c00289e1:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00289e6:	68 18 08 03 c0       	push   $0xc0030818
c00289eb:	68 9f 00 00 00       	push   $0x9f
c00289f0:	68 c7 29 03 c0       	push   $0xc00329c7
c00289f5:	e8 83 fc ff ff       	call   c002867d <debug_panic>

c00289fa <list_insert>:
{
c00289fa:	83 ec 0c             	sub    $0xc,%esp
c00289fd:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028a01:	8b 54 24 14          	mov    0x14(%esp),%edx
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028a05:	85 c0                	test   %eax,%eax
c0028a07:	74 2c                	je     c0028a35 <list_insert+0x3b>
c0028a09:	83 38 00             	cmpl   $0x0,(%eax)
c0028a0c:	74 1c                	je     c0028a2a <list_insert+0x30>
c0028a0e:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0028a12:	74 16                	je     c0028a2a <list_insert+0x30>
  ASSERT (elem != NULL);
c0028a14:	85 d2                	test   %edx,%edx
c0028a16:	74 3e                	je     c0028a56 <list_insert+0x5c>
  elem->prev = before->prev;
c0028a18:	8b 08                	mov    (%eax),%ecx
c0028a1a:	89 0a                	mov    %ecx,(%edx)
  elem->next = before;
c0028a1c:	89 42 04             	mov    %eax,0x4(%edx)
  before->prev->next = elem;
c0028a1f:	8b 08                	mov    (%eax),%ecx
c0028a21:	89 51 04             	mov    %edx,0x4(%ecx)
  before->prev = elem;
c0028a24:	89 10                	mov    %edx,(%eax)
}
c0028a26:	83 c4 0c             	add    $0xc,%esp
c0028a29:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0028a2a:	83 38 00             	cmpl   $0x0,(%eax)
c0028a2d:	74 06                	je     c0028a35 <list_insert+0x3b>
c0028a2f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0028a33:	74 df                	je     c0028a14 <list_insert+0x1a>
  ASSERT (is_interior (before) || is_tail (before));
c0028a35:	83 ec 0c             	sub    $0xc,%esp
c0028a38:	68 cc 2a 03 c0       	push   $0xc0032acc
c0028a3d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028a42:	68 0c 08 03 c0       	push   $0xc003080c
c0028a47:	68 a9 00 00 00       	push   $0xa9
c0028a4c:	68 c7 29 03 c0       	push   $0xc00329c7
c0028a51:	e8 27 fc ff ff       	call   c002867d <debug_panic>
  ASSERT (elem != NULL);
c0028a56:	83 ec 0c             	sub    $0xc,%esp
c0028a59:	68 fd 29 03 c0       	push   $0xc00329fd
c0028a5e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028a63:	68 0c 08 03 c0       	push   $0xc003080c
c0028a68:	68 aa 00 00 00       	push   $0xaa
c0028a6d:	68 c7 29 03 c0       	push   $0xc00329c7
c0028a72:	e8 06 fc ff ff       	call   c002867d <debug_panic>

c0028a77 <list_splice>:
{
c0028a77:	56                   	push   %esi
c0028a78:	53                   	push   %ebx
c0028a79:	83 ec 04             	sub    $0x4,%esp
c0028a7c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028a80:	8b 74 24 14          	mov    0x14(%esp),%esi
c0028a84:	8b 44 24 18          	mov    0x18(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028a88:	85 db                	test   %ebx,%ebx
c0028a8a:	74 64                	je     c0028af0 <list_splice+0x79>
c0028a8c:	83 3b 00             	cmpl   $0x0,(%ebx)
c0028a8f:	74 54                	je     c0028ae5 <list_splice+0x6e>
c0028a91:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0028a95:	74 4e                	je     c0028ae5 <list_splice+0x6e>
  if (first == last)
c0028a97:	39 c6                	cmp    %eax,%esi
c0028a99:	74 44                	je     c0028adf <list_splice+0x68>
  last = list_prev (last);
c0028a9b:	83 ec 0c             	sub    $0xc,%esp
c0028a9e:	50                   	push   %eax
c0028a9f:	e8 9b fd ff ff       	call   c002883f <list_prev>
c0028aa4:	83 c4 10             	add    $0x10,%esp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028aa7:	85 f6                	test   %esi,%esi
c0028aa9:	74 66                	je     c0028b11 <list_splice+0x9a>
c0028aab:	8b 16                	mov    (%esi),%edx
c0028aad:	85 d2                	test   %edx,%edx
c0028aaf:	74 60                	je     c0028b11 <list_splice+0x9a>
c0028ab1:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0028ab5:	74 5a                	je     c0028b11 <list_splice+0x9a>
c0028ab7:	85 c0                	test   %eax,%eax
c0028ab9:	74 77                	je     c0028b32 <list_splice+0xbb>
c0028abb:	83 38 00             	cmpl   $0x0,(%eax)
c0028abe:	74 72                	je     c0028b32 <list_splice+0xbb>
c0028ac0:	8b 48 04             	mov    0x4(%eax),%ecx
c0028ac3:	85 c9                	test   %ecx,%ecx
c0028ac5:	74 6b                	je     c0028b32 <list_splice+0xbb>
  first->prev->next = last->next;
c0028ac7:	89 4a 04             	mov    %ecx,0x4(%edx)
  last->next->prev = first->prev;
c0028aca:	8b 50 04             	mov    0x4(%eax),%edx
c0028acd:	8b 0e                	mov    (%esi),%ecx
c0028acf:	89 0a                	mov    %ecx,(%edx)
  first->prev = before->prev;
c0028ad1:	8b 13                	mov    (%ebx),%edx
c0028ad3:	89 16                	mov    %edx,(%esi)
  last->next = before;
c0028ad5:	89 58 04             	mov    %ebx,0x4(%eax)
  before->prev->next = first;
c0028ad8:	8b 13                	mov    (%ebx),%edx
c0028ada:	89 72 04             	mov    %esi,0x4(%edx)
  before->prev = last;
c0028add:	89 03                	mov    %eax,(%ebx)
}
c0028adf:	83 c4 04             	add    $0x4,%esp
c0028ae2:	5b                   	pop    %ebx
c0028ae3:	5e                   	pop    %esi
c0028ae4:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0028ae5:	83 3b 00             	cmpl   $0x0,(%ebx)
c0028ae8:	74 06                	je     c0028af0 <list_splice+0x79>
c0028aea:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0028aee:	74 a7                	je     c0028a97 <list_splice+0x20>
  ASSERT (is_interior (before) || is_tail (before));
c0028af0:	83 ec 0c             	sub    $0xc,%esp
c0028af3:	68 cc 2a 03 c0       	push   $0xc0032acc
c0028af8:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028afd:	68 00 08 03 c0       	push   $0xc0030800
c0028b02:	68 b9 00 00 00       	push   $0xb9
c0028b07:	68 c7 29 03 c0       	push   $0xc00329c7
c0028b0c:	e8 6c fb ff ff       	call   c002867d <debug_panic>
  ASSERT (is_interior (first));
c0028b11:	83 ec 0c             	sub    $0xc,%esp
c0028b14:	68 0a 2a 03 c0       	push   $0xc0032a0a
c0028b19:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028b1e:	68 00 08 03 c0       	push   $0xc0030800
c0028b23:	68 be 00 00 00       	push   $0xbe
c0028b28:	68 c7 29 03 c0       	push   $0xc00329c7
c0028b2d:	e8 4b fb ff ff       	call   c002867d <debug_panic>
  ASSERT (is_interior (last));
c0028b32:	83 ec 0c             	sub    $0xc,%esp
c0028b35:	68 1e 2a 03 c0       	push   $0xc0032a1e
c0028b3a:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028b3f:	68 00 08 03 c0       	push   $0xc0030800
c0028b44:	68 bf 00 00 00       	push   $0xbf
c0028b49:	68 c7 29 03 c0       	push   $0xc00329c7
c0028b4e:	e8 2a fb ff ff       	call   c002867d <debug_panic>

c0028b53 <list_push_front>:
{
c0028b53:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_begin (list), elem);
c0028b56:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028b5a:	e8 08 fc ff ff       	call   c0028767 <list_begin>
c0028b5f:	83 c4 08             	add    $0x8,%esp
c0028b62:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028b66:	50                   	push   %eax
c0028b67:	e8 8e fe ff ff       	call   c00289fa <list_insert>
}
c0028b6c:	83 c4 1c             	add    $0x1c,%esp
c0028b6f:	c3                   	ret    

c0028b70 <list_push_back>:
{
c0028b70:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_end (list), elem);
c0028b73:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028b77:	e8 63 fc ff ff       	call   c00287df <list_end>
c0028b7c:	83 c4 08             	add    $0x8,%esp
c0028b7f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028b83:	50                   	push   %eax
c0028b84:	e8 71 fe ff ff       	call   c00289fa <list_insert>
}
c0028b89:	83 c4 1c             	add    $0x1c,%esp
c0028b8c:	c3                   	ret    

c0028b8d <list_remove>:
{
c0028b8d:	83 ec 0c             	sub    $0xc,%esp
c0028b90:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028b94:	85 c0                	test   %eax,%eax
c0028b96:	74 1e                	je     c0028bb6 <list_remove+0x29>
c0028b98:	8b 10                	mov    (%eax),%edx
c0028b9a:	85 d2                	test   %edx,%edx
c0028b9c:	74 18                	je     c0028bb6 <list_remove+0x29>
c0028b9e:	8b 48 04             	mov    0x4(%eax),%ecx
c0028ba1:	85 c9                	test   %ecx,%ecx
c0028ba3:	74 11                	je     c0028bb6 <list_remove+0x29>
  elem->prev->next = elem->next;
c0028ba5:	89 4a 04             	mov    %ecx,0x4(%edx)
  elem->next->prev = elem->prev;
c0028ba8:	8b 50 04             	mov    0x4(%eax),%edx
c0028bab:	8b 08                	mov    (%eax),%ecx
c0028bad:	89 0a                	mov    %ecx,(%edx)
  return elem->next;
c0028baf:	8b 40 04             	mov    0x4(%eax),%eax
}
c0028bb2:	83 c4 0c             	add    $0xc,%esp
c0028bb5:	c3                   	ret    
  ASSERT (is_interior (elem));
c0028bb6:	83 ec 0c             	sub    $0xc,%esp
c0028bb9:	68 31 2a 03 c0       	push   $0xc0032a31
c0028bbe:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028bc3:	68 f4 07 03 c0       	push   $0xc00307f4
c0028bc8:	68 f9 00 00 00       	push   $0xf9
c0028bcd:	68 c7 29 03 c0       	push   $0xc00329c7
c0028bd2:	e8 a6 fa ff ff       	call   c002867d <debug_panic>

c0028bd7 <list_size>:
{
c0028bd7:	57                   	push   %edi
c0028bd8:	56                   	push   %esi
c0028bd9:	53                   	push   %ebx
c0028bda:	8b 7c 24 10          	mov    0x10(%esp),%edi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028bde:	83 ec 0c             	sub    $0xc,%esp
c0028be1:	57                   	push   %edi
c0028be2:	e8 80 fb ff ff       	call   c0028767 <list_begin>
c0028be7:	83 c4 10             	add    $0x10,%esp
c0028bea:	89 c3                	mov    %eax,%ebx
  size_t cnt = 0;
c0028bec:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028bf1:	eb 0f                	jmp    c0028c02 <list_size+0x2b>
    cnt++;
c0028bf3:	46                   	inc    %esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028bf4:	83 ec 0c             	sub    $0xc,%esp
c0028bf7:	53                   	push   %ebx
c0028bf8:	e8 9a fb ff ff       	call   c0028797 <list_next>
c0028bfd:	83 c4 10             	add    $0x10,%esp
c0028c00:	89 c3                	mov    %eax,%ebx
c0028c02:	83 ec 0c             	sub    $0xc,%esp
c0028c05:	57                   	push   %edi
c0028c06:	e8 d4 fb ff ff       	call   c00287df <list_end>
c0028c0b:	83 c4 10             	add    $0x10,%esp
c0028c0e:	39 c3                	cmp    %eax,%ebx
c0028c10:	75 e1                	jne    c0028bf3 <list_size+0x1c>
}
c0028c12:	89 f0                	mov    %esi,%eax
c0028c14:	5b                   	pop    %ebx
c0028c15:	5e                   	pop    %esi
c0028c16:	5f                   	pop    %edi
c0028c17:	c3                   	ret    

c0028c18 <list_empty>:
{
c0028c18:	56                   	push   %esi
c0028c19:	53                   	push   %ebx
c0028c1a:	83 ec 10             	sub    $0x10,%esp
c0028c1d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  return list_begin (list) == list_end (list);
c0028c21:	53                   	push   %ebx
c0028c22:	e8 40 fb ff ff       	call   c0028767 <list_begin>
c0028c27:	89 c6                	mov    %eax,%esi
c0028c29:	89 1c 24             	mov    %ebx,(%esp)
c0028c2c:	e8 ae fb ff ff       	call   c00287df <list_end>
c0028c31:	39 c6                	cmp    %eax,%esi
c0028c33:	0f 94 c0             	sete   %al
}
c0028c36:	83 c4 14             	add    $0x14,%esp
c0028c39:	5b                   	pop    %ebx
c0028c3a:	5e                   	pop    %esi
c0028c3b:	c3                   	ret    

c0028c3c <list_front>:
{
c0028c3c:	53                   	push   %ebx
c0028c3d:	83 ec 14             	sub    $0x14,%esp
c0028c40:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  ASSERT (!list_empty (list));
c0028c44:	53                   	push   %ebx
c0028c45:	e8 ce ff ff ff       	call   c0028c18 <list_empty>
c0028c4a:	83 c4 10             	add    $0x10,%esp
c0028c4d:	84 c0                	test   %al,%al
c0028c4f:	75 08                	jne    c0028c59 <list_front+0x1d>
  return list->head.next;
c0028c51:	8b 43 04             	mov    0x4(%ebx),%eax
}
c0028c54:	83 c4 08             	add    $0x8,%esp
c0028c57:	5b                   	pop    %ebx
c0028c58:	c3                   	ret    
  ASSERT (!list_empty (list));
c0028c59:	83 ec 0c             	sub    $0xc,%esp
c0028c5c:	68 44 2a 03 c0       	push   $0xc0032a44
c0028c61:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028c66:	68 e8 07 03 c0       	push   $0xc00307e8
c0028c6b:	68 18 01 00 00       	push   $0x118
c0028c70:	68 c7 29 03 c0       	push   $0xc00329c7
c0028c75:	e8 03 fa ff ff       	call   c002867d <debug_panic>

c0028c7a <list_pop_front>:
{
c0028c7a:	53                   	push   %ebx
c0028c7b:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *front = list_front (list);
c0028c7e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028c82:	e8 b5 ff ff ff       	call   c0028c3c <list_front>
c0028c87:	89 c3                	mov    %eax,%ebx
  list_remove (front);
c0028c89:	89 04 24             	mov    %eax,(%esp)
c0028c8c:	e8 fc fe ff ff       	call   c0028b8d <list_remove>
}
c0028c91:	89 d8                	mov    %ebx,%eax
c0028c93:	83 c4 18             	add    $0x18,%esp
c0028c96:	5b                   	pop    %ebx
c0028c97:	c3                   	ret    

c0028c98 <list_back>:
{
c0028c98:	53                   	push   %ebx
c0028c99:	83 ec 14             	sub    $0x14,%esp
c0028c9c:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  ASSERT (!list_empty (list));
c0028ca0:	53                   	push   %ebx
c0028ca1:	e8 72 ff ff ff       	call   c0028c18 <list_empty>
c0028ca6:	83 c4 10             	add    $0x10,%esp
c0028ca9:	84 c0                	test   %al,%al
c0028cab:	75 08                	jne    c0028cb5 <list_back+0x1d>
  return list->tail.prev;
c0028cad:	8b 43 08             	mov    0x8(%ebx),%eax
}
c0028cb0:	83 c4 08             	add    $0x8,%esp
c0028cb3:	5b                   	pop    %ebx
c0028cb4:	c3                   	ret    
  ASSERT (!list_empty (list));
c0028cb5:	83 ec 0c             	sub    $0xc,%esp
c0028cb8:	68 44 2a 03 c0       	push   $0xc0032a44
c0028cbd:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028cc2:	68 dc 07 03 c0       	push   $0xc00307dc
c0028cc7:	68 21 01 00 00       	push   $0x121
c0028ccc:	68 c7 29 03 c0       	push   $0xc00329c7
c0028cd1:	e8 a7 f9 ff ff       	call   c002867d <debug_panic>

c0028cd6 <list_pop_back>:
{
c0028cd6:	53                   	push   %ebx
c0028cd7:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *back = list_back (list);
c0028cda:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028cde:	e8 b5 ff ff ff       	call   c0028c98 <list_back>
c0028ce3:	89 c3                	mov    %eax,%ebx
  list_remove (back);
c0028ce5:	89 04 24             	mov    %eax,(%esp)
c0028ce8:	e8 a0 fe ff ff       	call   c0028b8d <list_remove>
}
c0028ced:	89 d8                	mov    %ebx,%eax
c0028cef:	83 c4 18             	add    $0x18,%esp
c0028cf2:	5b                   	pop    %ebx
c0028cf3:	c3                   	ret    

c0028cf4 <list_reverse>:
{
c0028cf4:	56                   	push   %esi
c0028cf5:	53                   	push   %ebx
c0028cf6:	83 ec 10             	sub    $0x10,%esp
c0028cf9:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  if (!list_empty (list)) 
c0028cfd:	56                   	push   %esi
c0028cfe:	e8 15 ff ff ff       	call   c0028c18 <list_empty>
c0028d03:	83 c4 10             	add    $0x10,%esp
c0028d06:	84 c0                	test   %al,%al
c0028d08:	74 06                	je     c0028d10 <list_reverse+0x1c>
}
c0028d0a:	83 c4 04             	add    $0x4,%esp
c0028d0d:	5b                   	pop    %ebx
c0028d0e:	5e                   	pop    %esi
c0028d0f:	c3                   	ret    
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0028d10:	83 ec 0c             	sub    $0xc,%esp
c0028d13:	56                   	push   %esi
c0028d14:	e8 4e fa ff ff       	call   c0028767 <list_begin>
c0028d19:	83 c4 10             	add    $0x10,%esp
c0028d1c:	89 c3                	mov    %eax,%ebx
c0028d1e:	eb 0c                	jmp    c0028d2c <list_reverse+0x38>
  struct list_elem *t = *a;
c0028d20:	8b 13                	mov    (%ebx),%edx
  *a = *b;
c0028d22:	8b 43 04             	mov    0x4(%ebx),%eax
c0028d25:	89 03                	mov    %eax,(%ebx)
  *b = t;
c0028d27:	89 53 04             	mov    %edx,0x4(%ebx)
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0028d2a:	89 c3                	mov    %eax,%ebx
c0028d2c:	83 ec 0c             	sub    $0xc,%esp
c0028d2f:	56                   	push   %esi
c0028d30:	e8 aa fa ff ff       	call   c00287df <list_end>
c0028d35:	83 c4 10             	add    $0x10,%esp
c0028d38:	39 c3                	cmp    %eax,%ebx
c0028d3a:	75 e4                	jne    c0028d20 <list_reverse+0x2c>
  struct list_elem *t = *a;
c0028d3c:	8b 46 04             	mov    0x4(%esi),%eax
  *a = *b;
c0028d3f:	8b 56 08             	mov    0x8(%esi),%edx
c0028d42:	89 56 04             	mov    %edx,0x4(%esi)
  *b = t;
c0028d45:	89 46 08             	mov    %eax,0x8(%esi)
  struct list_elem *t = *a;
c0028d48:	8b 0a                	mov    (%edx),%ecx
  *a = *b;
c0028d4a:	8b 58 04             	mov    0x4(%eax),%ebx
c0028d4d:	89 1a                	mov    %ebx,(%edx)
  *b = t;
c0028d4f:	89 48 04             	mov    %ecx,0x4(%eax)
}
c0028d52:	eb b6                	jmp    c0028d0a <list_reverse+0x16>

c0028d54 <is_sorted>:
{
c0028d54:	55                   	push   %ebp
c0028d55:	57                   	push   %edi
c0028d56:	56                   	push   %esi
c0028d57:	53                   	push   %ebx
c0028d58:	83 ec 0c             	sub    $0xc,%esp
c0028d5b:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0028d5f:	8b 74 24 24          	mov    0x24(%esp),%esi
c0028d63:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c0028d67:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  return true;
c0028d6b:	b0 01                	mov    $0x1,%al
  if (a != b)
c0028d6d:	39 f3                	cmp    %esi,%ebx
c0028d6f:	74 30                	je     c0028da1 <is_sorted+0x4d>
    while ((a = list_next (a)) != b) 
c0028d71:	83 ec 0c             	sub    $0xc,%esp
c0028d74:	53                   	push   %ebx
c0028d75:	e8 1d fa ff ff       	call   c0028797 <list_next>
c0028d7a:	83 c4 10             	add    $0x10,%esp
c0028d7d:	89 c3                	mov    %eax,%ebx
c0028d7f:	39 c6                	cmp    %eax,%esi
c0028d81:	74 1c                	je     c0028d9f <is_sorted+0x4b>
      if (less (a, list_prev (a), aux))
c0028d83:	83 ec 0c             	sub    $0xc,%esp
c0028d86:	53                   	push   %ebx
c0028d87:	e8 b3 fa ff ff       	call   c002883f <list_prev>
c0028d8c:	83 c4 0c             	add    $0xc,%esp
c0028d8f:	57                   	push   %edi
c0028d90:	50                   	push   %eax
c0028d91:	53                   	push   %ebx
c0028d92:	ff d5                	call   *%ebp
c0028d94:	83 c4 10             	add    $0x10,%esp
c0028d97:	84 c0                	test   %al,%al
c0028d99:	74 d6                	je     c0028d71 <is_sorted+0x1d>
        return false;
c0028d9b:	b0 00                	mov    $0x0,%al
c0028d9d:	eb 02                	jmp    c0028da1 <is_sorted+0x4d>
  return true;
c0028d9f:	b0 01                	mov    $0x1,%al
}
c0028da1:	83 c4 0c             	add    $0xc,%esp
c0028da4:	5b                   	pop    %ebx
c0028da5:	5e                   	pop    %esi
c0028da6:	5f                   	pop    %edi
c0028da7:	5d                   	pop    %ebp
c0028da8:	c3                   	ret    

c0028da9 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c0028da9:	55                   	push   %ebp
c0028daa:	57                   	push   %edi
c0028dab:	56                   	push   %esi
c0028dac:	53                   	push   %ebx
c0028dad:	83 ec 1c             	sub    $0x1c,%esp
c0028db0:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028db4:	8b 7c 24 38          	mov    0x38(%esp),%edi
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c0028db8:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0028dbd:	74 29                	je     c0028de8 <list_sort+0x3f>
  ASSERT (less != NULL);
c0028dbf:	85 ed                	test   %ebp,%ebp
c0028dc1:	0f 85 ee 01 00 00    	jne    c0028fb5 <list_sort+0x20c>
c0028dc7:	83 ec 0c             	sub    $0xc,%esp
c0028dca:	68 e9 29 03 c0       	push   $0xc00329e9
c0028dcf:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028dd4:	68 d0 07 03 c0       	push   $0xc00307d0
c0028dd9:	68 98 01 00 00       	push   $0x198
c0028dde:	68 c7 29 03 c0       	push   $0xc00329c7
c0028de3:	e8 95 f8 ff ff       	call   c002867d <debug_panic>
  ASSERT (list != NULL);
c0028de8:	83 ec 0c             	sub    $0xc,%esp
c0028deb:	68 ba 29 03 c0       	push   $0xc00329ba
c0028df0:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028df5:	68 d0 07 03 c0       	push   $0xc00307d0
c0028dfa:	68 97 01 00 00       	push   $0x197
c0028dff:	68 c7 29 03 c0       	push   $0xc00329c7
c0028e04:	e8 74 f8 ff ff       	call   c002867d <debug_panic>
  ASSERT (a0 != NULL);
c0028e09:	83 ec 0c             	sub    $0xc,%esp
c0028e0c:	68 57 2a 03 c0       	push   $0xc0032a57
c0028e11:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028e16:	68 b0 07 03 c0       	push   $0xc00307b0
c0028e1b:	68 7e 01 00 00       	push   $0x17e
c0028e20:	68 c7 29 03 c0       	push   $0xc00329c7
c0028e25:	e8 53 f8 ff ff       	call   c002867d <debug_panic>
  ASSERT (a1b0 != NULL);
c0028e2a:	83 ec 0c             	sub    $0xc,%esp
c0028e2d:	68 62 2a 03 c0       	push   $0xc0032a62
c0028e32:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028e37:	68 b0 07 03 c0       	push   $0xc00307b0
c0028e3c:	68 7f 01 00 00       	push   $0x17f
c0028e41:	68 c7 29 03 c0       	push   $0xc00329c7
c0028e46:	e8 32 f8 ff ff       	call   c002867d <debug_panic>
  ASSERT (b1 != NULL);
c0028e4b:	83 ec 0c             	sub    $0xc,%esp
c0028e4e:	68 6f 2a 03 c0       	push   $0xc0032a6f
c0028e53:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028e58:	68 b0 07 03 c0       	push   $0xc00307b0
c0028e5d:	68 80 01 00 00       	push   $0x180
c0028e62:	68 c7 29 03 c0       	push   $0xc00329c7
c0028e67:	e8 11 f8 ff ff       	call   c002867d <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0028e6c:	83 ec 0c             	sub    $0xc,%esp
c0028e6f:	68 f8 2a 03 c0       	push   $0xc0032af8
c0028e74:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028e79:	68 b0 07 03 c0       	push   $0xc00307b0
c0028e7e:	68 82 01 00 00       	push   $0x182
c0028e83:	68 c7 29 03 c0       	push   $0xc00329c7
c0028e88:	e8 f0 f7 ff ff       	call   c002867d <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0028e8d:	83 ec 0c             	sub    $0xc,%esp
c0028e90:	68 18 2b 03 c0       	push   $0xc0032b18
c0028e95:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0028e9a:	68 b0 07 03 c0       	push   $0xc00307b0
c0028e9f:	68 83 01 00 00       	push   $0x183
c0028ea4:	68 c7 29 03 c0       	push   $0xc00329c7
c0028ea9:	e8 cf f7 ff ff       	call   c002867d <debug_panic>
        a1b0 = list_next (a1b0);
c0028eae:	83 ec 0c             	sub    $0xc,%esp
c0028eb1:	53                   	push   %ebx
c0028eb2:	e8 e0 f8 ff ff       	call   c0028797 <list_next>
c0028eb7:	89 c3                	mov    %eax,%ebx
        list_splice (a0, list_prev (a1b0), a1b0);
c0028eb9:	89 04 24             	mov    %eax,(%esp)
c0028ebc:	e8 7e f9 ff ff       	call   c002883f <list_prev>
c0028ec1:	83 c4 0c             	add    $0xc,%esp
c0028ec4:	53                   	push   %ebx
c0028ec5:	50                   	push   %eax
c0028ec6:	56                   	push   %esi
c0028ec7:	e8 ab fb ff ff       	call   c0028a77 <list_splice>
c0028ecc:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c0028ecf:	39 f3                	cmp    %esi,%ebx
c0028ed1:	74 25                	je     c0028ef8 <list_sort+0x14f>
c0028ed3:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
c0028ed7:	74 1f                	je     c0028ef8 <list_sort+0x14f>
    if (!less (a1b0, a0, aux)) 
c0028ed9:	83 ec 04             	sub    $0x4,%esp
c0028edc:	57                   	push   %edi
c0028edd:	56                   	push   %esi
c0028ede:	53                   	push   %ebx
c0028edf:	ff d5                	call   *%ebp
c0028ee1:	83 c4 10             	add    $0x10,%esp
c0028ee4:	84 c0                	test   %al,%al
c0028ee6:	75 c6                	jne    c0028eae <list_sort+0x105>
      a0 = list_next (a0);
c0028ee8:	83 ec 0c             	sub    $0xc,%esp
c0028eeb:	56                   	push   %esi
c0028eec:	e8 a6 f8 ff ff       	call   c0028797 <list_next>
c0028ef1:	83 c4 10             	add    $0x10,%esp
c0028ef4:	89 c6                	mov    %eax,%esi
c0028ef6:	eb d7                	jmp    c0028ecf <list_sort+0x126>
{
c0028ef8:	8b 74 24 08          	mov    0x8(%esp),%esi
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028efc:	83 ec 0c             	sub    $0xc,%esp
c0028eff:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028f03:	e8 d7 f8 ff ff       	call   c00287df <list_end>
c0028f08:	83 c4 10             	add    $0x10,%esp
c0028f0b:	39 c6                	cmp    %eax,%esi
c0028f0d:	0f 84 9b 00 00 00    	je     c0028fae <list_sort+0x205>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c0028f13:	ff 44 24 0c          	incl   0xc(%esp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c0028f17:	83 ec 0c             	sub    $0xc,%esp
c0028f1a:	57                   	push   %edi
c0028f1b:	89 e9                	mov    %ebp,%ecx
c0028f1d:	89 c2                	mov    %eax,%edx
c0028f1f:	89 f0                	mov    %esi,%eax
c0028f21:	e8 5e f9 ff ff       	call   c0028884 <find_end_of_run>
c0028f26:	89 c3                	mov    %eax,%ebx
          if (a1b0 == list_end (list))
c0028f28:	83 c4 04             	add    $0x4,%esp
c0028f2b:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028f2f:	e8 ab f8 ff ff       	call   c00287df <list_end>
c0028f34:	83 c4 10             	add    $0x10,%esp
c0028f37:	39 c3                	cmp    %eax,%ebx
c0028f39:	74 73                	je     c0028fae <list_sort+0x205>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c0028f3b:	83 ec 0c             	sub    $0xc,%esp
c0028f3e:	57                   	push   %edi
c0028f3f:	89 e9                	mov    %ebp,%ecx
c0028f41:	89 c2                	mov    %eax,%edx
c0028f43:	89 d8                	mov    %ebx,%eax
c0028f45:	e8 3a f9 ff ff       	call   c0028884 <find_end_of_run>
c0028f4a:	89 44 24 18          	mov    %eax,0x18(%esp)
  ASSERT (a0 != NULL);
c0028f4e:	83 c4 10             	add    $0x10,%esp
c0028f51:	85 f6                	test   %esi,%esi
c0028f53:	0f 84 b0 fe ff ff    	je     c0028e09 <list_sort+0x60>
  ASSERT (a1b0 != NULL);
c0028f59:	85 db                	test   %ebx,%ebx
c0028f5b:	0f 84 c9 fe ff ff    	je     c0028e2a <list_sort+0x81>
  ASSERT (b1 != NULL);
c0028f61:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028f66:	0f 84 df fe ff ff    	je     c0028e4b <list_sort+0xa2>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0028f6c:	57                   	push   %edi
c0028f6d:	55                   	push   %ebp
c0028f6e:	53                   	push   %ebx
c0028f6f:	56                   	push   %esi
c0028f70:	e8 df fd ff ff       	call   c0028d54 <is_sorted>
c0028f75:	83 c4 10             	add    $0x10,%esp
c0028f78:	84 c0                	test   %al,%al
c0028f7a:	0f 84 ec fe ff ff    	je     c0028e6c <list_sort+0xc3>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0028f80:	57                   	push   %edi
c0028f81:	55                   	push   %ebp
c0028f82:	ff 74 24 10          	pushl  0x10(%esp)
c0028f86:	53                   	push   %ebx
c0028f87:	e8 c8 fd ff ff       	call   c0028d54 <is_sorted>
c0028f8c:	83 c4 10             	add    $0x10,%esp
c0028f8f:	84 c0                	test   %al,%al
c0028f91:	0f 84 f6 fe ff ff    	je     c0028e8d <list_sort+0xe4>
  while (a0 != a1b0 && a1b0 != b1)
c0028f97:	39 de                	cmp    %ebx,%esi
c0028f99:	0f 84 59 ff ff ff    	je     c0028ef8 <list_sort+0x14f>
c0028f9f:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0028fa3:	0f 85 30 ff ff ff    	jne    c0028ed9 <list_sort+0x130>
c0028fa9:	e9 4a ff ff ff       	jmp    c0028ef8 <list_sort+0x14f>

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c0028fae:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
c0028fb3:	76 1e                	jbe    c0028fd3 <list_sort+0x22a>
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028fb5:	83 ec 0c             	sub    $0xc,%esp
c0028fb8:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028fbc:	e8 a6 f7 ff ff       	call   c0028767 <list_begin>
c0028fc1:	83 c4 10             	add    $0x10,%esp
c0028fc4:	89 c6                	mov    %eax,%esi
      output_run_cnt = 0;
c0028fc6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0028fcd:	00 
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028fce:	e9 29 ff ff ff       	jmp    c0028efc <list_sort+0x153>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0028fd3:	83 ec 0c             	sub    $0xc,%esp
c0028fd6:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028fda:	e8 00 f8 ff ff       	call   c00287df <list_end>
c0028fdf:	83 c4 04             	add    $0x4,%esp
c0028fe2:	89 c3                	mov    %eax,%ebx
c0028fe4:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028fe8:	e8 7a f7 ff ff       	call   c0028767 <list_begin>
c0028fed:	83 c4 10             	add    $0x10,%esp
c0028ff0:	57                   	push   %edi
c0028ff1:	55                   	push   %ebp
c0028ff2:	53                   	push   %ebx
c0028ff3:	50                   	push   %eax
c0028ff4:	e8 5b fd ff ff       	call   c0028d54 <is_sorted>
c0028ff9:	83 c4 10             	add    $0x10,%esp
c0028ffc:	84 c0                	test   %al,%al
c0028ffe:	74 08                	je     c0029008 <list_sort+0x25f>
}
c0029000:	83 c4 1c             	add    $0x1c,%esp
c0029003:	5b                   	pop    %ebx
c0029004:	5e                   	pop    %esi
c0029005:	5f                   	pop    %edi
c0029006:	5d                   	pop    %ebp
c0029007:	c3                   	ret    
  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0029008:	83 ec 0c             	sub    $0xc,%esp
c002900b:	68 38 2b 03 c0       	push   $0xc0032b38
c0029010:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029015:	68 d0 07 03 c0       	push   $0xc00307d0
c002901a:	68 b5 01 00 00       	push   $0x1b5
c002901f:	68 c7 29 03 c0       	push   $0xc00329c7
c0029024:	e8 54 f6 ff ff       	call   c002867d <debug_panic>

c0029029 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c0029029:	55                   	push   %ebp
c002902a:	57                   	push   %edi
c002902b:	56                   	push   %esi
c002902c:	53                   	push   %ebx
c002902d:	83 ec 0c             	sub    $0xc,%esp
c0029030:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029034:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029038:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *e;

  ASSERT (list != NULL);
c002903c:	85 f6                	test   %esi,%esi
c002903e:	74 50                	je     c0029090 <list_insert_ordered+0x67>
  ASSERT (elem != NULL);
c0029040:	85 ff                	test   %edi,%edi
c0029042:	74 6d                	je     c00290b1 <list_insert_ordered+0x88>
  ASSERT (less != NULL);
c0029044:	85 ed                	test   %ebp,%ebp
c0029046:	0f 84 86 00 00 00    	je     c00290d2 <list_insert_ordered+0xa9>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002904c:	83 ec 0c             	sub    $0xc,%esp
c002904f:	56                   	push   %esi
c0029050:	e8 12 f7 ff ff       	call   c0028767 <list_begin>
c0029055:	83 c4 10             	add    $0x10,%esp
c0029058:	89 c3                	mov    %eax,%ebx
c002905a:	83 ec 0c             	sub    $0xc,%esp
c002905d:	56                   	push   %esi
c002905e:	e8 7c f7 ff ff       	call   c00287df <list_end>
c0029063:	83 c4 10             	add    $0x10,%esp
c0029066:	39 c3                	cmp    %eax,%ebx
c0029068:	0f 84 85 00 00 00    	je     c00290f3 <list_insert_ordered+0xca>
    if (less (elem, e, aux))
c002906e:	83 ec 04             	sub    $0x4,%esp
c0029071:	ff 74 24 30          	pushl  0x30(%esp)
c0029075:	53                   	push   %ebx
c0029076:	57                   	push   %edi
c0029077:	ff d5                	call   *%ebp
c0029079:	83 c4 10             	add    $0x10,%esp
c002907c:	84 c0                	test   %al,%al
c002907e:	75 73                	jne    c00290f3 <list_insert_ordered+0xca>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029080:	83 ec 0c             	sub    $0xc,%esp
c0029083:	53                   	push   %ebx
c0029084:	e8 0e f7 ff ff       	call   c0028797 <list_next>
c0029089:	83 c4 10             	add    $0x10,%esp
c002908c:	89 c3                	mov    %eax,%ebx
c002908e:	eb ca                	jmp    c002905a <list_insert_ordered+0x31>
  ASSERT (list != NULL);
c0029090:	83 ec 0c             	sub    $0xc,%esp
c0029093:	68 ba 29 03 c0       	push   $0xc00329ba
c0029098:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002909d:	68 9c 07 03 c0       	push   $0xc003079c
c00290a2:	68 c1 01 00 00       	push   $0x1c1
c00290a7:	68 c7 29 03 c0       	push   $0xc00329c7
c00290ac:	e8 cc f5 ff ff       	call   c002867d <debug_panic>
  ASSERT (elem != NULL);
c00290b1:	83 ec 0c             	sub    $0xc,%esp
c00290b4:	68 fd 29 03 c0       	push   $0xc00329fd
c00290b9:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00290be:	68 9c 07 03 c0       	push   $0xc003079c
c00290c3:	68 c2 01 00 00       	push   $0x1c2
c00290c8:	68 c7 29 03 c0       	push   $0xc00329c7
c00290cd:	e8 ab f5 ff ff       	call   c002867d <debug_panic>
  ASSERT (less != NULL);
c00290d2:	83 ec 0c             	sub    $0xc,%esp
c00290d5:	68 e9 29 03 c0       	push   $0xc00329e9
c00290da:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00290df:	68 9c 07 03 c0       	push   $0xc003079c
c00290e4:	68 c3 01 00 00       	push   $0x1c3
c00290e9:	68 c7 29 03 c0       	push   $0xc00329c7
c00290ee:	e8 8a f5 ff ff       	call   c002867d <debug_panic>
      break;
  return list_insert (e, elem);
c00290f3:	83 ec 08             	sub    $0x8,%esp
c00290f6:	57                   	push   %edi
c00290f7:	53                   	push   %ebx
c00290f8:	e8 fd f8 ff ff       	call   c00289fa <list_insert>
}
c00290fd:	83 c4 1c             	add    $0x1c,%esp
c0029100:	5b                   	pop    %ebx
c0029101:	5e                   	pop    %esi
c0029102:	5f                   	pop    %edi
c0029103:	5d                   	pop    %ebp
c0029104:	c3                   	ret    

c0029105 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c0029105:	55                   	push   %ebp
c0029106:	57                   	push   %edi
c0029107:	56                   	push   %esi
c0029108:	53                   	push   %ebx
c0029109:	83 ec 0c             	sub    $0xc,%esp
c002910c:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0029110:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c0029114:	85 ff                	test   %edi,%edi
c0029116:	74 1c                	je     c0029134 <list_unique+0x2f>
  ASSERT (less != NULL);
c0029118:	85 ed                	test   %ebp,%ebp
c002911a:	74 39                	je     c0029155 <list_unique+0x50>
  if (list_empty (list))
c002911c:	83 ec 0c             	sub    $0xc,%esp
c002911f:	57                   	push   %edi
c0029120:	e8 f3 fa ff ff       	call   c0028c18 <list_empty>
c0029125:	83 c4 10             	add    $0x10,%esp
c0029128:	84 c0                	test   %al,%al
c002912a:	74 4a                	je     c0029176 <list_unique+0x71>
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c002912c:	83 c4 0c             	add    $0xc,%esp
c002912f:	5b                   	pop    %ebx
c0029130:	5e                   	pop    %esi
c0029131:	5f                   	pop    %edi
c0029132:	5d                   	pop    %ebp
c0029133:	c3                   	ret    
  ASSERT (list != NULL);
c0029134:	83 ec 0c             	sub    $0xc,%esp
c0029137:	68 ba 29 03 c0       	push   $0xc00329ba
c002913c:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029141:	68 90 07 03 c0       	push   $0xc0030790
c0029146:	68 d5 01 00 00       	push   $0x1d5
c002914b:	68 c7 29 03 c0       	push   $0xc00329c7
c0029150:	e8 28 f5 ff ff       	call   c002867d <debug_panic>
  ASSERT (less != NULL);
c0029155:	83 ec 0c             	sub    $0xc,%esp
c0029158:	68 e9 29 03 c0       	push   $0xc00329e9
c002915d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029162:	68 90 07 03 c0       	push   $0xc0030790
c0029167:	68 d6 01 00 00       	push   $0x1d6
c002916c:	68 c7 29 03 c0       	push   $0xc00329c7
c0029171:	e8 07 f5 ff ff       	call   c002867d <debug_panic>
  elem = list_begin (list);
c0029176:	83 ec 0c             	sub    $0xc,%esp
c0029179:	57                   	push   %edi
c002917a:	e8 e8 f5 ff ff       	call   c0028767 <list_begin>
c002917f:	83 c4 10             	add    $0x10,%esp
c0029182:	89 c6                	mov    %eax,%esi
  while ((next = list_next (elem)) != list_end (list))
c0029184:	eb 04                	jmp    c002918a <list_unique+0x85>
c0029186:	89 f3                	mov    %esi,%ebx
c0029188:	89 de                	mov    %ebx,%esi
c002918a:	83 ec 0c             	sub    $0xc,%esp
c002918d:	56                   	push   %esi
c002918e:	e8 04 f6 ff ff       	call   c0028797 <list_next>
c0029193:	89 c3                	mov    %eax,%ebx
c0029195:	89 3c 24             	mov    %edi,(%esp)
c0029198:	e8 42 f6 ff ff       	call   c00287df <list_end>
c002919d:	83 c4 10             	add    $0x10,%esp
c00291a0:	39 c3                	cmp    %eax,%ebx
c00291a2:	74 88                	je     c002912c <list_unique+0x27>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c00291a4:	83 ec 04             	sub    $0x4,%esp
c00291a7:	ff 74 24 30          	pushl  0x30(%esp)
c00291ab:	53                   	push   %ebx
c00291ac:	56                   	push   %esi
c00291ad:	ff d5                	call   *%ebp
c00291af:	83 c4 10             	add    $0x10,%esp
c00291b2:	84 c0                	test   %al,%al
c00291b4:	75 d2                	jne    c0029188 <list_unique+0x83>
c00291b6:	83 ec 04             	sub    $0x4,%esp
c00291b9:	ff 74 24 30          	pushl  0x30(%esp)
c00291bd:	56                   	push   %esi
c00291be:	53                   	push   %ebx
c00291bf:	ff d5                	call   *%ebp
c00291c1:	83 c4 10             	add    $0x10,%esp
c00291c4:	84 c0                	test   %al,%al
c00291c6:	75 c0                	jne    c0029188 <list_unique+0x83>
        list_remove (next);
c00291c8:	83 ec 0c             	sub    $0xc,%esp
c00291cb:	53                   	push   %ebx
c00291cc:	e8 bc f9 ff ff       	call   c0028b8d <list_remove>
        if (duplicates != NULL)
c00291d1:	83 c4 10             	add    $0x10,%esp
c00291d4:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c00291d9:	74 ab                	je     c0029186 <list_unique+0x81>
          list_push_back (duplicates, next);
c00291db:	83 ec 08             	sub    $0x8,%esp
c00291de:	53                   	push   %ebx
c00291df:	ff 74 24 30          	pushl  0x30(%esp)
c00291e3:	e8 88 f9 ff ff       	call   c0028b70 <list_push_back>
c00291e8:	83 c4 10             	add    $0x10,%esp
c00291eb:	89 f3                	mov    %esi,%ebx
c00291ed:	eb 99                	jmp    c0029188 <list_unique+0x83>

c00291ef <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c00291ef:	55                   	push   %ebp
c00291f0:	57                   	push   %edi
c00291f1:	56                   	push   %esi
c00291f2:	53                   	push   %ebx
c00291f3:	83 ec 18             	sub    $0x18,%esp
c00291f6:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c00291fa:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *max = list_begin (list);
c00291fe:	57                   	push   %edi
c00291ff:	e8 63 f5 ff ff       	call   c0028767 <list_begin>
c0029204:	89 c6                	mov    %eax,%esi
  if (max != list_end (list)) 
c0029206:	89 3c 24             	mov    %edi,(%esp)
c0029209:	e8 d1 f5 ff ff       	call   c00287df <list_end>
c002920e:	83 c4 10             	add    $0x10,%esp
c0029211:	39 c6                	cmp    %eax,%esi
c0029213:	74 43                	je     c0029258 <list_max+0x69>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c0029215:	83 ec 0c             	sub    $0xc,%esp
c0029218:	56                   	push   %esi
c0029219:	e8 79 f5 ff ff       	call   c0028797 <list_next>
c002921e:	83 c4 10             	add    $0x10,%esp
c0029221:	89 c3                	mov    %eax,%ebx
c0029223:	eb 0e                	jmp    c0029233 <list_max+0x44>
c0029225:	83 ec 0c             	sub    $0xc,%esp
c0029228:	53                   	push   %ebx
c0029229:	e8 69 f5 ff ff       	call   c0028797 <list_next>
c002922e:	83 c4 10             	add    $0x10,%esp
c0029231:	89 c3                	mov    %eax,%ebx
c0029233:	83 ec 0c             	sub    $0xc,%esp
c0029236:	57                   	push   %edi
c0029237:	e8 a3 f5 ff ff       	call   c00287df <list_end>
c002923c:	83 c4 10             	add    $0x10,%esp
c002923f:	39 c3                	cmp    %eax,%ebx
c0029241:	74 17                	je     c002925a <list_max+0x6b>
        if (less (max, e, aux))
c0029243:	83 ec 04             	sub    $0x4,%esp
c0029246:	55                   	push   %ebp
c0029247:	53                   	push   %ebx
c0029248:	56                   	push   %esi
c0029249:	ff 54 24 34          	call   *0x34(%esp)
c002924d:	83 c4 10             	add    $0x10,%esp
c0029250:	84 c0                	test   %al,%al
c0029252:	74 d1                	je     c0029225 <list_max+0x36>
          max = e; 
c0029254:	89 de                	mov    %ebx,%esi
c0029256:	eb cd                	jmp    c0029225 <list_max+0x36>
  struct list_elem *max = list_begin (list);
c0029258:	89 c6                	mov    %eax,%esi
    }
  return max;
}
c002925a:	89 f0                	mov    %esi,%eax
c002925c:	83 c4 0c             	add    $0xc,%esp
c002925f:	5b                   	pop    %ebx
c0029260:	5e                   	pop    %esi
c0029261:	5f                   	pop    %edi
c0029262:	5d                   	pop    %ebp
c0029263:	c3                   	ret    

c0029264 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c0029264:	55                   	push   %ebp
c0029265:	57                   	push   %edi
c0029266:	56                   	push   %esi
c0029267:	53                   	push   %ebx
c0029268:	83 ec 18             	sub    $0x18,%esp
c002926b:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002926f:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *min = list_begin (list);
c0029273:	57                   	push   %edi
c0029274:	e8 ee f4 ff ff       	call   c0028767 <list_begin>
c0029279:	89 c6                	mov    %eax,%esi
  if (min != list_end (list)) 
c002927b:	89 3c 24             	mov    %edi,(%esp)
c002927e:	e8 5c f5 ff ff       	call   c00287df <list_end>
c0029283:	83 c4 10             	add    $0x10,%esp
c0029286:	39 c6                	cmp    %eax,%esi
c0029288:	74 43                	je     c00292cd <list_min+0x69>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002928a:	83 ec 0c             	sub    $0xc,%esp
c002928d:	56                   	push   %esi
c002928e:	e8 04 f5 ff ff       	call   c0028797 <list_next>
c0029293:	83 c4 10             	add    $0x10,%esp
c0029296:	89 c3                	mov    %eax,%ebx
c0029298:	eb 0e                	jmp    c00292a8 <list_min+0x44>
c002929a:	83 ec 0c             	sub    $0xc,%esp
c002929d:	53                   	push   %ebx
c002929e:	e8 f4 f4 ff ff       	call   c0028797 <list_next>
c00292a3:	83 c4 10             	add    $0x10,%esp
c00292a6:	89 c3                	mov    %eax,%ebx
c00292a8:	83 ec 0c             	sub    $0xc,%esp
c00292ab:	57                   	push   %edi
c00292ac:	e8 2e f5 ff ff       	call   c00287df <list_end>
c00292b1:	83 c4 10             	add    $0x10,%esp
c00292b4:	39 c3                	cmp    %eax,%ebx
c00292b6:	74 17                	je     c00292cf <list_min+0x6b>
        if (less (e, min, aux))
c00292b8:	83 ec 04             	sub    $0x4,%esp
c00292bb:	55                   	push   %ebp
c00292bc:	56                   	push   %esi
c00292bd:	53                   	push   %ebx
c00292be:	ff 54 24 34          	call   *0x34(%esp)
c00292c2:	83 c4 10             	add    $0x10,%esp
c00292c5:	84 c0                	test   %al,%al
c00292c7:	74 d1                	je     c002929a <list_min+0x36>
          min = e; 
c00292c9:	89 de                	mov    %ebx,%esi
c00292cb:	eb cd                	jmp    c002929a <list_min+0x36>
  struct list_elem *min = list_begin (list);
c00292cd:	89 c6                	mov    %eax,%esi
    }
  return min;
}
c00292cf:	89 f0                	mov    %esi,%eax
c00292d1:	83 c4 0c             	add    $0xc,%esp
c00292d4:	5b                   	pop    %ebx
c00292d5:	5e                   	pop    %esi
c00292d6:	5f                   	pop    %edi
c00292d7:	5d                   	pop    %ebp
c00292d8:	c3                   	ret    

c00292d9 <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c00292d9:	8b 44 24 04          	mov    0x4(%esp),%eax
c00292dd:	83 c0 1f             	add    $0x1f,%eax
c00292e0:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c00292e3:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c00292ea:	c3                   	ret    

c00292eb <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c00292eb:	53                   	push   %ebx
c00292ec:	83 ec 08             	sub    $0x8,%esp
c00292ef:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (b != NULL) 
c00292f3:	85 db                	test   %ebx,%ebx
c00292f5:	74 16                	je     c002930d <bitmap_destroy+0x22>
    {
      free (b->bits);
c00292f7:	83 ec 0c             	sub    $0xc,%esp
c00292fa:	ff 73 04             	pushl  0x4(%ebx)
c00292fd:	e8 c5 a8 ff ff       	call   c0023bc7 <free>
      free (b);
c0029302:	89 1c 24             	mov    %ebx,(%esp)
c0029305:	e8 bd a8 ff ff       	call   c0023bc7 <free>
c002930a:	83 c4 10             	add    $0x10,%esp
    }
}
c002930d:	83 c4 08             	add    $0x8,%esp
c0029310:	5b                   	pop    %ebx
c0029311:	c3                   	ret    

c0029312 <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c0029312:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029316:	8b 00                	mov    (%eax),%eax
}
c0029318:	c3                   	ret    

c0029319 <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c0029319:	53                   	push   %ebx
c002931a:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002931e:	89 cb                	mov    %ecx,%ebx
c0029320:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029323:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029327:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002932a:	b8 01 00 00 00       	mov    $0x1,%eax
c002932f:	d3 e0                	shl    %cl,%eax
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029331:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c0029334:	5b                   	pop    %ebx
c0029335:	c3                   	ret    

c0029336 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c0029336:	53                   	push   %ebx
c0029337:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002933b:	89 cb                	mov    %ecx,%ebx
c002933d:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0029340:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029344:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029347:	b8 01 00 00 00       	mov    $0x1,%eax
c002934c:	d3 e0                	shl    %cl,%eax
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002934e:	f7 d0                	not    %eax
c0029350:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c0029353:	5b                   	pop    %ebx
c0029354:	c3                   	ret    

c0029355 <bitmap_set>:
{
c0029355:	83 ec 0c             	sub    $0xc,%esp
c0029358:	8b 44 24 10          	mov    0x10(%esp),%eax
c002935c:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029360:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c0029364:	85 c0                	test   %eax,%eax
c0029366:	74 19                	je     c0029381 <bitmap_set+0x2c>
  ASSERT (idx < b->bit_cnt);
c0029368:	39 10                	cmp    %edx,(%eax)
c002936a:	76 36                	jbe    c00293a2 <bitmap_set+0x4d>
  if (value)
c002936c:	84 c9                	test   %cl,%cl
c002936e:	75 53                	jne    c00293c3 <bitmap_set+0x6e>
    bitmap_reset (b, idx);
c0029370:	83 ec 08             	sub    $0x8,%esp
c0029373:	52                   	push   %edx
c0029374:	50                   	push   %eax
c0029375:	e8 bc ff ff ff       	call   c0029336 <bitmap_reset>
c002937a:	83 c4 10             	add    $0x10,%esp
}
c002937d:	83 c4 0c             	add    $0xc,%esp
c0029380:	c3                   	ret    
  ASSERT (b != NULL);
c0029381:	83 ec 0c             	sub    $0xc,%esp
c0029384:	68 df 29 03 c0       	push   $0xc00329df
c0029389:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002938e:	68 e0 08 03 c0       	push   $0xc00308e0
c0029393:	68 93 00 00 00       	push   $0x93
c0029398:	68 72 2b 03 c0       	push   $0xc0032b72
c002939d:	e8 db f2 ff ff       	call   c002867d <debug_panic>
  ASSERT (idx < b->bit_cnt);
c00293a2:	83 ec 0c             	sub    $0xc,%esp
c00293a5:	68 8c 2b 03 c0       	push   $0xc0032b8c
c00293aa:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00293af:	68 e0 08 03 c0       	push   $0xc00308e0
c00293b4:	68 94 00 00 00       	push   $0x94
c00293b9:	68 72 2b 03 c0       	push   $0xc0032b72
c00293be:	e8 ba f2 ff ff       	call   c002867d <debug_panic>
    bitmap_mark (b, idx);
c00293c3:	83 ec 08             	sub    $0x8,%esp
c00293c6:	52                   	push   %edx
c00293c7:	50                   	push   %eax
c00293c8:	e8 4c ff ff ff       	call   c0029319 <bitmap_mark>
c00293cd:	83 c4 10             	add    $0x10,%esp
c00293d0:	eb ab                	jmp    c002937d <bitmap_set+0x28>

c00293d2 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c00293d2:	53                   	push   %ebx
c00293d3:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c00293d7:	89 cb                	mov    %ecx,%ebx
c00293d9:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c00293dc:	8b 44 24 08          	mov    0x8(%esp),%eax
c00293e0:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c00293e3:	b8 01 00 00 00       	mov    $0x1,%eax
c00293e8:	d3 e0                	shl    %cl,%eax
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c00293ea:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c00293ed:	5b                   	pop    %ebx
c00293ee:	c3                   	ret    

c00293ef <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c00293ef:	53                   	push   %ebx
c00293f0:	83 ec 08             	sub    $0x8,%esp
c00293f3:	8b 44 24 10          	mov    0x10(%esp),%eax
c00293f7:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c00293fb:	85 c0                	test   %eax,%eax
c00293fd:	74 1e                	je     c002941d <bitmap_test+0x2e>
  ASSERT (idx < b->bit_cnt);
c00293ff:	39 08                	cmp    %ecx,(%eax)
c0029401:	76 3b                	jbe    c002943e <bitmap_test+0x4f>
  return bit_idx / ELEM_BITS;
c0029403:	89 cb                	mov    %ecx,%ebx
c0029405:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c0029408:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002940b:	b8 01 00 00 00       	mov    $0x1,%eax
c0029410:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c0029412:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c0029415:	0f 95 c0             	setne  %al
}
c0029418:	83 c4 08             	add    $0x8,%esp
c002941b:	5b                   	pop    %ebx
c002941c:	c3                   	ret    
  ASSERT (b != NULL);
c002941d:	83 ec 0c             	sub    $0xc,%esp
c0029420:	68 df 29 03 c0       	push   $0xc00329df
c0029425:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002942a:	68 d4 08 03 c0       	push   $0xc00308d4
c002942f:	68 c8 00 00 00       	push   $0xc8
c0029434:	68 72 2b 03 c0       	push   $0xc0032b72
c0029439:	e8 3f f2 ff ff       	call   c002867d <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002943e:	83 ec 0c             	sub    $0xc,%esp
c0029441:	68 8c 2b 03 c0       	push   $0xc0032b8c
c0029446:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002944b:	68 d4 08 03 c0       	push   $0xc00308d4
c0029450:	68 c9 00 00 00       	push   $0xc9
c0029455:	68 72 2b 03 c0       	push   $0xc0032b72
c002945a:	e8 1e f2 ff ff       	call   c002867d <debug_panic>

c002945f <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002945f:	55                   	push   %ebp
c0029460:	57                   	push   %edi
c0029461:	56                   	push   %esi
c0029462:	53                   	push   %ebx
c0029463:	83 ec 0c             	sub    $0xc,%esp
c0029466:	8b 74 24 20          	mov    0x20(%esp),%esi
c002946a:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c002946e:	8b 54 24 28          	mov    0x28(%esp),%edx
c0029472:	8a 44 24 2c          	mov    0x2c(%esp),%al
  size_t i;
  
  ASSERT (b != NULL);
c0029476:	85 f6                	test   %esi,%esi
c0029478:	74 2f                	je     c00294a9 <bitmap_set_multiple+0x4a>
  ASSERT (start <= b->bit_cnt);
c002947a:	8b 0e                	mov    (%esi),%ecx
c002947c:	39 d9                	cmp    %ebx,%ecx
c002947e:	72 4a                	jb     c00294ca <bitmap_set_multiple+0x6b>
  ASSERT (start + cnt <= b->bit_cnt);
c0029480:	8d 2c 13             	lea    (%ebx,%edx,1),%ebp
c0029483:	39 e9                	cmp    %ebp,%ecx
c0029485:	72 64                	jb     c00294eb <bitmap_set_multiple+0x8c>

  for (i = 0; i < cnt; i++)
c0029487:	85 d2                	test   %edx,%edx
c0029489:	74 16                	je     c00294a1 <bitmap_set_multiple+0x42>
    bitmap_set (b, start + i, value);
c002948b:	0f b6 f8             	movzbl %al,%edi
c002948e:	83 ec 04             	sub    $0x4,%esp
c0029491:	57                   	push   %edi
c0029492:	53                   	push   %ebx
c0029493:	56                   	push   %esi
c0029494:	e8 bc fe ff ff       	call   c0029355 <bitmap_set>
c0029499:	43                   	inc    %ebx
  for (i = 0; i < cnt; i++)
c002949a:	83 c4 10             	add    $0x10,%esp
c002949d:	39 dd                	cmp    %ebx,%ebp
c002949f:	75 ed                	jne    c002948e <bitmap_set_multiple+0x2f>
}
c00294a1:	83 c4 0c             	add    $0xc,%esp
c00294a4:	5b                   	pop    %ebx
c00294a5:	5e                   	pop    %esi
c00294a6:	5f                   	pop    %edi
c00294a7:	5d                   	pop    %ebp
c00294a8:	c3                   	ret    
  ASSERT (b != NULL);
c00294a9:	83 ec 0c             	sub    $0xc,%esp
c00294ac:	68 df 29 03 c0       	push   $0xc00329df
c00294b1:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00294b6:	68 b0 08 03 c0       	push   $0xc00308b0
c00294bb:	68 de 00 00 00       	push   $0xde
c00294c0:	68 72 2b 03 c0       	push   $0xc0032b72
c00294c5:	e8 b3 f1 ff ff       	call   c002867d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c00294ca:	83 ec 0c             	sub    $0xc,%esp
c00294cd:	68 9d 2b 03 c0       	push   $0xc0032b9d
c00294d2:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00294d7:	68 b0 08 03 c0       	push   $0xc00308b0
c00294dc:	68 df 00 00 00       	push   $0xdf
c00294e1:	68 72 2b 03 c0       	push   $0xc0032b72
c00294e6:	e8 92 f1 ff ff       	call   c002867d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c00294eb:	83 ec 0c             	sub    $0xc,%esp
c00294ee:	68 b1 2b 03 c0       	push   $0xc0032bb1
c00294f3:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00294f8:	68 b0 08 03 c0       	push   $0xc00308b0
c00294fd:	68 e0 00 00 00       	push   $0xe0
c0029502:	68 72 2b 03 c0       	push   $0xc0032b72
c0029507:	e8 71 f1 ff ff       	call   c002867d <debug_panic>

c002950c <bitmap_set_all>:
{
c002950c:	83 ec 0c             	sub    $0xc,%esp
c002950f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029513:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c0029517:	85 c0                	test   %eax,%eax
c0029519:	74 12                	je     c002952d <bitmap_set_all+0x21>
  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002951b:	0f b6 d2             	movzbl %dl,%edx
c002951e:	52                   	push   %edx
c002951f:	ff 30                	pushl  (%eax)
c0029521:	6a 00                	push   $0x0
c0029523:	50                   	push   %eax
c0029524:	e8 36 ff ff ff       	call   c002945f <bitmap_set_multiple>
}
c0029529:	83 c4 1c             	add    $0x1c,%esp
c002952c:	c3                   	ret    
  ASSERT (b != NULL);
c002952d:	83 ec 0c             	sub    $0xc,%esp
c0029530:	68 df 29 03 c0       	push   $0xc00329df
c0029535:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002953a:	68 c4 08 03 c0       	push   $0xc00308c4
c002953f:	68 d3 00 00 00       	push   $0xd3
c0029544:	68 72 2b 03 c0       	push   $0xc0032b72
c0029549:	e8 2f f1 ff ff       	call   c002867d <debug_panic>

c002954e <bitmap_create>:
{
c002954e:	56                   	push   %esi
c002954f:	53                   	push   %ebx
c0029550:	83 ec 10             	sub    $0x10,%esp
c0029553:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct bitmap *b = malloc (sizeof *b);
c0029557:	6a 08                	push   $0x8
c0029559:	e8 c6 a4 ff ff       	call   c0023a24 <malloc>
c002955e:	89 c3                	mov    %eax,%ebx
  if (b != NULL)
c0029560:	83 c4 10             	add    $0x10,%esp
c0029563:	85 c0                	test   %eax,%eax
c0029565:	74 2c                	je     c0029593 <bitmap_create+0x45>
      b->bit_cnt = bit_cnt;
c0029567:	89 30                	mov    %esi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c0029569:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002956c:	8d 46 1f             	lea    0x1f(%esi),%eax
c002956f:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c0029572:	c1 e0 02             	shl    $0x2,%eax
      b->bits = malloc (byte_cnt (bit_cnt));
c0029575:	50                   	push   %eax
c0029576:	e8 a9 a4 ff ff       	call   c0023a24 <malloc>
c002957b:	89 43 04             	mov    %eax,0x4(%ebx)
      if (b->bits != NULL || bit_cnt == 0)
c002957e:	83 c4 10             	add    $0x10,%esp
c0029581:	85 c0                	test   %eax,%eax
c0029583:	74 16                	je     c002959b <bitmap_create+0x4d>
          bitmap_set_all (b, false);
c0029585:	83 ec 08             	sub    $0x8,%esp
c0029588:	6a 00                	push   $0x0
c002958a:	53                   	push   %ebx
c002958b:	e8 7c ff ff ff       	call   c002950c <bitmap_set_all>
          return b;
c0029590:	83 c4 10             	add    $0x10,%esp
}
c0029593:	89 d8                	mov    %ebx,%eax
c0029595:	83 c4 04             	add    $0x4,%esp
c0029598:	5b                   	pop    %ebx
c0029599:	5e                   	pop    %esi
c002959a:	c3                   	ret    
      if (b->bits != NULL || bit_cnt == 0)
c002959b:	85 f6                	test   %esi,%esi
c002959d:	74 e6                	je     c0029585 <bitmap_create+0x37>
      free (b);
c002959f:	83 ec 0c             	sub    $0xc,%esp
c00295a2:	53                   	push   %ebx
c00295a3:	e8 1f a6 ff ff       	call   c0023bc7 <free>
c00295a8:	83 c4 10             	add    $0x10,%esp
  return NULL;
c00295ab:	bb 00 00 00 00       	mov    $0x0,%ebx
c00295b0:	eb e1                	jmp    c0029593 <bitmap_create+0x45>

c00295b2 <bitmap_create_in_buf>:
{
c00295b2:	56                   	push   %esi
c00295b3:	53                   	push   %ebx
c00295b4:	83 ec 04             	sub    $0x4,%esp
c00295b7:	8b 74 24 10          	mov    0x10(%esp),%esi
c00295bb:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c00295bf:	56                   	push   %esi
c00295c0:	e8 14 fd ff ff       	call   c00292d9 <bitmap_buf_size>
c00295c5:	83 c4 04             	add    $0x4,%esp
c00295c8:	3b 44 24 18          	cmp    0x18(%esp),%eax
c00295cc:	77 1b                	ja     c00295e9 <bitmap_create_in_buf+0x37>
  b->bit_cnt = bit_cnt;
c00295ce:	89 33                	mov    %esi,(%ebx)
  b->bits = (elem_type *) (b + 1);
c00295d0:	8d 43 08             	lea    0x8(%ebx),%eax
c00295d3:	89 43 04             	mov    %eax,0x4(%ebx)
  bitmap_set_all (b, false);
c00295d6:	83 ec 08             	sub    $0x8,%esp
c00295d9:	6a 00                	push   $0x0
c00295db:	53                   	push   %ebx
c00295dc:	e8 2b ff ff ff       	call   c002950c <bitmap_set_all>
}
c00295e1:	89 d8                	mov    %ebx,%eax
c00295e3:	83 c4 14             	add    $0x14,%esp
c00295e6:	5b                   	pop    %ebx
c00295e7:	5e                   	pop    %esi
c00295e8:	c3                   	ret    
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c00295e9:	83 ec 0c             	sub    $0xc,%esp
c00295ec:	68 cc 2b 03 c0       	push   $0xc0032bcc
c00295f1:	68 b3 0c 03 c0       	push   $0xc0030cb3
c00295f6:	68 ec 08 03 c0       	push   $0xc00308ec
c00295fb:	6a 68                	push   $0x68
c00295fd:	68 72 2b 03 c0       	push   $0xc0032b72
c0029602:	e8 76 f0 ff ff       	call   c002867d <debug_panic>

c0029607 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0029607:	55                   	push   %ebp
c0029608:	57                   	push   %edi
c0029609:	56                   	push   %esi
c002960a:	53                   	push   %ebx
c002960b:	83 ec 1c             	sub    $0x1c,%esp
c002960e:	8b 7c 24 30          	mov    0x30(%esp),%edi
c0029612:	8b 74 24 34          	mov    0x34(%esp),%esi
c0029616:	8b 44 24 38          	mov    0x38(%esp),%eax
c002961a:	8a 5c 24 3c          	mov    0x3c(%esp),%bl
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002961e:	85 ff                	test   %edi,%edi
c0029620:	74 29                	je     c002964b <bitmap_count+0x44>
  ASSERT (start <= b->bit_cnt);
c0029622:	8b 17                	mov    (%edi),%edx
c0029624:	39 f2                	cmp    %esi,%edx
c0029626:	72 44                	jb     c002966c <bitmap_count+0x65>
  ASSERT (start + cnt <= b->bit_cnt);
c0029628:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002962b:	39 ea                	cmp    %ebp,%edx
c002962d:	72 5e                	jb     c002968d <bitmap_count+0x86>

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
c002962f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0029636:	00 
c0029637:	85 c0                	test   %eax,%eax
c0029639:	75 78                	jne    c00296b3 <bitmap_count+0xac>
c002963b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (bitmap_test (b, start + i) == value)
      value_cnt++;
  return value_cnt;
}
c002963f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029643:	83 c4 1c             	add    $0x1c,%esp
c0029646:	5b                   	pop    %ebx
c0029647:	5e                   	pop    %esi
c0029648:	5f                   	pop    %edi
c0029649:	5d                   	pop    %ebp
c002964a:	c3                   	ret    
  ASSERT (b != NULL);
c002964b:	83 ec 0c             	sub    $0xc,%esp
c002964e:	68 df 29 03 c0       	push   $0xc00329df
c0029653:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029658:	68 a0 08 03 c0       	push   $0xc00308a0
c002965d:	68 ed 00 00 00       	push   $0xed
c0029662:	68 72 2b 03 c0       	push   $0xc0032b72
c0029667:	e8 11 f0 ff ff       	call   c002867d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002966c:	83 ec 0c             	sub    $0xc,%esp
c002966f:	68 9d 2b 03 c0       	push   $0xc0032b9d
c0029674:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029679:	68 a0 08 03 c0       	push   $0xc00308a0
c002967e:	68 ee 00 00 00       	push   $0xee
c0029683:	68 72 2b 03 c0       	push   $0xc0032b72
c0029688:	e8 f0 ef ff ff       	call   c002867d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002968d:	83 ec 0c             	sub    $0xc,%esp
c0029690:	68 b1 2b 03 c0       	push   $0xc0032bb1
c0029695:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002969a:	68 a0 08 03 c0       	push   $0xc00308a0
c002969f:	68 ef 00 00 00       	push   $0xef
c00296a4:	68 72 2b 03 c0       	push   $0xc0032b72
c00296a9:	e8 cf ef ff ff       	call   c002867d <debug_panic>
c00296ae:	46                   	inc    %esi
  for (i = 0; i < cnt; i++)
c00296af:	39 f5                	cmp    %esi,%ebp
c00296b1:	74 8c                	je     c002963f <bitmap_count+0x38>
    if (bitmap_test (b, start + i) == value)
c00296b3:	83 ec 08             	sub    $0x8,%esp
c00296b6:	56                   	push   %esi
c00296b7:	57                   	push   %edi
c00296b8:	e8 32 fd ff ff       	call   c00293ef <bitmap_test>
c00296bd:	83 c4 10             	add    $0x10,%esp
c00296c0:	38 d8                	cmp    %bl,%al
c00296c2:	75 ea                	jne    c00296ae <bitmap_count+0xa7>
      value_cnt++;
c00296c4:	ff 44 24 0c          	incl   0xc(%esp)
c00296c8:	eb e4                	jmp    c00296ae <bitmap_count+0xa7>

c00296ca <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c00296ca:	55                   	push   %ebp
c00296cb:	57                   	push   %edi
c00296cc:	56                   	push   %esi
c00296cd:	53                   	push   %ebx
c00296ce:	83 ec 0c             	sub    $0xc,%esp
c00296d1:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00296d5:	8b 74 24 24          	mov    0x24(%esp),%esi
c00296d9:	8b 44 24 28          	mov    0x28(%esp),%eax
c00296dd:	8a 5c 24 2c          	mov    0x2c(%esp),%bl
  size_t i;
  
  ASSERT (b != NULL);
c00296e1:	85 ff                	test   %edi,%edi
c00296e3:	74 2b                	je     c0029710 <bitmap_contains+0x46>
  ASSERT (start <= b->bit_cnt);
c00296e5:	8b 17                	mov    (%edi),%edx
c00296e7:	39 f2                	cmp    %esi,%edx
c00296e9:	72 46                	jb     c0029731 <bitmap_contains+0x67>
  ASSERT (start + cnt <= b->bit_cnt);
c00296eb:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c00296ee:	39 ea                	cmp    %ebp,%edx
c00296f0:	72 60                	jb     c0029752 <bitmap_contains+0x88>

  for (i = 0; i < cnt; i++)
c00296f2:	85 c0                	test   %eax,%eax
c00296f4:	74 7f                	je     c0029775 <bitmap_contains+0xab>
    if (bitmap_test (b, start + i) == value)
c00296f6:	83 ec 08             	sub    $0x8,%esp
c00296f9:	56                   	push   %esi
c00296fa:	57                   	push   %edi
c00296fb:	e8 ef fc ff ff       	call   c00293ef <bitmap_test>
c0029700:	83 c4 10             	add    $0x10,%esp
c0029703:	38 d8                	cmp    %bl,%al
c0029705:	74 6c                	je     c0029773 <bitmap_contains+0xa9>
c0029707:	46                   	inc    %esi
  for (i = 0; i < cnt; i++)
c0029708:	39 f5                	cmp    %esi,%ebp
c002970a:	75 ea                	jne    c00296f6 <bitmap_contains+0x2c>
      return true;
  return false;
c002970c:	b0 00                	mov    $0x0,%al
c002970e:	eb 65                	jmp    c0029775 <bitmap_contains+0xab>
  ASSERT (b != NULL);
c0029710:	83 ec 0c             	sub    $0xc,%esp
c0029713:	68 df 29 03 c0       	push   $0xc00329df
c0029718:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002971d:	68 90 08 03 c0       	push   $0xc0030890
c0029722:	68 ff 00 00 00       	push   $0xff
c0029727:	68 72 2b 03 c0       	push   $0xc0032b72
c002972c:	e8 4c ef ff ff       	call   c002867d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0029731:	83 ec 0c             	sub    $0xc,%esp
c0029734:	68 9d 2b 03 c0       	push   $0xc0032b9d
c0029739:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002973e:	68 90 08 03 c0       	push   $0xc0030890
c0029743:	68 00 01 00 00       	push   $0x100
c0029748:	68 72 2b 03 c0       	push   $0xc0032b72
c002974d:	e8 2b ef ff ff       	call   c002867d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c0029752:	83 ec 0c             	sub    $0xc,%esp
c0029755:	68 b1 2b 03 c0       	push   $0xc0032bb1
c002975a:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002975f:	68 90 08 03 c0       	push   $0xc0030890
c0029764:	68 01 01 00 00       	push   $0x101
c0029769:	68 72 2b 03 c0       	push   $0xc0032b72
c002976e:	e8 0a ef ff ff       	call   c002867d <debug_panic>
      return true;
c0029773:	b0 01                	mov    $0x1,%al
}
c0029775:	83 c4 0c             	add    $0xc,%esp
c0029778:	5b                   	pop    %ebx
c0029779:	5e                   	pop    %esi
c002977a:	5f                   	pop    %edi
c002977b:	5d                   	pop    %ebp
c002977c:	c3                   	ret    

c002977d <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002977d:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c0029780:	6a 01                	push   $0x1
c0029782:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029786:	ff 74 24 1c          	pushl  0x1c(%esp)
c002978a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002978e:	e8 37 ff ff ff       	call   c00296ca <bitmap_contains>
}
c0029793:	83 c4 1c             	add    $0x1c,%esp
c0029796:	c3                   	ret    

c0029797 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c0029797:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c002979a:	6a 01                	push   $0x1
c002979c:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297a0:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297a4:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297a8:	e8 1d ff ff ff       	call   c00296ca <bitmap_contains>
c00297ad:	83 f0 01             	xor    $0x1,%eax
}
c00297b0:	83 c4 1c             	add    $0x1c,%esp
c00297b3:	c3                   	ret    

c00297b4 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c00297b4:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c00297b7:	6a 00                	push   $0x0
c00297b9:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297bd:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297c1:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297c5:	e8 00 ff ff ff       	call   c00296ca <bitmap_contains>
c00297ca:	83 f0 01             	xor    $0x1,%eax
}
c00297cd:	83 c4 1c             	add    $0x1c,%esp
c00297d0:	c3                   	ret    

c00297d1 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c00297d1:	55                   	push   %ebp
c00297d2:	57                   	push   %edi
c00297d3:	56                   	push   %esi
c00297d4:	53                   	push   %ebx
c00297d5:	83 ec 1c             	sub    $0x1c,%esp
c00297d8:	8b 74 24 30          	mov    0x30(%esp),%esi
c00297dc:	8b 5c 24 34          	mov    0x34(%esp),%ebx
c00297e0:	8b 7c 24 38          	mov    0x38(%esp),%edi
c00297e4:	8a 54 24 3c          	mov    0x3c(%esp),%dl
  ASSERT (b != NULL);
c00297e8:	85 f6                	test   %esi,%esi
c00297ea:	74 17                	je     c0029803 <bitmap_scan+0x32>
  ASSERT (start <= b->bit_cnt);
c00297ec:	8b 06                	mov    (%esi),%eax
c00297ee:	39 d8                	cmp    %ebx,%eax
c00297f0:	72 32                	jb     c0029824 <bitmap_scan+0x53>

  if (cnt <= b->bit_cnt) 
c00297f2:	39 f8                	cmp    %edi,%eax
c00297f4:	73 4f                	jae    c0029845 <bitmap_scan+0x74>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c00297f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c00297fb:	83 c4 1c             	add    $0x1c,%esp
c00297fe:	5b                   	pop    %ebx
c00297ff:	5e                   	pop    %esi
c0029800:	5f                   	pop    %edi
c0029801:	5d                   	pop    %ebp
c0029802:	c3                   	ret    
  ASSERT (b != NULL);
c0029803:	83 ec 0c             	sub    $0xc,%esp
c0029806:	68 df 29 03 c0       	push   $0xc00329df
c002980b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029810:	68 84 08 03 c0       	push   $0xc0030884
c0029815:	68 2a 01 00 00       	push   $0x12a
c002981a:	68 72 2b 03 c0       	push   $0xc0032b72
c002981f:	e8 59 ee ff ff       	call   c002867d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0029824:	83 ec 0c             	sub    $0xc,%esp
c0029827:	68 9d 2b 03 c0       	push   $0xc0032b9d
c002982c:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029831:	68 84 08 03 c0       	push   $0xc0030884
c0029836:	68 2b 01 00 00       	push   $0x12b
c002983b:	68 72 2b 03 c0       	push   $0xc0032b72
c0029840:	e8 38 ee ff ff       	call   c002867d <debug_panic>
      size_t last = b->bit_cnt - cnt;
c0029845:	29 f8                	sub    %edi,%eax
c0029847:	89 44 24 0c          	mov    %eax,0xc(%esp)
      for (i = start; i <= last; i++)
c002984b:	39 c3                	cmp    %eax,%ebx
c002984d:	77 24                	ja     c0029873 <bitmap_scan+0xa2>
        if (!bitmap_contains (b, i, cnt, !value))
c002984f:	83 f2 01             	xor    $0x1,%edx
c0029852:	0f b6 ea             	movzbl %dl,%ebp
c0029855:	55                   	push   %ebp
c0029856:	57                   	push   %edi
c0029857:	53                   	push   %ebx
c0029858:	56                   	push   %esi
c0029859:	e8 6c fe ff ff       	call   c00296ca <bitmap_contains>
c002985e:	83 c4 10             	add    $0x10,%esp
c0029861:	84 c0                	test   %al,%al
c0029863:	74 15                	je     c002987a <bitmap_scan+0xa9>
      for (i = start; i <= last; i++)
c0029865:	43                   	inc    %ebx
c0029866:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c002986a:	73 e9                	jae    c0029855 <bitmap_scan+0x84>
  return BITMAP_ERROR;
c002986c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0029871:	eb 88                	jmp    c00297fb <bitmap_scan+0x2a>
c0029873:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0029878:	eb 81                	jmp    c00297fb <bitmap_scan+0x2a>
c002987a:	89 d8                	mov    %ebx,%eax
c002987c:	e9 7a ff ff ff       	jmp    c00297fb <bitmap_scan+0x2a>

c0029881 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c0029881:	55                   	push   %ebp
c0029882:	57                   	push   %edi
c0029883:	56                   	push   %esi
c0029884:	53                   	push   %ebx
c0029885:	83 ec 0c             	sub    $0xc,%esp
c0029888:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002988c:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c0029890:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c0029894:	0f b6 c3             	movzbl %bl,%eax
c0029897:	50                   	push   %eax
c0029898:	55                   	push   %ebp
c0029899:	ff 74 24 2c          	pushl  0x2c(%esp)
c002989d:	57                   	push   %edi
c002989e:	e8 2e ff ff ff       	call   c00297d1 <bitmap_scan>
c00298a3:	83 c4 10             	add    $0x10,%esp
c00298a6:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c00298a8:	83 f8 ff             	cmp    $0xffffffff,%eax
c00298ab:	74 12                	je     c00298bf <bitmap_scan_and_flip+0x3e>
    bitmap_set_multiple (b, idx, cnt, !value);
c00298ad:	83 f3 01             	xor    $0x1,%ebx
c00298b0:	0f b6 db             	movzbl %bl,%ebx
c00298b3:	53                   	push   %ebx
c00298b4:	55                   	push   %ebp
c00298b5:	50                   	push   %eax
c00298b6:	57                   	push   %edi
c00298b7:	e8 a3 fb ff ff       	call   c002945f <bitmap_set_multiple>
c00298bc:	83 c4 10             	add    $0x10,%esp
  return idx;
}
c00298bf:	89 f0                	mov    %esi,%eax
c00298c1:	83 c4 0c             	add    $0xc,%esp
c00298c4:	5b                   	pop    %ebx
c00298c5:	5e                   	pop    %esi
c00298c6:	5f                   	pop    %edi
c00298c7:	5d                   	pop    %ebp
c00298c8:	c3                   	ret    

c00298c9 <bitmap_file_size>:
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c00298c9:	8b 44 24 04          	mov    0x4(%esp),%eax
c00298cd:	8b 00                	mov    (%eax),%eax
c00298cf:	83 c0 1f             	add    $0x1f,%eax
c00298d2:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c00298d5:	c1 e0 02             	shl    $0x2,%eax
/* Returns the number of bytes needed to store B in a file. */
size_t
bitmap_file_size (const struct bitmap *b) 
{
  return byte_cnt (b->bit_cnt);
}
c00298d8:	c3                   	ret    

c00298d9 <bitmap_read>:

/* Reads B from FILE.  Returns true if successful, false
   otherwise. */
bool
bitmap_read (struct bitmap *b, struct file *file) 
{
c00298d9:	56                   	push   %esi
c00298da:	53                   	push   %ebx
c00298db:	83 ec 04             	sub    $0x4,%esp
c00298de:	8b 74 24 10          	mov    0x10(%esp),%esi
  bool success = true;
  if (b->bit_cnt > 0) 
c00298e2:	8b 06                	mov    (%esi),%eax
c00298e4:	85 c0                	test   %eax,%eax
c00298e6:	75 08                	jne    c00298f0 <bitmap_read+0x17>
  bool success = true;
c00298e8:	b0 01                	mov    $0x1,%al
      off_t size = byte_cnt (b->bit_cnt);
      success = file_read_at (file, b->bits, size, 0) == size;
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
    }
  return success;
}
c00298ea:	83 c4 04             	add    $0x4,%esp
c00298ed:	5b                   	pop    %ebx
c00298ee:	5e                   	pop    %esi
c00298ef:	c3                   	ret    
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c00298f0:	83 c0 1f             	add    $0x1f,%eax
c00298f3:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c00298f6:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
      success = file_read_at (file, b->bits, size, 0) == size;
c00298fd:	6a 00                	push   $0x0
c00298ff:	53                   	push   %ebx
c0029900:	ff 76 04             	pushl  0x4(%esi)
c0029903:	ff 74 24 20          	pushl  0x20(%esp)
c0029907:	e8 ae 33 00 00       	call   c002ccba <file_read_at>
c002990c:	83 c4 10             	add    $0x10,%esp
c002990f:	39 c3                	cmp    %eax,%ebx
c0029911:	0f 94 c0             	sete   %al
  int last_bits = b->bit_cnt % ELEM_BITS;
c0029914:	8b 16                	mov    (%esi),%edx
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c0029916:	89 d1                	mov    %edx,%ecx
c0029918:	83 e1 1f             	and    $0x1f,%ecx
c002991b:	74 19                	je     c0029936 <bitmap_read+0x5d>
c002991d:	bb 01 00 00 00       	mov    $0x1,%ebx
c0029922:	d3 e3                	shl    %cl,%ebx
c0029924:	8d 4b ff             	lea    -0x1(%ebx),%ecx
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029927:	83 c2 1f             	add    $0x1f,%edx
c002992a:	c1 ea 05             	shr    $0x5,%edx
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
c002992d:	8b 5e 04             	mov    0x4(%esi),%ebx
c0029930:	21 4c 93 fc          	and    %ecx,-0x4(%ebx,%edx,4)
c0029934:	eb b4                	jmp    c00298ea <bitmap_read+0x11>
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c0029936:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002993b:	eb ea                	jmp    c0029927 <bitmap_read+0x4e>

c002993d <bitmap_write>:

/* Writes B to FILE.  Return true if successful, false
   otherwise. */
bool
bitmap_write (const struct bitmap *b, struct file *file)
{
c002993d:	53                   	push   %ebx
c002993e:	83 ec 08             	sub    $0x8,%esp
c0029941:	8b 44 24 10          	mov    0x10(%esp),%eax
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029945:	8b 10                	mov    (%eax),%edx
c0029947:	8d 5a 1f             	lea    0x1f(%edx),%ebx
c002994a:	c1 eb 05             	shr    $0x5,%ebx
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002994d:	c1 e3 02             	shl    $0x2,%ebx
  off_t size = byte_cnt (b->bit_cnt);
  return file_write_at (file, b->bits, size, 0) == size;
c0029950:	6a 00                	push   $0x0
c0029952:	53                   	push   %ebx
c0029953:	ff 70 04             	pushl  0x4(%eax)
c0029956:	ff 74 24 20          	pushl  0x20(%esp)
c002995a:	e8 9b 33 00 00       	call   c002ccfa <file_write_at>
c002995f:	39 c3                	cmp    %eax,%ebx
c0029961:	0f 94 c0             	sete   %al
}
c0029964:	83 c4 18             	add    $0x18,%esp
c0029967:	5b                   	pop    %ebx
c0029968:	c3                   	ret    

c0029969 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c0029969:	83 ec 0c             	sub    $0xc,%esp
c002996c:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c0029970:	6a 00                	push   $0x0
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029972:	8b 02                	mov    (%edx),%eax
c0029974:	83 c0 1f             	add    $0x1f,%eax
c0029977:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002997a:	c1 e0 02             	shl    $0x2,%eax
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002997d:	50                   	push   %eax
c002997e:	ff 72 04             	pushl  0x4(%edx)
c0029981:	6a 00                	push   $0x0
c0029983:	e8 f0 d9 ff ff       	call   c0027378 <hex_dump>
}
c0029988:	83 c4 1c             	add    $0x1c,%esp
c002998b:	c3                   	ret    

c002998c <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002998c:	53                   	push   %ebx
c002998d:	83 ec 10             	sub    $0x10,%esp
c0029990:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c0029992:	ff 70 14             	pushl  0x14(%eax)
c0029995:	52                   	push   %edx
c0029996:	ff 50 0c             	call   *0xc(%eax)
c0029999:	8b 4b 04             	mov    0x4(%ebx),%ecx
c002999c:	8d 51 ff             	lea    -0x1(%ecx),%edx
c002999f:	21 d0                	and    %edx,%eax
  return &h->buckets[bucket_idx];
c00299a1:	c1 e0 04             	shl    $0x4,%eax
c00299a4:	03 43 08             	add    0x8(%ebx),%eax
}
c00299a7:	83 c4 18             	add    $0x18,%esp
c00299aa:	5b                   	pop    %ebx
c00299ab:	c3                   	ret    

c00299ac <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c00299ac:	55                   	push   %ebp
c00299ad:	57                   	push   %edi
c00299ae:	56                   	push   %esi
c00299af:	53                   	push   %ebx
c00299b0:	83 ec 18             	sub    $0x18,%esp
c00299b3:	89 c6                	mov    %eax,%esi
c00299b5:	89 d5                	mov    %edx,%ebp
c00299b7:	89 cf                	mov    %ecx,%edi
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c00299b9:	52                   	push   %edx
c00299ba:	e8 a8 ed ff ff       	call   c0028767 <list_begin>
c00299bf:	89 c3                	mov    %eax,%ebx
c00299c1:	83 c4 10             	add    $0x10,%esp
c00299c4:	eb 0e                	jmp    c00299d4 <find_elem+0x28>
c00299c6:	83 ec 0c             	sub    $0xc,%esp
c00299c9:	53                   	push   %ebx
c00299ca:	e8 c8 ed ff ff       	call   c0028797 <list_next>
c00299cf:	89 c3                	mov    %eax,%ebx
c00299d1:	83 c4 10             	add    $0x10,%esp
c00299d4:	83 ec 0c             	sub    $0xc,%esp
c00299d7:	55                   	push   %ebp
c00299d8:	e8 02 ee ff ff       	call   c00287df <list_end>
c00299dd:	83 c4 10             	add    $0x10,%esp
c00299e0:	39 c3                	cmp    %eax,%ebx
c00299e2:	74 28                	je     c0029a0c <find_elem+0x60>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c00299e4:	83 ec 04             	sub    $0x4,%esp
c00299e7:	ff 76 14             	pushl  0x14(%esi)
c00299ea:	57                   	push   %edi
c00299eb:	53                   	push   %ebx
c00299ec:	ff 56 10             	call   *0x10(%esi)
c00299ef:	83 c4 10             	add    $0x10,%esp
c00299f2:	84 c0                	test   %al,%al
c00299f4:	75 d0                	jne    c00299c6 <find_elem+0x1a>
c00299f6:	83 ec 04             	sub    $0x4,%esp
c00299f9:	ff 76 14             	pushl  0x14(%esi)
c00299fc:	53                   	push   %ebx
c00299fd:	57                   	push   %edi
c00299fe:	ff 56 10             	call   *0x10(%esi)
c0029a01:	83 c4 10             	add    $0x10,%esp
c0029a04:	84 c0                	test   %al,%al
c0029a06:	75 be                	jne    c00299c6 <find_elem+0x1a>
c0029a08:	89 d8                	mov    %ebx,%eax
c0029a0a:	eb 05                	jmp    c0029a11 <find_elem+0x65>
        return hi; 
    }
  return NULL;
c0029a0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029a11:	83 c4 0c             	add    $0xc,%esp
c0029a14:	5b                   	pop    %ebx
c0029a15:	5e                   	pop    %esi
c0029a16:	5f                   	pop    %edi
c0029a17:	5d                   	pop    %ebp
c0029a18:	c3                   	ret    

c0029a19 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c0029a19:	55                   	push   %ebp
c0029a1a:	57                   	push   %edi
c0029a1b:	56                   	push   %esi
c0029a1c:	53                   	push   %ebx
c0029a1d:	83 ec 2c             	sub    $0x2c,%esp
c0029a20:	89 44 24 0c          	mov    %eax,0xc(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c0029a24:	85 c0                	test   %eax,%eax
c0029a26:	74 21                	je     c0029a49 <rehash+0x30>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c0029a28:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029a2c:	8b 48 04             	mov    0x4(%eax),%ecx
c0029a2f:	89 4c 24 18          	mov    %ecx,0x18(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c0029a33:	8b 00                	mov    (%eax),%eax
c0029a35:	89 44 24 10          	mov    %eax,0x10(%esp)
c0029a39:	89 c3                	mov    %eax,%ebx
c0029a3b:	d1 eb                	shr    %ebx
c0029a3d:	83 fb 04             	cmp    $0x4,%ebx
c0029a40:	73 2d                	jae    c0029a6f <rehash+0x56>
c0029a42:	bb 04 00 00 00       	mov    $0x4,%ebx
c0029a47:	eb 26                	jmp    c0029a6f <rehash+0x56>
  ASSERT (h != NULL);
c0029a49:	83 ec 0c             	sub    $0xc,%esp
c0029a4c:	68 f4 2b 03 c0       	push   $0xc0032bf4
c0029a51:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029a56:	68 40 09 03 c0       	push   $0xc0030940
c0029a5b:	68 66 01 00 00       	push   $0x166
c0029a60:	68 fe 2b 03 c0       	push   $0xc0032bfe
c0029a65:	e8 13 ec ff ff       	call   c002867d <debug_panic>
  return x & (x - 1);
c0029a6a:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0029a6d:	21 c3                	and    %eax,%ebx
  return x != 0 && turn_off_least_1bit (x) == 0;
c0029a6f:	85 db                	test   %ebx,%ebx
c0029a71:	74 f7                	je     c0029a6a <rehash+0x51>
  return x & (x - 1);
c0029a73:	8d 43 ff             	lea    -0x1(%ebx),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c0029a76:	21 d8                	and    %ebx,%eax
c0029a78:	75 f0                	jne    c0029a6a <rehash+0x51>
c0029a7a:	89 c6                	mov    %eax,%esi
c0029a7c:	89 44 24 10          	mov    %eax,0x10(%esp)
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c0029a80:	3b 5c 24 18          	cmp    0x18(%esp),%ebx
c0029a84:	0f 84 ce 00 00 00    	je     c0029b58 <rehash+0x13f>
  old_buckets = h->buckets;
c0029a8a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029a8e:	8b 40 08             	mov    0x8(%eax),%eax
c0029a91:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c0029a95:	83 ec 0c             	sub    $0xc,%esp
c0029a98:	89 d8                	mov    %ebx,%eax
c0029a9a:	c1 e0 04             	shl    $0x4,%eax
c0029a9d:	50                   	push   %eax
c0029a9e:	e8 81 9f ff ff       	call   c0023a24 <malloc>
c0029aa3:	89 c5                	mov    %eax,%ebp
  if (new_buckets == NULL) 
c0029aa5:	83 c4 10             	add    $0x10,%esp
c0029aa8:	85 c0                	test   %eax,%eax
c0029aaa:	0f 84 a8 00 00 00    	je     c0029b58 <rehash+0x13f>
c0029ab0:	89 c7                	mov    %eax,%edi
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c0029ab2:	83 ec 0c             	sub    $0xc,%esp
c0029ab5:	57                   	push   %edi
c0029ab6:	e8 69 ec ff ff       	call   c0028724 <list_init>
  for (i = 0; i < new_bucket_cnt; i++) 
c0029abb:	46                   	inc    %esi
c0029abc:	83 c7 10             	add    $0x10,%edi
c0029abf:	83 c4 10             	add    $0x10,%esp
c0029ac2:	39 f3                	cmp    %esi,%ebx
c0029ac4:	75 ec                	jne    c0029ab2 <rehash+0x99>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c0029ac6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029aca:	89 68 08             	mov    %ebp,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c0029acd:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c0029ad0:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0029ad5:	74 72                	je     c0029b49 <rehash+0x130>
c0029ad7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0029adb:	89 44 24 14          	mov    %eax,0x14(%esp)
c0029adf:	eb 52                	jmp    c0029b33 <rehash+0x11a>

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c0029ae1:	89 da                	mov    %ebx,%edx
c0029ae3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029ae7:	e8 a0 fe ff ff       	call   c002998c <find_bucket>
c0029aec:	89 c7                	mov    %eax,%edi
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c0029aee:	83 ec 0c             	sub    $0xc,%esp
c0029af1:	53                   	push   %ebx
c0029af2:	e8 a0 ec ff ff       	call   c0028797 <list_next>
c0029af7:	89 c6                	mov    %eax,%esi
          list_remove (elem);
c0029af9:	89 1c 24             	mov    %ebx,(%esp)
c0029afc:	e8 8c f0 ff ff       	call   c0028b8d <list_remove>
          list_push_front (new_bucket, elem);
c0029b01:	83 c4 08             	add    $0x8,%esp
c0029b04:	53                   	push   %ebx
c0029b05:	57                   	push   %edi
c0029b06:	e8 48 f0 ff ff       	call   c0028b53 <list_push_front>
           elem != list_end (old_bucket); elem = next) 
c0029b0b:	83 c4 10             	add    $0x10,%esp
c0029b0e:	89 f3                	mov    %esi,%ebx
c0029b10:	83 ec 0c             	sub    $0xc,%esp
c0029b13:	55                   	push   %ebp
c0029b14:	e8 c6 ec ff ff       	call   c00287df <list_end>
      for (elem = list_begin (old_bucket);
c0029b19:	83 c4 10             	add    $0x10,%esp
c0029b1c:	39 c3                	cmp    %eax,%ebx
c0029b1e:	75 c1                	jne    c0029ae1 <rehash+0xc8>
  for (i = 0; i < old_bucket_cnt; i++) 
c0029b20:	ff 44 24 10          	incl   0x10(%esp)
c0029b24:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029b28:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c0029b2d:	39 44 24 18          	cmp    %eax,0x18(%esp)
c0029b31:	74 16                	je     c0029b49 <rehash+0x130>
      old_bucket = &old_buckets[i];
c0029b33:	8b 44 24 14          	mov    0x14(%esp),%eax
c0029b37:	89 c5                	mov    %eax,%ebp
      for (elem = list_begin (old_bucket);
c0029b39:	83 ec 0c             	sub    $0xc,%esp
c0029b3c:	50                   	push   %eax
c0029b3d:	e8 25 ec ff ff       	call   c0028767 <list_begin>
c0029b42:	89 c3                	mov    %eax,%ebx
c0029b44:	83 c4 10             	add    $0x10,%esp
c0029b47:	eb c7                	jmp    c0029b10 <rehash+0xf7>
        }
    }

  free (old_buckets);
c0029b49:	83 ec 0c             	sub    $0xc,%esp
c0029b4c:	ff 74 24 28          	pushl  0x28(%esp)
c0029b50:	e8 72 a0 ff ff       	call   c0023bc7 <free>
c0029b55:	83 c4 10             	add    $0x10,%esp
}
c0029b58:	83 c4 2c             	add    $0x2c,%esp
c0029b5b:	5b                   	pop    %ebx
c0029b5c:	5e                   	pop    %esi
c0029b5d:	5f                   	pop    %edi
c0029b5e:	5d                   	pop    %ebp
c0029b5f:	c3                   	ret    

c0029b60 <hash_clear>:
{
c0029b60:	55                   	push   %ebp
c0029b61:	57                   	push   %edi
c0029b62:	56                   	push   %esi
c0029b63:	53                   	push   %ebx
c0029b64:	83 ec 0c             	sub    $0xc,%esp
c0029b67:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029b6b:	8b 7c 24 24          	mov    0x24(%esp),%edi
  for (i = 0; i < h->bucket_cnt; i++) 
c0029b6f:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029b73:	74 4c                	je     c0029bc1 <hash_clear+0x61>
c0029b75:	bd 00 00 00 00       	mov    $0x0,%ebp
c0029b7a:	eb 37                	jmp    c0029bb3 <hash_clear+0x53>
            struct list_elem *list_elem = list_pop_front (bucket);
c0029b7c:	83 ec 0c             	sub    $0xc,%esp
c0029b7f:	53                   	push   %ebx
c0029b80:	e8 f5 f0 ff ff       	call   c0028c7a <list_pop_front>
            destructor (hash_elem, h->aux);
c0029b85:	83 c4 08             	add    $0x8,%esp
c0029b88:	ff 76 14             	pushl  0x14(%esi)
c0029b8b:	50                   	push   %eax
c0029b8c:	ff d7                	call   *%edi
c0029b8e:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c0029b91:	83 ec 0c             	sub    $0xc,%esp
c0029b94:	53                   	push   %ebx
c0029b95:	e8 7e f0 ff ff       	call   c0028c18 <list_empty>
c0029b9a:	83 c4 10             	add    $0x10,%esp
c0029b9d:	84 c0                	test   %al,%al
c0029b9f:	74 db                	je     c0029b7c <hash_clear+0x1c>
      list_init (bucket); 
c0029ba1:	83 ec 0c             	sub    $0xc,%esp
c0029ba4:	53                   	push   %ebx
c0029ba5:	e8 7a eb ff ff       	call   c0028724 <list_init>
  for (i = 0; i < h->bucket_cnt; i++) 
c0029baa:	45                   	inc    %ebp
c0029bab:	83 c4 10             	add    $0x10,%esp
c0029bae:	39 6e 04             	cmp    %ebp,0x4(%esi)
c0029bb1:	76 0e                	jbe    c0029bc1 <hash_clear+0x61>
      struct list *bucket = &h->buckets[i];
c0029bb3:	89 eb                	mov    %ebp,%ebx
c0029bb5:	c1 e3 04             	shl    $0x4,%ebx
c0029bb8:	03 5e 08             	add    0x8(%esi),%ebx
      if (destructor != NULL) 
c0029bbb:	85 ff                	test   %edi,%edi
c0029bbd:	75 d2                	jne    c0029b91 <hash_clear+0x31>
c0029bbf:	eb e0                	jmp    c0029ba1 <hash_clear+0x41>
  h->elem_cnt = 0;
c0029bc1:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
c0029bc7:	83 c4 0c             	add    $0xc,%esp
c0029bca:	5b                   	pop    %ebx
c0029bcb:	5e                   	pop    %esi
c0029bcc:	5f                   	pop    %edi
c0029bcd:	5d                   	pop    %ebp
c0029bce:	c3                   	ret    

c0029bcf <hash_init>:
{
c0029bcf:	53                   	push   %ebx
c0029bd0:	83 ec 14             	sub    $0x14,%esp
c0029bd3:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  h->elem_cnt = 0;
c0029bd7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  h->bucket_cnt = 4;
c0029bdd:	c7 43 04 04 00 00 00 	movl   $0x4,0x4(%ebx)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c0029be4:	6a 40                	push   $0x40
c0029be6:	e8 39 9e ff ff       	call   c0023a24 <malloc>
c0029beb:	89 43 08             	mov    %eax,0x8(%ebx)
  h->hash = hash;
c0029bee:	8b 54 24 24          	mov    0x24(%esp),%edx
c0029bf2:	89 53 0c             	mov    %edx,0xc(%ebx)
  h->less = less;
c0029bf5:	8b 54 24 28          	mov    0x28(%esp),%edx
c0029bf9:	89 53 10             	mov    %edx,0x10(%ebx)
  h->aux = aux;
c0029bfc:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0029c00:	89 53 14             	mov    %edx,0x14(%ebx)
  if (h->buckets != NULL) 
c0029c03:	83 c4 10             	add    $0x10,%esp
c0029c06:	85 c0                	test   %eax,%eax
c0029c08:	74 15                	je     c0029c1f <hash_init+0x50>
      hash_clear (h, NULL);
c0029c0a:	83 ec 08             	sub    $0x8,%esp
c0029c0d:	6a 00                	push   $0x0
c0029c0f:	53                   	push   %ebx
c0029c10:	e8 4b ff ff ff       	call   c0029b60 <hash_clear>
      return true;
c0029c15:	83 c4 10             	add    $0x10,%esp
c0029c18:	b0 01                	mov    $0x1,%al
}
c0029c1a:	83 c4 08             	add    $0x8,%esp
c0029c1d:	5b                   	pop    %ebx
c0029c1e:	c3                   	ret    
    return false;
c0029c1f:	b0 00                	mov    $0x0,%al
c0029c21:	eb f7                	jmp    c0029c1a <hash_init+0x4b>

c0029c23 <hash_destroy>:
{
c0029c23:	53                   	push   %ebx
c0029c24:	83 ec 08             	sub    $0x8,%esp
c0029c27:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0029c2b:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c0029c2f:	85 c0                	test   %eax,%eax
c0029c31:	74 0d                	je     c0029c40 <hash_destroy+0x1d>
    hash_clear (h, destructor);
c0029c33:	83 ec 08             	sub    $0x8,%esp
c0029c36:	50                   	push   %eax
c0029c37:	53                   	push   %ebx
c0029c38:	e8 23 ff ff ff       	call   c0029b60 <hash_clear>
c0029c3d:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c0029c40:	83 ec 0c             	sub    $0xc,%esp
c0029c43:	ff 73 08             	pushl  0x8(%ebx)
c0029c46:	e8 7c 9f ff ff       	call   c0023bc7 <free>
}
c0029c4b:	83 c4 18             	add    $0x18,%esp
c0029c4e:	5b                   	pop    %ebx
c0029c4f:	c3                   	ret    

c0029c50 <hash_insert>:
{
c0029c50:	55                   	push   %ebp
c0029c51:	57                   	push   %edi
c0029c52:	56                   	push   %esi
c0029c53:	53                   	push   %ebx
c0029c54:	83 ec 0c             	sub    $0xc,%esp
c0029c57:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0029c5b:	8b 74 24 24          	mov    0x24(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c0029c5f:	89 f2                	mov    %esi,%edx
c0029c61:	89 d8                	mov    %ebx,%eax
c0029c63:	e8 24 fd ff ff       	call   c002998c <find_bucket>
c0029c68:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c0029c6a:	89 f1                	mov    %esi,%ecx
c0029c6c:	89 c2                	mov    %eax,%edx
c0029c6e:	89 d8                	mov    %ebx,%eax
c0029c70:	e8 37 fd ff ff       	call   c00299ac <find_elem>
c0029c75:	89 c7                	mov    %eax,%edi
  if (old == NULL) 
c0029c77:	85 c0                	test   %eax,%eax
c0029c79:	74 11                	je     c0029c8c <hash_insert+0x3c>
  rehash (h);
c0029c7b:	89 d8                	mov    %ebx,%eax
c0029c7d:	e8 97 fd ff ff       	call   c0029a19 <rehash>
}
c0029c82:	89 f8                	mov    %edi,%eax
c0029c84:	83 c4 0c             	add    $0xc,%esp
c0029c87:	5b                   	pop    %ebx
c0029c88:	5e                   	pop    %esi
c0029c89:	5f                   	pop    %edi
c0029c8a:	5d                   	pop    %ebp
c0029c8b:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c0029c8c:	ff 03                	incl   (%ebx)
  list_push_front (bucket, &e->list_elem);
c0029c8e:	83 ec 08             	sub    $0x8,%esp
c0029c91:	56                   	push   %esi
c0029c92:	55                   	push   %ebp
c0029c93:	e8 bb ee ff ff       	call   c0028b53 <list_push_front>
c0029c98:	83 c4 10             	add    $0x10,%esp
c0029c9b:	eb de                	jmp    c0029c7b <hash_insert+0x2b>

c0029c9d <hash_replace>:
{
c0029c9d:	55                   	push   %ebp
c0029c9e:	57                   	push   %edi
c0029c9f:	56                   	push   %esi
c0029ca0:	53                   	push   %ebx
c0029ca1:	83 ec 0c             	sub    $0xc,%esp
c0029ca4:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0029ca8:	8b 74 24 24          	mov    0x24(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c0029cac:	89 f2                	mov    %esi,%edx
c0029cae:	89 d8                	mov    %ebx,%eax
c0029cb0:	e8 d7 fc ff ff       	call   c002998c <find_bucket>
c0029cb5:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c0029cb7:	89 f1                	mov    %esi,%ecx
c0029cb9:	89 c2                	mov    %eax,%edx
c0029cbb:	89 d8                	mov    %ebx,%eax
c0029cbd:	e8 ea fc ff ff       	call   c00299ac <find_elem>
c0029cc2:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c0029cc4:	85 c0                	test   %eax,%eax
c0029cc6:	74 0e                	je     c0029cd6 <hash_replace+0x39>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c0029cc8:	ff 0b                	decl   (%ebx)
  list_remove (&e->list_elem);
c0029cca:	83 ec 0c             	sub    $0xc,%esp
c0029ccd:	50                   	push   %eax
c0029cce:	e8 ba ee ff ff       	call   c0028b8d <list_remove>
c0029cd3:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c0029cd6:	ff 03                	incl   (%ebx)
  list_push_front (bucket, &e->list_elem);
c0029cd8:	83 ec 08             	sub    $0x8,%esp
c0029cdb:	56                   	push   %esi
c0029cdc:	55                   	push   %ebp
c0029cdd:	e8 71 ee ff ff       	call   c0028b53 <list_push_front>
  rehash (h);
c0029ce2:	89 d8                	mov    %ebx,%eax
c0029ce4:	e8 30 fd ff ff       	call   c0029a19 <rehash>
}
c0029ce9:	89 f8                	mov    %edi,%eax
c0029ceb:	83 c4 1c             	add    $0x1c,%esp
c0029cee:	5b                   	pop    %ebx
c0029cef:	5e                   	pop    %esi
c0029cf0:	5f                   	pop    %edi
c0029cf1:	5d                   	pop    %ebp
c0029cf2:	c3                   	ret    

c0029cf3 <hash_find>:
{
c0029cf3:	83 ec 0c             	sub    $0xc,%esp
  return find_elem (h, find_bucket (h, e), e);
c0029cf6:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029cfa:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029cfe:	e8 89 fc ff ff       	call   c002998c <find_bucket>
c0029d03:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0029d07:	89 c2                	mov    %eax,%edx
c0029d09:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029d0d:	e8 9a fc ff ff       	call   c00299ac <find_elem>
}
c0029d12:	83 c4 0c             	add    $0xc,%esp
c0029d15:	c3                   	ret    

c0029d16 <hash_delete>:
{
c0029d16:	56                   	push   %esi
c0029d17:	53                   	push   %ebx
c0029d18:	83 ec 04             	sub    $0x4,%esp
c0029d1b:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0029d1f:	8b 74 24 14          	mov    0x14(%esp),%esi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c0029d23:	89 f2                	mov    %esi,%edx
c0029d25:	89 d8                	mov    %ebx,%eax
c0029d27:	e8 60 fc ff ff       	call   c002998c <find_bucket>
c0029d2c:	89 f1                	mov    %esi,%ecx
c0029d2e:	89 c2                	mov    %eax,%edx
c0029d30:	89 d8                	mov    %ebx,%eax
c0029d32:	e8 75 fc ff ff       	call   c00299ac <find_elem>
c0029d37:	89 c6                	mov    %eax,%esi
  if (found != NULL) 
c0029d39:	85 c0                	test   %eax,%eax
c0029d3b:	74 15                	je     c0029d52 <hash_delete+0x3c>
  h->elem_cnt--;
c0029d3d:	ff 0b                	decl   (%ebx)
  list_remove (&e->list_elem);
c0029d3f:	83 ec 0c             	sub    $0xc,%esp
c0029d42:	50                   	push   %eax
c0029d43:	e8 45 ee ff ff       	call   c0028b8d <list_remove>
      rehash (h); 
c0029d48:	89 d8                	mov    %ebx,%eax
c0029d4a:	e8 ca fc ff ff       	call   c0029a19 <rehash>
c0029d4f:	83 c4 10             	add    $0x10,%esp
}
c0029d52:	89 f0                	mov    %esi,%eax
c0029d54:	83 c4 04             	add    $0x4,%esp
c0029d57:	5b                   	pop    %ebx
c0029d58:	5e                   	pop    %esi
c0029d59:	c3                   	ret    

c0029d5a <hash_apply>:
{
c0029d5a:	55                   	push   %ebp
c0029d5b:	57                   	push   %edi
c0029d5c:	56                   	push   %esi
c0029d5d:	53                   	push   %ebx
c0029d5e:	83 ec 1c             	sub    $0x1c,%esp
c0029d61:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (action != NULL);
c0029d65:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c0029d6a:	74 16                	je     c0029d82 <hash_apply+0x28>
  for (i = 0; i < h->bucket_cnt; i++) 
c0029d6c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0029d73:	00 
c0029d74:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c0029d78:	75 61                	jne    c0029ddb <hash_apply+0x81>
}
c0029d7a:	83 c4 1c             	add    $0x1c,%esp
c0029d7d:	5b                   	pop    %ebx
c0029d7e:	5e                   	pop    %esi
c0029d7f:	5f                   	pop    %edi
c0029d80:	5d                   	pop    %ebp
c0029d81:	c3                   	ret    
  ASSERT (action != NULL);
c0029d82:	83 ec 0c             	sub    $0xc,%esp
c0029d85:	68 16 2c 03 c0       	push   $0xc0032c16
c0029d8a:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029d8f:	68 34 09 03 c0       	push   $0xc0030934
c0029d94:	68 a7 00 00 00       	push   $0xa7
c0029d99:	68 fe 2b 03 c0       	push   $0xc0032bfe
c0029d9e:	e8 da e8 ff ff       	call   c002867d <debug_panic>
          next = list_next (elem);
c0029da3:	83 ec 0c             	sub    $0xc,%esp
c0029da6:	53                   	push   %ebx
c0029da7:	e8 eb e9 ff ff       	call   c0028797 <list_next>
c0029dac:	89 c6                	mov    %eax,%esi
          action (list_elem_to_hash_elem (elem), h->aux);
c0029dae:	83 c4 08             	add    $0x8,%esp
c0029db1:	ff 75 14             	pushl  0x14(%ebp)
c0029db4:	53                   	push   %ebx
c0029db5:	ff 54 24 44          	call   *0x44(%esp)
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c0029db9:	83 c4 10             	add    $0x10,%esp
c0029dbc:	89 f3                	mov    %esi,%ebx
c0029dbe:	83 ec 0c             	sub    $0xc,%esp
c0029dc1:	57                   	push   %edi
c0029dc2:	e8 18 ea ff ff       	call   c00287df <list_end>
c0029dc7:	83 c4 10             	add    $0x10,%esp
c0029dca:	39 c3                	cmp    %eax,%ebx
c0029dcc:	75 d5                	jne    c0029da3 <hash_apply+0x49>
  for (i = 0; i < h->bucket_cnt; i++) 
c0029dce:	ff 44 24 0c          	incl   0xc(%esp)
c0029dd2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029dd6:	39 45 04             	cmp    %eax,0x4(%ebp)
c0029dd9:	76 9f                	jbe    c0029d7a <hash_apply+0x20>
      struct list *bucket = &h->buckets[i];
c0029ddb:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0029ddf:	c1 e7 04             	shl    $0x4,%edi
c0029de2:	03 7d 08             	add    0x8(%ebp),%edi
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c0029de5:	83 ec 0c             	sub    $0xc,%esp
c0029de8:	57                   	push   %edi
c0029de9:	e8 79 e9 ff ff       	call   c0028767 <list_begin>
c0029dee:	89 c3                	mov    %eax,%ebx
c0029df0:	83 c4 10             	add    $0x10,%esp
c0029df3:	eb c9                	jmp    c0029dbe <hash_apply+0x64>

c0029df5 <hash_first>:
{
c0029df5:	53                   	push   %ebx
c0029df6:	83 ec 08             	sub    $0x8,%esp
c0029df9:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0029dfd:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c0029e01:	85 db                	test   %ebx,%ebx
c0029e03:	74 1d                	je     c0029e22 <hash_first+0x2d>
  ASSERT (h != NULL);
c0029e05:	85 c0                	test   %eax,%eax
c0029e07:	74 3a                	je     c0029e43 <hash_first+0x4e>
  i->hash = h;
c0029e09:	89 03                	mov    %eax,(%ebx)
  i->bucket = i->hash->buckets;
c0029e0b:	8b 40 08             	mov    0x8(%eax),%eax
c0029e0e:	89 43 04             	mov    %eax,0x4(%ebx)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c0029e11:	83 ec 0c             	sub    $0xc,%esp
c0029e14:	50                   	push   %eax
c0029e15:	e8 7d eb ff ff       	call   c0028997 <list_head>
c0029e1a:	89 43 08             	mov    %eax,0x8(%ebx)
}
c0029e1d:	83 c4 18             	add    $0x18,%esp
c0029e20:	5b                   	pop    %ebx
c0029e21:	c3                   	ret    
  ASSERT (i != NULL);
c0029e22:	83 ec 0c             	sub    $0xc,%esp
c0029e25:	68 25 2c 03 c0       	push   $0xc0032c25
c0029e2a:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029e2f:	68 28 09 03 c0       	push   $0xc0030928
c0029e34:	68 ca 00 00 00       	push   $0xca
c0029e39:	68 fe 2b 03 c0       	push   $0xc0032bfe
c0029e3e:	e8 3a e8 ff ff       	call   c002867d <debug_panic>
  ASSERT (h != NULL);
c0029e43:	83 ec 0c             	sub    $0xc,%esp
c0029e46:	68 f4 2b 03 c0       	push   $0xc0032bf4
c0029e4b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029e50:	68 28 09 03 c0       	push   $0xc0030928
c0029e55:	68 cb 00 00 00       	push   $0xcb
c0029e5a:	68 fe 2b 03 c0       	push   $0xc0032bfe
c0029e5f:	e8 19 e8 ff ff       	call   c002867d <debug_panic>

c0029e64 <hash_next>:
{
c0029e64:	56                   	push   %esi
c0029e65:	53                   	push   %ebx
c0029e66:	83 ec 04             	sub    $0x4,%esp
c0029e69:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (i != NULL);
c0029e6d:	85 db                	test   %ebx,%ebx
c0029e6f:	74 4f                	je     c0029ec0 <hash_next+0x5c>
  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c0029e71:	83 ec 0c             	sub    $0xc,%esp
c0029e74:	ff 73 08             	pushl  0x8(%ebx)
c0029e77:	e8 1b e9 ff ff       	call   c0028797 <list_next>
c0029e7c:	89 43 08             	mov    %eax,0x8(%ebx)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c0029e7f:	83 c4 10             	add    $0x10,%esp
c0029e82:	8b 73 08             	mov    0x8(%ebx),%esi
c0029e85:	83 ec 0c             	sub    $0xc,%esp
c0029e88:	ff 73 04             	pushl  0x4(%ebx)
c0029e8b:	e8 4f e9 ff ff       	call   c00287df <list_end>
c0029e90:	83 c4 10             	add    $0x10,%esp
c0029e93:	39 c6                	cmp    %eax,%esi
c0029e95:	75 51                	jne    c0029ee8 <hash_next+0x84>
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c0029e97:	8b 43 04             	mov    0x4(%ebx),%eax
c0029e9a:	8d 50 10             	lea    0x10(%eax),%edx
c0029e9d:	89 53 04             	mov    %edx,0x4(%ebx)
c0029ea0:	8b 0b                	mov    (%ebx),%ecx
c0029ea2:	8b 41 04             	mov    0x4(%ecx),%eax
c0029ea5:	c1 e0 04             	shl    $0x4,%eax
c0029ea8:	03 41 08             	add    0x8(%ecx),%eax
c0029eab:	39 c2                	cmp    %eax,%edx
c0029ead:	73 32                	jae    c0029ee1 <hash_next+0x7d>
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c0029eaf:	83 ec 0c             	sub    $0xc,%esp
c0029eb2:	52                   	push   %edx
c0029eb3:	e8 af e8 ff ff       	call   c0028767 <list_begin>
c0029eb8:	89 43 08             	mov    %eax,0x8(%ebx)
c0029ebb:	83 c4 10             	add    $0x10,%esp
c0029ebe:	eb c2                	jmp    c0029e82 <hash_next+0x1e>
  ASSERT (i != NULL);
c0029ec0:	83 ec 0c             	sub    $0xc,%esp
c0029ec3:	68 25 2c 03 c0       	push   $0xc0032c25
c0029ec8:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029ecd:	68 1c 09 03 c0       	push   $0xc003091c
c0029ed2:	68 dd 00 00 00       	push   $0xdd
c0029ed7:	68 fe 2b 03 c0       	push   $0xc0032bfe
c0029edc:	e8 9c e7 ff ff       	call   c002867d <debug_panic>
          i->elem = NULL;
c0029ee1:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  return i->elem;
c0029ee8:	8b 43 08             	mov    0x8(%ebx),%eax
}
c0029eeb:	83 c4 04             	add    $0x4,%esp
c0029eee:	5b                   	pop    %ebx
c0029eef:	5e                   	pop    %esi
c0029ef0:	c3                   	ret    

c0029ef1 <hash_cur>:
  return i->elem;
c0029ef1:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029ef5:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029ef8:	c3                   	ret    

c0029ef9 <hash_size>:
  return h->elem_cnt;
c0029ef9:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029efd:	8b 00                	mov    (%eax),%eax
}
c0029eff:	c3                   	ret    

c0029f00 <hash_empty>:
  return h->elem_cnt == 0;
c0029f00:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029f04:	83 38 00             	cmpl   $0x0,(%eax)
c0029f07:	0f 94 c0             	sete   %al
}
c0029f0a:	c3                   	ret    

c0029f0b <hash_bytes>:
{
c0029f0b:	53                   	push   %ebx
c0029f0c:	83 ec 08             	sub    $0x8,%esp
c0029f0f:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0029f13:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  ASSERT (buf != NULL);
c0029f17:	85 c9                	test   %ecx,%ecx
c0029f19:	74 35                	je     c0029f50 <hash_bytes+0x45>
  while (size-- > 0)
c0029f1b:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
c0029f20:	85 db                	test   %ebx,%ebx
c0029f22:	74 27                	je     c0029f4b <hash_bytes+0x40>
c0029f24:	01 cb                	add    %ecx,%ebx
c0029f26:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c0029f2b:	89 c2                	mov    %eax,%edx
c0029f2d:	c1 e2 10             	shl    $0x10,%edx
c0029f30:	01 c2                	add    %eax,%edx
c0029f32:	01 d2                	add    %edx,%edx
c0029f34:	01 c2                	add    %eax,%edx
c0029f36:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029f39:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029f3c:	01 d2                	add    %edx,%edx
c0029f3e:	01 d0                	add    %edx,%eax
c0029f40:	41                   	inc    %ecx
c0029f41:	0f b6 51 ff          	movzbl -0x1(%ecx),%edx
c0029f45:	31 d0                	xor    %edx,%eax
  while (size-- > 0)
c0029f47:	39 d9                	cmp    %ebx,%ecx
c0029f49:	75 e0                	jne    c0029f2b <hash_bytes+0x20>
} 
c0029f4b:	83 c4 08             	add    $0x8,%esp
c0029f4e:	5b                   	pop    %ebx
c0029f4f:	c3                   	ret    
  ASSERT (buf != NULL);
c0029f50:	83 ec 0c             	sub    $0xc,%esp
c0029f53:	68 2f 2c 03 c0       	push   $0xc0032c2f
c0029f58:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029f5d:	68 10 09 03 c0       	push   $0xc0030910
c0029f62:	68 10 01 00 00       	push   $0x110
c0029f67:	68 fe 2b 03 c0       	push   $0xc0032bfe
c0029f6c:	e8 0c e7 ff ff       	call   c002867d <debug_panic>

c0029f71 <hash_string>:
{
c0029f71:	53                   	push   %ebx
c0029f72:	83 ec 08             	sub    $0x8,%esp
c0029f75:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (s != NULL);
c0029f79:	85 db                	test   %ebx,%ebx
c0029f7b:	74 36                	je     c0029fb3 <hash_string+0x42>
  while (*s != '\0')
c0029f7d:	8a 0b                	mov    (%ebx),%cl
c0029f7f:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
c0029f84:	84 c9                	test   %cl,%cl
c0029f86:	74 26                	je     c0029fae <hash_string+0x3d>
c0029f88:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
    hash = (hash * FNV_32_PRIME) ^ *s++;
c0029f8d:	89 c2                	mov    %eax,%edx
c0029f8f:	c1 e2 10             	shl    $0x10,%edx
c0029f92:	01 c2                	add    %eax,%edx
c0029f94:	01 d2                	add    %edx,%edx
c0029f96:	01 c2                	add    %eax,%edx
c0029f98:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029f9b:	8d 14 d0             	lea    (%eax,%edx,8),%edx
c0029f9e:	01 d2                	add    %edx,%edx
c0029fa0:	01 d0                	add    %edx,%eax
c0029fa2:	43                   	inc    %ebx
c0029fa3:	0f b6 c9             	movzbl %cl,%ecx
c0029fa6:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c0029fa8:	8a 0b                	mov    (%ebx),%cl
c0029faa:	84 c9                	test   %cl,%cl
c0029fac:	75 df                	jne    c0029f8d <hash_string+0x1c>
}
c0029fae:	83 c4 08             	add    $0x8,%esp
c0029fb1:	5b                   	pop    %ebx
c0029fb2:	c3                   	ret    
  ASSERT (s != NULL);
c0029fb3:	83 ec 0c             	sub    $0xc,%esp
c0029fb6:	68 bb 27 03 c0       	push   $0xc00327bb
c0029fbb:	68 b3 0c 03 c0       	push   $0xc0030cb3
c0029fc0:	68 04 09 03 c0       	push   $0xc0030904
c0029fc5:	68 20 01 00 00       	push   $0x120
c0029fca:	68 fe 2b 03 c0       	push   $0xc0032bfe
c0029fcf:	e8 a9 e6 ff ff       	call   c002867d <debug_panic>

c0029fd4 <hash_int>:
{
c0029fd4:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c0029fd7:	6a 04                	push   $0x4
c0029fd9:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0029fdd:	50                   	push   %eax
c0029fde:	e8 28 ff ff ff       	call   c0029f0b <hash_bytes>
}
c0029fe3:	83 c4 1c             	add    $0x1c,%esp
c0029fe6:	c3                   	ret    

c0029fe7 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c0029fe7:	53                   	push   %ebx
c0029fe8:	83 ec 08             	sub    $0x8,%esp
c0029feb:	89 c3                	mov    %eax,%ebx
  return (intr_context ()
c0029fed:	e8 8a 7c ff ff       	call   c0021c7c <intr_context>
          || lock_held_by_current_thread (&console_lock));
c0029ff2:	84 c0                	test   %al,%al
c0029ff4:	75 09                	jne    c0029fff <putchar_have_lock+0x18>
          || !use_console_lock
c0029ff6:	80 3d 6c e4 03 c0 00 	cmpb   $0x0,0xc003e46c
c0029ffd:	75 27                	jne    c002a026 <putchar_have_lock+0x3f>
  ASSERT (console_locked_by_current_thread ());
  write_cnt++;
c0029fff:	83 05 60 e4 03 c0 01 	addl   $0x1,0xc003e460
c002a006:	83 15 64 e4 03 c0 00 	adcl   $0x0,0xc003e464
  serial_putc (c);
c002a00d:	0f b6 db             	movzbl %bl,%ebx
c002a010:	83 ec 0c             	sub    $0xc,%esp
c002a013:	53                   	push   %ebx
c002a014:	e8 34 aa ff ff       	call   c0024a4d <serial_putc>
  vga_putc (c);
c002a019:	89 1c 24             	mov    %ebx,(%esp)
c002a01c:	e8 7e a6 ff ff       	call   c002469f <vga_putc>
}
c002a021:	83 c4 18             	add    $0x18,%esp
c002a024:	5b                   	pop    %ebx
c002a025:	c3                   	ret    
          || lock_held_by_current_thread (&console_lock));
c002a026:	83 ec 0c             	sub    $0xc,%esp
c002a029:	68 80 e4 03 c0       	push   $0xc003e480
c002a02e:	e8 62 8e ff ff       	call   c0022e95 <lock_held_by_current_thread>
  ASSERT (console_locked_by_current_thread ());
c002a033:	83 c4 10             	add    $0x10,%esp
c002a036:	84 c0                	test   %al,%al
c002a038:	75 c5                	jne    c0029fff <putchar_have_lock+0x18>
c002a03a:	83 ec 0c             	sub    $0xc,%esp
c002a03d:	68 3c 2c 03 c0       	push   $0xc0032c3c
c002a042:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002a047:	68 48 09 03 c0       	push   $0xc0030948
c002a04c:	68 bb 00 00 00       	push   $0xbb
c002a051:	68 81 2c 03 c0       	push   $0xc0032c81
c002a056:	e8 22 e6 ff ff       	call   c002867d <debug_panic>

c002a05b <vprintf_helper>:
{
c002a05b:	83 ec 0c             	sub    $0xc,%esp
c002a05e:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c002a062:	ff 00                	incl   (%eax)
  putchar_have_lock (c);
c002a064:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002a069:	e8 79 ff ff ff       	call   c0029fe7 <putchar_have_lock>
}
c002a06e:	83 c4 0c             	add    $0xc,%esp
c002a071:	c3                   	ret    

c002a072 <acquire_console>:
{
c002a072:	83 ec 0c             	sub    $0xc,%esp
  if (!intr_context () && use_console_lock) 
c002a075:	e8 02 7c ff ff       	call   c0021c7c <intr_context>
c002a07a:	84 c0                	test   %al,%al
c002a07c:	75 09                	jne    c002a087 <acquire_console+0x15>
c002a07e:	80 3d 6c e4 03 c0 00 	cmpb   $0x0,0xc003e46c
c002a085:	75 04                	jne    c002a08b <acquire_console+0x19>
}
c002a087:	83 c4 0c             	add    $0xc,%esp
c002a08a:	c3                   	ret    
      if (lock_held_by_current_thread (&console_lock)) 
c002a08b:	83 ec 0c             	sub    $0xc,%esp
c002a08e:	68 80 e4 03 c0       	push   $0xc003e480
c002a093:	e8 fd 8d ff ff       	call   c0022e95 <lock_held_by_current_thread>
c002a098:	83 c4 10             	add    $0x10,%esp
c002a09b:	84 c0                	test   %al,%al
c002a09d:	74 08                	je     c002a0a7 <acquire_console+0x35>
        console_lock_depth++; 
c002a09f:	ff 05 68 e4 03 c0    	incl   0xc003e468
c002a0a5:	eb e0                	jmp    c002a087 <acquire_console+0x15>
        lock_acquire (&console_lock); 
c002a0a7:	83 ec 0c             	sub    $0xc,%esp
c002a0aa:	68 80 e4 03 c0       	push   $0xc003e480
c002a0af:	e8 1f 8e ff ff       	call   c0022ed3 <lock_acquire>
c002a0b4:	83 c4 10             	add    $0x10,%esp
}
c002a0b7:	eb ce                	jmp    c002a087 <acquire_console+0x15>

c002a0b9 <release_console>:
{
c002a0b9:	83 ec 0c             	sub    $0xc,%esp
  if (!intr_context () && use_console_lock) 
c002a0bc:	e8 bb 7b ff ff       	call   c0021c7c <intr_context>
c002a0c1:	84 c0                	test   %al,%al
c002a0c3:	75 18                	jne    c002a0dd <release_console+0x24>
c002a0c5:	80 3d 6c e4 03 c0 00 	cmpb   $0x0,0xc003e46c
c002a0cc:	74 0f                	je     c002a0dd <release_console+0x24>
      if (console_lock_depth > 0)
c002a0ce:	a1 68 e4 03 c0       	mov    0xc003e468,%eax
c002a0d3:	85 c0                	test   %eax,%eax
c002a0d5:	7e 0a                	jle    c002a0e1 <release_console+0x28>
        console_lock_depth--;
c002a0d7:	48                   	dec    %eax
c002a0d8:	a3 68 e4 03 c0       	mov    %eax,0xc003e468
}
c002a0dd:	83 c4 0c             	add    $0xc,%esp
c002a0e0:	c3                   	ret    
        lock_release (&console_lock); 
c002a0e1:	83 ec 0c             	sub    $0xc,%esp
c002a0e4:	68 80 e4 03 c0       	push   $0xc003e480
c002a0e9:	e8 82 8f ff ff       	call   c0023070 <lock_release>
c002a0ee:	83 c4 10             	add    $0x10,%esp
}
c002a0f1:	eb ea                	jmp    c002a0dd <release_console+0x24>

c002a0f3 <console_init>:
{
c002a0f3:	83 ec 18             	sub    $0x18,%esp
  lock_init (&console_lock);
c002a0f6:	68 80 e4 03 c0       	push   $0xc003e480
c002a0fb:	e8 5f 8c ff ff       	call   c0022d5f <lock_init>
  use_console_lock = true;
c002a100:	c6 05 6c e4 03 c0 01 	movb   $0x1,0xc003e46c
}
c002a107:	83 c4 1c             	add    $0x1c,%esp
c002a10a:	c3                   	ret    

c002a10b <console_panic>:
  use_console_lock = false;
c002a10b:	c6 05 6c e4 03 c0 00 	movb   $0x0,0xc003e46c
c002a112:	c3                   	ret    

c002a113 <console_print_stats>:
{
c002a113:	83 ec 10             	sub    $0x10,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002a116:	ff 35 64 e4 03 c0    	pushl  0xc003e464
c002a11c:	ff 35 60 e4 03 c0    	pushl  0xc003e460
c002a122:	68 60 2c 03 c0       	push   $0xc0032c60
c002a127:	e8 a3 ca ff ff       	call   c0026bcf <printf>
}
c002a12c:	83 c4 1c             	add    $0x1c,%esp
c002a12f:	c3                   	ret    

c002a130 <vprintf>:
{
c002a130:	83 ec 1c             	sub    $0x1c,%esp
  int char_cnt = 0;
c002a133:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002a13a:	00 
  acquire_console ();
c002a13b:	e8 32 ff ff ff       	call   c002a072 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002a140:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002a144:	50                   	push   %eax
c002a145:	68 5b a0 02 c0       	push   $0xc002a05b
c002a14a:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a14e:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a152:	e8 ad ca ff ff       	call   c0026c04 <__vprintf>
  release_console ();
c002a157:	e8 5d ff ff ff       	call   c002a0b9 <release_console>
}
c002a15c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a160:	83 c4 2c             	add    $0x2c,%esp
c002a163:	c3                   	ret    

c002a164 <puts>:
{
c002a164:	53                   	push   %ebx
c002a165:	83 ec 08             	sub    $0x8,%esp
c002a168:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002a16c:	e8 01 ff ff ff       	call   c002a072 <acquire_console>
  while (*s != '\0')
c002a171:	8a 03                	mov    (%ebx),%al
c002a173:	84 c0                	test   %al,%al
c002a175:	74 0f                	je     c002a186 <puts+0x22>
    putchar_have_lock (*s++);
c002a177:	43                   	inc    %ebx
c002a178:	0f b6 c0             	movzbl %al,%eax
c002a17b:	e8 67 fe ff ff       	call   c0029fe7 <putchar_have_lock>
  while (*s != '\0')
c002a180:	8a 03                	mov    (%ebx),%al
c002a182:	84 c0                	test   %al,%al
c002a184:	75 f1                	jne    c002a177 <puts+0x13>
  putchar_have_lock ('\n');
c002a186:	b8 0a 00 00 00       	mov    $0xa,%eax
c002a18b:	e8 57 fe ff ff       	call   c0029fe7 <putchar_have_lock>
  release_console ();
c002a190:	e8 24 ff ff ff       	call   c002a0b9 <release_console>
}
c002a195:	b8 00 00 00 00       	mov    $0x0,%eax
c002a19a:	83 c4 08             	add    $0x8,%esp
c002a19d:	5b                   	pop    %ebx
c002a19e:	c3                   	ret    

c002a19f <putbuf>:
{
c002a19f:	56                   	push   %esi
c002a1a0:	53                   	push   %ebx
c002a1a1:	83 ec 04             	sub    $0x4,%esp
c002a1a4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002a1a8:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console ();
c002a1ac:	e8 c1 fe ff ff       	call   c002a072 <acquire_console>
  while (n-- > 0)
c002a1b1:	85 f6                	test   %esi,%esi
c002a1b3:	74 10                	je     c002a1c5 <putbuf+0x26>
c002a1b5:	01 de                	add    %ebx,%esi
    putchar_have_lock (*buffer++);
c002a1b7:	43                   	inc    %ebx
c002a1b8:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c002a1bc:	e8 26 fe ff ff       	call   c0029fe7 <putchar_have_lock>
  while (n-- > 0)
c002a1c1:	39 de                	cmp    %ebx,%esi
c002a1c3:	75 f2                	jne    c002a1b7 <putbuf+0x18>
  release_console ();
c002a1c5:	e8 ef fe ff ff       	call   c002a0b9 <release_console>
}
c002a1ca:	83 c4 04             	add    $0x4,%esp
c002a1cd:	5b                   	pop    %ebx
c002a1ce:	5e                   	pop    %esi
c002a1cf:	c3                   	ret    

c002a1d0 <putchar>:
{
c002a1d0:	83 ec 0c             	sub    $0xc,%esp
  acquire_console ();
c002a1d3:	e8 9a fe ff ff       	call   c002a072 <acquire_console>
  putchar_have_lock (c);
c002a1d8:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002a1dd:	e8 05 fe ff ff       	call   c0029fe7 <putchar_have_lock>
  release_console ();
c002a1e2:	e8 d2 fe ff ff       	call   c002a0b9 <release_console>
}
c002a1e7:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a1eb:	83 c4 0c             	add    $0xc,%esp
c002a1ee:	c3                   	ret    

c002a1ef <process_execute>:
   FILENAME.  The new thread may be scheduled (and may even exit)
   before process_execute() returns.  Returns the new process's
   thread id, or TID_ERROR if the thread cannot be created. */
tid_t
process_execute (const char *file_name) 
{
c002a1ef:	55                   	push   %ebp
c002a1f0:	57                   	push   %edi
c002a1f1:	56                   	push   %esi
c002a1f2:	53                   	push   %ebx
c002a1f3:	83 ec 28             	sub    $0x28,%esp
c002a1f6:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
	char *fn_copy;
	tid_t tid;

	/* Make a copy of FILE_NAME.
		 Otherwise there's a race between the caller and load(). */
	fn_copy = malloc(strlen(file_name)+1);
c002a1fa:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002a1ff:	89 df                	mov    %ebx,%edi
c002a201:	b0 00                	mov    $0x0,%al
c002a203:	f2 ae                	repnz scas %es:(%edi),%al
c002a205:	f7 d1                	not    %ecx
c002a207:	51                   	push   %ecx
c002a208:	e8 17 98 ff ff       	call   c0023a24 <malloc>
c002a20d:	89 c6                	mov    %eax,%esi
	strlcpy (fn_copy, file_name, PGSIZE);
c002a20f:	83 c4 0c             	add    $0xc,%esp
c002a212:	68 00 10 00 00       	push   $0x1000
c002a217:	53                   	push   %ebx
c002a218:	50                   	push   %eax
c002a219:	e8 59 db ff ff       	call   c0027d77 <strlcpy>

	char *fn_cp = malloc(strlen(file_name)+1);
c002a21e:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002a223:	89 df                	mov    %ebx,%edi
c002a225:	b0 00                	mov    $0x0,%al
c002a227:	f2 ae                	repnz scas %es:(%edi),%al
c002a229:	f7 d1                	not    %ecx
c002a22b:	89 0c 24             	mov    %ecx,(%esp)
c002a22e:	e8 f1 97 ff ff       	call   c0023a24 <malloc>
c002a233:	89 c5                	mov    %eax,%ebp
	strlcpy (fn_cp, file_name, strlen(file_name)+1);
c002a235:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002a23a:	89 df                	mov    %ebx,%edi
c002a23c:	b0 00                	mov    $0x0,%al
c002a23e:	f2 ae                	repnz scas %es:(%edi),%al
c002a240:	f7 d1                	not    %ecx
c002a242:	83 c4 0c             	add    $0xc,%esp
c002a245:	51                   	push   %ecx
c002a246:	53                   	push   %ebx
c002a247:	55                   	push   %ebp
c002a248:	e8 2a db ff ff       	call   c0027d77 <strlcpy>

	/* Get the real name */
	char *token, *save_ptr;
	token = strtok_r(fn_cp, " ", &save_ptr);
c002a24d:	83 c4 0c             	add    $0xc,%esp
c002a250:	8d 44 24 10          	lea    0x10(%esp),%eax
c002a254:	50                   	push   %eax
c002a255:	68 0a 27 03 c0       	push   $0xc003270a
c002a25a:	55                   	push   %ebp
c002a25b:	e8 3d d9 ff ff       	call   c0027b9d <strtok_r>
c002a260:	89 c3                	mov    %eax,%ebx

	/* Create a new thread to execute FILE_NAME. */
  struct thread *current_thread = thread_current();
c002a262:	e8 af 6a ff ff       	call   c0020d16 <thread_current>
c002a267:	89 c5                	mov    %eax,%ebp
	tid = thread_create (token, PRI_DEFAULT, start_process, fn_copy);
c002a269:	56                   	push   %esi
c002a26a:	68 e8 a4 02 c0       	push   $0xc002a4e8
c002a26f:	6a 1f                	push   $0x1f
c002a271:	53                   	push   %ebx
c002a272:	e8 56 73 ff ff       	call   c00215cd <thread_create>
c002a277:	89 c3                	mov    %eax,%ebx

	if (tid == TID_ERROR) {
c002a279:	83 c4 20             	add    $0x20,%esp
c002a27c:	83 f8 ff             	cmp    $0xffffffff,%eax
c002a27f:	74 22                	je     c002a2a3 <process_execute+0xb4>
		palloc_free_page (fn_copy);
	}
	else {
		/* Wait child thread running start_process */
		sema_down(&current_thread->load_sema);
c002a281:	83 ec 0c             	sub    $0xc,%esp
c002a284:	8d 45 78             	lea    0x78(%ebp),%eax
c002a287:	50                   	push   %eax
c002a288:	e8 66 88 ff ff       	call   c0022af3 <sema_down>
		if (!current_thread->load_success)
c002a28d:	83 c4 10             	add    $0x10,%esp
c002a290:	80 bd a0 00 00 00 00 	cmpb   $0x0,0xa0(%ebp)
c002a297:	74 18                	je     c002a2b1 <process_execute+0xc2>
			return TID_ERROR;
	}

	return tid;
}
c002a299:	89 d8                	mov    %ebx,%eax
c002a29b:	83 c4 1c             	add    $0x1c,%esp
c002a29e:	5b                   	pop    %ebx
c002a29f:	5e                   	pop    %esi
c002a2a0:	5f                   	pop    %edi
c002a2a1:	5d                   	pop    %ebp
c002a2a2:	c3                   	ret    
		palloc_free_page (fn_copy);
c002a2a3:	83 ec 0c             	sub    $0xc,%esp
c002a2a6:	56                   	push   %esi
c002a2a7:	e8 2c 95 ff ff       	call   c00237d8 <palloc_free_page>
c002a2ac:	83 c4 10             	add    $0x10,%esp
c002a2af:	eb e8                	jmp    c002a299 <process_execute+0xaa>
			return TID_ERROR;
c002a2b1:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002a2b6:	eb e1                	jmp    c002a299 <process_execute+0xaa>

c002a2b8 <process_wait>:
   immediately, without waiting.
   This function will be implemented in problem 2-2.  For now, it
   does nothing. */
int
process_wait (tid_t child_tid)
{
c002a2b8:	56                   	push   %esi
c002a2b9:	53                   	push   %ebx
c002a2ba:	83 ec 04             	sub    $0x4,%esp
	struct thread *t = thread_current ();
c002a2bd:	e8 54 6a ff ff       	call   c0020d16 <thread_current>
c002a2c2:	89 c6                	mov    %eax,%esi

	struct child_process *ch = get_child_by_tid(&t->children, child_tid);
c002a2c4:	83 ec 08             	sub    $0x8,%esp
c002a2c7:	ff 74 24 18          	pushl  0x18(%esp)
c002a2cb:	8d 80 a8 00 00 00    	lea    0xa8(%eax),%eax
c002a2d1:	50                   	push   %eax
c002a2d2:	e8 8b 74 ff ff       	call   c0021762 <get_child_by_tid>

	if (ch == NULL) {
c002a2d7:	83 c4 10             	add    $0x10,%esp
c002a2da:	85 c0                	test   %eax,%eax
c002a2dc:	74 3b                	je     c002a319 <process_wait+0x61>
c002a2de:	89 c3                	mov    %eax,%ebx
		return -1;
	}
	if (ch->waited) {
c002a2e0:	80 78 09 00          	cmpb   $0x0,0x9(%eax)
c002a2e4:	75 3a                	jne    c002a320 <process_wait+0x68>
		return -1;
	}
	ch->waited = true;
c002a2e6:	c6 40 09 01          	movb   $0x1,0x9(%eax)
	t->wait_tid = ch->tid;
c002a2ea:	8b 00                	mov    (%eax),%eax
c002a2ec:	89 46 74             	mov    %eax,0x74(%esi)
	if (!ch->done)
c002a2ef:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
c002a2f3:	74 10                	je     c002a305 <process_wait+0x4d>
		sema_down(&t->wait_sema);
	t->wait_tid = -1;
c002a2f5:	c7 46 74 ff ff ff ff 	movl   $0xffffffff,0x74(%esi)

	return ch->ret_status;
c002a2fc:	8b 43 04             	mov    0x4(%ebx),%eax
}
c002a2ff:	83 c4 04             	add    $0x4,%esp
c002a302:	5b                   	pop    %ebx
c002a303:	5e                   	pop    %esi
c002a304:	c3                   	ret    
		sema_down(&t->wait_sema);
c002a305:	83 ec 0c             	sub    $0xc,%esp
c002a308:	8d 86 8c 00 00 00    	lea    0x8c(%esi),%eax
c002a30e:	50                   	push   %eax
c002a30f:	e8 df 87 ff ff       	call   c0022af3 <sema_down>
c002a314:	83 c4 10             	add    $0x10,%esp
c002a317:	eb dc                	jmp    c002a2f5 <process_wait+0x3d>
		return -1;
c002a319:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a31e:	eb df                	jmp    c002a2ff <process_wait+0x47>
		return -1;
c002a320:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a325:	eb d8                	jmp    c002a2ff <process_wait+0x47>

c002a327 <process_exit>:

/* Free the current process's resources. */
void
process_exit (void)
{
c002a327:	55                   	push   %ebp
c002a328:	57                   	push   %edi
c002a329:	56                   	push   %esi
c002a32a:	53                   	push   %ebx
c002a32b:	83 ec 1c             	sub    $0x1c,%esp
	struct thread *cur = thread_current ();
c002a32e:	e8 e3 69 ff ff       	call   c0020d16 <thread_current>
c002a333:	89 44 24 0c          	mov    %eax,0xc(%esp)
  uint32_t *pd;

  printf("%s: exit(%d)\n", cur->name, cur->ret_status);
c002a337:	83 ec 04             	sub    $0x4,%esp
c002a33a:	ff 70 68             	pushl  0x68(%eax)
c002a33d:	83 c0 0c             	add    $0xc,%eax
c002a340:	50                   	push   %eax
c002a341:	68 9c 2c 03 c0       	push   $0xc0032c9c
c002a346:	e8 84 c8 ff ff       	call   c0026bcf <printf>
//	printf("tid = %d %s: exit(%d)\n", cur->tid, cur->name, cur->ret_status);

  /* ??? */
  if (!lock_held_by_current_thread(&filesys_lock))
c002a34b:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002a352:	e8 3e 8b ff ff       	call   c0022e95 <lock_held_by_current_thread>
c002a357:	83 c4 10             	add    $0x10,%esp
c002a35a:	84 c0                	test   %al,%al
c002a35c:	74 1d                	je     c002a37b <process_exit+0x54>
    lock_acquire(&filesys_lock);

	/* Close files */
	file_close(cur->self);
c002a35e:	83 ec 0c             	sub    $0xc,%esp
c002a361:	8b 7c 24 18          	mov    0x18(%esp),%edi
c002a365:	ff b7 b8 00 00 00    	pushl  0xb8(%edi)
c002a36b:	e8 3a 2a 00 00       	call   c002cdaa <file_close>

	struct fd_t *entry;
	while (!list_empty(&cur->files)) {
c002a370:	83 c4 10             	add    $0x10,%esp
c002a373:	8d b7 bc 00 00 00    	lea    0xbc(%edi),%esi
c002a379:	eb 3e                	jmp    c002a3b9 <process_exit+0x92>
    lock_acquire(&filesys_lock);
c002a37b:	83 ec 0c             	sub    $0xc,%esp
c002a37e:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002a383:	e8 4b 8b ff ff       	call   c0022ed3 <lock_acquire>
c002a388:	83 c4 10             	add    $0x10,%esp
c002a38b:	eb d1                	jmp    c002a35e <process_exit+0x37>
		entry = list_entry (list_pop_front(&cur->files), struct fd_t, elem);
c002a38d:	83 ec 0c             	sub    $0xc,%esp
c002a390:	56                   	push   %esi
c002a391:	e8 e4 e8 ff ff       	call   c0028c7a <list_pop_front>
c002a396:	89 c3                	mov    %eax,%ebx
		file_close(entry->ptr);
c002a398:	83 c4 04             	add    $0x4,%esp
c002a39b:	ff 70 f4             	pushl  -0xc(%eax)
c002a39e:	e8 07 2a 00 00       	call   c002cdaa <file_close>
		list_remove(&entry->elem);
c002a3a3:	8d 7b f4             	lea    -0xc(%ebx),%edi
c002a3a6:	89 1c 24             	mov    %ebx,(%esp)
c002a3a9:	e8 df e7 ff ff       	call   c0028b8d <list_remove>
		free(entry);
c002a3ae:	89 3c 24             	mov    %edi,(%esp)
c002a3b1:	e8 11 98 ff ff       	call   c0023bc7 <free>
c002a3b6:	83 c4 10             	add    $0x10,%esp
	while (!list_empty(&cur->files)) {
c002a3b9:	83 ec 0c             	sub    $0xc,%esp
c002a3bc:	56                   	push   %esi
c002a3bd:	e8 56 e8 ff ff       	call   c0028c18 <list_empty>
c002a3c2:	83 c4 10             	add    $0x10,%esp
c002a3c5:	84 c0                	test   %al,%al
c002a3c7:	74 c4                	je     c002a38d <process_exit+0x66>
	}

	lock_release(&filesys_lock);
c002a3c9:	83 ec 0c             	sub    $0xc,%esp
c002a3cc:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002a3d1:	e8 9a 8c ff ff       	call   c0023070 <lock_release>

//	printf("page_exit done\n");

	struct mapping_t *mp_e;
	while (!list_empty(&cur->mappings)) {
c002a3d6:	83 c4 10             	add    $0x10,%esp
c002a3d9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a3dd:	8d b8 cc 00 00 00    	lea    0xcc(%eax),%edi
c002a3e3:	eb 14                	jmp    c002a3f9 <process_exit+0xd2>
		mp_e = list_entry(list_pop_front(&cur->mappings), struct mapping_t, elem);
		for (int i = 0; i < mp_e->page_cnt; i++) {
			page_free(page_for_addr((void *) ((mp_e->base) + (PGSIZE * i))));
		}
		list_remove(&mp_e->elem);
c002a3e5:	83 ec 0c             	sub    $0xc,%esp
c002a3e8:	56                   	push   %esi
c002a3e9:	e8 9f e7 ff ff       	call   c0028b8d <list_remove>
		free(mp_e);
c002a3ee:	89 2c 24             	mov    %ebp,(%esp)
c002a3f1:	e8 d1 97 ff ff       	call   c0023bc7 <free>
c002a3f6:	83 c4 10             	add    $0x10,%esp
	while (!list_empty(&cur->mappings)) {
c002a3f9:	83 ec 0c             	sub    $0xc,%esp
c002a3fc:	57                   	push   %edi
c002a3fd:	e8 16 e8 ff ff       	call   c0028c18 <list_empty>
c002a402:	83 c4 10             	add    $0x10,%esp
c002a405:	84 c0                	test   %al,%al
c002a407:	75 40                	jne    c002a449 <process_exit+0x122>
		mp_e = list_entry(list_pop_front(&cur->mappings), struct mapping_t, elem);
c002a409:	83 ec 0c             	sub    $0xc,%esp
c002a40c:	57                   	push   %edi
c002a40d:	e8 68 e8 ff ff       	call   c0028c7a <list_pop_front>
c002a412:	89 c6                	mov    %eax,%esi
c002a414:	8d 68 f0             	lea    -0x10(%eax),%ebp
		for (int i = 0; i < mp_e->page_cnt; i++) {
c002a417:	83 c4 10             	add    $0x10,%esp
c002a41a:	83 78 f8 00          	cmpl   $0x0,-0x8(%eax)
c002a41e:	7e c5                	jle    c002a3e5 <process_exit+0xbe>
c002a420:	bb 00 00 00 00       	mov    $0x0,%ebx
			page_free(page_for_addr((void *) ((mp_e->base) + (PGSIZE * i))));
c002a425:	83 ec 0c             	sub    $0xc,%esp
c002a428:	89 d8                	mov    %ebx,%eax
c002a42a:	c1 e0 0c             	shl    $0xc,%eax
c002a42d:	03 46 fc             	add    -0x4(%esi),%eax
c002a430:	50                   	push   %eax
c002a431:	e8 4d 4a 00 00       	call   c002ee83 <page_for_addr>
c002a436:	89 04 24             	mov    %eax,(%esp)
c002a439:	e8 a5 4b 00 00       	call   c002efe3 <page_free>
		for (int i = 0; i < mp_e->page_cnt; i++) {
c002a43e:	43                   	inc    %ebx
c002a43f:	83 c4 10             	add    $0x10,%esp
c002a442:	39 5e f8             	cmp    %ebx,-0x8(%esi)
c002a445:	7f de                	jg     c002a425 <process_exit+0xfe>
c002a447:	eb 9c                	jmp    c002a3e5 <process_exit+0xbe>
	}

	lock_acquire(&frame_lock);
c002a449:	83 ec 0c             	sub    $0xc,%esp
c002a44c:	68 00 6c 04 c0       	push   $0xc0046c00
c002a451:	e8 7d 8a ff ff       	call   c0022ed3 <lock_acquire>
	page_exit();
c002a456:	e8 18 4c 00 00       	call   c002f073 <page_exit>
	lock_release(&frame_lock);
c002a45b:	c7 04 24 00 6c 04 c0 	movl   $0xc0046c00,(%esp)
c002a462:	e8 09 8c ff ff       	call   c0023070 <lock_release>

	/* delete children list */
	while (!list_empty(&cur->children)) {
c002a467:	83 c4 10             	add    $0x10,%esp
c002a46a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a46e:	8d 98 a8 00 00 00    	lea    0xa8(%eax),%ebx
c002a474:	eb 17                	jmp    c002a48d <process_exit+0x166>
		struct child_process *entry = list_entry(list_pop_front(&cur->children), struct child_process, elem);
c002a476:	83 ec 0c             	sub    $0xc,%esp
c002a479:	53                   	push   %ebx
c002a47a:	e8 fb e7 ff ff       	call   c0028c7a <list_pop_front>
		free(entry);
c002a47f:	83 e8 0c             	sub    $0xc,%eax
c002a482:	89 04 24             	mov    %eax,(%esp)
c002a485:	e8 3d 97 ff ff       	call   c0023bc7 <free>
c002a48a:	83 c4 10             	add    $0x10,%esp
	while (!list_empty(&cur->children)) {
c002a48d:	83 ec 0c             	sub    $0xc,%esp
c002a490:	53                   	push   %ebx
c002a491:	e8 82 e7 ff ff       	call   c0028c18 <list_empty>
c002a496:	83 c4 10             	add    $0x10,%esp
c002a499:	84 c0                	test   %al,%al
c002a49b:	74 d9                	je     c002a476 <process_exit+0x14f>
	}

  /* Destroy the current process's page directory and switch back
     to the kernel-only page directory. */
  pd = cur->pagedir;
c002a49d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a4a1:	8b 58 64             	mov    0x64(%eax),%ebx
  if (pd != NULL) 
c002a4a4:	85 db                	test   %ebx,%ebx
c002a4a6:	74 1c                	je     c002a4c4 <process_exit+0x19d>
         so that a timer interrupt can't switch back to the
         process page directory.  We must activate the base page
         directory before destroying the process's page
         directory, or our active page directory will be one
         that's been freed (and cleared). */
      cur->pagedir = NULL;
c002a4a8:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
      pagedir_activate (NULL);
c002a4af:	83 ec 0c             	sub    $0xc,%esp
c002a4b2:	6a 00                	push   $0x0
c002a4b4:	e8 5f 0c 00 00       	call   c002b118 <pagedir_activate>
      pagedir_destroy (pd);
c002a4b9:	89 1c 24             	mov    %ebx,(%esp)
c002a4bc:	e8 d5 08 00 00       	call   c002ad96 <pagedir_destroy>
c002a4c1:	83 c4 10             	add    $0x10,%esp
    }
}
c002a4c4:	83 c4 1c             	add    $0x1c,%esp
c002a4c7:	5b                   	pop    %ebx
c002a4c8:	5e                   	pop    %esi
c002a4c9:	5f                   	pop    %edi
c002a4ca:	5d                   	pop    %ebp
c002a4cb:	c3                   	ret    

c002a4cc <process_activate>:
/* Sets up the CPU for running user code in the current
   thread.
   This function is called on every context switch. */
void
process_activate (void)
{
c002a4cc:	83 ec 0c             	sub    $0xc,%esp
  struct thread *t = thread_current ();
c002a4cf:	e8 42 68 ff ff       	call   c0020d16 <thread_current>

  /* Activate thread's page tables. */
  pagedir_activate (t->pagedir);
c002a4d4:	83 ec 0c             	sub    $0xc,%esp
c002a4d7:	ff 70 64             	pushl  0x64(%eax)
c002a4da:	e8 39 0c 00 00       	call   c002b118 <pagedir_activate>

  /* Set thread's kernel stack for use in processing
     interrupts. */
  tss_update ();
c002a4df:	e8 4a 1f 00 00       	call   c002c42e <tss_update>
}
c002a4e4:	83 c4 1c             	add    $0x1c,%esp
c002a4e7:	c3                   	ret    

c002a4e8 <start_process>:
{
c002a4e8:	55                   	push   %ebp
c002a4e9:	57                   	push   %edi
c002a4ea:	56                   	push   %esi
c002a4eb:	53                   	push   %ebx
c002a4ec:	81 ec dc 00 00 00    	sub    $0xdc,%esp
  memset (&if_, 0, sizeof if_);
c002a4f2:	8d 94 24 80 00 00 00 	lea    0x80(%esp),%edx
c002a4f9:	b9 14 00 00 00       	mov    $0x14,%ecx
c002a4fe:	b8 00 00 00 00       	mov    $0x0,%eax
c002a503:	89 d7                	mov    %edx,%edi
c002a505:	f3 ab                	rep stos %eax,%es:(%edi)
  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
c002a507:	66 c7 84 24 cc 00 00 	movw   $0x23,0xcc(%esp)
c002a50e:	00 23 00 
c002a511:	66 c7 84 24 ac 00 00 	movw   $0x23,0xac(%esp)
c002a518:	00 23 00 
c002a51b:	66 c7 84 24 a8 00 00 	movw   $0x23,0xa8(%esp)
c002a522:	00 23 00 
c002a525:	66 c7 84 24 a4 00 00 	movw   $0x23,0xa4(%esp)
c002a52c:	00 23 00 
c002a52f:	66 c7 84 24 a0 00 00 	movw   $0x23,0xa0(%esp)
c002a536:	00 23 00 
  if_.cs = SEL_UCSEG;
c002a539:	66 c7 84 24 c0 00 00 	movw   $0x1b,0xc0(%esp)
c002a540:	00 1b 00 
  if_.eflags = FLAG_IF | FLAG_MBS;
c002a543:	c7 84 24 c4 00 00 00 	movl   $0x202,0xc4(%esp)
c002a54a:	02 02 00 00 
	char *fn_cp = malloc(strlen(file_name) + 1);
c002a54e:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002a553:	b3 00                	mov    $0x0,%bl
c002a555:	89 f1                	mov    %esi,%ecx
c002a557:	8b bc 24 f0 00 00 00 	mov    0xf0(%esp),%edi
c002a55e:	88 d8                	mov    %bl,%al
c002a560:	f2 ae                	repnz scas %es:(%edi),%al
c002a562:	f7 d1                	not    %ecx
c002a564:	83 ec 0c             	sub    $0xc,%esp
c002a567:	51                   	push   %ecx
c002a568:	e8 b7 94 ff ff       	call   c0023a24 <malloc>
c002a56d:	89 c5                	mov    %eax,%ebp
	strlcpy (fn_cp, file_name, strlen(file_name) + 1);
c002a56f:	89 f1                	mov    %esi,%ecx
c002a571:	8b bc 24 00 01 00 00 	mov    0x100(%esp),%edi
c002a578:	88 d8                	mov    %bl,%al
c002a57a:	f2 ae                	repnz scas %es:(%edi),%al
c002a57c:	f7 d1                	not    %ecx
c002a57e:	83 c4 0c             	add    $0xc,%esp
c002a581:	51                   	push   %ecx
c002a582:	ff b4 24 f8 00 00 00 	pushl  0xf8(%esp)
c002a589:	55                   	push   %ebp
c002a58a:	e8 e8 d7 ff ff       	call   c0027d77 <strlcpy>
	token = strtok_r(fn_cp, " ", &save_ptr);
c002a58f:	83 c4 0c             	add    $0xc,%esp
c002a592:	8d 84 24 80 00 00 00 	lea    0x80(%esp),%eax
c002a599:	50                   	push   %eax
c002a59a:	68 0a 27 03 c0       	push   $0xc003270a
c002a59f:	55                   	push   %ebp
c002a5a0:	e8 f8 d5 ff ff       	call   c0027b9d <strtok_r>
c002a5a5:	89 c7                	mov    %eax,%edi
   and its initial stack pointer into *ESP.
   Returns true if successful, false otherwise. */
bool
load (const char *file_name, void (**eip) (void), void **esp) 
{
  struct thread *t = thread_current ();
c002a5a7:	e8 6a 67 ff ff       	call   c0020d16 <thread_current>
c002a5ac:	89 c3                	mov    %eax,%ebx
  struct file *file = NULL;
  off_t file_ofs;
  bool success = false;
  int i;

	lock_acquire(&filesys_lock);
c002a5ae:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002a5b5:	e8 19 89 ff ff       	call   c0022ed3 <lock_acquire>

  /* Allocate and activate page directory. */
  t->pagedir = pagedir_create ();
c002a5ba:	e8 af 07 00 00       	call   c002ad6e <pagedir_create>
c002a5bf:	89 43 64             	mov    %eax,0x64(%ebx)
  if (t->pagedir == NULL) 
c002a5c2:	83 c4 10             	add    $0x10,%esp
c002a5c5:	85 c0                	test   %eax,%eax
c002a5c7:	0f 84 bd 04 00 00    	je     c002aa8a <start_process+0x5a2>
    goto done;
  process_activate ();
c002a5cd:	e8 fa fe ff ff       	call   c002a4cc <process_activate>

  /* Allocate page table */
	t->pages = malloc (sizeof *t->pages);
c002a5d2:	83 ec 0c             	sub    $0xc,%esp
c002a5d5:	6a 18                	push   $0x18
c002a5d7:	e8 48 94 ff ff       	call   c0023a24 <malloc>
c002a5dc:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
	if (t->pages == NULL)
c002a5e2:	83 c4 10             	add    $0x10,%esp
c002a5e5:	85 c0                	test   %eax,%eax
c002a5e7:	0f 84 a6 04 00 00    	je     c002aa93 <start_process+0x5ab>
		goto done;
	hash_init(t->pages, page_hash, page_less, NULL);
c002a5ed:	6a 00                	push   $0x0
c002a5ef:	68 a5 f0 02 c0       	push   $0xc002f0a5
c002a5f4:	68 9a f0 02 c0       	push   $0xc002f09a
c002a5f9:	50                   	push   %eax
c002a5fa:	e8 d0 f5 ff ff       	call   c0029bcf <hash_init>

  /* Open executable file. */
  file = filesys_open (file_name);
c002a5ff:	89 3c 24             	mov    %edi,(%esp)
c002a602:	e8 b3 21 00 00       	call   c002c7ba <filesys_open>
c002a607:	89 c6                	mov    %eax,%esi
  if (file == NULL)
c002a609:	83 c4 10             	add    $0x10,%esp
c002a60c:	85 c0                	test   %eax,%eax
c002a60e:	0f 84 e4 00 00 00    	je     c002a6f8 <start_process+0x210>
    {
      printf ("load: %s: open failed\n", file_name);
      goto done; 
    }
	file_deny_write(file);
c002a614:	83 ec 0c             	sub    $0xc,%esp
c002a617:	50                   	push   %eax
c002a618:	e8 fb 26 00 00       	call   c002cd18 <file_deny_write>

  /* Read and verify executable header. */
  if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
c002a61d:	83 c4 0c             	add    $0xc,%esp
c002a620:	6a 34                	push   $0x34
c002a622:	8d 44 24 50          	lea    0x50(%esp),%eax
c002a626:	50                   	push   %eax
c002a627:	56                   	push   %esi
c002a628:	e8 6b 26 00 00       	call   c002cc98 <file_read>
c002a62d:	83 c4 10             	add    $0x10,%esp
c002a630:	83 f8 34             	cmp    $0x34,%eax
c002a633:	75 2c                	jne    c002a661 <start_process+0x179>
      || memcmp (ehdr.e_ident, "\177ELF\1\1\1", 7)
c002a635:	83 ec 04             	sub    $0x4,%esp
c002a638:	6a 07                	push   $0x7
c002a63a:	68 c1 2c 03 c0       	push   $0xc0032cc1
c002a63f:	8d 44 24 54          	lea    0x54(%esp),%eax
c002a643:	50                   	push   %eax
c002a644:	e8 9f d3 ff ff       	call   c00279e8 <memcmp>
c002a649:	83 c4 10             	add    $0x10,%esp
c002a64c:	89 04 24             	mov    %eax,(%esp)
c002a64f:	85 c0                	test   %eax,%eax
c002a651:	75 0e                	jne    c002a661 <start_process+0x179>
      || ehdr.e_type != 2
      || ehdr.e_machine != 3
c002a653:	81 7c 24 58 02 00 03 	cmpl   $0x30002,0x58(%esp)
c002a65a:	00 
c002a65b:	0f 84 b1 00 00 00    	je     c002a712 <start_process+0x22a>
      || ehdr.e_version != 1
      || ehdr.e_phentsize != sizeof (struct Elf32_Phdr)
      || ehdr.e_phnum > 1024) 
    {
      printf ("load: %s: error loading executable\n", file_name);
c002a661:	83 ec 08             	sub    $0x8,%esp
c002a664:	57                   	push   %edi
c002a665:	68 e4 2c 03 c0       	push   $0xc0032ce4
c002a66a:	e8 60 c5 ff ff       	call   c0026bcf <printf>
c002a66f:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002a672:	c6 04 24 00          	movb   $0x0,(%esp)
  thread_current()->self = file;

 done:
  /* We arrive here whether the load is successful or not. */
//  file_close (file);
	lock_release(&filesys_lock);
c002a676:	83 ec 0c             	sub    $0xc,%esp
c002a679:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002a67e:	e8 ed 89 ff ff       	call   c0023070 <lock_release>
  for (; token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
c002a683:	83 c4 10             	add    $0x10,%esp
c002a686:	85 ff                	test   %edi,%edi
c002a688:	0f 84 0e 04 00 00    	je     c002aa9c <start_process+0x5b4>
c002a68e:	bb 00 00 00 00       	mov    $0x0,%ebx
c002a693:	8d 74 24 7c          	lea    0x7c(%esp),%esi
	  argc++;
c002a697:	43                   	inc    %ebx
  for (; token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
c002a698:	83 ec 04             	sub    $0x4,%esp
c002a69b:	56                   	push   %esi
c002a69c:	68 0a 27 03 c0       	push   $0xc003270a
c002a6a1:	6a 00                	push   $0x0
c002a6a3:	e8 f5 d4 ff ff       	call   c0027b9d <strtok_r>
c002a6a8:	83 c4 10             	add    $0x10,%esp
c002a6ab:	85 c0                	test   %eax,%eax
c002a6ad:	75 e8                	jne    c002a697 <start_process+0x1af>
  free(fn_cp);
c002a6af:	83 ec 0c             	sub    $0xc,%esp
c002a6b2:	55                   	push   %ebp
c002a6b3:	e8 0f 95 ff ff       	call   c0023bc7 <free>
	int *argv = calloc(argc, sizeof(int));
c002a6b8:	83 c4 08             	add    $0x8,%esp
c002a6bb:	6a 04                	push   $0x4
c002a6bd:	53                   	push   %ebx
c002a6be:	e8 ba 94 ff ff       	call   c0023b7d <calloc>
c002a6c3:	89 c5                	mov    %eax,%ebp
	for (token = strtok_r(file_name, " ", &save_ptr); token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
c002a6c5:	83 c4 0c             	add    $0xc,%esp
c002a6c8:	8d 84 24 80 00 00 00 	lea    0x80(%esp),%eax
c002a6cf:	50                   	push   %eax
c002a6d0:	68 0a 27 03 c0       	push   $0xc003270a
c002a6d5:	ff b4 24 fc 00 00 00 	pushl  0xfc(%esp)
c002a6dc:	e8 bc d4 ff ff       	call   c0027b9d <strtok_r>
c002a6e1:	89 c6                	mov    %eax,%esi
c002a6e3:	83 c4 10             	add    $0x10,%esp
c002a6e6:	85 c0                	test   %eax,%eax
c002a6e8:	0f 84 fa 04 00 00    	je     c002abe8 <start_process+0x700>
c002a6ee:	bb 00 00 00 00       	mov    $0x0,%ebx
c002a6f3:	e9 b0 03 00 00       	jmp    c002aaa8 <start_process+0x5c0>
      printf ("load: %s: open failed\n", file_name);
c002a6f8:	83 ec 08             	sub    $0x8,%esp
c002a6fb:	57                   	push   %edi
c002a6fc:	68 aa 2c 03 c0       	push   $0xc0032caa
c002a701:	e8 c9 c4 ff ff       	call   c0026bcf <printf>
c002a706:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002a709:	c6 04 24 00          	movb   $0x0,(%esp)
c002a70d:	e9 64 ff ff ff       	jmp    c002a676 <start_process+0x18e>
      || ehdr.e_version != 1
c002a712:	83 7c 24 5c 01       	cmpl   $0x1,0x5c(%esp)
c002a717:	0f 85 44 ff ff ff    	jne    c002a661 <start_process+0x179>
      || ehdr.e_phentsize != sizeof (struct Elf32_Phdr)
c002a71d:	66 83 7c 24 72 20    	cmpw   $0x20,0x72(%esp)
c002a723:	0f 85 38 ff ff ff    	jne    c002a661 <start_process+0x179>
      || ehdr.e_phnum > 1024) 
c002a729:	66 81 7c 24 74 00 04 	cmpw   $0x400,0x74(%esp)
c002a730:	0f 87 2b ff ff ff    	ja     c002a661 <start_process+0x179>
  file_ofs = ehdr.e_phoff;
c002a736:	8b 44 24 64          	mov    0x64(%esp),%eax
c002a73a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002a73e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002a742:	89 7c 24 08          	mov    %edi,0x8(%esp)
c002a746:	eb 11                	jmp    c002a759 <start_process+0x271>
      switch (phdr.p_type) 
c002a748:	83 f8 05             	cmp    $0x5,%eax
c002a74b:	0f 84 38 02 00 00    	je     c002a989 <start_process+0x4a1>
c002a751:	83 44 24 1c 20       	addl   $0x20,0x1c(%esp)
  for (i = 0; i < ehdr.e_phnum; i++) 
c002a756:	ff 04 24             	incl   (%esp)
c002a759:	0f b7 44 24 74       	movzwl 0x74(%esp),%eax
c002a75e:	39 04 24             	cmp    %eax,(%esp)
c002a761:	0f 8d 83 02 00 00    	jge    c002a9ea <start_process+0x502>
      if (file_ofs < 0 || file_ofs > file_length (file))
c002a767:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002a76b:	85 db                	test   %ebx,%ebx
c002a76d:	0f 88 ee 01 00 00    	js     c002a961 <start_process+0x479>
c002a773:	83 ec 0c             	sub    $0xc,%esp
c002a776:	56                   	push   %esi
c002a777:	e8 68 26 00 00       	call   c002cde4 <file_length>
c002a77c:	83 c4 10             	add    $0x10,%esp
c002a77f:	39 c3                	cmp    %eax,%ebx
c002a781:	0f 8f e4 01 00 00    	jg     c002a96b <start_process+0x483>
      file_seek (file, file_ofs);
c002a787:	83 ec 08             	sub    $0x8,%esp
c002a78a:	53                   	push   %ebx
c002a78b:	56                   	push   %esi
c002a78c:	e8 8d 26 00 00       	call   c002ce1e <file_seek>
      if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
c002a791:	83 c4 0c             	add    $0xc,%esp
c002a794:	6a 20                	push   $0x20
c002a796:	8d 44 24 30          	lea    0x30(%esp),%eax
c002a79a:	50                   	push   %eax
c002a79b:	56                   	push   %esi
c002a79c:	e8 f7 24 00 00       	call   c002cc98 <file_read>
c002a7a1:	83 c4 10             	add    $0x10,%esp
c002a7a4:	83 f8 20             	cmp    $0x20,%eax
c002a7a7:	0f 85 c8 01 00 00    	jne    c002a975 <start_process+0x48d>
      switch (phdr.p_type) 
c002a7ad:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a7b1:	83 f8 03             	cmp    $0x3,%eax
c002a7b4:	77 92                	ja     c002a748 <start_process+0x260>
c002a7b6:	83 f8 02             	cmp    $0x2,%eax
c002a7b9:	0f 83 c0 01 00 00    	jae    c002a97f <start_process+0x497>
c002a7bf:	83 f8 01             	cmp    $0x1,%eax
c002a7c2:	75 8d                	jne    c002a751 <start_process+0x269>
   FILE and returns true if so, false otherwise. */
static bool
validate_segment (const struct Elf32_Phdr *phdr, struct file *file) 
{
  /* p_offset and p_vaddr must have the same page offset. */
  if ((phdr->p_offset & PGMASK) != (phdr->p_vaddr & PGMASK)) 
c002a7c4:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c002a7c8:	89 d8                	mov    %ebx,%eax
c002a7ca:	33 44 24 30          	xor    0x30(%esp),%eax
c002a7ce:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002a7d3:	74 0d                	je     c002a7e2 <start_process+0x2fa>
c002a7d5:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a7d9:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a7dd:	e9 af 01 00 00       	jmp    c002a991 <start_process+0x4a9>
    return false; 

  /* p_offset must point within FILE. */
  if (phdr->p_offset > (Elf32_Off) file_length (file)) 
c002a7e2:	83 ec 0c             	sub    $0xc,%esp
c002a7e5:	56                   	push   %esi
c002a7e6:	e8 f9 25 00 00       	call   c002cde4 <file_length>
c002a7eb:	83 c4 10             	add    $0x10,%esp
c002a7ee:	39 c3                	cmp    %eax,%ebx
c002a7f0:	0f 87 a4 01 00 00    	ja     c002a99a <start_process+0x4b2>
    return false;

  /* p_memsz must be at least as big as p_filesz. */
  if (phdr->p_memsz < phdr->p_filesz) 
c002a7f6:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c002a7fa:	8b 5c 24 38          	mov    0x38(%esp),%ebx
c002a7fe:	39 da                	cmp    %ebx,%edx
c002a800:	0f 82 9e 01 00 00    	jb     c002a9a4 <start_process+0x4bc>
    return false; 

  /* The segment must not be empty. */
  if (phdr->p_memsz == 0)
c002a806:	85 d2                	test   %edx,%edx
c002a808:	0f 84 a0 01 00 00    	je     c002a9ae <start_process+0x4c6>
    return false;
  
  /* The virtual memory region must both start and end within the
     user address space range. */
  if (!is_user_vaddr ((void *) phdr->p_vaddr))
c002a80e:	8b 44 24 30          	mov    0x30(%esp),%eax
c002a812:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002a817:	0f 87 9b 01 00 00    	ja     c002a9b8 <start_process+0x4d0>
    return false;
  if (!is_user_vaddr ((void *) (phdr->p_vaddr + phdr->p_memsz)))
c002a81d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c002a820:	81 f9 ff ff ff bf    	cmp    $0xbfffffff,%ecx
c002a826:	0f 87 96 01 00 00    	ja     c002a9c2 <start_process+0x4da>
    return false;

  /* The region cannot "wrap around" across the kernel virtual
     address space. */
  if (phdr->p_vaddr + phdr->p_memsz < phdr->p_vaddr)
c002a82c:	39 c8                	cmp    %ecx,%eax
c002a82e:	0f 87 98 01 00 00    	ja     c002a9cc <start_process+0x4e4>
          if (validate_segment (&phdr, file)) 
c002a834:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002a839:	0f 86 97 01 00 00    	jbe    c002a9d6 <start_process+0x4ee>
              bool writable = (phdr.p_flags & PF_W) != 0;
c002a83f:	8b 7c 24 40          	mov    0x40(%esp),%edi
c002a843:	d1 ef                	shr    %edi
c002a845:	83 e7 01             	and    $0x1,%edi
              uint32_t file_page = phdr.p_offset & ~PGMASK;
c002a848:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
c002a84c:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
              uint32_t mem_page = phdr.p_vaddr & ~PGMASK;
c002a852:	89 c5                	mov    %eax,%ebp
c002a854:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
              uint32_t page_offset = phdr.p_vaddr & PGMASK;
c002a85a:	25 ff 0f 00 00       	and    $0xfff,%eax
              if (phdr.p_filesz > 0)
c002a85f:	85 db                	test   %ebx,%ebx
c002a861:	74 42                	je     c002a8a5 <start_process+0x3bd>
                  read_bytes = page_offset + phdr.p_filesz;
c002a863:	01 c3                	add    %eax,%ebx
                  zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
c002a865:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax
c002a86c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002a871:	29 d8                	sub    %ebx,%eax
c002a873:	89 44 24 0c          	mov    %eax,0xc(%esp)
              if (!load_segment (file, file_page, (void *) mem_page,
c002a877:	89 f8                	mov    %edi,%eax
c002a879:	0f b6 c0             	movzbl %al,%eax
c002a87c:	89 44 24 18          	mov    %eax,0x18(%esp)
c002a880:	89 cf                	mov    %ecx,%edi
   or disk read error occurs. */
static bool
load_segment (struct file *file, off_t ofs, uint8_t *upage,
              uint32_t read_bytes, uint32_t zero_bytes, bool writable) 
{
  ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002a882:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a886:	01 d8                	add    %ebx,%eax
c002a888:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002a88d:	75 2d                	jne    c002a8bc <start_process+0x3d4>
  ASSERT (pg_ofs (upage) == 0);
  ASSERT (ofs % PGSIZE == 0);

  file_seek (file, ofs);
c002a88f:	83 ec 08             	sub    $0x8,%esp
c002a892:	51                   	push   %ecx
c002a893:	56                   	push   %esi
c002a894:	e8 85 25 00 00       	call   c002ce1e <file_seek>
c002a899:	83 c4 10             	add    $0x10,%esp
c002a89c:	89 74 24 14          	mov    %esi,0x14(%esp)
c002a8a0:	e9 97 00 00 00       	jmp    c002a93c <start_process+0x454>
                  zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
c002a8a5:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax
c002a8ac:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002a8b1:	89 44 24 0c          	mov    %eax,0xc(%esp)
                  read_bytes = 0;
c002a8b5:	bb 00 00 00 00       	mov    $0x0,%ebx
c002a8ba:	eb bb                	jmp    c002a877 <start_process+0x38f>
  ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002a8bc:	83 ec 0c             	sub    $0xc,%esp
c002a8bf:	68 08 2d 03 c0       	push   $0xc0032d08
c002a8c4:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002a8c9:	68 5c 09 03 c0       	push   $0xc003095c
c002a8ce:	68 0f 02 00 00       	push   $0x20f
c002a8d3:	68 c9 2c 03 c0       	push   $0xc0032cc9
c002a8d8:	e8 a0 dd ff ff       	call   c002867d <debug_panic>
    {
      /* Calculate how to fill this page.
         We will read PAGE_READ_BYTES bytes from FILE
         and zero the final PAGE_ZERO_BYTES bytes. */
      size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
      size_t page_zero_bytes = PGSIZE - page_read_bytes;
c002a8dd:	b8 00 10 00 00       	mov    $0x1000,%eax
c002a8e2:	29 f0                	sub    %esi,%eax
c002a8e4:	89 44 24 10          	mov    %eax,0x10(%esp)
      /* Get a page of memory. */
#ifdef VM
      lock_release(&filesys_lock);
c002a8e8:	83 ec 0c             	sub    $0xc,%esp
c002a8eb:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002a8f0:	e8 7b 87 ff ff       	call   c0023070 <lock_release>
	    struct page *kpage = page_alloc(upage, writable);
c002a8f5:	83 c4 08             	add    $0x8,%esp
c002a8f8:	ff 74 24 20          	pushl  0x20(%esp)
c002a8fc:	55                   	push   %ebp
c002a8fd:	e8 db 44 00 00       	call   c002eddd <page_alloc>
      if (kpage == NULL)
c002a902:	83 c4 10             	add    $0x10,%esp
c002a905:	85 c0                	test   %eax,%eax
c002a907:	0f 84 d3 00 00 00    	je     c002a9e0 <start_process+0x4f8>
        return false;

      kpage->file = file;
c002a90d:	8b 54 24 14          	mov    0x14(%esp),%edx
c002a911:	89 50 20             	mov    %edx,0x20(%eax)
      kpage->file_offset = ofs;
c002a914:	89 78 24             	mov    %edi,0x24(%eax)
      kpage->read_bytes = page_read_bytes;
c002a917:	89 70 28             	mov    %esi,0x28(%eax)
      ofs += page_read_bytes;
c002a91a:	01 f7                	add    %esi,%edi
//			if (file_read(file, kpage->frame->base, page_read_bytes) != (int) page_read_bytes) {
//        page_free(kpage);
//        return false;
//      }
//      memset(kpage->frame->base + page_read_bytes, 0, page_zero_bytes);
		lock_acquire(&filesys_lock);
c002a91c:	83 ec 0c             	sub    $0xc,%esp
c002a91f:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002a924:	e8 aa 85 ff ff       	call   c0022ed3 <lock_acquire>
          palloc_free_page (kpage);
          return false; 
        }
#endif
      /* Advance. */
      read_bytes -= page_read_bytes;
c002a929:	29 f3                	sub    %esi,%ebx
      zero_bytes -= page_zero_bytes;
c002a92b:	8b 44 24 20          	mov    0x20(%esp),%eax
c002a92f:	29 44 24 1c          	sub    %eax,0x1c(%esp)
      upage += PGSIZE;
c002a933:	81 c5 00 10 00 00    	add    $0x1000,%ebp
c002a939:	83 c4 10             	add    $0x10,%esp
  while (read_bytes > 0 || zero_bytes > 0)
c002a93c:	85 db                	test   %ebx,%ebx
c002a93e:	75 07                	jne    c002a947 <start_process+0x45f>
c002a940:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c002a945:	74 11                	je     c002a958 <start_process+0x470>
      size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
c002a947:	89 de                	mov    %ebx,%esi
c002a949:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
c002a94f:	76 8c                	jbe    c002a8dd <start_process+0x3f5>
c002a951:	be 00 10 00 00       	mov    $0x1000,%esi
c002a956:	eb 85                	jmp    c002a8dd <start_process+0x3f5>
c002a958:	8b 74 24 14          	mov    0x14(%esp),%esi
c002a95c:	e9 f0 fd ff ff       	jmp    c002a751 <start_process+0x269>
c002a961:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a965:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a969:	eb 26                	jmp    c002a991 <start_process+0x4a9>
c002a96b:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a96f:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a973:	eb 1c                	jmp    c002a991 <start_process+0x4a9>
c002a975:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a979:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a97d:	eb 12                	jmp    c002a991 <start_process+0x4a9>
c002a97f:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a983:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a987:	eb 08                	jmp    c002a991 <start_process+0x4a9>
c002a989:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a98d:	8b 7c 24 08          	mov    0x8(%esp),%edi
  bool success = false;
c002a991:	c6 04 24 00          	movb   $0x0,(%esp)
c002a995:	e9 dc fc ff ff       	jmp    c002a676 <start_process+0x18e>
c002a99a:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a99e:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a9a2:	eb ed                	jmp    c002a991 <start_process+0x4a9>
c002a9a4:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a9a8:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a9ac:	eb e3                	jmp    c002a991 <start_process+0x4a9>
c002a9ae:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a9b2:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a9b6:	eb d9                	jmp    c002a991 <start_process+0x4a9>
c002a9b8:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a9bc:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a9c0:	eb cf                	jmp    c002a991 <start_process+0x4a9>
c002a9c2:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a9c6:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a9ca:	eb c5                	jmp    c002a991 <start_process+0x4a9>
c002a9cc:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a9d0:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a9d4:	eb bb                	jmp    c002a991 <start_process+0x4a9>
c002a9d6:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a9da:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a9de:	eb b1                	jmp    c002a991 <start_process+0x4a9>
c002a9e0:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a9e4:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002a9e8:	eb a7                	jmp    c002a991 <start_process+0x4a9>
c002a9ea:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002a9ee:	8b 7c 24 08          	mov    0x8(%esp),%edi
static bool
setup_stack (void **esp) 
{
  bool success = false;
#ifdef VM
  lock_release(&filesys_lock);
c002a9f2:	83 ec 0c             	sub    $0xc,%esp
c002a9f5:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002a9fa:	e8 71 86 ff ff       	call   c0023070 <lock_release>
  struct page *kpage = page_alloc(((uint8_t *) PHYS_BASE) - PGSIZE, true);
c002a9ff:	83 c4 08             	add    $0x8,%esp
c002aa02:	6a 01                	push   $0x1
c002aa04:	68 00 f0 ff bf       	push   $0xbffff000
c002aa09:	e8 cf 43 00 00       	call   c002eddd <page_alloc>
c002aa0e:	89 c3                	mov    %eax,%ebx
  if (kpage != NULL) {
c002aa10:	83 c4 10             	add    $0x10,%esp
c002aa13:	85 c0                	test   %eax,%eax
c002aa15:	74 5a                	je     c002aa71 <start_process+0x589>
    success = frame_alloc(kpage);
c002aa17:	83 ec 0c             	sub    $0xc,%esp
c002aa1a:	50                   	push   %eax
c002aa1b:	e8 b4 46 00 00       	call   c002f0d4 <frame_alloc>
c002aa20:	88 44 24 10          	mov    %al,0x10(%esp)
		if (success) {
c002aa24:	83 c4 10             	add    $0x10,%esp
c002aa27:	84 c0                	test   %al,%al
c002aa29:	74 3a                	je     c002aa65 <start_process+0x57d>
			kpage->private = false;
c002aa2b:	c6 43 18 00          	movb   $0x0,0x18(%ebx)
			*esp = PHYS_BASE;
c002aa2f:	c7 84 24 c8 00 00 00 	movl   $0xc0000000,0xc8(%esp)
c002aa36:	00 00 00 c0 
		}
    else {
			page_free(kpage);
		}
  }
  lock_acquire(&filesys_lock);
c002aa3a:	83 ec 0c             	sub    $0xc,%esp
c002aa3d:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002aa42:	e8 8c 84 ff ff       	call   c0022ed3 <lock_acquire>
  *eip = (void (*) (void)) ehdr.e_entry;
c002aa47:	8b 44 24 70          	mov    0x70(%esp),%eax
c002aa4b:	89 84 24 cc 00 00 00 	mov    %eax,0xcc(%esp)
  thread_current()->self = file;
c002aa52:	e8 bf 62 ff ff       	call   c0020d16 <thread_current>
c002aa57:	89 b0 b8 00 00 00    	mov    %esi,0xb8(%eax)
c002aa5d:	83 c4 10             	add    $0x10,%esp
c002aa60:	e9 11 fc ff ff       	jmp    c002a676 <start_process+0x18e>
			page_free(kpage);
c002aa65:	83 ec 0c             	sub    $0xc,%esp
c002aa68:	53                   	push   %ebx
c002aa69:	e8 75 45 00 00       	call   c002efe3 <page_free>
c002aa6e:	83 c4 10             	add    $0x10,%esp
  lock_acquire(&filesys_lock);
c002aa71:	83 ec 0c             	sub    $0xc,%esp
c002aa74:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002aa79:	e8 55 84 ff ff       	call   c0022ed3 <lock_acquire>
c002aa7e:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002aa81:	c6 04 24 00          	movb   $0x0,(%esp)
c002aa85:	e9 ec fb ff ff       	jmp    c002a676 <start_process+0x18e>
c002aa8a:	c6 04 24 00          	movb   $0x0,(%esp)
c002aa8e:	e9 e3 fb ff ff       	jmp    c002a676 <start_process+0x18e>
c002aa93:	c6 04 24 00          	movb   $0x0,(%esp)
c002aa97:	e9 da fb ff ff       	jmp    c002a676 <start_process+0x18e>
  int argc = 0;
c002aa9c:	bb 00 00 00 00       	mov    $0x0,%ebx
c002aaa1:	e9 09 fc ff ff       	jmp    c002a6af <start_process+0x1c7>
		argv[argc++] = if_.esp;
c002aaa6:	89 fb                	mov    %edi,%ebx
		if_.esp -= strlen(token) + 1;
c002aaa8:	b0 00                	mov    $0x0,%al
c002aaaa:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002aaaf:	89 f7                	mov    %esi,%edi
c002aab1:	f2 ae                	repnz scas %es:(%edi),%al
c002aab3:	8b 94 24 c8 00 00 00 	mov    0xc8(%esp),%edx
c002aaba:	8d 54 0a 01          	lea    0x1(%edx,%ecx,1),%edx
c002aabe:	89 94 24 c8 00 00 00 	mov    %edx,0xc8(%esp)
		memcpy(if_.esp, token, strlen(token) + 1);
c002aac5:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002aaca:	89 f7                	mov    %esi,%edi
c002aacc:	f2 ae                	repnz scas %es:(%edi),%al
c002aace:	f7 d1                	not    %ecx
c002aad0:	89 d7                	mov    %edx,%edi
c002aad2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		argv[argc++] = if_.esp;
c002aad4:	8d 7b 01             	lea    0x1(%ebx),%edi
c002aad7:	8b 84 24 c8 00 00 00 	mov    0xc8(%esp),%eax
c002aade:	89 44 bd fc          	mov    %eax,-0x4(%ebp,%edi,4)
	for (token = strtok_r(file_name, " ", &save_ptr); token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
c002aae2:	83 ec 04             	sub    $0x4,%esp
c002aae5:	8d 84 24 80 00 00 00 	lea    0x80(%esp),%eax
c002aaec:	50                   	push   %eax
c002aaed:	68 0a 27 03 c0       	push   $0xc003270a
c002aaf2:	6a 00                	push   $0x0
c002aaf4:	e8 a4 d0 ff ff       	call   c0027b9d <strtok_r>
c002aaf9:	89 c6                	mov    %eax,%esi
c002aafb:	83 c4 10             	add    $0x10,%esp
c002aafe:	85 c0                	test   %eax,%eax
c002ab00:	75 a4                	jne    c002aaa6 <start_process+0x5be>
	if_.esp -= ((unsigned)if_.esp % WORD_SIZE);
c002ab02:	8b 84 24 c8 00 00 00 	mov    0xc8(%esp),%eax
c002ab09:	83 e0 fc             	and    $0xfffffffc,%eax
	if_.esp -= sizeof(int);
c002ab0c:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ab0f:	89 94 24 c8 00 00 00 	mov    %edx,0xc8(%esp)
	*(int*)if_.esp = 0;
c002ab16:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	for(int i = argc - 1; i >= 0; i--) {
c002ab1d:	85 db                	test   %ebx,%ebx
c002ab1f:	78 1e                	js     c002ab3f <start_process+0x657>
		if_.esp -= sizeof(int);
c002ab21:	8b 84 24 c8 00 00 00 	mov    0xc8(%esp),%eax
c002ab28:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ab2b:	89 94 24 c8 00 00 00 	mov    %edx,0xc8(%esp)
		memcpy(if_.esp, &argv[i], sizeof(int));
c002ab32:	8b 54 9d 00          	mov    0x0(%ebp,%ebx,4),%edx
c002ab36:	89 50 fc             	mov    %edx,-0x4(%eax)
	for(int i = argc - 1; i >= 0; i--) {
c002ab39:	4b                   	dec    %ebx
c002ab3a:	83 fb ff             	cmp    $0xffffffff,%ebx
c002ab3d:	75 e2                	jne    c002ab21 <start_process+0x639>
	int tmp = if_.esp;
c002ab3f:	8b 84 24 c8 00 00 00 	mov    0xc8(%esp),%eax
	if_.esp -= sizeof(int);
c002ab46:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ab49:	89 94 24 c8 00 00 00 	mov    %edx,0xc8(%esp)
	memcpy(if_.esp, &tmp, sizeof(int));
c002ab50:	89 40 fc             	mov    %eax,-0x4(%eax)
	if_.esp -= sizeof(int);
c002ab53:	8b 84 24 c8 00 00 00 	mov    0xc8(%esp),%eax
c002ab5a:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ab5d:	89 94 24 c8 00 00 00 	mov    %edx,0xc8(%esp)
	memcpy(if_.esp, &argc, sizeof(int));
c002ab64:	89 78 fc             	mov    %edi,-0x4(%eax)
	if_.esp -= sizeof(int);
c002ab67:	8b 84 24 c8 00 00 00 	mov    0xc8(%esp),%eax
c002ab6e:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ab71:	89 94 24 c8 00 00 00 	mov    %edx,0xc8(%esp)
	*(int*)if_.esp = 0;
c002ab78:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	free(file_name);
c002ab7f:	83 ec 0c             	sub    $0xc,%esp
c002ab82:	ff b4 24 fc 00 00 00 	pushl  0xfc(%esp)
c002ab89:	e8 39 90 ff ff       	call   c0023bc7 <free>
	struct thread * current_thread = thread_current();
c002ab8e:	e8 83 61 ff ff       	call   c0020d16 <thread_current>
	current_thread->parent->load_success = success;
c002ab93:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
c002ab99:	8a 5c 24 10          	mov    0x10(%esp),%bl
c002ab9d:	88 9a a0 00 00 00    	mov    %bl,0xa0(%edx)
	if (!success)
c002aba3:	83 c4 10             	add    $0x10,%esp
c002aba6:	84 db                	test   %bl,%bl
c002aba8:	75 05                	jne    c002abaf <start_process+0x6c7>
	  thread_exit();
c002abaa:	e8 ff 6b ff ff       	call   c00217ae <thread_exit>
	sema_up(&current_thread->parent->load_sema);
c002abaf:	83 ec 0c             	sub    $0xc,%esp
c002abb2:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c002abb8:	83 c0 78             	add    $0x78,%eax
c002abbb:	50                   	push   %eax
c002abbc:	e8 13 80 ff ff       	call   c0022bd4 <sema_up>
  asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
c002abc1:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
c002abc8:	89 c4                	mov    %eax,%esp
c002abca:	e9 20 73 ff ff       	jmp    c0021eef <intr_exit>
  NOT_REACHED ();
c002abcf:	68 54 14 03 c0       	push   $0xc0031454
c002abd4:	68 6c 09 03 c0       	push   $0xc003096c
c002abd9:	68 98 00 00 00       	push   $0x98
c002abde:	68 c9 2c 03 c0       	push   $0xc0032cc9
c002abe3:	e8 95 da ff ff       	call   c002867d <debug_panic>
	if_.esp -= ((unsigned)if_.esp % WORD_SIZE);
c002abe8:	8b 84 24 c8 00 00 00 	mov    0xc8(%esp),%eax
c002abef:	83 e0 fc             	and    $0xfffffffc,%eax
	if_.esp -= sizeof(int);
c002abf2:	8d 50 fc             	lea    -0x4(%eax),%edx
c002abf5:	89 94 24 c8 00 00 00 	mov    %edx,0xc8(%esp)
	*(int*)if_.esp = 0;
c002abfc:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	argc = 0;
c002ac03:	bf 00 00 00 00       	mov    $0x0,%edi
c002ac08:	e9 32 ff ff ff       	jmp    c002ab3f <start_process+0x657>

c002ac0d <lookup_page>:
   on CREATE.  If CREATE is true, then a new page table is
   created and a pointer into it is returned.  Otherwise, a null
   pointer is returned. */
static uint32_t *
lookup_page (uint32_t *pd, const void *vaddr, bool create)
{
c002ac0d:	56                   	push   %esi
c002ac0e:	53                   	push   %ebx
c002ac0f:	83 ec 04             	sub    $0x4,%esp
  uint32_t *pt, *pde;

  ASSERT (pd != NULL);
c002ac12:	85 c0                	test   %eax,%eax
c002ac14:	0f 84 85 00 00 00    	je     c002ac9f <lookup_page+0x92>

  /* Shouldn't create new kernel virtual mappings. */
  ASSERT (!create || is_user_vaddr (vaddr));
c002ac1a:	84 c9                	test   %cl,%cl
c002ac1c:	0f 84 31 01 00 00    	je     c002ad53 <lookup_page+0x146>
c002ac22:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002ac28:	0f 87 8f 00 00 00    	ja     c002acbd <lookup_page+0xb0>
  return (uintptr_t) va >> PDSHIFT;
c002ac2e:	89 d3                	mov    %edx,%ebx
c002ac30:	c1 ea 16             	shr    $0x16,%edx

  /* Check for a page table for VADDR.
     If one is missing, create one if requested. */
  pde = pd + pd_no (vaddr);
c002ac33:	8d 34 90             	lea    (%eax,%edx,4),%esi
  if (*pde == 0) 
c002ac36:	83 3e 00             	cmpl   $0x0,(%esi)
c002ac39:	75 34                	jne    c002ac6f <lookup_page+0x62>
    {
      if (create)
        {
          pt = palloc_get_page (PAL_ZERO);
c002ac3b:	83 ec 0c             	sub    $0xc,%esp
c002ac3e:	6a 02                	push   $0x2
c002ac40:	e8 69 8a ff ff       	call   c00236ae <palloc_get_page>
          if (pt == NULL) 
c002ac45:	83 c4 10             	add    $0x10,%esp
c002ac48:	85 c0                	test   %eax,%eax
c002ac4a:	74 4d                	je     c002ac99 <lookup_page+0x8c>
c002ac4c:	89 c2                	mov    %eax,%edx
  ASSERT (pg_ofs (pt) == 0);
c002ac4e:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002ac53:	0f 85 82 00 00 00    	jne    c002acdb <lookup_page+0xce>
  ASSERT (is_kernel_vaddr (vaddr));
c002ac59:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002ac5e:	0f 86 95 00 00 00    	jbe    c002acf9 <lookup_page+0xec>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002ac64:	81 c2 00 00 00 40    	add    $0x40000000,%edx
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c002ac6a:	83 ca 07             	or     $0x7,%edx
c002ac6d:	89 16                	mov    %edx,(%esi)
      else
        return NULL;
    }

  /* Return the page table entry. */
  pt = pde_get_pt (*pde);
c002ac6f:	8b 06                	mov    (%esi),%eax
  ASSERT (pde & PTE_P);
c002ac71:	a8 01                	test   $0x1,%al
c002ac73:	0f 84 9e 00 00 00    	je     c002ad17 <lookup_page+0x10a>
  return ptov (pde & PTE_ADDR);
c002ac79:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c002ac7e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002ac83:	0f 87 ac 00 00 00    	ja     c002ad35 <lookup_page+0x128>
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002ac89:	c1 eb 0a             	shr    $0xa,%ebx
  return &pt[pt_no (vaddr)];
c002ac8c:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
c002ac92:	8d 84 18 00 00 00 c0 	lea    -0x40000000(%eax,%ebx,1),%eax
}
c002ac99:	83 c4 04             	add    $0x4,%esp
c002ac9c:	5b                   	pop    %ebx
c002ac9d:	5e                   	pop    %esi
c002ac9e:	c3                   	ret    
  ASSERT (pd != NULL);
c002ac9f:	83 ec 0c             	sub    $0xc,%esp
c002aca2:	68 30 2d 03 c0       	push   $0xc0032d30
c002aca7:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002acac:	68 b0 09 03 c0       	push   $0xc00309b0
c002acb1:	6a 3d                	push   $0x3d
c002acb3:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002acb8:	e8 c0 d9 ff ff       	call   c002867d <debug_panic>
  ASSERT (!create || is_user_vaddr (vaddr));
c002acbd:	83 ec 0c             	sub    $0xc,%esp
c002acc0:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002acc5:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002acca:	68 b0 09 03 c0       	push   $0xc00309b0
c002accf:	6a 40                	push   $0x40
c002acd1:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002acd6:	e8 a2 d9 ff ff       	call   c002867d <debug_panic>
  ASSERT (pg_ofs (pt) == 0);
c002acdb:	83 ec 0c             	sub    $0xc,%esp
c002acde:	68 a2 0c 03 c0       	push   $0xc0030ca2
c002ace3:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ace8:	68 a4 09 03 c0       	push   $0xc00309a4
c002aced:	6a 48                	push   $0x48
c002acef:	68 ca 0c 03 c0       	push   $0xc0030cca
c002acf4:	e8 84 d9 ff ff       	call   c002867d <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c002acf9:	83 ec 0c             	sub    $0xc,%esp
c002acfc:	68 de 0c 03 c0       	push   $0xc0030cde
c002ad01:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ad06:	68 bc 09 03 c0       	push   $0xc00309bc
c002ad0b:	6a 54                	push   $0x54
c002ad0d:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002ad12:	e8 66 d9 ff ff       	call   c002867d <debug_panic>
  ASSERT (pde & PTE_P);
c002ad17:	83 ec 0c             	sub    $0xc,%esp
c002ad1a:	68 54 2d 03 c0       	push   $0xc0032d54
c002ad1f:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ad24:	68 e0 09 03 c0       	push   $0xc00309e0
c002ad29:	6a 4f                	push   $0x4f
c002ad2b:	68 ca 0c 03 c0       	push   $0xc0030cca
c002ad30:	e8 48 d9 ff ff       	call   c002867d <debug_panic>
  ASSERT ((void *) paddr < PHYS_BASE);
c002ad35:	83 ec 0c             	sub    $0xc,%esp
c002ad38:	68 6b 19 03 c0       	push   $0xc003196b
c002ad3d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ad42:	68 d8 09 03 c0       	push   $0xc00309d8
c002ad47:	6a 4a                	push   $0x4a
c002ad49:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002ad4e:	e8 2a d9 ff ff       	call   c002867d <debug_panic>
  return (uintptr_t) va >> PDSHIFT;
c002ad53:	89 d3                	mov    %edx,%ebx
c002ad55:	c1 ea 16             	shr    $0x16,%edx
  pde = pd + pd_no (vaddr);
c002ad58:	8d 34 90             	lea    (%eax,%edx,4),%esi
  if (*pde == 0) 
c002ad5b:	83 3e 00             	cmpl   $0x0,(%esi)
c002ad5e:	0f 85 0b ff ff ff    	jne    c002ac6f <lookup_page+0x62>
        return NULL;
c002ad64:	b8 00 00 00 00       	mov    $0x0,%eax
c002ad69:	e9 2b ff ff ff       	jmp    c002ac99 <lookup_page+0x8c>

c002ad6e <pagedir_create>:
{
c002ad6e:	57                   	push   %edi
c002ad6f:	56                   	push   %esi
c002ad70:	83 ec 10             	sub    $0x10,%esp
  uint32_t *pd = palloc_get_page (0);
c002ad73:	6a 00                	push   $0x0
c002ad75:	e8 34 89 ff ff       	call   c00236ae <palloc_get_page>
  if (pd != NULL)
c002ad7a:	83 c4 10             	add    $0x10,%esp
c002ad7d:	85 c0                	test   %eax,%eax
c002ad7f:	74 0f                	je     c002ad90 <pagedir_create+0x22>
    memcpy (pd, init_page_dir, PGSIZE);
c002ad81:	8b 35 34 6c 04 c0    	mov    0xc0046c34,%esi
c002ad87:	b9 00 04 00 00       	mov    $0x400,%ecx
c002ad8c:	89 c7                	mov    %eax,%edi
c002ad8e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
c002ad90:	83 c4 04             	add    $0x4,%esp
c002ad93:	5e                   	pop    %esi
c002ad94:	5f                   	pop    %edi
c002ad95:	c3                   	ret    

c002ad96 <pagedir_destroy>:
{
c002ad96:	55                   	push   %ebp
c002ad97:	57                   	push   %edi
c002ad98:	56                   	push   %esi
c002ad99:	53                   	push   %ebx
c002ad9a:	83 ec 1c             	sub    $0x1c,%esp
  if (pd == NULL)
c002ad9d:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c002ada2:	0f 84 05 01 00 00    	je     c002aead <pagedir_destroy+0x117>
  ASSERT (pd != init_page_dir);
c002ada8:	a1 34 6c 04 c0       	mov    0xc0046c34,%eax
c002adad:	39 44 24 30          	cmp    %eax,0x30(%esp)
c002adb1:	74 20                	je     c002add3 <pagedir_destroy+0x3d>
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002adb3:	8b 44 24 30          	mov    0x30(%esp),%eax
c002adb7:	05 00 0c 00 00       	add    $0xc00,%eax
c002adbc:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002adc0:	39 44 24 30          	cmp    %eax,0x30(%esp)
c002adc4:	0f 83 d4 00 00 00    	jae    c002ae9e <pagedir_destroy+0x108>
c002adca:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002adce:	e9 9b 00 00 00       	jmp    c002ae6e <pagedir_destroy+0xd8>
  ASSERT (pd != init_page_dir);
c002add3:	83 ec 0c             	sub    $0xc,%esp
c002add6:	68 60 2d 03 c0       	push   $0xc0032d60
c002addb:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ade0:	68 ec 09 03 c0       	push   $0xc00309ec
c002ade5:	6a 23                	push   $0x23
c002ade7:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002adec:	e8 8c d8 ff ff       	call   c002867d <debug_panic>
c002adf1:	83 ec 0c             	sub    $0xc,%esp
c002adf4:	68 6b 19 03 c0       	push   $0xc003196b
c002adf9:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002adfe:	68 d8 09 03 c0       	push   $0xc00309d8
c002ae03:	6a 4a                	push   $0x4a
c002ae05:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002ae0a:	e8 6e d8 ff ff       	call   c002867d <debug_panic>
c002ae0f:	83 ec 0c             	sub    $0xc,%esp
c002ae12:	68 6b 19 03 c0       	push   $0xc003196b
c002ae17:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ae1c:	68 d8 09 03 c0       	push   $0xc00309d8
c002ae21:	6a 4a                	push   $0x4a
c002ae23:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002ae28:	e8 50 d8 ff ff       	call   c002867d <debug_panic>
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002ae2d:	83 c3 04             	add    $0x4,%ebx
c002ae30:	39 f3                	cmp    %esi,%ebx
c002ae32:	74 25                	je     c002ae59 <pagedir_destroy+0xc3>
          if (*pte & PTE_P) 
c002ae34:	8b 03                	mov    (%ebx),%eax
c002ae36:	a8 01                	test   $0x1,%al
c002ae38:	74 f3                	je     c002ae2d <pagedir_destroy+0x97>
}

/* Returns a pointer to the page that page table entry PTE points
   to. */
static inline void *pte_get_page (uint32_t pte) {
  return ptov (pte & PTE_ADDR);
c002ae3a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002ae3f:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002ae44:	77 c9                	ja     c002ae0f <pagedir_destroy+0x79>
            palloc_free_page (pte_get_page (*pte));
c002ae46:	83 ec 0c             	sub    $0xc,%esp
  return (void *) (paddr + PHYS_BASE);
c002ae49:	2d 00 00 00 40       	sub    $0x40000000,%eax
c002ae4e:	50                   	push   %eax
c002ae4f:	e8 84 89 ff ff       	call   c00237d8 <palloc_free_page>
c002ae54:	83 c4 10             	add    $0x10,%esp
c002ae57:	eb d4                	jmp    c002ae2d <pagedir_destroy+0x97>
        palloc_free_page (pt);
c002ae59:	83 ec 0c             	sub    $0xc,%esp
c002ae5c:	55                   	push   %ebp
c002ae5d:	e8 76 89 ff ff       	call   c00237d8 <palloc_free_page>
c002ae62:	83 c4 10             	add    $0x10,%esp
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002ae65:	83 c7 04             	add    $0x4,%edi
c002ae68:	39 7c 24 0c          	cmp    %edi,0xc(%esp)
c002ae6c:	74 30                	je     c002ae9e <pagedir_destroy+0x108>
    if (*pde & PTE_P) 
c002ae6e:	8b 37                	mov    (%edi),%esi
c002ae70:	f7 c6 01 00 00 00    	test   $0x1,%esi
c002ae76:	74 ed                	je     c002ae65 <pagedir_destroy+0xcf>
  return ptov (pde & PTE_ADDR);
c002ae78:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  ASSERT ((void *) paddr < PHYS_BASE);
c002ae7e:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002ae84:	0f 87 67 ff ff ff    	ja     c002adf1 <pagedir_destroy+0x5b>
  return (void *) (paddr + PHYS_BASE);
c002ae8a:	8d ae 00 00 00 c0    	lea    -0x40000000(%esi),%ebp
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002ae90:	81 ee 00 f0 ff 3f    	sub    $0x3ffff000,%esi
c002ae96:	39 f5                	cmp    %esi,%ebp
c002ae98:	73 bf                	jae    c002ae59 <pagedir_destroy+0xc3>
c002ae9a:	89 eb                	mov    %ebp,%ebx
c002ae9c:	eb 96                	jmp    c002ae34 <pagedir_destroy+0x9e>
  palloc_free_page (pd);
c002ae9e:	83 ec 0c             	sub    $0xc,%esp
c002aea1:	ff 74 24 3c          	pushl  0x3c(%esp)
c002aea5:	e8 2e 89 ff ff       	call   c00237d8 <palloc_free_page>
c002aeaa:	83 c4 10             	add    $0x10,%esp
}
c002aead:	83 c4 1c             	add    $0x1c,%esp
c002aeb0:	5b                   	pop    %ebx
c002aeb1:	5e                   	pop    %esi
c002aeb2:	5f                   	pop    %edi
c002aeb3:	5d                   	pop    %ebp
c002aeb4:	c3                   	ret    

c002aeb5 <pagedir_set_page>:
   otherwise it is read-only.
   Returns true if successful, false if memory allocation
   failed. */
bool
pagedir_set_page (uint32_t *pd, void *upage, void *kpage, bool writable)
{
c002aeb5:	56                   	push   %esi
c002aeb6:	53                   	push   %ebx
c002aeb7:	83 ec 04             	sub    $0x4,%esp
c002aeba:	8b 44 24 10          	mov    0x10(%esp),%eax
c002aebe:	8b 54 24 14          	mov    0x14(%esp),%edx
c002aec2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c002aec6:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  uint32_t *pte;

  ASSERT (pg_ofs (upage) == 0);
c002aeca:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002aed0:	75 7f                	jne    c002af51 <pagedir_set_page+0x9c>
  ASSERT (pg_ofs (kpage) == 0);
c002aed2:	f7 c1 ff 0f 00 00    	test   $0xfff,%ecx
c002aed8:	0f 85 91 00 00 00    	jne    c002af6f <pagedir_set_page+0xba>
  ASSERT (is_user_vaddr (upage));
c002aede:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002aee4:	0f 87 a3 00 00 00    	ja     c002af8d <pagedir_set_page+0xd8>
  ASSERT (is_kernel_vaddr (vaddr));
c002aeea:	81 f9 ff ff ff bf    	cmp    $0xbfffffff,%ecx
c002aef0:	0f 86 b5 00 00 00    	jbe    c002afab <pagedir_set_page+0xf6>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002aef6:	8d 99 00 00 00 40    	lea    0x40000000(%ecx),%ebx
  ASSERT (vtop (kpage) >> PTSHIFT < init_ram_pages);
c002aefc:	89 d9                	mov    %ebx,%ecx
c002aefe:	c1 e9 0c             	shr    $0xc,%ecx
c002af01:	3b 0d 5e 01 02 c0    	cmp    0xc002015e,%ecx
c002af07:	0f 83 bc 00 00 00    	jae    c002afc9 <pagedir_set_page+0x114>
  ASSERT (pd != init_page_dir);
c002af0d:	39 05 34 6c 04 c0    	cmp    %eax,0xc0046c34
c002af13:	0f 84 ce 00 00 00    	je     c002afe7 <pagedir_set_page+0x132>

  pte = lookup_page (pd, upage, true);
c002af19:	b9 01 00 00 00       	mov    $0x1,%ecx
c002af1e:	e8 ea fc ff ff       	call   c002ac0d <lookup_page>

  if (pte != NULL) 
c002af23:	85 c0                	test   %eax,%eax
c002af25:	0f 84 f8 00 00 00    	je     c002b023 <pagedir_set_page+0x16e>
    {
      ASSERT ((*pte & PTE_P) == 0);
c002af2b:	f6 00 01             	testb  $0x1,(%eax)
c002af2e:	0f 85 d1 00 00 00    	jne    c002b005 <pagedir_set_page+0x150>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002af34:	89 f2                	mov    %esi,%edx
c002af36:	84 d2                	test   %dl,%dl
c002af38:	0f 95 c1             	setne  %cl
c002af3b:	0f b6 c9             	movzbl %cl,%ecx
c002af3e:	d1 e1                	shl    %ecx
  return pte_create_kernel (page, writable) | PTE_U;
c002af40:	83 cb 05             	or     $0x5,%ebx
c002af43:	89 da                	mov    %ebx,%edx
c002af45:	09 ca                	or     %ecx,%edx
c002af47:	89 10                	mov    %edx,(%eax)
      *pte = pte_create_user (kpage, writable);
      return true;
c002af49:	b0 01                	mov    $0x1,%al
    }
  else
    return false;
}
c002af4b:	83 c4 04             	add    $0x4,%esp
c002af4e:	5b                   	pop    %ebx
c002af4f:	5e                   	pop    %esi
c002af50:	c3                   	ret    
  ASSERT (pg_ofs (upage) == 0);
c002af51:	83 ec 0c             	sub    $0xc,%esp
c002af54:	68 74 2d 03 c0       	push   $0xc0032d74
c002af59:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002af5e:	68 c4 09 03 c0       	push   $0xc00309c4
c002af63:	6a 67                	push   $0x67
c002af65:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002af6a:	e8 0e d7 ff ff       	call   c002867d <debug_panic>
  ASSERT (pg_ofs (kpage) == 0);
c002af6f:	83 ec 0c             	sub    $0xc,%esp
c002af72:	68 88 2d 03 c0       	push   $0xc0032d88
c002af77:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002af7c:	68 c4 09 03 c0       	push   $0xc00309c4
c002af81:	6a 68                	push   $0x68
c002af83:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002af88:	e8 f0 d6 ff ff       	call   c002867d <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002af8d:	83 ec 0c             	sub    $0xc,%esp
c002af90:	68 9c 2d 03 c0       	push   $0xc0032d9c
c002af95:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002af9a:	68 c4 09 03 c0       	push   $0xc00309c4
c002af9f:	6a 69                	push   $0x69
c002afa1:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002afa6:	e8 d2 d6 ff ff       	call   c002867d <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c002afab:	83 ec 0c             	sub    $0xc,%esp
c002afae:	68 de 0c 03 c0       	push   $0xc0030cde
c002afb3:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002afb8:	68 bc 09 03 c0       	push   $0xc00309bc
c002afbd:	6a 54                	push   $0x54
c002afbf:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002afc4:	e8 b4 d6 ff ff       	call   c002867d <debug_panic>
  ASSERT (vtop (kpage) >> PTSHIFT < init_ram_pages);
c002afc9:	83 ec 0c             	sub    $0xc,%esp
c002afcc:	68 00 2e 03 c0       	push   $0xc0032e00
c002afd1:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002afd6:	68 c4 09 03 c0       	push   $0xc00309c4
c002afdb:	6a 6a                	push   $0x6a
c002afdd:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002afe2:	e8 96 d6 ff ff       	call   c002867d <debug_panic>
  ASSERT (pd != init_page_dir);
c002afe7:	83 ec 0c             	sub    $0xc,%esp
c002afea:	68 60 2d 03 c0       	push   $0xc0032d60
c002afef:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002aff4:	68 c4 09 03 c0       	push   $0xc00309c4
c002aff9:	6a 6b                	push   $0x6b
c002affb:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002b000:	e8 78 d6 ff ff       	call   c002867d <debug_panic>
      ASSERT ((*pte & PTE_P) == 0);
c002b005:	83 ec 0c             	sub    $0xc,%esp
c002b008:	68 b2 2d 03 c0       	push   $0xc0032db2
c002b00d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002b012:	68 c4 09 03 c0       	push   $0xc00309c4
c002b017:	6a 71                	push   $0x71
c002b019:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002b01e:	e8 5a d6 ff ff       	call   c002867d <debug_panic>
    return false;
c002b023:	b0 00                	mov    $0x0,%al
c002b025:	e9 21 ff ff ff       	jmp    c002af4b <pagedir_set_page+0x96>

c002b02a <pagedir_get_page>:
   address UADDR in PD.  Returns the kernel virtual address
   corresponding to that physical address, or a null pointer if
   UADDR is unmapped. */
void *
pagedir_get_page (uint32_t *pd, const void *uaddr) 
{
c002b02a:	53                   	push   %ebx
c002b02b:	83 ec 08             	sub    $0x8,%esp
c002b02e:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  uint32_t *pte;

  ASSERT (is_user_vaddr (uaddr));
c002b032:	81 fb ff ff ff bf    	cmp    $0xbfffffff,%ebx
c002b038:	77 39                	ja     c002b073 <pagedir_get_page+0x49>
  
  pte = lookup_page (pd, uaddr, false);
c002b03a:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b03f:	89 da                	mov    %ebx,%edx
c002b041:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b045:	e8 c3 fb ff ff       	call   c002ac0d <lookup_page>
  if (pte != NULL && (*pte & PTE_P) != 0)
c002b04a:	85 c0                	test   %eax,%eax
c002b04c:	74 64                	je     c002b0b2 <pagedir_get_page+0x88>
c002b04e:	8b 00                	mov    (%eax),%eax
c002b050:	a8 01                	test   $0x1,%al
c002b052:	74 65                	je     c002b0b9 <pagedir_get_page+0x8f>
  return ptov (pte & PTE_ADDR);
c002b054:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c002b059:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002b05e:	77 34                	ja     c002b094 <pagedir_get_page+0x6a>
  return (uintptr_t) va & PGMASK;
c002b060:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
    return pte_get_page (*pte) + pg_ofs (uaddr);
c002b066:	09 c3                	or     %eax,%ebx
c002b068:	8d 83 00 00 00 c0    	lea    -0x40000000(%ebx),%eax
  else
    return NULL;
}
c002b06e:	83 c4 08             	add    $0x8,%esp
c002b071:	5b                   	pop    %ebx
c002b072:	c3                   	ret    
  ASSERT (is_user_vaddr (uaddr));
c002b073:	83 ec 0c             	sub    $0xc,%esp
c002b076:	68 c6 2d 03 c0       	push   $0xc0032dc6
c002b07b:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002b080:	68 90 09 03 c0       	push   $0xc0030990
c002b085:	68 82 00 00 00       	push   $0x82
c002b08a:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002b08f:	e8 e9 d5 ff ff       	call   c002867d <debug_panic>
  ASSERT ((void *) paddr < PHYS_BASE);
c002b094:	83 ec 0c             	sub    $0xc,%esp
c002b097:	68 6b 19 03 c0       	push   $0xc003196b
c002b09c:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002b0a1:	68 d8 09 03 c0       	push   $0xc00309d8
c002b0a6:	6a 4a                	push   $0x4a
c002b0a8:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002b0ad:	e8 cb d5 ff ff       	call   c002867d <debug_panic>
    return NULL;
c002b0b2:	b8 00 00 00 00       	mov    $0x0,%eax
c002b0b7:	eb b5                	jmp    c002b06e <pagedir_get_page+0x44>
c002b0b9:	b8 00 00 00 00       	mov    $0x0,%eax
c002b0be:	eb ae                	jmp    c002b06e <pagedir_get_page+0x44>

c002b0c0 <pagedir_is_dirty>:
   that is, if the page has been modified since the PTE was
   installed.
   Returns false if PD contains no PTE for VPAGE. */
bool
pagedir_is_dirty (uint32_t *pd, const void *vpage) 
{
c002b0c0:	83 ec 0c             	sub    $0xc,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002b0c3:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b0c8:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b0cc:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b0d0:	e8 38 fb ff ff       	call   c002ac0d <lookup_page>
  return pte != NULL && (*pte & PTE_D) != 0;
c002b0d5:	85 c0                	test   %eax,%eax
c002b0d7:	74 0f                	je     c002b0e8 <pagedir_is_dirty+0x28>
c002b0d9:	8b 00                	mov    (%eax),%eax
c002b0db:	c1 e8 06             	shr    $0x6,%eax
c002b0de:	83 e0 01             	and    $0x1,%eax
c002b0e1:	83 e0 01             	and    $0x1,%eax
}
c002b0e4:	83 c4 0c             	add    $0xc,%esp
c002b0e7:	c3                   	ret    
c002b0e8:	b0 00                	mov    $0x0,%al
c002b0ea:	eb f5                	jmp    c002b0e1 <pagedir_is_dirty+0x21>

c002b0ec <pagedir_is_accessed>:
   accessed recently, that is, between the time the PTE was
   installed and the last time it was cleared.  Returns false if
   PD contains no PTE for VPAGE. */
bool
pagedir_is_accessed (uint32_t *pd, const void *vpage) 
{
c002b0ec:	83 ec 0c             	sub    $0xc,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002b0ef:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b0f4:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b0f8:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b0fc:	e8 0c fb ff ff       	call   c002ac0d <lookup_page>
  return pte != NULL && (*pte & PTE_A) != 0;
c002b101:	85 c0                	test   %eax,%eax
c002b103:	74 0f                	je     c002b114 <pagedir_is_accessed+0x28>
c002b105:	8b 00                	mov    (%eax),%eax
c002b107:	c1 e8 05             	shr    $0x5,%eax
c002b10a:	83 e0 01             	and    $0x1,%eax
c002b10d:	83 e0 01             	and    $0x1,%eax
}
c002b110:	83 c4 0c             	add    $0xc,%esp
c002b113:	c3                   	ret    
c002b114:	b0 00                	mov    $0x0,%al
c002b116:	eb f5                	jmp    c002b10d <pagedir_is_accessed+0x21>

c002b118 <pagedir_activate>:

/* Loads page directory PD into the CPU's page directory base
   register. */
void
pagedir_activate (uint32_t *pd) 
{
c002b118:	83 ec 0c             	sub    $0xc,%esp
c002b11b:	8b 44 24 10          	mov    0x10(%esp),%eax
  if (pd == NULL)
c002b11f:	85 c0                	test   %eax,%eax
c002b121:	74 13                	je     c002b136 <pagedir_activate+0x1e>
  ASSERT (is_kernel_vaddr (vaddr));
c002b123:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002b128:	76 13                	jbe    c002b13d <pagedir_activate+0x25>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002b12a:	05 00 00 00 40       	add    $0x40000000,%eax
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
     Address of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (pd)) : "memory");
c002b12f:	0f 22 d8             	mov    %eax,%cr3
}
c002b132:	83 c4 0c             	add    $0xc,%esp
c002b135:	c3                   	ret    
    pd = init_page_dir;
c002b136:	a1 34 6c 04 c0       	mov    0xc0046c34,%eax
c002b13b:	eb e6                	jmp    c002b123 <pagedir_activate+0xb>
  ASSERT (is_kernel_vaddr (vaddr));
c002b13d:	83 ec 0c             	sub    $0xc,%esp
c002b140:	68 de 0c 03 c0       	push   $0xc0030cde
c002b145:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002b14a:	68 bc 09 03 c0       	push   $0xc00309bc
c002b14f:	6a 54                	push   $0x54
c002b151:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002b156:	e8 22 d5 ff ff       	call   c002867d <debug_panic>

c002b15b <invalidate_pagedir>:
   This function invalidates the TLB if PD is the active page
   directory.  (If PD is not active then its entries are not in
   the TLB, so there is no need to invalidate anything.) */
static void
invalidate_pagedir (uint32_t *pd) 
{
c002b15b:	83 ec 0c             	sub    $0xc,%esp
  asm volatile ("movl %%cr3, %0" : "=r" (pd));
c002b15e:	0f 20 da             	mov    %cr3,%edx
  ASSERT ((void *) paddr < PHYS_BASE);
c002b161:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002b167:	77 0e                	ja     c002b177 <invalidate_pagedir+0x1c>
  return (void *) (paddr + PHYS_BASE);
c002b169:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
  if (active_pd () == pd) 
c002b16f:	39 d0                	cmp    %edx,%eax
c002b171:	74 22                	je     c002b195 <invalidate_pagedir+0x3a>
    {
      /* Re-activating PD clears the TLB.  See [IA32-v3a] 3.12
         "Translation Lookaside Buffers (TLBs)". */
      pagedir_activate (pd);
    } 
}
c002b173:	83 c4 0c             	add    $0xc,%esp
c002b176:	c3                   	ret    
  ASSERT ((void *) paddr < PHYS_BASE);
c002b177:	83 ec 0c             	sub    $0xc,%esp
c002b17a:	68 6b 19 03 c0       	push   $0xc003196b
c002b17f:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002b184:	68 d8 09 03 c0       	push   $0xc00309d8
c002b189:	6a 4a                	push   $0x4a
c002b18b:	68 f6 0c 03 c0       	push   $0xc0030cf6
c002b190:	e8 e8 d4 ff ff       	call   c002867d <debug_panic>
      pagedir_activate (pd);
c002b195:	83 ec 0c             	sub    $0xc,%esp
c002b198:	50                   	push   %eax
c002b199:	e8 7a ff ff ff       	call   c002b118 <pagedir_activate>
c002b19e:	83 c4 10             	add    $0x10,%esp
}
c002b1a1:	eb d0                	jmp    c002b173 <invalidate_pagedir+0x18>

c002b1a3 <pagedir_clear_page>:
{
c002b1a3:	83 ec 0c             	sub    $0xc,%esp
c002b1a6:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (pg_ofs (upage) == 0);
c002b1aa:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002b1b0:	75 25                	jne    c002b1d7 <pagedir_clear_page+0x34>
  ASSERT (is_user_vaddr (upage));
c002b1b2:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002b1b8:	77 3e                	ja     c002b1f8 <pagedir_clear_page+0x55>
  pte = lookup_page (pd, upage, false);
c002b1ba:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b1bf:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b1c3:	e8 45 fa ff ff       	call   c002ac0d <lookup_page>
  if (pte != NULL && (*pte & PTE_P) != 0)
c002b1c8:	85 c0                	test   %eax,%eax
c002b1ca:	74 07                	je     c002b1d3 <pagedir_clear_page+0x30>
c002b1cc:	8b 10                	mov    (%eax),%edx
c002b1ce:	f6 c2 01             	test   $0x1,%dl
c002b1d1:	75 46                	jne    c002b219 <pagedir_clear_page+0x76>
}
c002b1d3:	83 c4 0c             	add    $0xc,%esp
c002b1d6:	c3                   	ret    
  ASSERT (pg_ofs (upage) == 0);
c002b1d7:	83 ec 0c             	sub    $0xc,%esp
c002b1da:	68 74 2d 03 c0       	push   $0xc0032d74
c002b1df:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002b1e4:	68 7c 09 03 c0       	push   $0xc003097c
c002b1e9:	68 94 00 00 00       	push   $0x94
c002b1ee:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002b1f3:	e8 85 d4 ff ff       	call   c002867d <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002b1f8:	83 ec 0c             	sub    $0xc,%esp
c002b1fb:	68 9c 2d 03 c0       	push   $0xc0032d9c
c002b200:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002b205:	68 7c 09 03 c0       	push   $0xc003097c
c002b20a:	68 95 00 00 00       	push   $0x95
c002b20f:	68 3b 2d 03 c0       	push   $0xc0032d3b
c002b214:	e8 64 d4 ff ff       	call   c002867d <debug_panic>
      *pte &= ~PTE_P;
c002b219:	83 e2 fe             	and    $0xfffffffe,%edx
c002b21c:	89 10                	mov    %edx,(%eax)
      invalidate_pagedir (pd);
c002b21e:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b222:	e8 34 ff ff ff       	call   c002b15b <invalidate_pagedir>
}
c002b227:	eb aa                	jmp    c002b1d3 <pagedir_clear_page+0x30>

c002b229 <pagedir_set_dirty>:
{
c002b229:	53                   	push   %ebx
c002b22a:	83 ec 08             	sub    $0x8,%esp
c002b22d:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  uint32_t *pte = lookup_page (pd, vpage, false);
c002b231:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b236:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b23a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b23e:	e8 ca f9 ff ff       	call   c002ac0d <lookup_page>
  if (pte != NULL) 
c002b243:	85 c0                	test   %eax,%eax
c002b245:	74 07                	je     c002b24e <pagedir_set_dirty+0x25>
      if (dirty)
c002b247:	84 db                	test   %bl,%bl
c002b249:	74 08                	je     c002b253 <pagedir_set_dirty+0x2a>
        *pte |= PTE_D;
c002b24b:	83 08 40             	orl    $0x40,(%eax)
}
c002b24e:	83 c4 08             	add    $0x8,%esp
c002b251:	5b                   	pop    %ebx
c002b252:	c3                   	ret    
          *pte &= ~(uint32_t) PTE_D;
c002b253:	83 20 bf             	andl   $0xffffffbf,(%eax)
          invalidate_pagedir (pd);
c002b256:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b25a:	e8 fc fe ff ff       	call   c002b15b <invalidate_pagedir>
}
c002b25f:	eb ed                	jmp    c002b24e <pagedir_set_dirty+0x25>

c002b261 <pagedir_set_accessed>:
{
c002b261:	53                   	push   %ebx
c002b262:	83 ec 08             	sub    $0x8,%esp
c002b265:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  uint32_t *pte = lookup_page (pd, vpage, false);
c002b269:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b26e:	8b 54 24 14          	mov    0x14(%esp),%edx
c002b272:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b276:	e8 92 f9 ff ff       	call   c002ac0d <lookup_page>
  if (pte != NULL) 
c002b27b:	85 c0                	test   %eax,%eax
c002b27d:	74 07                	je     c002b286 <pagedir_set_accessed+0x25>
      if (accessed)
c002b27f:	84 db                	test   %bl,%bl
c002b281:	74 08                	je     c002b28b <pagedir_set_accessed+0x2a>
        *pte |= PTE_A;
c002b283:	83 08 20             	orl    $0x20,(%eax)
}
c002b286:	83 c4 08             	add    $0x8,%esp
c002b289:	5b                   	pop    %ebx
c002b28a:	c3                   	ret    
          *pte &= ~(uint32_t) PTE_A; 
c002b28b:	83 20 df             	andl   $0xffffffdf,(%eax)
          invalidate_pagedir (pd);
c002b28e:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b292:	e8 c4 fe ff ff       	call   c002b15b <invalidate_pagedir>
}
c002b297:	eb ed                	jmp    c002b286 <pagedir_set_accessed+0x25>

c002b299 <kill>:
}

/* Handler for an exception (probably) caused by a user process. */
static void
kill (struct intr_frame *f) 
{
c002b299:	57                   	push   %edi
c002b29a:	56                   	push   %esi
c002b29b:	53                   	push   %ebx
c002b29c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
     exceptions back to the process via signals, but we don't
     implement them. */
     
  /* The interrupt frame's code segment value tells us where the
     exception originated. */
  switch (f->cs)
c002b2a0:	8b 73 40             	mov    0x40(%ebx),%esi
c002b2a3:	66 83 fe 08          	cmp    $0x8,%si
c002b2a7:	74 38                	je     c002b2e1 <kill+0x48>
c002b2a9:	66 83 fe 1b          	cmp    $0x1b,%si
c002b2ad:	75 51                	jne    c002b300 <kill+0x67>
    {
    case SEL_UCSEG:
      /* User's code segment, so it's a user exception, as we
         expected.  Kill the user process.  */

      printf ("%s: dying due to interrupt %#04x (%s).\n",
c002b2af:	83 ec 0c             	sub    $0xc,%esp
c002b2b2:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
c002b2b6:	50                   	push   %eax
c002b2b7:	e8 08 6c ff ff       	call   c0021ec4 <intr_name>
c002b2bc:	89 c7                	mov    %eax,%edi
c002b2be:	8b 73 30             	mov    0x30(%ebx),%esi
c002b2c1:	e8 15 5b ff ff       	call   c0020ddb <thread_name>
c002b2c6:	57                   	push   %edi
c002b2c7:	56                   	push   %esi
c002b2c8:	50                   	push   %eax
c002b2c9:	68 2c 2e 03 c0       	push   $0xc0032e2c
c002b2ce:	e8 fc b8 ff ff       	call   c0026bcf <printf>
              thread_name (), f->vec_no, intr_name (f->vec_no));
      intr_dump_frame (f);
c002b2d3:	83 c4 14             	add    $0x14,%esp
c002b2d6:	53                   	push   %ebx
c002b2d7:	e8 5b 6b ff ff       	call   c0021e37 <intr_dump_frame>
      thread_exit ();
c002b2dc:	e8 cd 64 ff ff       	call   c00217ae <thread_exit>
         Kernel code shouldn't throw exceptions.  (Page faults
         may cause kernel exceptions--but they shouldn't arrive
         here.)  Panic the kernel to make the point.  */
	    /* modified */

	    intr_dump_frame (f);
c002b2e1:	83 ec 0c             	sub    $0xc,%esp
c002b2e4:	53                   	push   %ebx
c002b2e5:	e8 4d 6b ff ff       	call   c0021e37 <intr_dump_frame>

      PANIC ("Kernel bug - unexpected interrupt in kernel"); 
c002b2ea:	68 54 2e 03 c0       	push   $0xc0032e54
c002b2ef:	68 fc 09 03 c0       	push   $0xc00309fc
c002b2f4:	6a 69                	push   $0x69
c002b2f6:	68 e3 2e 03 c0       	push   $0xc0032ee3
c002b2fb:	e8 7d d3 ff ff       	call   c002867d <debug_panic>
      /* Some other code segment?  Shouldn't happen.  Panic the
         kernel. */

	    /* modified */

      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002b300:	83 ec 0c             	sub    $0xc,%esp
c002b303:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
c002b307:	50                   	push   %eax
c002b308:	e8 b7 6b ff ff       	call   c0021ec4 <intr_name>
  switch (f->cs)
c002b30d:	0f b7 f6             	movzwl %si,%esi
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002b310:	56                   	push   %esi
c002b311:	50                   	push   %eax
c002b312:	ff 73 30             	pushl  0x30(%ebx)
c002b315:	68 80 2e 03 c0       	push   $0xc0032e80
c002b31a:	e8 b0 b8 ff ff       	call   c0026bcf <printf>
             f->vec_no, intr_name (f->vec_no), f->cs);
      thread_exit ();
c002b31f:	83 c4 20             	add    $0x20,%esp
c002b322:	e8 87 64 ff ff       	call   c00217ae <thread_exit>

c002b327 <page_fault>:
   can find more information about both of these in the
   description of "Interrupt 14--Page Fault Exception (#PF)" in
   [IA32-v3a] section 5.15 "Exception and Interrupt Reference". */
static void
page_fault (struct intr_frame *f) 
{
c002b327:	55                   	push   %ebp
c002b328:	57                   	push   %edi
c002b329:	56                   	push   %esi
c002b32a:	53                   	push   %ebx
c002b32b:	83 ec 0c             	sub    $0xc,%esp
c002b32e:	8b 6c 24 20          	mov    0x20(%esp),%ebp
     data.  It is not necessarily the address of the instruction
     that caused the fault (that's f->eip).
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (fault_addr));
c002b332:	0f 20 d7             	mov    %cr2,%edi

  /* Turn interrupts back on (they were only off so that we could
     be assured of reading CR2 before it changed). */
  intr_enable ();
c002b335:	e8 ed 66 ff ff       	call   c0021a27 <intr_enable>

  /* Count page faults. */
  page_fault_cnt++;
c002b33a:	83 05 b8 e4 03 c0 01 	addl   $0x1,0xc003e4b8
c002b341:	83 15 bc e4 03 c0 00 	adcl   $0x0,0xc003e4bc

  /* Determine cause. */
  not_present = (f->error_code & PF_P) == 0;
c002b348:	8b 5d 34             	mov    0x34(%ebp),%ebx
c002b34b:	89 de                	mov    %ebx,%esi
c002b34d:	83 e6 01             	and    $0x1,%esi
  write = (f->error_code & PF_W) != 0;
  user = (f->error_code & PF_U) != 0;

  sema_up(&thread_current()->parent->load_sema);
c002b350:	e8 c1 59 ff ff       	call   c0020d16 <thread_current>
c002b355:	83 ec 0c             	sub    $0xc,%esp
c002b358:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c002b35e:	83 c0 78             	add    $0x78,%eax
c002b361:	50                   	push   %eax
c002b362:	e8 6d 78 ff ff       	call   c0022bd4 <sema_up>
#ifdef VM
	if (user && not_present) {
c002b367:	83 c4 10             	add    $0x10,%esp
c002b36a:	f6 c3 04             	test   $0x4,%bl
c002b36d:	74 74                	je     c002b3e3 <page_fault+0xbc>
c002b36f:	85 f6                	test   %esi,%esi
c002b371:	0f 85 8a 00 00 00    	jne    c002b401 <page_fault+0xda>
		if (!page_in (fault_addr)) {
c002b377:	83 ec 0c             	sub    $0xc,%esp
c002b37a:	57                   	push   %edi
c002b37b:	e8 78 3b 00 00       	call   c002eef8 <page_in>
c002b380:	83 c4 10             	add    $0x10,%esp
c002b383:	85 c0                	test   %eax,%eax
c002b385:	74 08                	je     c002b38f <page_fault+0x68>
          fault_addr,
          not_present ? "not present" : "rights violation",
          write ? "writing" : "reading",
          user ? "user" : "kernel");
  kill (f);
}
c002b387:	83 c4 0c             	add    $0xc,%esp
c002b38a:	5b                   	pop    %ebx
c002b38b:	5e                   	pop    %esi
c002b38c:	5f                   	pop    %edi
c002b38d:	5d                   	pop    %ebp
c002b38e:	c3                   	ret    
			syscall_exit_helper(-1);
c002b38f:	83 ec 0c             	sub    $0xc,%esp
c002b392:	6a ff                	push   $0xffffffff
c002b394:	e8 43 02 00 00       	call   c002b5dc <syscall_exit_helper>
c002b399:	83 c4 10             	add    $0x10,%esp
c002b39c:	eb e9                	jmp    c002b387 <page_fault+0x60>
  printf ("Page fault at %p: %s error %s page in %s context.\n",
c002b39e:	ba cc 1e 03 c0       	mov    $0xc0031ecc,%edx
c002b3a3:	b8 fe 2e 03 c0       	mov    $0xc0032efe,%eax
c002b3a8:	b9 13 2f 03 c0       	mov    $0xc0032f13,%ecx
c002b3ad:	85 f6                	test   %esi,%esi
c002b3af:	75 1a                	jne    c002b3cb <page_fault+0xa4>
c002b3b1:	83 ec 0c             	sub    $0xc,%esp
c002b3b4:	52                   	push   %edx
c002b3b5:	50                   	push   %eax
c002b3b6:	51                   	push   %ecx
c002b3b7:	57                   	push   %edi
c002b3b8:	68 b0 2e 03 c0       	push   $0xc0032eb0
c002b3bd:	e8 0d b8 ff ff       	call   c0026bcf <printf>
  kill (f);
c002b3c2:	83 c4 14             	add    $0x14,%esp
c002b3c5:	55                   	push   %ebp
c002b3c6:	e8 ce fe ff ff       	call   c002b299 <kill>
  printf ("Page fault at %p: %s error %s page in %s context.\n",
c002b3cb:	b9 1f 2f 03 c0       	mov    $0xc0032f1f,%ecx
c002b3d0:	eb df                	jmp    c002b3b1 <page_fault+0x8a>
c002b3d2:	b8 fe 2e 03 c0       	mov    $0xc0032efe,%eax
c002b3d7:	ba 0e 2f 03 c0       	mov    $0xc0032f0e,%edx
c002b3dc:	b9 1f 2f 03 c0       	mov    $0xc0032f1f,%ecx
c002b3e1:	eb ce                	jmp    c002b3b1 <page_fault+0x8a>
  syscall_exit_helper(-1);
c002b3e3:	83 ec 0c             	sub    $0xc,%esp
c002b3e6:	6a ff                	push   $0xffffffff
c002b3e8:	e8 ef 01 00 00       	call   c002b5dc <syscall_exit_helper>
  printf ("Page fault at %p: %s error %s page in %s context.\n",
c002b3ed:	83 c4 10             	add    $0x10,%esp
c002b3f0:	f6 c3 02             	test   $0x2,%bl
c002b3f3:	75 a9                	jne    c002b39e <page_fault+0x77>
c002b3f5:	ba cc 1e 03 c0       	mov    $0xc0031ecc,%edx
c002b3fa:	b8 06 2f 03 c0       	mov    $0xc0032f06,%eax
c002b3ff:	eb a7                	jmp    c002b3a8 <page_fault+0x81>
  syscall_exit_helper(-1);
c002b401:	83 ec 0c             	sub    $0xc,%esp
c002b404:	6a ff                	push   $0xffffffff
c002b406:	e8 d1 01 00 00       	call   c002b5dc <syscall_exit_helper>
  printf ("Page fault at %p: %s error %s page in %s context.\n",
c002b40b:	83 c4 10             	add    $0x10,%esp
c002b40e:	f6 c3 02             	test   $0x2,%bl
c002b411:	75 bf                	jne    c002b3d2 <page_fault+0xab>
c002b413:	ba 0e 2f 03 c0       	mov    $0xc0032f0e,%edx
c002b418:	b8 06 2f 03 c0       	mov    $0xc0032f06,%eax
c002b41d:	eb 89                	jmp    c002b3a8 <page_fault+0x81>

c002b41f <exception_init>:
{
c002b41f:	83 ec 18             	sub    $0x18,%esp
  intr_register_int (3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
c002b422:	68 16 15 03 c0       	push   $0xc0031516
c002b427:	68 99 b2 02 c0       	push   $0xc002b299
c002b42c:	6a 01                	push   $0x1
c002b42e:	6a 03                	push   $0x3
c002b430:	6a 03                	push   $0x3
c002b432:	e8 f6 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (4, 3, INTR_ON, kill, "#OF Overflow Exception");
c002b437:	83 c4 14             	add    $0x14,%esp
c002b43a:	68 2f 15 03 c0       	push   $0xc003152f
c002b43f:	68 99 b2 02 c0       	push   $0xc002b299
c002b444:	6a 01                	push   $0x1
c002b446:	6a 03                	push   $0x3
c002b448:	6a 04                	push   $0x4
c002b44a:	e8 de 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (5, 3, INTR_ON, kill,
c002b44f:	83 c4 14             	add    $0x14,%esp
c002b452:	68 6c 16 03 c0       	push   $0xc003166c
c002b457:	68 99 b2 02 c0       	push   $0xc002b299
c002b45c:	6a 01                	push   $0x1
c002b45e:	6a 03                	push   $0x3
c002b460:	6a 05                	push   $0x5
c002b462:	e8 c6 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (0, 0, INTR_ON, kill, "#DE Divide Error");
c002b467:	83 c4 14             	add    $0x14,%esp
c002b46a:	68 e3 14 03 c0       	push   $0xc00314e3
c002b46f:	68 99 b2 02 c0       	push   $0xc002b299
c002b474:	6a 01                	push   $0x1
c002b476:	6a 00                	push   $0x0
c002b478:	6a 00                	push   $0x0
c002b47a:	e8 ae 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (1, 0, INTR_ON, kill, "#DB Debug Exception");
c002b47f:	83 c4 14             	add    $0x14,%esp
c002b482:	68 f4 14 03 c0       	push   $0xc00314f4
c002b487:	68 99 b2 02 c0       	push   $0xc002b299
c002b48c:	6a 01                	push   $0x1
c002b48e:	6a 00                	push   $0x0
c002b490:	6a 01                	push   $0x1
c002b492:	e8 96 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
c002b497:	83 c4 14             	add    $0x14,%esp
c002b49a:	68 46 15 03 c0       	push   $0xc0031546
c002b49f:	68 99 b2 02 c0       	push   $0xc002b299
c002b4a4:	6a 01                	push   $0x1
c002b4a6:	6a 00                	push   $0x0
c002b4a8:	6a 06                	push   $0x6
c002b4aa:	e8 7e 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (7, 0, INTR_ON, kill,
c002b4af:	83 c4 14             	add    $0x14,%esp
c002b4b2:	68 90 16 03 c0       	push   $0xc0031690
c002b4b7:	68 99 b2 02 c0       	push   $0xc002b299
c002b4bc:	6a 01                	push   $0x1
c002b4be:	6a 00                	push   $0x0
c002b4c0:	6a 07                	push   $0x7
c002b4c2:	e8 66 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (11, 0, INTR_ON, kill, "#NP Segment Not Present");
c002b4c7:	83 c4 14             	add    $0x14,%esp
c002b4ca:	68 b4 15 03 c0       	push   $0xc00315b4
c002b4cf:	68 99 b2 02 c0       	push   $0xc002b299
c002b4d4:	6a 01                	push   $0x1
c002b4d6:	6a 00                	push   $0x0
c002b4d8:	6a 0b                	push   $0xb
c002b4da:	e8 4e 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
c002b4df:	83 c4 14             	add    $0x14,%esp
c002b4e2:	68 cc 15 03 c0       	push   $0xc00315cc
c002b4e7:	68 99 b2 02 c0       	push   $0xc002b299
c002b4ec:	6a 01                	push   $0x1
c002b4ee:	6a 00                	push   $0x0
c002b4f0:	6a 0c                	push   $0xc
c002b4f2:	e8 36 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (13, 0, INTR_ON, kill, "#GP General Protection Exception");
c002b4f7:	83 c4 14             	add    $0x14,%esp
c002b4fa:	68 b4 16 03 c0       	push   $0xc00316b4
c002b4ff:	68 99 b2 02 c0       	push   $0xc002b299
c002b504:	6a 01                	push   $0x1
c002b506:	6a 00                	push   $0x0
c002b508:	6a 0d                	push   $0xd
c002b50a:	e8 1e 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
c002b50f:	83 c4 14             	add    $0x14,%esp
c002b512:	68 d8 16 03 c0       	push   $0xc00316d8
c002b517:	68 99 b2 02 c0       	push   $0xc002b299
c002b51c:	6a 01                	push   $0x1
c002b51e:	6a 00                	push   $0x0
c002b520:	6a 10                	push   $0x10
c002b522:	e8 06 67 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (19, 0, INTR_ON, kill,
c002b527:	83 c4 14             	add    $0x14,%esp
c002b52a:	68 fc 16 03 c0       	push   $0xc00316fc
c002b52f:	68 99 b2 02 c0       	push   $0xc002b299
c002b534:	6a 01                	push   $0x1
c002b536:	6a 00                	push   $0x0
c002b538:	6a 13                	push   $0x13
c002b53a:	e8 ee 66 ff ff       	call   c0021c2d <intr_register_int>
  intr_register_int (14, 0, INTR_OFF, page_fault, "#PF Page-Fault Exception");
c002b53f:	83 c4 14             	add    $0x14,%esp
c002b542:	68 e6 15 03 c0       	push   $0xc00315e6
c002b547:	68 27 b3 02 c0       	push   $0xc002b327
c002b54c:	6a 00                	push   $0x0
c002b54e:	6a 00                	push   $0x0
c002b550:	6a 0e                	push   $0xe
c002b552:	e8 d6 66 ff ff       	call   c0021c2d <intr_register_int>
}
c002b557:	83 c4 2c             	add    $0x2c,%esp
c002b55a:	c3                   	ret    

c002b55b <exception_print_stats>:
{
c002b55b:	83 ec 10             	sub    $0x10,%esp
  printf ("Exception: %lld page faults\n", page_fault_cnt);
c002b55e:	ff 35 bc e4 03 c0    	pushl  0xc003e4bc
c002b564:	ff 35 b8 e4 03 c0    	pushl  0xc003e4b8
c002b56a:	68 30 2f 03 c0       	push   $0xc0032f30
c002b56f:	e8 5b b6 ff ff       	call   c0026bcf <printf>
}
c002b574:	83 c4 1c             	add    $0x1c,%esp
c002b577:	c3                   	ret    

c002b578 <get_file_by_fd>:
    return fd_e->fd;
  }
}

static struct fd_t*
get_file_by_fd(struct list* files, int fd) {
c002b578:	57                   	push   %edi
c002b579:	56                   	push   %esi
c002b57a:	53                   	push   %ebx
c002b57b:	89 c6                	mov    %eax,%esi
c002b57d:	89 d7                	mov    %edx,%edi
  struct fd_t *entry;
  for (struct list_elem *e = list_begin(files); e != list_end(files); e = list_next(e)) {
c002b57f:	83 ec 0c             	sub    $0xc,%esp
c002b582:	50                   	push   %eax
c002b583:	e8 df d1 ff ff       	call   c0028767 <list_begin>
c002b588:	89 c3                	mov    %eax,%ebx
c002b58a:	83 c4 10             	add    $0x10,%esp
c002b58d:	83 ec 0c             	sub    $0xc,%esp
c002b590:	56                   	push   %esi
c002b591:	e8 49 d2 ff ff       	call   c00287df <list_end>
c002b596:	83 c4 10             	add    $0x10,%esp
c002b599:	39 c3                	cmp    %eax,%ebx
c002b59b:	74 1a                	je     c002b5b7 <get_file_by_fd+0x3f>
    entry = list_entry(e, struct fd_t, elem);
    if (entry->fd == fd)
c002b59d:	39 7b f8             	cmp    %edi,-0x8(%ebx)
c002b5a0:	74 10                	je     c002b5b2 <get_file_by_fd+0x3a>
  for (struct list_elem *e = list_begin(files); e != list_end(files); e = list_next(e)) {
c002b5a2:	83 ec 0c             	sub    $0xc,%esp
c002b5a5:	53                   	push   %ebx
c002b5a6:	e8 ec d1 ff ff       	call   c0028797 <list_next>
c002b5ab:	89 c3                	mov    %eax,%ebx
c002b5ad:	83 c4 10             	add    $0x10,%esp
c002b5b0:	eb db                	jmp    c002b58d <get_file_by_fd+0x15>
    entry = list_entry(e, struct fd_t, elem);
c002b5b2:	8d 43 f4             	lea    -0xc(%ebx),%eax
c002b5b5:	eb 05                	jmp    c002b5bc <get_file_by_fd+0x44>
      return entry;
  }
  return NULL;
c002b5b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b5bc:	5b                   	pop    %ebx
c002b5bd:	5e                   	pop    %esi
c002b5be:	5f                   	pop    %edi
c002b5bf:	c3                   	ret    

c002b5c0 <syscall_init>:
{
c002b5c0:	83 ec 18             	sub    $0x18,%esp
  intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
c002b5c3:	68 4d 2f 03 c0       	push   $0xc0032f4d
c002b5c8:	68 21 b9 02 c0       	push   $0xc002b921
c002b5cd:	6a 01                	push   $0x1
c002b5cf:	6a 03                	push   $0x3
c002b5d1:	6a 30                	push   $0x30
c002b5d3:	e8 55 66 ff ff       	call   c0021c2d <intr_register_int>
}
c002b5d8:	83 c4 2c             	add    $0x2c,%esp
c002b5db:	c3                   	ret    

c002b5dc <syscall_exit_helper>:
syscall_exit_helper(int status) {
c002b5dc:	53                   	push   %ebx
c002b5dd:	83 ec 08             	sub    $0x8,%esp
c002b5e0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  struct thread *t = thread_current();
c002b5e4:	e8 2d 57 ff ff       	call   c0020d16 <thread_current>
  t->ret_status = status;
c002b5e9:	89 58 68             	mov    %ebx,0x68(%eax)
  struct child_process *ch = get_child_by_tid(&t->parent->children, t->tid);
c002b5ec:	83 ec 08             	sub    $0x8,%esp
c002b5ef:	ff 70 04             	pushl  0x4(%eax)
c002b5f2:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c002b5f8:	05 a8 00 00 00       	add    $0xa8,%eax
c002b5fd:	50                   	push   %eax
c002b5fe:	e8 5f 61 ff ff       	call   c0021762 <get_child_by_tid>
  ch->ret_status = status;
c002b603:	89 58 04             	mov    %ebx,0x4(%eax)
  thread_exit();
c002b606:	e8 a3 61 ff ff       	call   c00217ae <thread_exit>

c002b60b <is_valid_addr>:
is_valid_addr(void *addr) {
c002b60b:	83 ec 0c             	sub    $0xc,%esp
	if (!is_user_vaddr(addr) || !(ret = page_for_addr(addr))) {
c002b60e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002b613:	77 1e                	ja     c002b633 <is_valid_addr+0x28>
c002b615:	83 ec 0c             	sub    $0xc,%esp
c002b618:	50                   	push   %eax
c002b619:	e8 65 38 00 00       	call   c002ee83 <page_for_addr>
c002b61e:	89 c2                	mov    %eax,%edx
c002b620:	83 c4 10             	add    $0x10,%esp
c002b623:	85 c0                	test   %eax,%eax
c002b625:	74 0c                	je     c002b633 <is_valid_addr+0x28>
	return true;
c002b627:	b0 01                	mov    $0x1,%al
	if (ret->frame == NULL) {
c002b629:	83 7a 14 00          	cmpl   $0x0,0x14(%edx)
c002b62d:	74 0e                	je     c002b63d <is_valid_addr+0x32>
}
c002b62f:	83 c4 0c             	add    $0xc,%esp
c002b632:	c3                   	ret    
		syscall_exit_helper(-1);
c002b633:	83 ec 0c             	sub    $0xc,%esp
c002b636:	6a ff                	push   $0xffffffff
c002b638:	e8 9f ff ff ff       	call   c002b5dc <syscall_exit_helper>
		if (page_in(ret->vaddr))
c002b63d:	83 ec 0c             	sub    $0xc,%esp
c002b640:	ff 32                	pushl  (%edx)
c002b642:	e8 b1 38 00 00       	call   c002eef8 <page_in>
c002b647:	83 c4 10             	add    $0x10,%esp
c002b64a:	eb e3                	jmp    c002b62f <is_valid_addr+0x24>

c002b64c <pop_stack>:
pop_stack(int *esp, void *dst, int offset) {
c002b64c:	57                   	push   %edi
c002b64d:	56                   	push   %esi
c002b64e:	53                   	push   %ebx
  *((int *)dst) = *((int *)get_paddr(esp + offset));
c002b64f:	8d 1c 88             	lea    (%eax,%ecx,4),%ebx
	if (!is_user_vaddr(vaddr) || !(ret = page_for_addr(vaddr))) {
c002b652:	81 fb ff ff ff bf    	cmp    $0xbfffffff,%ebx
c002b658:	77 2b                	ja     c002b685 <pop_stack+0x39>
c002b65a:	89 d6                	mov    %edx,%esi
c002b65c:	83 ec 0c             	sub    $0xc,%esp
c002b65f:	53                   	push   %ebx
c002b660:	e8 1e 38 00 00       	call   c002ee83 <page_for_addr>
c002b665:	89 c7                	mov    %eax,%edi
c002b667:	83 c4 10             	add    $0x10,%esp
c002b66a:	85 c0                	test   %eax,%eax
c002b66c:	74 17                	je     c002b685 <pop_stack+0x39>
	if (ret->frame == NULL) {
c002b66e:	8b 40 14             	mov    0x14(%eax),%eax
c002b671:	85 c0                	test   %eax,%eax
c002b673:	74 1a                	je     c002b68f <pop_stack+0x43>
  return (uintptr_t) va & PGMASK;
c002b675:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
	return ret->frame->base + pg_ofs(vaddr);
c002b67b:	03 18                	add    (%eax),%ebx
  *((int *)dst) = *((int *)get_paddr(esp + offset));
c002b67d:	8b 03                	mov    (%ebx),%eax
c002b67f:	89 06                	mov    %eax,(%esi)
}
c002b681:	5b                   	pop    %ebx
c002b682:	5e                   	pop    %esi
c002b683:	5f                   	pop    %edi
c002b684:	c3                   	ret    
		syscall_exit_helper(-1);
c002b685:	83 ec 0c             	sub    $0xc,%esp
c002b688:	6a ff                	push   $0xffffffff
c002b68a:	e8 4d ff ff ff       	call   c002b5dc <syscall_exit_helper>
		if (page_in(ret->vaddr))
c002b68f:	83 ec 0c             	sub    $0xc,%esp
c002b692:	ff 37                	pushl  (%edi)
c002b694:	e8 5f 38 00 00       	call   c002eef8 <page_in>
c002b699:	83 c4 10             	add    $0x10,%esp
c002b69c:	84 c0                	test   %al,%al
c002b69e:	74 0d                	je     c002b6ad <pop_stack+0x61>
			return ret->frame->base + pg_ofs(vaddr);
c002b6a0:	8b 47 14             	mov    0x14(%edi),%eax
c002b6a3:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
c002b6a9:	03 18                	add    (%eax),%ebx
c002b6ab:	eb d0                	jmp    c002b67d <pop_stack+0x31>
			return NULL;
c002b6ad:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b6b2:	eb c9                	jmp    c002b67d <pop_stack+0x31>

c002b6b4 <syscall_mmap>:
}
#endif

#ifdef VM
int
syscall_mmap(struct intr_frame *f) {
c002b6b4:	55                   	push   %ebp
c002b6b5:	57                   	push   %edi
c002b6b6:	56                   	push   %esi
c002b6b7:	53                   	push   %ebx
c002b6b8:	83 ec 2c             	sub    $0x2c,%esp
c002b6bb:	8b 5c 24 40          	mov    0x40(%esp),%ebx
	int fd;
	void *addr;
	pop_stack(f->esp, &fd, 1);
c002b6bf:	8b 43 48             	mov    0x48(%ebx),%eax
c002b6c2:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b6c7:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b6cb:	e8 7c ff ff ff       	call   c002b64c <pop_stack>
	pop_stack(f->esp, &addr, 2);
c002b6d0:	8b 43 48             	mov    0x48(%ebx),%eax
c002b6d3:	b9 02 00 00 00       	mov    $0x2,%ecx
c002b6d8:	8d 54 24 18          	lea    0x18(%esp),%edx
c002b6dc:	e8 6b ff ff ff       	call   c002b64c <pop_stack>

	if (addr == NULL || pg_ofs(addr) != 0)
c002b6e1:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b6e5:	85 c0                	test   %eax,%eax
c002b6e7:	0f 84 5e 01 00 00    	je     c002b84b <syscall_mmap+0x197>
c002b6ed:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002b6f2:	0f 85 5a 01 00 00    	jne    c002b852 <syscall_mmap+0x19e>
		return -1;

	struct fd_t *entry = get_file_by_fd(&thread_current()->files, fd);
c002b6f8:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002b6fc:	e8 15 56 ff ff       	call   c0020d16 <thread_current>
c002b701:	05 bc 00 00 00       	add    $0xbc,%eax
c002b706:	89 da                	mov    %ebx,%edx
c002b708:	e8 6b fe ff ff       	call   c002b578 <get_file_by_fd>
c002b70d:	89 c3                	mov    %eax,%ebx

	if (entry == NULL) {
c002b70f:	85 c0                	test   %eax,%eax
c002b711:	0f 84 42 01 00 00    	je     c002b859 <syscall_mmap+0x1a5>
		return -1;
	}

	struct mapping_t *mp_e = malloc(sizeof(*mp_e));
c002b717:	83 ec 0c             	sub    $0xc,%esp
c002b71a:	6a 18                	push   $0x18
c002b71c:	e8 03 83 ff ff       	call   c0023a24 <malloc>
c002b721:	89 c6                	mov    %eax,%esi
	struct thread *t = thread_current();
c002b723:	e8 ee 55 ff ff       	call   c0020d16 <thread_current>
c002b728:	89 c1                	mov    %eax,%ecx
c002b72a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	mp_e->id = t->mapping_cnt++;
c002b72e:	8b 40 70             	mov    0x70(%eax),%eax
c002b731:	8d 50 01             	lea    0x1(%eax),%edx
c002b734:	89 51 70             	mov    %edx,0x70(%ecx)
c002b737:	89 46 04             	mov    %eax,0x4(%esi)
	lock_acquire(&filesys_lock);
c002b73a:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002b741:	e8 8d 77 ff ff       	call   c0022ed3 <lock_acquire>
	mp_e->ptr = file_reopen(entry->ptr);
c002b746:	83 c4 04             	add    $0x4,%esp
c002b749:	ff 33                	pushl  (%ebx)
c002b74b:	e8 11 15 00 00       	call   c002cc61 <file_reopen>
c002b750:	89 06                	mov    %eax,(%esi)
	lock_release(&filesys_lock);
c002b752:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002b759:	e8 12 79 ff ff       	call   c0023070 <lock_release>
	mp_e->page_cnt = 0;
c002b75e:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
	mp_e->base = addr;
c002b765:	8b 44 24 28          	mov    0x28(%esp),%eax
c002b769:	89 46 0c             	mov    %eax,0xc(%esi)

	int ofs = 0;
	lock_acquire(&filesys_lock);
c002b76c:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002b773:	e8 5b 77 ff ff       	call   c0022ed3 <lock_acquire>
	int size = file_length (mp_e->ptr);
c002b778:	83 c4 04             	add    $0x4,%esp
c002b77b:	ff 36                	pushl  (%esi)
c002b77d:	e8 62 16 00 00       	call   c002cde4 <file_length>
c002b782:	89 c3                	mov    %eax,%ebx
	lock_release(&filesys_lock);
c002b784:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002b78b:	e8 e0 78 ff ff       	call   c0023070 <lock_release>
	while (size > 0) {
c002b790:	83 c4 10             	add    $0x10,%esp
c002b793:	85 db                	test   %ebx,%ebx
c002b795:	0f 8e 8c 00 00 00    	jle    c002b827 <syscall_mmap+0x173>
c002b79b:	bf 00 00 00 00       	mov    $0x0,%edi
			return -1;
		}
		p->private = false;
		p->file = mp_e->ptr;
		p->file_offset = ofs;
		p->read_bytes = size >= PGSIZE ? PGSIZE : size;
c002b7a0:	bd 00 10 00 00       	mov    $0x1000,%ebp
c002b7a5:	eb 4e                	jmp    c002b7f5 <syscall_mmap+0x141>
			for (int i = 0; i < mp_e->page_cnt; i++) {
c002b7a7:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
c002b7ab:	7e 27                	jle    c002b7d4 <syscall_mmap+0x120>
c002b7ad:	bb 00 00 00 00       	mov    $0x0,%ebx
				page_free(page_for_addr((void *) ((mp_e->base) + (PGSIZE * i))));
c002b7b2:	83 ec 0c             	sub    $0xc,%esp
c002b7b5:	89 d8                	mov    %ebx,%eax
c002b7b7:	c1 e0 0c             	shl    $0xc,%eax
c002b7ba:	03 46 0c             	add    0xc(%esi),%eax
c002b7bd:	50                   	push   %eax
c002b7be:	e8 c0 36 00 00       	call   c002ee83 <page_for_addr>
c002b7c3:	89 04 24             	mov    %eax,(%esp)
c002b7c6:	e8 18 38 00 00       	call   c002efe3 <page_free>
			for (int i = 0; i < mp_e->page_cnt; i++) {
c002b7cb:	43                   	inc    %ebx
c002b7cc:	83 c4 10             	add    $0x10,%esp
c002b7cf:	39 5e 08             	cmp    %ebx,0x8(%esi)
c002b7d2:	7f de                	jg     c002b7b2 <syscall_mmap+0xfe>
			free(mp_e);
c002b7d4:	83 ec 0c             	sub    $0xc,%esp
c002b7d7:	56                   	push   %esi
c002b7d8:	e8 ea 83 ff ff       	call   c0023bc7 <free>
			return -1;
c002b7dd:	83 c4 10             	add    $0x10,%esp
c002b7e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b7e5:	eb 5c                	jmp    c002b843 <syscall_mmap+0x18f>
		p->read_bytes = size >= PGSIZE ? PGSIZE : size;
c002b7e7:	89 50 28             	mov    %edx,0x28(%eax)
		ofs += p->read_bytes;
c002b7ea:	01 d7                	add    %edx,%edi
		size -= p->read_bytes;
c002b7ec:	29 d3                	sub    %edx,%ebx
		mp_e->page_cnt++;
c002b7ee:	ff 46 08             	incl   0x8(%esi)
	while (size > 0) {
c002b7f1:	85 db                	test   %ebx,%ebx
c002b7f3:	7e 32                	jle    c002b827 <syscall_mmap+0x173>
		struct page *p = page_alloc((uint8_t *)addr + ofs, true);
c002b7f5:	83 ec 08             	sub    $0x8,%esp
c002b7f8:	6a 01                	push   $0x1
c002b7fa:	89 f8                	mov    %edi,%eax
c002b7fc:	03 44 24 24          	add    0x24(%esp),%eax
c002b800:	50                   	push   %eax
c002b801:	e8 d7 35 00 00       	call   c002eddd <page_alloc>
		if (p == NULL) {
c002b806:	83 c4 10             	add    $0x10,%esp
c002b809:	85 c0                	test   %eax,%eax
c002b80b:	74 9a                	je     c002b7a7 <syscall_mmap+0xf3>
		p->private = false;
c002b80d:	c6 40 18 00          	movb   $0x0,0x18(%eax)
		p->file = mp_e->ptr;
c002b811:	8b 16                	mov    (%esi),%edx
c002b813:	89 50 20             	mov    %edx,0x20(%eax)
		p->file_offset = ofs;
c002b816:	89 78 24             	mov    %edi,0x24(%eax)
		p->read_bytes = size >= PGSIZE ? PGSIZE : size;
c002b819:	89 da                	mov    %ebx,%edx
c002b81b:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
c002b821:	7e c4                	jle    c002b7e7 <syscall_mmap+0x133>
c002b823:	89 ea                	mov    %ebp,%edx
c002b825:	eb c0                	jmp    c002b7e7 <syscall_mmap+0x133>
	}

	list_push_back(&t->mappings, &mp_e->elem);
c002b827:	83 ec 08             	sub    $0x8,%esp
c002b82a:	8d 46 10             	lea    0x10(%esi),%eax
c002b82d:	50                   	push   %eax
c002b82e:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b832:	05 cc 00 00 00       	add    $0xcc,%eax
c002b837:	50                   	push   %eax
c002b838:	e8 33 d3 ff ff       	call   c0028b70 <list_push_back>
	return mp_e->id;
c002b83d:	8b 46 04             	mov    0x4(%esi),%eax
c002b840:	83 c4 10             	add    $0x10,%esp
}
c002b843:	83 c4 2c             	add    $0x2c,%esp
c002b846:	5b                   	pop    %ebx
c002b847:	5e                   	pop    %esi
c002b848:	5f                   	pop    %edi
c002b849:	5d                   	pop    %ebp
c002b84a:	c3                   	ret    
		return -1;
c002b84b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b850:	eb f1                	jmp    c002b843 <syscall_mmap+0x18f>
c002b852:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b857:	eb ea                	jmp    c002b843 <syscall_mmap+0x18f>
		return -1;
c002b859:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002b85e:	eb e3                	jmp    c002b843 <syscall_mmap+0x18f>

c002b860 <get_mapping_by_id>:

struct mapping_t*
get_mapping_by_id(struct list* mappings, int id) {
c002b860:	57                   	push   %edi
c002b861:	56                   	push   %esi
c002b862:	53                   	push   %ebx
c002b863:	8b 74 24 10          	mov    0x10(%esp),%esi
c002b867:	8b 7c 24 14          	mov    0x14(%esp),%edi
	struct mapping_t *entry;
	for (struct list_elem *e = list_begin(mappings); e != list_end(mappings); e = list_next(e)) {
c002b86b:	83 ec 0c             	sub    $0xc,%esp
c002b86e:	56                   	push   %esi
c002b86f:	e8 f3 ce ff ff       	call   c0028767 <list_begin>
c002b874:	89 c3                	mov    %eax,%ebx
c002b876:	83 c4 10             	add    $0x10,%esp
c002b879:	83 ec 0c             	sub    $0xc,%esp
c002b87c:	56                   	push   %esi
c002b87d:	e8 5d cf ff ff       	call   c00287df <list_end>
c002b882:	83 c4 10             	add    $0x10,%esp
c002b885:	39 c3                	cmp    %eax,%ebx
c002b887:	74 1a                	je     c002b8a3 <get_mapping_by_id+0x43>
		entry = list_entry(e, struct mapping_t, elem);
		if (entry->id == id)
c002b889:	39 7b f4             	cmp    %edi,-0xc(%ebx)
c002b88c:	74 10                	je     c002b89e <get_mapping_by_id+0x3e>
	for (struct list_elem *e = list_begin(mappings); e != list_end(mappings); e = list_next(e)) {
c002b88e:	83 ec 0c             	sub    $0xc,%esp
c002b891:	53                   	push   %ebx
c002b892:	e8 00 cf ff ff       	call   c0028797 <list_next>
c002b897:	89 c3                	mov    %eax,%ebx
c002b899:	83 c4 10             	add    $0x10,%esp
c002b89c:	eb db                	jmp    c002b879 <get_mapping_by_id+0x19>
		entry = list_entry(e, struct mapping_t, elem);
c002b89e:	8d 43 f0             	lea    -0x10(%ebx),%eax
c002b8a1:	eb 05                	jmp    c002b8a8 <get_mapping_by_id+0x48>
			return entry;
	}
	return NULL;
c002b8a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b8a8:	5b                   	pop    %ebx
c002b8a9:	5e                   	pop    %esi
c002b8aa:	5f                   	pop    %edi
c002b8ab:	c3                   	ret    

c002b8ac <syscall_munmap>:

void
syscall_munmap(struct intr_frame *f) {
c002b8ac:	56                   	push   %esi
c002b8ad:	53                   	push   %ebx
c002b8ae:	83 ec 14             	sub    $0x14,%esp
	int m_id;
	pop_stack(f->esp, &m_id, 1);
c002b8b1:	8b 44 24 20          	mov    0x20(%esp),%eax
c002b8b5:	8b 40 48             	mov    0x48(%eax),%eax
c002b8b8:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b8bd:	8d 54 24 0c          	lea    0xc(%esp),%edx
c002b8c1:	e8 86 fd ff ff       	call   c002b64c <pop_stack>

	struct mapping_t *entry = get_mapping_by_id(&thread_current()->mappings, m_id);
c002b8c6:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002b8ca:	e8 47 54 ff ff       	call   c0020d16 <thread_current>
c002b8cf:	83 ec 08             	sub    $0x8,%esp
c002b8d2:	53                   	push   %ebx
c002b8d3:	05 cc 00 00 00       	add    $0xcc,%eax
c002b8d8:	50                   	push   %eax
c002b8d9:	e8 82 ff ff ff       	call   c002b860 <get_mapping_by_id>
c002b8de:	89 c6                	mov    %eax,%esi
	list_remove(&entry->elem);
c002b8e0:	8d 40 10             	lea    0x10(%eax),%eax
c002b8e3:	89 04 24             	mov    %eax,(%esp)
c002b8e6:	e8 a2 d2 ff ff       	call   c0028b8d <list_remove>

//	printf("%x\n", entry->base);

	for (int i = 0; i < entry->page_cnt; i++) {
c002b8eb:	83 c4 10             	add    $0x10,%esp
c002b8ee:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
c002b8f2:	7e 27                	jle    c002b91b <syscall_munmap+0x6f>
c002b8f4:	bb 00 00 00 00       	mov    $0x0,%ebx
		page_free(page_for_addr((void *) ((entry->base) + (PGSIZE * i))));
c002b8f9:	83 ec 0c             	sub    $0xc,%esp
c002b8fc:	89 d8                	mov    %ebx,%eax
c002b8fe:	c1 e0 0c             	shl    $0xc,%eax
c002b901:	03 46 0c             	add    0xc(%esi),%eax
c002b904:	50                   	push   %eax
c002b905:	e8 79 35 00 00       	call   c002ee83 <page_for_addr>
c002b90a:	89 04 24             	mov    %eax,(%esp)
c002b90d:	e8 d1 36 00 00       	call   c002efe3 <page_free>
	for (int i = 0; i < entry->page_cnt; i++) {
c002b912:	43                   	inc    %ebx
c002b913:	83 c4 10             	add    $0x10,%esp
c002b916:	39 5e 08             	cmp    %ebx,0x8(%esi)
c002b919:	7f de                	jg     c002b8f9 <syscall_munmap+0x4d>
	}
}
c002b91b:	83 c4 14             	add    $0x14,%esp
c002b91e:	5b                   	pop    %ebx
c002b91f:	5e                   	pop    %esi
c002b920:	c3                   	ret    

c002b921 <syscall_handler>:
{
c002b921:	55                   	push   %ebp
c002b922:	57                   	push   %edi
c002b923:	56                   	push   %esi
c002b924:	53                   	push   %ebx
c002b925:	83 ec 2c             	sub    $0x2c,%esp
c002b928:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  is_valid_addr(f->esp);
c002b92c:	8b 45 48             	mov    0x48(%ebp),%eax
c002b92f:	e8 d7 fc ff ff       	call   c002b60b <is_valid_addr>
  int sysnum = *(int*)f->esp;
c002b934:	8b 45 48             	mov    0x48(%ebp),%eax
c002b937:	8b 10                	mov    (%eax),%edx
  switch (sysnum) {
c002b939:	83 fa 13             	cmp    $0x13,%edx
c002b93c:	0f 87 ec 09 00 00    	ja     c002c32e <syscall_handler+0xa0d>
c002b942:	ff 24 95 04 0a 03 c0 	jmp    *-0x3ffcf5fc(,%edx,4)
  shutdown_power_off();
c002b949:	e8 35 ab ff ff       	call   c0026483 <shutdown_power_off>
	pop_stack(f->esp, &status, 1);
c002b94e:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b953:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002b957:	e8 f0 fc ff ff       	call   c002b64c <pop_stack>
	syscall_exit_helper(status);
c002b95c:	83 ec 0c             	sub    $0xc,%esp
c002b95f:	ff 74 24 28          	pushl  0x28(%esp)
c002b963:	e8 74 fc ff ff       	call   c002b5dc <syscall_exit_helper>
  pop_stack(f->esp, &file_name, 1);
c002b968:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b96d:	8d 54 24 18          	lea    0x18(%esp),%edx
c002b971:	e8 d6 fc ff ff       	call   c002b64c <pop_stack>
  if (!is_valid_addr(file_name)) {
c002b976:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b97a:	e8 8c fc ff ff       	call   c002b60b <is_valid_addr>
c002b97f:	84 c0                	test   %al,%al
c002b981:	0f 84 a8 00 00 00    	je     c002ba2f <syscall_handler+0x10e>
  lock_acquire(&filesys_lock);
c002b987:	83 ec 0c             	sub    $0xc,%esp
c002b98a:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002b98f:	e8 3f 75 ff ff       	call   c0022ed3 <lock_acquire>
  char *fn_cp = malloc(strlen(file_name) + 1);
c002b994:	8b 5c 24 28          	mov    0x28(%esp),%ebx
c002b998:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b99d:	89 df                	mov    %ebx,%edi
c002b99f:	b0 00                	mov    $0x0,%al
c002b9a1:	f2 ae                	repnz scas %es:(%edi),%al
c002b9a3:	f7 d1                	not    %ecx
c002b9a5:	89 0c 24             	mov    %ecx,(%esp)
c002b9a8:	e8 77 80 ff ff       	call   c0023a24 <malloc>
c002b9ad:	89 c6                	mov    %eax,%esi
  strlcpy(fn_cp, file_name, strlen(file_name) + 1);
c002b9af:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b9b4:	89 df                	mov    %ebx,%edi
c002b9b6:	b0 00                	mov    $0x0,%al
c002b9b8:	f2 ae                	repnz scas %es:(%edi),%al
c002b9ba:	f7 d1                	not    %ecx
c002b9bc:	83 c4 0c             	add    $0xc,%esp
c002b9bf:	51                   	push   %ecx
c002b9c0:	53                   	push   %ebx
c002b9c1:	56                   	push   %esi
c002b9c2:	e8 b0 c3 ff ff       	call   c0027d77 <strlcpy>
  token = strtok_r(fn_cp, " ", &save_ptr);
c002b9c7:	83 c4 0c             	add    $0xc,%esp
c002b9ca:	8d 44 24 20          	lea    0x20(%esp),%eax
c002b9ce:	50                   	push   %eax
c002b9cf:	68 0a 27 03 c0       	push   $0xc003270a
c002b9d4:	56                   	push   %esi
c002b9d5:	e8 c3 c1 ff ff       	call   c0027b9d <strtok_r>
  struct file *fi = filesys_open(token);
c002b9da:	89 04 24             	mov    %eax,(%esp)
c002b9dd:	e8 d8 0d 00 00       	call   c002c7ba <filesys_open>
  if (fi == NULL) {
c002b9e2:	83 c4 10             	add    $0x10,%esp
c002b9e5:	85 c0                	test   %eax,%eax
c002b9e7:	74 2f                	je     c002ba18 <syscall_handler+0xf7>
    file_close(fi);
c002b9e9:	83 ec 0c             	sub    $0xc,%esp
c002b9ec:	50                   	push   %eax
c002b9ed:	e8 b8 13 00 00       	call   c002cdaa <file_close>
    lock_release(&filesys_lock);
c002b9f2:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002b9f9:	e8 72 76 ff ff       	call   c0023070 <lock_release>
    return process_execute(file_name);
c002b9fe:	83 c4 04             	add    $0x4,%esp
c002ba01:	ff 74 24 24          	pushl  0x24(%esp)
c002ba05:	e8 e5 e7 ff ff       	call   c002a1ef <process_execute>
c002ba0a:	83 c4 10             	add    $0x10,%esp
	  case SYS_EXEC: f->eax = syscall_exec(f); break;
c002ba0d:	89 45 1c             	mov    %eax,0x1c(%ebp)
}
c002ba10:	83 c4 2c             	add    $0x2c,%esp
c002ba13:	5b                   	pop    %ebx
c002ba14:	5e                   	pop    %esi
c002ba15:	5f                   	pop    %edi
c002ba16:	5d                   	pop    %ebp
c002ba17:	c3                   	ret    
    lock_release(&filesys_lock);
c002ba18:	83 ec 0c             	sub    $0xc,%esp
c002ba1b:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002ba20:	e8 4b 76 ff ff       	call   c0023070 <lock_release>
c002ba25:	83 c4 10             	add    $0x10,%esp
    return -1;
c002ba28:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002ba2d:	eb de                	jmp    c002ba0d <syscall_handler+0xec>
    return -1;
c002ba2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002ba34:	eb d7                	jmp    c002ba0d <syscall_handler+0xec>
  pop_stack(f->esp, &tid, 1);
c002ba36:	b9 01 00 00 00       	mov    $0x1,%ecx
c002ba3b:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002ba3f:	e8 08 fc ff ff       	call   c002b64c <pop_stack>
  return process_wait(tid);
c002ba44:	83 ec 0c             	sub    $0xc,%esp
c002ba47:	ff 74 24 28          	pushl  0x28(%esp)
c002ba4b:	e8 68 e8 ff ff       	call   c002a2b8 <process_wait>
	  case SYS_WAIT: f->eax = syscall_wait(f); break;
c002ba50:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002ba53:	83 c4 10             	add    $0x10,%esp
c002ba56:	eb b8                	jmp    c002ba10 <syscall_handler+0xef>
  pop_stack(f->esp, &size, 2);
c002ba58:	b9 02 00 00 00       	mov    $0x2,%ecx
c002ba5d:	8d 54 24 18          	lea    0x18(%esp),%edx
c002ba61:	e8 e6 fb ff ff       	call   c002b64c <pop_stack>
  pop_stack(f->esp, &file_name, 1);
c002ba66:	8b 45 48             	mov    0x48(%ebp),%eax
c002ba69:	b9 01 00 00 00       	mov    $0x1,%ecx
c002ba6e:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002ba72:	e8 d5 fb ff ff       	call   c002b64c <pop_stack>
  if (!is_valid_addr(file_name))
c002ba77:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ba7b:	e8 8b fb ff ff       	call   c002b60b <is_valid_addr>
c002ba80:	88 c3                	mov    %al,%bl
c002ba82:	84 c0                	test   %al,%al
c002ba84:	75 08                	jne    c002ba8e <syscall_handler+0x16d>
	  case SYS_CREATE: f->eax = syscall_create(f); break;
c002ba86:	0f b6 db             	movzbl %bl,%ebx
c002ba89:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002ba8c:	eb 82                	jmp    c002ba10 <syscall_handler+0xef>
  lock_acquire(&filesys_lock);
c002ba8e:	83 ec 0c             	sub    $0xc,%esp
c002ba91:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002ba96:	e8 38 74 ff ff       	call   c0022ed3 <lock_acquire>
  ret = filesys_create(file_name, size);
c002ba9b:	83 c4 08             	add    $0x8,%esp
c002ba9e:	ff 74 24 20          	pushl  0x20(%esp)
c002baa2:	ff 74 24 28          	pushl  0x28(%esp)
c002baa6:	e8 67 0c 00 00       	call   c002c712 <filesys_create>
c002baab:	88 c3                	mov    %al,%bl
  lock_release(&filesys_lock);
c002baad:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002bab4:	e8 b7 75 ff ff       	call   c0023070 <lock_release>
c002bab9:	83 c4 10             	add    $0x10,%esp
c002babc:	eb c8                	jmp    c002ba86 <syscall_handler+0x165>
  pop_stack(f->esp, &file_name, 1);
c002babe:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bac3:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bac7:	e8 80 fb ff ff       	call   c002b64c <pop_stack>
  if (!is_valid_addr(file_name))
c002bacc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002bad0:	e8 36 fb ff ff       	call   c002b60b <is_valid_addr>
c002bad5:	88 c3                	mov    %al,%bl
c002bad7:	84 c0                	test   %al,%al
c002bad9:	75 0b                	jne    c002bae6 <syscall_handler+0x1c5>
	  case SYS_REMOVE: f->eax = syscall_remove(f); break;
c002badb:	0f b6 db             	movzbl %bl,%ebx
c002bade:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002bae1:	e9 2a ff ff ff       	jmp    c002ba10 <syscall_handler+0xef>
  lock_acquire(&filesys_lock);
c002bae6:	83 ec 0c             	sub    $0xc,%esp
c002bae9:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002baee:	e8 e0 73 ff ff       	call   c0022ed3 <lock_acquire>
  ret = filesys_remove(file_name);
c002baf3:	83 c4 04             	add    $0x4,%esp
c002baf6:	ff 74 24 28          	pushl  0x28(%esp)
c002bafa:	e8 0d 0e 00 00       	call   c002c90c <filesys_remove>
c002baff:	88 c3                	mov    %al,%bl
  lock_release(&filesys_lock);
c002bb01:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002bb08:	e8 63 75 ff ff       	call   c0023070 <lock_release>
c002bb0d:	83 c4 10             	add    $0x10,%esp
c002bb10:	eb c9                	jmp    c002badb <syscall_handler+0x1ba>
	pop_stack(f->esp, &file_name, 1);
c002bb12:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bb17:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bb1b:	e8 2c fb ff ff       	call   c002b64c <pop_stack>
	if (!is_valid_addr(file_name)) {
c002bb20:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002bb24:	e8 e2 fa ff ff       	call   c002b60b <is_valid_addr>
c002bb29:	84 c0                	test   %al,%al
c002bb2b:	0f 84 ac 00 00 00    	je     c002bbdd <syscall_handler+0x2bc>
	lock_acquire(&filesys_lock);
c002bb31:	83 ec 0c             	sub    $0xc,%esp
c002bb34:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002bb39:	e8 95 73 ff ff       	call   c0022ed3 <lock_acquire>
	struct file *fi = filesys_open(file_name);
c002bb3e:	83 c4 04             	add    $0x4,%esp
c002bb41:	ff 74 24 28          	pushl  0x28(%esp)
c002bb45:	e8 70 0c 00 00       	call   c002c7ba <filesys_open>
c002bb4a:	89 c7                	mov    %eax,%edi
	lock_release(&filesys_lock);
c002bb4c:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002bb53:	e8 18 75 ff ff       	call   c0023070 <lock_release>
	if (fi == NULL) {
c002bb58:	83 c4 10             	add    $0x10,%esp
c002bb5b:	85 ff                	test   %edi,%edi
c002bb5d:	0f 84 81 00 00 00    	je     c002bbe4 <syscall_handler+0x2c3>
    struct fd_t *fd_e = malloc(sizeof(*fd_e));
c002bb63:	83 ec 0c             	sub    $0xc,%esp
c002bb66:	6a 14                	push   $0x14
c002bb68:	e8 b7 7e ff ff       	call   c0023a24 <malloc>
c002bb6d:	89 c6                	mov    %eax,%esi
    fd_e->ptr = fi;
c002bb6f:	89 38                	mov    %edi,(%eax)
    struct thread *t = thread_current();
c002bb71:	e8 a0 51 ff ff       	call   c0020d16 <thread_current>
c002bb76:	89 c3                	mov    %eax,%ebx
    fd_e->fd = t->file_cnt++;
c002bb78:	8b 40 6c             	mov    0x6c(%eax),%eax
c002bb7b:	8d 50 01             	lea    0x1(%eax),%edx
c002bb7e:	89 53 6c             	mov    %edx,0x6c(%ebx)
c002bb81:	89 46 04             	mov    %eax,0x4(%esi)
    if (inode_is_dir(file_get_inode(fi))) {
c002bb84:	89 3c 24             	mov    %edi,(%esp)
c002bb87:	e8 05 11 00 00       	call   c002cc91 <file_get_inode>
c002bb8c:	89 04 24             	mov    %eax,(%esp)
c002bb8f:	e8 d2 27 00 00       	call   c002e366 <inode_is_dir>
c002bb94:	83 c4 10             	add    $0x10,%esp
c002bb97:	84 c0                	test   %al,%al
c002bb99:	75 21                	jne    c002bbbc <syscall_handler+0x29b>
    list_push_back(&t->files, &fd_e->elem);
c002bb9b:	83 ec 08             	sub    $0x8,%esp
c002bb9e:	8d 46 0c             	lea    0xc(%esi),%eax
c002bba1:	50                   	push   %eax
c002bba2:	81 c3 bc 00 00 00    	add    $0xbc,%ebx
c002bba8:	53                   	push   %ebx
c002bba9:	e8 c2 cf ff ff       	call   c0028b70 <list_push_back>
    return fd_e->fd;
c002bbae:	8b 46 04             	mov    0x4(%esi),%eax
c002bbb1:	83 c4 10             	add    $0x10,%esp
	  case SYS_OPEN: f->eax = syscall_open(f); break;
c002bbb4:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002bbb7:	e9 54 fe ff ff       	jmp    c002ba10 <syscall_handler+0xef>
      fd_e->opened_dir = dir_open(inode_reopen(file_get_inode(fi)));
c002bbbc:	83 ec 0c             	sub    $0xc,%esp
c002bbbf:	57                   	push   %edi
c002bbc0:	e8 cc 10 00 00       	call   c002cc91 <file_get_inode>
c002bbc5:	89 04 24             	mov    %eax,(%esp)
c002bbc8:	e8 15 22 00 00       	call   c002dde2 <inode_reopen>
c002bbcd:	89 04 24             	mov    %eax,(%esp)
c002bbd0:	e8 ba 13 00 00       	call   c002cf8f <dir_open>
c002bbd5:	89 46 08             	mov    %eax,0x8(%esi)
c002bbd8:	83 c4 10             	add    $0x10,%esp
c002bbdb:	eb be                	jmp    c002bb9b <syscall_handler+0x27a>
		return -1;
c002bbdd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002bbe2:	eb d0                	jmp    c002bbb4 <syscall_handler+0x293>
		return -1;
c002bbe4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002bbe9:	eb c9                	jmp    c002bbb4 <syscall_handler+0x293>
  pop_stack(f->esp, &fd, 1);
c002bbeb:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bbf0:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bbf4:	e8 53 fa ff ff       	call   c002b64c <pop_stack>
  lock_acquire(&filesys_lock);
c002bbf9:	83 ec 0c             	sub    $0xc,%esp
c002bbfc:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002bc01:	e8 cd 72 ff ff       	call   c0022ed3 <lock_acquire>
  int ret = file_length(get_file_by_fd(&thread_current()->files, fd)->ptr);
c002bc06:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c002bc0a:	e8 07 51 ff ff       	call   c0020d16 <thread_current>
c002bc0f:	05 bc 00 00 00       	add    $0xbc,%eax
c002bc14:	89 da                	mov    %ebx,%edx
c002bc16:	e8 5d f9 ff ff       	call   c002b578 <get_file_by_fd>
c002bc1b:	83 c4 04             	add    $0x4,%esp
c002bc1e:	ff 30                	pushl  (%eax)
c002bc20:	e8 bf 11 00 00       	call   c002cde4 <file_length>
c002bc25:	89 c3                	mov    %eax,%ebx
  lock_release(&filesys_lock);
c002bc27:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002bc2e:	e8 3d 74 ff ff       	call   c0023070 <lock_release>
	  case SYS_FILESIZE: f->eax = syscall_filesize(f); break;
c002bc33:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002bc36:	83 c4 10             	add    $0x10,%esp
c002bc39:	e9 d2 fd ff ff       	jmp    c002ba10 <syscall_handler+0xef>
	pop_stack(f->esp, &size, 3);
c002bc3e:	b9 03 00 00 00       	mov    $0x3,%ecx
c002bc43:	8d 54 24 14          	lea    0x14(%esp),%edx
c002bc47:	e8 00 fa ff ff       	call   c002b64c <pop_stack>
	pop_stack(f->esp, &buffer, 2);
c002bc4c:	8b 45 48             	mov    0x48(%ebp),%eax
c002bc4f:	b9 02 00 00 00       	mov    $0x2,%ecx
c002bc54:	8d 54 24 18          	lea    0x18(%esp),%edx
c002bc58:	e8 ef f9 ff ff       	call   c002b64c <pop_stack>
	pop_stack(f->esp, &fd, 1);
c002bc5d:	8b 45 48             	mov    0x48(%ebp),%eax
c002bc60:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bc65:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bc69:	e8 de f9 ff ff       	call   c002b64c <pop_stack>
	if (fd != 0) {
c002bc6e:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002bc72:	85 db                	test   %ebx,%ebx
c002bc74:	75 18                	jne    c002bc8e <syscall_handler+0x36d>
	while (size > 0) {
c002bc76:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c002bc7b:	0f 8e d6 00 00 00    	jle    c002bd57 <syscall_handler+0x436>
c002bc81:	b8 00 00 00 00       	mov    $0x0,%eax
		int page_left = PGSIZE - pg_ofs(buffer);
c002bc86:	89 6c 24 40          	mov    %ebp,0x40(%esp)
c002bc8a:	89 c5                	mov    %eax,%ebp
c002bc8c:	eb 59                	jmp    c002bce7 <syscall_handler+0x3c6>
		fd_e = get_file_by_fd(&thread_current()->files, fd);
c002bc8e:	e8 83 50 ff ff       	call   c0020d16 <thread_current>
c002bc93:	05 bc 00 00 00       	add    $0xbc,%eax
c002bc98:	89 da                	mov    %ebx,%edx
c002bc9a:	e8 d9 f8 ff ff       	call   c002b578 <get_file_by_fd>
c002bc9f:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (fd_e == NULL)
c002bca3:	85 c0                	test   %eax,%eax
c002bca5:	75 cf                	jne    c002bc76 <syscall_handler+0x355>
			return -1;
c002bca7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002bcac:	e9 b6 00 00 00       	jmp    c002bd67 <syscall_handler+0x446>
		if (fd == 0) {
c002bcb1:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002bcb5:	85 db                	test   %ebx,%ebx
c002bcb7:	75 59                	jne    c002bd12 <syscall_handler+0x3f1>
			for (int i = 0; i < read_size; ++i) {
c002bcb9:	85 ff                	test   %edi,%edi
c002bcbb:	0f 8e 82 00 00 00    	jle    c002bd43 <syscall_handler+0x422>
				buffer[i] = input_getc();
c002bcc1:	89 de                	mov    %ebx,%esi
c002bcc3:	03 74 24 18          	add    0x18(%esp),%esi
c002bcc7:	e8 34 a1 ff ff       	call   c0025e00 <input_getc>
c002bccc:	88 06                	mov    %al,(%esi)
			for (int i = 0; i < read_size; ++i) {
c002bcce:	43                   	inc    %ebx
c002bccf:	39 df                	cmp    %ebx,%edi
c002bcd1:	75 ee                	jne    c002bcc1 <syscall_handler+0x3a0>
		ret += ofs;
c002bcd3:	01 fd                	add    %edi,%ebp
		buffer += ofs;
c002bcd5:	01 7c 24 18          	add    %edi,0x18(%esp)
		size -= ofs;
c002bcd9:	8b 44 24 14          	mov    0x14(%esp),%eax
c002bcdd:	29 f8                	sub    %edi,%eax
c002bcdf:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (size > 0) {
c002bce3:	85 c0                	test   %eax,%eax
c002bce5:	7e 68                	jle    c002bd4f <syscall_handler+0x42e>
		if (!is_valid_addr(buffer))
c002bce7:	8b 44 24 18          	mov    0x18(%esp),%eax
c002bceb:	e8 1b f9 ff ff       	call   c002b60b <is_valid_addr>
c002bcf0:	84 c0                	test   %al,%al
c002bcf2:	74 6a                	je     c002bd5e <syscall_handler+0x43d>
c002bcf4:	8b 44 24 18          	mov    0x18(%esp),%eax
c002bcf8:	25 ff 0f 00 00       	and    $0xfff,%eax
		int page_left = PGSIZE - pg_ofs(buffer);
c002bcfd:	b9 00 10 00 00       	mov    $0x1000,%ecx
c002bd02:	29 c1                	sub    %eax,%ecx
		int read_size = size < page_left ? size : page_left;
c002bd04:	8b 54 24 14          	mov    0x14(%esp),%edx
c002bd08:	89 cf                	mov    %ecx,%edi
c002bd0a:	39 d1                	cmp    %edx,%ecx
c002bd0c:	7e a3                	jle    c002bcb1 <syscall_handler+0x390>
c002bd0e:	89 d7                	mov    %edx,%edi
c002bd10:	eb 9f                	jmp    c002bcb1 <syscall_handler+0x390>
			lock_acquire(&filesys_lock);
c002bd12:	83 ec 0c             	sub    $0xc,%esp
c002bd15:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002bd1a:	e8 b4 71 ff ff       	call   c0022ed3 <lock_acquire>
			ofs = file_read(fd_e->ptr, buffer, read_size);
c002bd1f:	83 c4 0c             	add    $0xc,%esp
c002bd22:	57                   	push   %edi
c002bd23:	ff 74 24 20          	pushl  0x20(%esp)
c002bd27:	8b 44 24 18          	mov    0x18(%esp),%eax
c002bd2b:	ff 30                	pushl  (%eax)
c002bd2d:	e8 66 0f 00 00       	call   c002cc98 <file_read>
c002bd32:	89 c7                	mov    %eax,%edi
			lock_release(&filesys_lock);
c002bd34:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002bd3b:	e8 30 73 ff ff       	call   c0023070 <lock_release>
c002bd40:	83 c4 10             	add    $0x10,%esp
		if (ofs == 0)
c002bd43:	85 ff                	test   %edi,%edi
c002bd45:	75 8c                	jne    c002bcd3 <syscall_handler+0x3b2>
c002bd47:	89 e8                	mov    %ebp,%eax
c002bd49:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c002bd4d:	eb 18                	jmp    c002bd67 <syscall_handler+0x446>
c002bd4f:	89 e8                	mov    %ebp,%eax
c002bd51:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c002bd55:	eb 10                	jmp    c002bd67 <syscall_handler+0x446>
	while (size > 0) {
c002bd57:	b8 00 00 00 00       	mov    $0x0,%eax
c002bd5c:	eb 09                	jmp    c002bd67 <syscall_handler+0x446>
c002bd5e:	8b 6c 24 40          	mov    0x40(%esp),%ebp
			return -1;
c002bd62:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	  case SYS_READ: f->eax = syscall_read(f); break;
c002bd67:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002bd6a:	e9 a1 fc ff ff       	jmp    c002ba10 <syscall_handler+0xef>
  pop_stack(f->esp, &size, 3);
c002bd6f:	b9 03 00 00 00       	mov    $0x3,%ecx
c002bd74:	8d 54 24 14          	lea    0x14(%esp),%edx
c002bd78:	e8 cf f8 ff ff       	call   c002b64c <pop_stack>
  pop_stack(f->esp, &buffer, 2);
c002bd7d:	8b 45 48             	mov    0x48(%ebp),%eax
c002bd80:	b9 02 00 00 00       	mov    $0x2,%ecx
c002bd85:	8d 54 24 18          	lea    0x18(%esp),%edx
c002bd89:	e8 be f8 ff ff       	call   c002b64c <pop_stack>
  pop_stack(f->esp, &fd, 1);
c002bd8e:	8b 45 48             	mov    0x48(%ebp),%eax
c002bd91:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bd96:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bd9a:	e8 ad f8 ff ff       	call   c002b64c <pop_stack>
  if (!is_valid_addr(buffer)) {
c002bd9f:	8b 44 24 18          	mov    0x18(%esp),%eax
c002bda3:	e8 63 f8 ff ff       	call   c002b60b <is_valid_addr>
c002bda8:	84 c0                	test   %al,%al
c002bdaa:	0f 84 dd 00 00 00    	je     c002be8d <syscall_handler+0x56c>
	if (fd != 1) {
c002bdb0:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002bdb4:	83 fb 01             	cmp    $0x1,%ebx
c002bdb7:	74 38                	je     c002bdf1 <syscall_handler+0x4d0>
		fd_e = get_file_by_fd(&thread_current()->files, fd);
c002bdb9:	e8 58 4f ff ff       	call   c0020d16 <thread_current>
c002bdbe:	05 bc 00 00 00       	add    $0xbc,%eax
c002bdc3:	89 da                	mov    %ebx,%edx
c002bdc5:	e8 ae f7 ff ff       	call   c002b578 <get_file_by_fd>
c002bdca:	89 c7                	mov    %eax,%edi
		if (fd_e == NULL || inode_is_dir (file_get_inode(fd_e->ptr)))
c002bdcc:	85 c0                	test   %eax,%eax
c002bdce:	0f 84 c0 00 00 00    	je     c002be94 <syscall_handler+0x573>
c002bdd4:	83 ec 0c             	sub    $0xc,%esp
c002bdd7:	ff 30                	pushl  (%eax)
c002bdd9:	e8 b3 0e 00 00       	call   c002cc91 <file_get_inode>
c002bdde:	89 04 24             	mov    %eax,(%esp)
c002bde1:	e8 80 25 00 00       	call   c002e366 <inode_is_dir>
c002bde6:	83 c4 10             	add    $0x10,%esp
c002bde9:	84 c0                	test   %al,%al
c002bdeb:	0f 85 aa 00 00 00    	jne    c002be9b <syscall_handler+0x57a>
	while (size > 0) {
c002bdf1:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c002bdf6:	0f 8e a6 00 00 00    	jle    c002bea2 <syscall_handler+0x581>
c002bdfc:	be 00 00 00 00       	mov    $0x0,%esi
c002be01:	eb 4c                	jmp    c002be4f <syscall_handler+0x52e>
		if (fd == 1) {
c002be03:	83 7c 24 1c 01       	cmpl   $0x1,0x1c(%esp)
c002be08:	74 74                	je     c002be7e <syscall_handler+0x55d>
			lock_acquire(&filesys_lock);
c002be0a:	83 ec 0c             	sub    $0xc,%esp
c002be0d:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002be12:	e8 bc 70 ff ff       	call   c0022ed3 <lock_acquire>
			ofs = file_write(fd_e->ptr, buffer, write_size);
c002be17:	83 c4 0c             	add    $0xc,%esp
c002be1a:	53                   	push   %ebx
c002be1b:	ff 74 24 20          	pushl  0x20(%esp)
c002be1f:	ff 37                	pushl  (%edi)
c002be21:	e8 b2 0e 00 00       	call   c002ccd8 <file_write>
c002be26:	89 c3                	mov    %eax,%ebx
			lock_release(&filesys_lock);
c002be28:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002be2f:	e8 3c 72 ff ff       	call   c0023070 <lock_release>
c002be34:	83 c4 10             	add    $0x10,%esp
		if (ofs == 0)
c002be37:	85 db                	test   %ebx,%ebx
c002be39:	74 73                	je     c002beae <syscall_handler+0x58d>
		ret += ofs;
c002be3b:	01 de                	add    %ebx,%esi
		buffer += ofs;
c002be3d:	01 5c 24 18          	add    %ebx,0x18(%esp)
		size -= ofs;
c002be41:	8b 44 24 14          	mov    0x14(%esp),%eax
c002be45:	29 d8                	sub    %ebx,%eax
c002be47:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (size > 0) {
c002be4b:	85 c0                	test   %eax,%eax
c002be4d:	7e 5f                	jle    c002beae <syscall_handler+0x58d>
		if (!is_valid_addr(buffer))
c002be4f:	8b 44 24 18          	mov    0x18(%esp),%eax
c002be53:	e8 b3 f7 ff ff       	call   c002b60b <is_valid_addr>
c002be58:	84 c0                	test   %al,%al
c002be5a:	74 4d                	je     c002bea9 <syscall_handler+0x588>
		int page_left = PGSIZE - pg_ofs(buffer);
c002be5c:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c002be60:	89 c8                	mov    %ecx,%eax
c002be62:	25 ff 0f 00 00       	and    $0xfff,%eax
c002be67:	ba 00 10 00 00       	mov    $0x1000,%edx
c002be6c:	29 c2                	sub    %eax,%edx
c002be6e:	89 d0                	mov    %edx,%eax
		int write_size = size < page_left ? size : page_left;
c002be70:	8b 54 24 14          	mov    0x14(%esp),%edx
c002be74:	89 c3                	mov    %eax,%ebx
c002be76:	39 d0                	cmp    %edx,%eax
c002be78:	7e 89                	jle    c002be03 <syscall_handler+0x4e2>
c002be7a:	89 d3                	mov    %edx,%ebx
c002be7c:	eb 85                	jmp    c002be03 <syscall_handler+0x4e2>
			putbuf(buffer, write_size);
c002be7e:	83 ec 08             	sub    $0x8,%esp
c002be81:	53                   	push   %ebx
c002be82:	51                   	push   %ecx
c002be83:	e8 17 e3 ff ff       	call   c002a19f <putbuf>
c002be88:	83 c4 10             	add    $0x10,%esp
c002be8b:	eb aa                	jmp    c002be37 <syscall_handler+0x516>
    return -1;
c002be8d:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002be92:	eb 1a                	jmp    c002beae <syscall_handler+0x58d>
			return -1;
c002be94:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002be99:	eb 13                	jmp    c002beae <syscall_handler+0x58d>
c002be9b:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002bea0:	eb 0c                	jmp    c002beae <syscall_handler+0x58d>
	while (size > 0) {
c002bea2:	be 00 00 00 00       	mov    $0x0,%esi
c002bea7:	eb 05                	jmp    c002beae <syscall_handler+0x58d>
			return -1;
c002bea9:	be ff ff ff ff       	mov    $0xffffffff,%esi
	  case SYS_WRITE: f->eax = syscall_write(f); break;
c002beae:	89 75 1c             	mov    %esi,0x1c(%ebp)
c002beb1:	e9 5a fb ff ff       	jmp    c002ba10 <syscall_handler+0xef>
	pop_stack(f->esp, &pos, 2);
c002beb6:	b9 02 00 00 00       	mov    $0x2,%ecx
c002bebb:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bebf:	e8 88 f7 ff ff       	call   c002b64c <pop_stack>
	pop_stack(f->esp, &fd, 1);
c002bec4:	8b 45 48             	mov    0x48(%ebp),%eax
c002bec7:	b9 01 00 00 00       	mov    $0x1,%ecx
c002becc:	8d 54 24 18          	lea    0x18(%esp),%edx
c002bed0:	e8 77 f7 ff ff       	call   c002b64c <pop_stack>
  lock_acquire(&filesys_lock);
c002bed5:	83 ec 0c             	sub    $0xc,%esp
c002bed8:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002bedd:	e8 f1 6f ff ff       	call   c0022ed3 <lock_acquire>
  file_seek(get_file_by_fd(&thread_current()->files, fd)->ptr, pos);
c002bee2:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c002bee6:	8b 74 24 28          	mov    0x28(%esp),%esi
c002beea:	e8 27 4e ff ff       	call   c0020d16 <thread_current>
c002beef:	05 bc 00 00 00       	add    $0xbc,%eax
c002bef4:	89 f2                	mov    %esi,%edx
c002bef6:	e8 7d f6 ff ff       	call   c002b578 <get_file_by_fd>
c002befb:	83 c4 08             	add    $0x8,%esp
c002befe:	53                   	push   %ebx
c002beff:	ff 30                	pushl  (%eax)
c002bf01:	e8 18 0f 00 00       	call   c002ce1e <file_seek>
  lock_release(&filesys_lock);
c002bf06:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002bf0d:	e8 5e 71 ff ff       	call   c0023070 <lock_release>
c002bf12:	83 c4 10             	add    $0x10,%esp
c002bf15:	e9 f6 fa ff ff       	jmp    c002ba10 <syscall_handler+0xef>
  pop_stack(f->esp, &fd, 1);
c002bf1a:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bf1f:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bf23:	e8 24 f7 ff ff       	call   c002b64c <pop_stack>
  lock_acquire(&filesys_lock);
c002bf28:	83 ec 0c             	sub    $0xc,%esp
c002bf2b:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002bf30:	e8 9e 6f ff ff       	call   c0022ed3 <lock_acquire>
  struct fd_t* fd_e = get_file_by_fd(&thread_current()->files, fd);
c002bf35:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c002bf39:	e8 d8 4d ff ff       	call   c0020d16 <thread_current>
c002bf3e:	05 bc 00 00 00       	add    $0xbc,%eax
c002bf43:	89 da                	mov    %ebx,%edx
c002bf45:	e8 2e f6 ff ff       	call   c002b578 <get_file_by_fd>
c002bf4a:	89 c3                	mov    %eax,%ebx
  if (fd_e == NULL || inode_is_dir (file_get_inode(fd_e->ptr))) {
c002bf4c:	83 c4 10             	add    $0x10,%esp
c002bf4f:	85 c0                	test   %eax,%eax
c002bf51:	74 40                	je     c002bf93 <syscall_handler+0x672>
c002bf53:	83 ec 0c             	sub    $0xc,%esp
c002bf56:	ff 30                	pushl  (%eax)
c002bf58:	e8 34 0d 00 00       	call   c002cc91 <file_get_inode>
c002bf5d:	89 04 24             	mov    %eax,(%esp)
c002bf60:	e8 01 24 00 00       	call   c002e366 <inode_is_dir>
c002bf65:	83 c4 10             	add    $0x10,%esp
c002bf68:	84 c0                	test   %al,%al
c002bf6a:	75 2e                	jne    c002bf9a <syscall_handler+0x679>
    ret = file_tell(fd_e->ptr);
c002bf6c:	83 ec 0c             	sub    $0xc,%esp
c002bf6f:	ff 33                	pushl  (%ebx)
c002bf71:	e8 04 0f 00 00       	call   c002ce7a <file_tell>
c002bf76:	89 c3                	mov    %eax,%ebx
c002bf78:	83 c4 10             	add    $0x10,%esp
  lock_release(&filesys_lock);
c002bf7b:	83 ec 0c             	sub    $0xc,%esp
c002bf7e:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002bf83:	e8 e8 70 ff ff       	call   c0023070 <lock_release>
	  case SYS_TELL: f->eax = syscall_tell(f); break;
c002bf88:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002bf8b:	83 c4 10             	add    $0x10,%esp
c002bf8e:	e9 7d fa ff ff       	jmp    c002ba10 <syscall_handler+0xef>
    ret = -1;
c002bf93:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002bf98:	eb e1                	jmp    c002bf7b <syscall_handler+0x65a>
c002bf9a:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002bf9f:	eb da                	jmp    c002bf7b <syscall_handler+0x65a>
  pop_stack(f->esp, &fd, 1);
c002bfa1:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bfa6:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002bfaa:	e8 9d f6 ff ff       	call   c002b64c <pop_stack>
  struct fd_t *entry = get_file_by_fd(&thread_current()->files, fd);
c002bfaf:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002bfb3:	e8 5e 4d ff ff       	call   c0020d16 <thread_current>
c002bfb8:	05 bc 00 00 00       	add    $0xbc,%eax
c002bfbd:	89 da                	mov    %ebx,%edx
c002bfbf:	e8 b4 f5 ff ff       	call   c002b578 <get_file_by_fd>
c002bfc4:	89 c3                	mov    %eax,%ebx
  if (entry != NULL) {
c002bfc6:	85 c0                	test   %eax,%eax
c002bfc8:	0f 84 42 fa ff ff    	je     c002ba10 <syscall_handler+0xef>
    lock_acquire(&filesys_lock);
c002bfce:	83 ec 0c             	sub    $0xc,%esp
c002bfd1:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002bfd6:	e8 f8 6e ff ff       	call   c0022ed3 <lock_acquire>
    if (inode_is_dir (file_get_inode(entry->ptr)))
c002bfdb:	83 c4 04             	add    $0x4,%esp
c002bfde:	ff 33                	pushl  (%ebx)
c002bfe0:	e8 ac 0c 00 00       	call   c002cc91 <file_get_inode>
c002bfe5:	89 04 24             	mov    %eax,(%esp)
c002bfe8:	e8 79 23 00 00       	call   c002e366 <inode_is_dir>
c002bfed:	83 c4 10             	add    $0x10,%esp
c002bff0:	84 c0                	test   %al,%al
c002bff2:	75 31                	jne    c002c025 <syscall_handler+0x704>
    file_close(entry->ptr);
c002bff4:	83 ec 0c             	sub    $0xc,%esp
c002bff7:	ff 33                	pushl  (%ebx)
c002bff9:	e8 ac 0d 00 00       	call   c002cdaa <file_close>
    list_remove(&entry->elem);
c002bffe:	8d 43 0c             	lea    0xc(%ebx),%eax
c002c001:	89 04 24             	mov    %eax,(%esp)
c002c004:	e8 84 cb ff ff       	call   c0028b8d <list_remove>
    free(entry);
c002c009:	89 1c 24             	mov    %ebx,(%esp)
c002c00c:	e8 b6 7b ff ff       	call   c0023bc7 <free>
    lock_release(&filesys_lock);
c002c011:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002c018:	e8 53 70 ff ff       	call   c0023070 <lock_release>
c002c01d:	83 c4 10             	add    $0x10,%esp
c002c020:	e9 eb f9 ff ff       	jmp    c002ba10 <syscall_handler+0xef>
      dir_close (entry->opened_dir);
c002c025:	83 ec 0c             	sub    $0xc,%esp
c002c028:	ff 73 08             	pushl  0x8(%ebx)
c002c02b:	e8 da 0f 00 00       	call   c002d00a <dir_close>
c002c030:	83 c4 10             	add    $0x10,%esp
c002c033:	eb bf                	jmp    c002bff4 <syscall_handler+0x6d3>
	  case SYS_MMAP: f->eax = syscall_mmap(f); break;
c002c035:	83 ec 0c             	sub    $0xc,%esp
c002c038:	55                   	push   %ebp
c002c039:	e8 76 f6 ff ff       	call   c002b6b4 <syscall_mmap>
c002c03e:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002c041:	83 c4 10             	add    $0x10,%esp
c002c044:	e9 c7 f9 ff ff       	jmp    c002ba10 <syscall_handler+0xef>
	  case SYS_MUNMAP: syscall_munmap(f); break;
c002c049:	83 ec 0c             	sub    $0xc,%esp
c002c04c:	55                   	push   %ebp
c002c04d:	e8 5a f8 ff ff       	call   c002b8ac <syscall_munmap>
c002c052:	83 c4 10             	add    $0x10,%esp
c002c055:	e9 b6 f9 ff ff       	jmp    c002ba10 <syscall_handler+0xef>
  pop_stack (f->esp, &path_name, 1);
c002c05a:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c05f:	8d 54 24 14          	lea    0x14(%esp),%edx
c002c063:	e8 e4 f5 ff ff       	call   c002b64c <pop_stack>
  if (path_name == NULL || strlen (path_name) == 0) {
c002c068:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002c06c:	85 db                	test   %ebx,%ebx
c002c06e:	0f 84 de 00 00 00    	je     c002c152 <syscall_handler+0x831>
c002c074:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c077:	75 0d                	jne    c002c086 <syscall_handler+0x765>
    return false;
c002c079:	b3 00                	mov    $0x0,%bl
    case SYS_CHDIR: f->eax = syscall_chdir(f); break;
c002c07b:	0f b6 db             	movzbl %bl,%ebx
c002c07e:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002c081:	e9 8a f9 ff ff       	jmp    c002ba10 <syscall_handler+0xef>
  char * pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002c086:	83 ec 08             	sub    $0x8,%esp
c002c089:	6a 01                	push   $0x1
c002c08b:	6a 0f                	push   $0xf
c002c08d:	e8 eb 7a ff ff       	call   c0023b7d <calloc>
c002c092:	89 44 24 28          	mov    %eax,0x28(%esp)
  if (filesys_is_root_dir (path_name)) {
c002c096:	89 1c 24             	mov    %ebx,(%esp)
c002c099:	e8 a6 04 00 00       	call   c002c544 <filesys_is_root_dir>
c002c09e:	89 c6                	mov    %eax,%esi
c002c0a0:	83 c4 10             	add    $0x10,%esp
c002c0a3:	84 c0                	test   %al,%al
c002c0a5:	74 3b                	je     c002c0e2 <syscall_handler+0x7c1>
    dir_close ( thread_current () -> dir);
c002c0a7:	e8 6a 4c ff ff       	call   c0020d16 <thread_current>
c002c0ac:	83 ec 0c             	sub    $0xc,%esp
c002c0af:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
c002c0b5:	e8 50 0f 00 00       	call   c002d00a <dir_close>
    thread_current () -> dir = dir_open_root ();
c002c0ba:	e8 57 4c ff ff       	call   c0020d16 <thread_current>
c002c0bf:	89 c3                	mov    %eax,%ebx
c002c0c1:	e8 14 0f 00 00       	call   c002cfda <dir_open_root>
c002c0c6:	89 83 e4 00 00 00    	mov    %eax,0xe4(%ebx)
c002c0cc:	83 c4 10             	add    $0x10,%esp
    success = true;
c002c0cf:	89 f3                	mov    %esi,%ebx
  free (pure_name);
c002c0d1:	83 ec 0c             	sub    $0xc,%esp
c002c0d4:	ff 74 24 24          	pushl  0x24(%esp)
c002c0d8:	e8 ea 7a ff ff       	call   c0023bc7 <free>
c002c0dd:	83 c4 10             	add    $0x10,%esp
c002c0e0:	eb 99                	jmp    c002c07b <syscall_handler+0x75a>
    if (filesys_path_parse (path_name, &dir, &pure_name, &is_dir)) {
c002c0e2:	8d 44 24 13          	lea    0x13(%esp),%eax
c002c0e6:	50                   	push   %eax
c002c0e7:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002c0eb:	50                   	push   %eax
c002c0ec:	8d 44 24 24          	lea    0x24(%esp),%eax
c002c0f0:	50                   	push   %eax
c002c0f1:	ff 74 24 20          	pushl  0x20(%esp)
c002c0f5:	e8 73 04 00 00       	call   c002c56d <filesys_path_parse>
c002c0fa:	88 c3                	mov    %al,%bl
c002c0fc:	83 c4 10             	add    $0x10,%esp
c002c0ff:	84 c0                	test   %al,%al
c002c101:	74 ce                	je     c002c0d1 <syscall_handler+0x7b0>
      struct dir * subdir = dir_subdir_lookup (dir, pure_name);
c002c103:	83 ec 08             	sub    $0x8,%esp
c002c106:	ff 74 24 20          	pushl  0x20(%esp)
c002c10a:	ff 74 24 28          	pushl  0x28(%esp)
c002c10e:	e8 2d 14 00 00       	call   c002d540 <dir_subdir_lookup>
c002c113:	89 c7                	mov    %eax,%edi
      if (subdir != NULL) {
c002c115:	83 c4 10             	add    $0x10,%esp
c002c118:	85 c0                	test   %eax,%eax
c002c11a:	74 32                	je     c002c14e <syscall_handler+0x82d>
        dir_close (thread_current () -> dir);
c002c11c:	e8 f5 4b ff ff       	call   c0020d16 <thread_current>
c002c121:	83 ec 0c             	sub    $0xc,%esp
c002c124:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
c002c12a:	e8 db 0e 00 00       	call   c002d00a <dir_close>
        thread_current () -> dir = subdir;
c002c12f:	e8 e2 4b ff ff       	call   c0020d16 <thread_current>
c002c134:	89 b8 e4 00 00 00    	mov    %edi,0xe4(%eax)
c002c13a:	83 c4 10             	add    $0x10,%esp
      dir_close (dir);
c002c13d:	83 ec 0c             	sub    $0xc,%esp
c002c140:	ff 74 24 28          	pushl  0x28(%esp)
c002c144:	e8 c1 0e 00 00       	call   c002d00a <dir_close>
c002c149:	83 c4 10             	add    $0x10,%esp
c002c14c:	eb 83                	jmp    c002c0d1 <syscall_handler+0x7b0>
  bool success = false;
c002c14e:	89 f3                	mov    %esi,%ebx
c002c150:	eb eb                	jmp    c002c13d <syscall_handler+0x81c>
    return false;
c002c152:	b3 00                	mov    $0x0,%bl
c002c154:	e9 22 ff ff ff       	jmp    c002c07b <syscall_handler+0x75a>
  pop_stack (f->esp, &path_name, 1);
c002c159:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c15e:	8d 54 24 14          	lea    0x14(%esp),%edx
c002c162:	e8 e5 f4 ff ff       	call   c002b64c <pop_stack>
  if (path_name == NULL || strlen (path_name) == 0) {
c002c167:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002c16b:	85 db                	test   %ebx,%ebx
c002c16d:	0f 84 88 00 00 00    	je     c002c1fb <syscall_handler+0x8da>
c002c173:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c176:	75 0d                	jne    c002c185 <syscall_handler+0x864>
    return false;
c002c178:	b3 00                	mov    $0x0,%bl
    case SYS_MKDIR: f->eax = syscall_mkdir(f); break;
c002c17a:	0f b6 db             	movzbl %bl,%ebx
c002c17d:	89 5d 1c             	mov    %ebx,0x1c(%ebp)
c002c180:	e9 8b f8 ff ff       	jmp    c002ba10 <syscall_handler+0xef>
  char * pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002c185:	83 ec 08             	sub    $0x8,%esp
c002c188:	6a 01                	push   $0x1
c002c18a:	6a 0f                	push   $0xf
c002c18c:	e8 ec 79 ff ff       	call   c0023b7d <calloc>
c002c191:	89 44 24 28          	mov    %eax,0x28(%esp)
  if (! filesys_is_root_dir (path_name) && filesys_path_parse (path_name, &dir, &pure_name, &is_dir)) {
c002c195:	89 1c 24             	mov    %ebx,(%esp)
c002c198:	e8 a7 03 00 00       	call   c002c544 <filesys_is_root_dir>
c002c19d:	83 c4 10             	add    $0x10,%esp
c002c1a0:	84 c0                	test   %al,%al
c002c1a2:	74 13                	je     c002c1b7 <syscall_handler+0x896>
  bool success = false;
c002c1a4:	b3 00                	mov    $0x0,%bl
  free (pure_name);
c002c1a6:	83 ec 0c             	sub    $0xc,%esp
c002c1a9:	ff 74 24 24          	pushl  0x24(%esp)
c002c1ad:	e8 15 7a ff ff       	call   c0023bc7 <free>
c002c1b2:	83 c4 10             	add    $0x10,%esp
c002c1b5:	eb c3                	jmp    c002c17a <syscall_handler+0x859>
  if (! filesys_is_root_dir (path_name) && filesys_path_parse (path_name, &dir, &pure_name, &is_dir)) {
c002c1b7:	8d 44 24 13          	lea    0x13(%esp),%eax
c002c1bb:	50                   	push   %eax
c002c1bc:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002c1c0:	50                   	push   %eax
c002c1c1:	8d 44 24 24          	lea    0x24(%esp),%eax
c002c1c5:	50                   	push   %eax
c002c1c6:	ff 74 24 20          	pushl  0x20(%esp)
c002c1ca:	e8 9e 03 00 00       	call   c002c56d <filesys_path_parse>
c002c1cf:	88 c3                	mov    %al,%bl
c002c1d1:	83 c4 10             	add    $0x10,%esp
c002c1d4:	84 c0                	test   %al,%al
c002c1d6:	74 ce                	je     c002c1a6 <syscall_handler+0x885>
    success = dir_subdir_create (dir, pure_name);
c002c1d8:	83 ec 08             	sub    $0x8,%esp
c002c1db:	ff 74 24 20          	pushl  0x20(%esp)
c002c1df:	ff 74 24 28          	pushl  0x28(%esp)
c002c1e3:	e8 c5 12 00 00       	call   c002d4ad <dir_subdir_create>
c002c1e8:	88 c3                	mov    %al,%bl
    dir_close (dir);
c002c1ea:	83 c4 04             	add    $0x4,%esp
c002c1ed:	ff 74 24 28          	pushl  0x28(%esp)
c002c1f1:	e8 14 0e 00 00       	call   c002d00a <dir_close>
c002c1f6:	83 c4 10             	add    $0x10,%esp
c002c1f9:	eb ab                	jmp    c002c1a6 <syscall_handler+0x885>
    return false;
c002c1fb:	b3 00                	mov    $0x0,%bl
c002c1fd:	e9 78 ff ff ff       	jmp    c002c17a <syscall_handler+0x859>
  pop_stack (f->esp, &fd, 1);
c002c202:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c207:	8d 54 24 18          	lea    0x18(%esp),%edx
c002c20b:	e8 3c f4 ff ff       	call   c002b64c <pop_stack>
  pop_stack (f->esp, &name, 2);
c002c210:	8b 45 48             	mov    0x48(%ebp),%eax
c002c213:	b9 02 00 00 00       	mov    $0x2,%ecx
c002c218:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002c21c:	e8 2b f4 ff ff       	call   c002b64c <pop_stack>
  if (fd <= 1 || name == NULL)
c002c221:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002c225:	83 fb 01             	cmp    $0x1,%ebx
c002c228:	7e 4d                	jle    c002c277 <syscall_handler+0x956>
c002c22a:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c002c22f:	74 4a                	je     c002c27b <syscall_handler+0x95a>
  struct fd_t * fd_e = get_file_by_fd(&thread_current()->files, fd);
c002c231:	e8 e0 4a ff ff       	call   c0020d16 <thread_current>
c002c236:	05 bc 00 00 00       	add    $0xbc,%eax
c002c23b:	89 da                	mov    %ebx,%edx
c002c23d:	e8 36 f3 ff ff       	call   c002b578 <get_file_by_fd>
c002c242:	89 c3                	mov    %eax,%ebx
  if (fd_e != NULL && dir_is_dirfile (fd_e)) {
c002c244:	85 c0                	test   %eax,%eax
c002c246:	74 37                	je     c002c27f <syscall_handler+0x95e>
c002c248:	83 ec 0c             	sub    $0xc,%esp
c002c24b:	50                   	push   %eax
c002c24c:	e8 8b 16 00 00       	call   c002d8dc <dir_is_dirfile>
c002c251:	83 c4 10             	add    $0x10,%esp
c002c254:	84 c0                	test   %al,%al
c002c256:	75 0b                	jne    c002c263 <syscall_handler+0x942>
    case SYS_READDIR: f->eax = syscall_readdir(f); break;
c002c258:	0f b6 c0             	movzbl %al,%eax
c002c25b:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002c25e:	e9 ad f7 ff ff       	jmp    c002ba10 <syscall_handler+0xef>
    success = dir_readdir (fd_e->opened_dir, name);
c002c263:	83 ec 08             	sub    $0x8,%esp
c002c266:	ff 74 24 24          	pushl  0x24(%esp)
c002c26a:	ff 73 08             	pushl  0x8(%ebx)
c002c26d:	e8 69 11 00 00       	call   c002d3db <dir_readdir>
c002c272:	83 c4 10             	add    $0x10,%esp
c002c275:	eb e1                	jmp    c002c258 <syscall_handler+0x937>
    return false;
c002c277:	b0 00                	mov    $0x0,%al
c002c279:	eb dd                	jmp    c002c258 <syscall_handler+0x937>
c002c27b:	b0 00                	mov    $0x0,%al
c002c27d:	eb d9                	jmp    c002c258 <syscall_handler+0x937>
  bool success = false;
c002c27f:	b0 00                	mov    $0x0,%al
c002c281:	eb d5                	jmp    c002c258 <syscall_handler+0x937>
  pop_stack (f->esp, &fd, 1);
c002c283:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c288:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002c28c:	e8 bb f3 ff ff       	call   c002b64c <pop_stack>
  if (fd <= 1) return false;
c002c291:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002c295:	83 fb 01             	cmp    $0x1,%ebx
c002c298:	7e 39                	jle    c002c2d3 <syscall_handler+0x9b2>
  struct fd_t * fd_e = get_file_by_fd(&thread_current()->files, fd);
c002c29a:	e8 77 4a ff ff       	call   c0020d16 <thread_current>
c002c29f:	05 bc 00 00 00       	add    $0xbc,%eax
c002c2a4:	89 da                	mov    %ebx,%edx
c002c2a6:	e8 cd f2 ff ff       	call   c002b578 <get_file_by_fd>
  return fd_e != NULL && dir_is_dirfile (fd_e);
c002c2ab:	85 c0                	test   %eax,%eax
c002c2ad:	74 1d                	je     c002c2cc <syscall_handler+0x9ab>
c002c2af:	83 ec 0c             	sub    $0xc,%esp
c002c2b2:	50                   	push   %eax
c002c2b3:	e8 24 16 00 00       	call   c002d8dc <dir_is_dirfile>
c002c2b8:	0f b6 c0             	movzbl %al,%eax
c002c2bb:	83 c4 10             	add    $0x10,%esp
c002c2be:	83 e0 01             	and    $0x1,%eax
    case SYS_ISDIR: f->eax = syscall_isdir(f); break;
c002c2c1:	0f b6 c0             	movzbl %al,%eax
c002c2c4:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002c2c7:	e9 44 f7 ff ff       	jmp    c002ba10 <syscall_handler+0xef>
  return fd_e != NULL && dir_is_dirfile (fd_e);
c002c2cc:	b8 00 00 00 00       	mov    $0x0,%eax
c002c2d1:	eb eb                	jmp    c002c2be <syscall_handler+0x99d>
  if (fd <= 1) return false;
c002c2d3:	b0 00                	mov    $0x0,%al
c002c2d5:	eb ea                	jmp    c002c2c1 <syscall_handler+0x9a0>
  pop_stack (f->esp, &fd, 1);
c002c2d7:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c2dc:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c002c2e0:	e8 67 f3 ff ff       	call   c002b64c <pop_stack>
  if (fd <= 1) return -1;
c002c2e5:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002c2e9:	83 fb 01             	cmp    $0x1,%ebx
c002c2ec:	7e 32                	jle    c002c320 <syscall_handler+0x9ff>
  struct fd_t * fd_e = get_file_by_fd (&thread_current()->files, fd);
c002c2ee:	e8 23 4a ff ff       	call   c0020d16 <thread_current>
c002c2f3:	05 bc 00 00 00       	add    $0xbc,%eax
c002c2f8:	89 da                	mov    %ebx,%edx
c002c2fa:	e8 79 f2 ff ff       	call   c002b578 <get_file_by_fd>
  if (fd_e != NULL) 
c002c2ff:	85 c0                	test   %eax,%eax
c002c301:	74 24                	je     c002c327 <syscall_handler+0xa06>
    return inode_get_inumber (file_get_inode (fd_e->ptr));
c002c303:	83 ec 0c             	sub    $0xc,%esp
c002c306:	ff 30                	pushl  (%eax)
c002c308:	e8 84 09 00 00       	call   c002cc91 <file_get_inode>
c002c30d:	89 04 24             	mov    %eax,(%esp)
c002c310:	e8 79 1b 00 00       	call   c002de8e <inode_get_inumber>
c002c315:	83 c4 10             	add    $0x10,%esp
    case SYS_INUMBER: f->eax = syscall_inumber(f); break;
c002c318:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002c31b:	e9 f0 f6 ff ff       	jmp    c002ba10 <syscall_handler+0xef>
  if (fd <= 1) return -1;
c002c320:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002c325:	eb f1                	jmp    c002c318 <syscall_handler+0x9f7>
  return -1;
c002c327:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002c32c:	eb ea                	jmp    c002c318 <syscall_handler+0x9f7>
      printf("Not implemented system call %d!\n", sysnum);
c002c32e:	83 ec 08             	sub    $0x8,%esp
c002c331:	52                   	push   %edx
c002c332:	68 58 2f 03 c0       	push   $0xc0032f58
c002c337:	e8 93 a8 ff ff       	call   c0026bcf <printf>
c002c33c:	83 c4 10             	add    $0x10,%esp
}
c002c33f:	e9 cc f6 ff ff       	jmp    c002ba10 <syscall_handler+0xef>

c002c344 <gdt_init>:

/* Sets up a proper GDT.  The bootstrap loader's GDT didn't
   include user-mode selectors or a TSS, but we need both now. */
void
gdt_init (void)
{
c002c344:	83 ec 1c             	sub    $0x1c,%esp
  uint64_t gdtr_operand;

  /* Initialize GDT. */
  gdt[SEL_NULL / sizeof *gdt] = 0;
c002c347:	c7 05 c0 e4 03 c0 00 	movl   $0x0,0xc003e4c0
c002c34e:	00 00 00 
c002c351:	c7 05 c4 e4 03 c0 00 	movl   $0x0,0xc003e4c4
c002c358:	00 00 00 
  gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc (0);
c002c35b:	c7 05 c8 e4 03 c0 ff 	movl   $0xffff,0xc003e4c8
c002c362:	ff 00 00 
c002c365:	c7 05 cc e4 03 c0 00 	movl   $0xcf9a00,0xc003e4cc
c002c36c:	9a cf 00 
  gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc (0);
c002c36f:	c7 05 d0 e4 03 c0 ff 	movl   $0xffff,0xc003e4d0
c002c376:	ff 00 00 
c002c379:	c7 05 d4 e4 03 c0 00 	movl   $0xcf9200,0xc003e4d4
c002c380:	92 cf 00 
  gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc (3);
c002c383:	c7 05 d8 e4 03 c0 ff 	movl   $0xffff,0xc003e4d8
c002c38a:	ff 00 00 
c002c38d:	c7 05 dc e4 03 c0 00 	movl   $0xcffa00,0xc003e4dc
c002c394:	fa cf 00 
  gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc (3);
c002c397:	c7 05 e0 e4 03 c0 ff 	movl   $0xffff,0xc003e4e0
c002c39e:	ff 00 00 
c002c3a1:	c7 05 e4 e4 03 c0 00 	movl   $0xcff200,0xc003e4e4
c002c3a8:	f2 cf 00 
  gdt[SEL_TSS / sizeof *gdt] = make_tss_desc (tss_get ());
c002c3ab:	e8 56 00 00 00       	call   c002c406 <tss_get>
  ASSERT (granularity == GRAN_BYTE || granularity == GRAN_PAGE);

  e0 = ((limit & 0xffff)             /* Limit 15:0. */
        | (base << 16));             /* Base 15:0. */

  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002c3b0:	89 c2                	mov    %eax,%edx
c002c3b2:	c1 ea 10             	shr    $0x10,%edx
c002c3b5:	0f b6 d2             	movzbl %dl,%edx
        | (dpl << 13)                /* Descriptor privilege. */
        | (1 << 15)                  /* Present. */
        | (limit & 0xf0000)          /* Limit 16:19. */
        | (1 << 22)                  /* 32-bit segment. */
        | (granularity << 23)        /* Byte/page granularity. */
        | (base & 0xff000000));      /* Base 31:24. */
c002c3b8:	89 c1                	mov    %eax,%ecx
c002c3ba:	81 e1 00 00 00 ff    	and    $0xff000000,%ecx
  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002c3c0:	81 c9 00 89 40 00    	or     $0x408900,%ecx
c002c3c6:	09 ca                	or     %ecx,%edx
        | (base << 16));             /* Base 15:0. */
c002c3c8:	c1 e0 10             	shl    $0x10,%eax
  e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002c3cb:	83 c8 67             	or     $0x67,%eax

  return e0 | ((uint64_t) e1 << 32);
c002c3ce:	a3 e8 e4 03 c0       	mov    %eax,0xc003e4e8
c002c3d3:	89 15 ec e4 03 c0    	mov    %edx,0xc003e4ec
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LGDT instruction. */
static uint64_t
make_gdtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
c002c3d9:	b8 c0 e4 03 c0       	mov    $0xc003e4c0,%eax
c002c3de:	ba 00 00 00 00       	mov    $0x0,%edx
c002c3e3:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002c3e7:	c1 e0 10             	shl    $0x10,%eax
c002c3ea:	83 c8 2f             	or     $0x2f,%eax
c002c3ed:	89 44 24 08          	mov    %eax,0x8(%esp)
c002c3f1:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lgdt %0" : : "m" (gdtr_operand));
c002c3f5:	0f 01 54 24 08       	lgdtl  0x8(%esp)
  asm volatile ("ltr %w0" : : "q" (SEL_TSS));
c002c3fa:	b8 28 00 00 00       	mov    $0x28,%eax
c002c3ff:	0f 00 d8             	ltr    %ax
}
c002c402:	83 c4 1c             	add    $0x1c,%esp
c002c405:	c3                   	ret    

c002c406 <tss_get>:

/* Returns the kernel TSS. */
struct tss *
tss_get (void) 
{
  ASSERT (tss != NULL);
c002c406:	a1 f0 e4 03 c0       	mov    0xc003e4f0,%eax
c002c40b:	85 c0                	test   %eax,%eax
c002c40d:	74 01                	je     c002c410 <tss_get+0xa>
  return tss;
}
c002c40f:	c3                   	ret    
{
c002c410:	83 ec 18             	sub    $0x18,%esp
  ASSERT (tss != NULL);
c002c413:	68 79 2f 03 c0       	push   $0xc0032f79
c002c418:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002c41d:	68 60 0a 03 c0       	push   $0xc0030a60
c002c422:	6a 5f                	push   $0x5f
c002c424:	68 85 2f 03 c0       	push   $0xc0032f85
c002c429:	e8 4f c2 ff ff       	call   c002867d <debug_panic>

c002c42e <tss_update>:

/* Sets the ring 0 stack pointer in the TSS to point to the end
   of the thread stack. */
void
tss_update (void) 
{
c002c42e:	53                   	push   %ebx
c002c42f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (tss != NULL);
c002c432:	8b 1d f0 e4 03 c0    	mov    0xc003e4f0,%ebx
c002c438:	85 db                	test   %ebx,%ebx
c002c43a:	74 12                	je     c002c44e <tss_update+0x20>
  tss->esp0 = (uint8_t *) thread_current () + PGSIZE;
c002c43c:	e8 d5 48 ff ff       	call   c0020d16 <thread_current>
c002c441:	05 00 10 00 00       	add    $0x1000,%eax
c002c446:	89 43 04             	mov    %eax,0x4(%ebx)
}
c002c449:	83 c4 08             	add    $0x8,%esp
c002c44c:	5b                   	pop    %ebx
c002c44d:	c3                   	ret    
  ASSERT (tss != NULL);
c002c44e:	83 ec 0c             	sub    $0xc,%esp
c002c451:	68 79 2f 03 c0       	push   $0xc0032f79
c002c456:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002c45b:	68 54 0a 03 c0       	push   $0xc0030a54
c002c460:	6a 68                	push   $0x68
c002c462:	68 85 2f 03 c0       	push   $0xc0032f85
c002c467:	e8 11 c2 ff ff       	call   c002867d <debug_panic>

c002c46c <tss_init>:
{
c002c46c:	83 ec 18             	sub    $0x18,%esp
  tss = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002c46f:	6a 03                	push   $0x3
c002c471:	e8 38 72 ff ff       	call   c00236ae <palloc_get_page>
c002c476:	a3 f0 e4 03 c0       	mov    %eax,0xc003e4f0
  tss->ss0 = SEL_KDSEG;
c002c47b:	66 c7 40 08 10 00    	movw   $0x10,0x8(%eax)
  tss->bitmap = 0xdfff;
c002c481:	66 c7 40 66 ff df    	movw   $0xdfff,0x66(%eax)
  tss_update ();
c002c487:	e8 a2 ff ff ff       	call   c002c42e <tss_update>
}
c002c48c:	83 c4 1c             	add    $0x1c,%esp
c002c48f:	c3                   	ret    

c002c490 <filesys_init>:

/* Initializes the file system module.
   If FORMAT is true, reformats the file system. */
void
filesys_init (bool format) 
{
c002c490:	53                   	push   %ebx
c002c491:	83 ec 14             	sub    $0x14,%esp
c002c494:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  fs_device = block_get_role (BLOCK_FILESYS);
c002c498:	6a 01                	push   $0x1
c002c49a:	e8 1b 87 ff ff       	call   c0024bba <block_get_role>
c002c49f:	a3 38 6c 04 c0       	mov    %eax,0xc0046c38
  if (fs_device == NULL)
c002c4a4:	83 c4 10             	add    $0x10,%esp
c002c4a7:	85 c0                	test   %eax,%eax
c002c4a9:	74 1d                	je     c002c4c8 <filesys_init+0x38>
    PANIC ("No file system device found, can't initialize file system.");

  inode_init ();
c002c4ab:	e8 c1 16 00 00       	call   c002db71 <inode_init>
  free_map_init ();
c002c4b0:	e8 21 05 00 00       	call   c002c9d6 <free_map_init>
  cache_init ();
c002c4b5:	e8 c3 25 00 00       	call   c002ea7d <cache_init>

  if (format) 
c002c4ba:	84 db                	test   %bl,%bl
c002c4bc:	75 20                	jne    c002c4de <filesys_init+0x4e>
    do_format ();

  free_map_open ();
c002c4be:	e8 3f 06 00 00       	call   c002cb02 <free_map_open>
}
c002c4c3:	83 c4 08             	add    $0x8,%esp
c002c4c6:	5b                   	pop    %ebx
c002c4c7:	c3                   	ret    
    PANIC ("No file system device found, can't initialize file system.");
c002c4c8:	68 9c 2f 03 c0       	push   $0xc0032f9c
c002c4cd:	68 88 0a 03 c0       	push   $0xc0030a88
c002c4d2:	6a 1a                	push   $0x1a
c002c4d4:	68 19 30 03 c0       	push   $0xc0033019
c002c4d9:	e8 9f c1 ff ff       	call   c002867d <debug_panic>

/* Formats the file system. */
static void
do_format (void)
{
  printf ("Formatting file system...");
c002c4de:	83 ec 0c             	sub    $0xc,%esp
c002c4e1:	68 31 30 03 c0       	push   $0xc0033031
c002c4e6:	e8 e4 a6 ff ff       	call   c0026bcf <printf>
  free_map_create ();
c002c4eb:	e8 88 06 00 00       	call   c002cb78 <free_map_create>
  if (!dir_create (ROOT_DIR_SECTOR, 16))
c002c4f0:	83 c4 08             	add    $0x8,%esp
c002c4f3:	6a 10                	push   $0x10
c002c4f5:	6a 01                	push   $0x1
c002c4f7:	e8 8f 0d 00 00       	call   c002d28b <dir_create>
c002c4fc:	83 c4 10             	add    $0x10,%esp
c002c4ff:	84 c0                	test   %al,%al
c002c501:	74 17                	je     c002c51a <filesys_init+0x8a>
    PANIC ("root directory creation failed");
  free_map_close ();
c002c503:	e8 5e 06 00 00       	call   c002cb66 <free_map_close>
  printf ("done.\n");
c002c508:	83 ec 0c             	sub    $0xc,%esp
c002c50b:	68 7c 18 03 c0       	push   $0xc003187c
c002c510:	e8 4f dc ff ff       	call   c002a164 <puts>
c002c515:	83 c4 10             	add    $0x10,%esp
c002c518:	eb a4                	jmp    c002c4be <filesys_init+0x2e>
    PANIC ("root directory creation failed");
c002c51a:	68 d8 2f 03 c0       	push   $0xc0032fd8
c002c51f:	68 7c 0a 03 c0       	push   $0xc0030a7c
c002c524:	68 a2 00 00 00       	push   $0xa2
c002c529:	68 19 30 03 c0       	push   $0xc0033019
c002c52e:	e8 4a c1 ff ff       	call   c002867d <debug_panic>

c002c533 <filesys_done>:
{
c002c533:	83 ec 0c             	sub    $0xc,%esp
  free_map_close ();
c002c536:	e8 2b 06 00 00       	call   c002cb66 <free_map_close>
  cache_done ();
c002c53b:	e8 cb 26 00 00       	call   c002ec0b <cache_done>
}
c002c540:	83 c4 0c             	add    $0xc,%esp
c002c543:	c3                   	ret    

c002c544 <filesys_is_root_dir>:
  return false;
}

/* name == "/" ? */
bool
filesys_is_root_dir (const char * name) {
c002c544:	8b 44 24 04          	mov    0x4(%esp),%eax
  return name != NULL && name[0] == '/' && name[1] == '\0';
c002c548:	85 c0                	test   %eax,%eax
c002c54a:	74 1a                	je     c002c566 <filesys_is_root_dir+0x22>
c002c54c:	80 38 2f             	cmpb   $0x2f,(%eax)
c002c54f:	74 09                	je     c002c55a <filesys_is_root_dir+0x16>
c002c551:	b8 00 00 00 00       	mov    $0x0,%eax
c002c556:	83 e0 01             	and    $0x1,%eax
}
c002c559:	c3                   	ret    
  return name != NULL && name[0] == '/' && name[1] == '\0';
c002c55a:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
c002c55e:	0f 94 c0             	sete   %al
c002c561:	0f b6 c0             	movzbl %al,%eax
c002c564:	eb f0                	jmp    c002c556 <filesys_is_root_dir+0x12>
c002c566:	b8 00 00 00 00       	mov    $0x0,%eax
c002c56b:	eb e9                	jmp    c002c556 <filesys_is_root_dir+0x12>

c002c56d <filesys_path_parse>:
dir       : On success, return the directory the file belong to. Should be closed by caller.
pure_name : On success, copy the name of file into *pure_name.
is_dir    : On success, indicate if path name is ended with slash.
*/
bool
filesys_path_parse (const char *name, struct dir **dir, char **pure_name, bool *is_dir) {
c002c56d:	55                   	push   %ebp
c002c56e:	57                   	push   %edi
c002c56f:	56                   	push   %esi
c002c570:	53                   	push   %ebx
c002c571:	83 ec 2c             	sub    $0x2c,%esp
c002c574:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c002c578:	8b 74 24 44          	mov    0x44(%esp),%esi
  int len;
  if (name == NULL || (len = strlen (name)) == 0 || (len == 1 && name[0] == '/'))
c002c57c:	85 ed                	test   %ebp,%ebp
c002c57e:	0f 84 86 01 00 00    	je     c002c70a <filesys_path_parse+0x19d>
c002c584:	b0 00                	mov    $0x0,%al
c002c586:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002c58b:	89 ef                	mov    %ebp,%edi
c002c58d:	f2 ae                	repnz scas %es:(%edi),%al
c002c58f:	f7 d1                	not    %ecx
c002c591:	49                   	dec    %ecx
c002c592:	89 cb                	mov    %ecx,%ebx
c002c594:	0f 84 74 01 00 00    	je     c002c70e <filesys_path_parse+0x1a1>
c002c59a:	83 f9 01             	cmp    $0x1,%ecx
c002c59d:	0f 84 83 00 00 00    	je     c002c626 <filesys_path_parse+0xb9>
    return false;
  char *path = calloc (len + 1, 1);
c002c5a3:	8d 7b 01             	lea    0x1(%ebx),%edi
c002c5a6:	83 ec 08             	sub    $0x8,%esp
c002c5a9:	6a 01                	push   $0x1
c002c5ab:	57                   	push   %edi
c002c5ac:	e8 cc 75 ff ff       	call   c0023b7d <calloc>
c002c5b1:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  strlcpy (path, name, len + 1);
c002c5b5:	83 c4 0c             	add    $0xc,%esp
c002c5b8:	57                   	push   %edi
c002c5b9:	55                   	push   %ebp
c002c5ba:	89 c7                	mov    %eax,%edi
c002c5bc:	50                   	push   %eax
c002c5bd:	e8 b5 b7 ff ff       	call   c0027d77 <strlcpy>
  if (path[len - 1] == '/') {
c002c5c2:	83 c4 10             	add    $0x10,%esp
c002c5c5:	80 7c 1f ff 2f       	cmpb   $0x2f,-0x1(%edi,%ebx,1)
c002c5ca:	74 6b                	je     c002c637 <filesys_path_parse+0xca>
    *is_dir = true;
    path[len--] = 0;
  } else {
    *is_dir = false;
c002c5cc:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002c5d0:	c6 00 00             	movb   $0x0,(%eax)
  }
  if (path[0] == '/') {
c002c5d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002c5d7:	80 38 2f             	cmpb   $0x2f,(%eax)
c002c5da:	74 6c                	je     c002c648 <filesys_path_parse+0xdb>
    *dir = dir_open_root ();
  } else {
    ASSERT (thread_current () -> dir != NULL);
c002c5dc:	e8 35 47 ff ff       	call   c0020d16 <thread_current>
c002c5e1:	83 b8 e4 00 00 00 00 	cmpl   $0x0,0xe4(%eax)
c002c5e8:	74 67                	je     c002c651 <filesys_path_parse+0xe4>
    *dir = dir_reopen (thread_current ()->dir); // NPE for start up
c002c5ea:	e8 27 47 ff ff       	call   c0020d16 <thread_current>
c002c5ef:	83 ec 0c             	sub    $0xc,%esp
c002c5f2:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
c002c5f8:	e8 f3 09 00 00       	call   c002cff0 <dir_reopen>
c002c5fd:	89 06                	mov    %eax,(%esi)
c002c5ff:	83 c4 10             	add    $0x10,%esp
  }
  char *token, *saveptr, *next;
  bool success = false;
  token = strtok_r (path, DELIM, &saveptr);
c002c602:	83 ec 04             	sub    $0x4,%esp
c002c605:	8d 44 24 20          	lea    0x20(%esp),%eax
c002c609:	50                   	push   %eax
c002c60a:	68 27 1c 03 c0       	push   $0xc0031c27
c002c60f:	ff 74 24 18          	pushl  0x18(%esp)
c002c613:	e8 85 b5 ff ff       	call   c0027b9d <strtok_r>
c002c618:	89 c3                	mov    %eax,%ebx
c002c61a:	83 c4 10             	add    $0x10,%esp
  for ( ; ; ) {
    if (!check_name (token)) {
      dir_close (*dir);
      break;
    }
    next = strtok_r (NULL, DELIM, &saveptr);
c002c61d:	8d 6c 24 1c          	lea    0x1c(%esp),%ebp
c002c621:	e9 87 00 00 00       	jmp    c002c6ad <filesys_path_parse+0x140>
  if (name == NULL || (len = strlen (name)) == 0 || (len == 1 && name[0] == '/'))
c002c626:	80 7d 00 2f          	cmpb   $0x2f,0x0(%ebp)
c002c62a:	0f 85 73 ff ff ff    	jne    c002c5a3 <filesys_path_parse+0x36>
    return false;
c002c630:	b3 00                	mov    $0x0,%bl
c002c632:	e9 ad 00 00 00       	jmp    c002c6e4 <filesys_path_parse+0x177>
    *is_dir = true;
c002c637:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002c63b:	c6 00 01             	movb   $0x1,(%eax)
    path[len--] = 0;
c002c63e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002c642:	c6 04 18 00          	movb   $0x0,(%eax,%ebx,1)
c002c646:	eb 8b                	jmp    c002c5d3 <filesys_path_parse+0x66>
    *dir = dir_open_root ();
c002c648:	e8 8d 09 00 00       	call   c002cfda <dir_open_root>
c002c64d:	89 06                	mov    %eax,(%esi)
c002c64f:	eb b1                	jmp    c002c602 <filesys_path_parse+0x95>
    ASSERT (thread_current () -> dir != NULL);
c002c651:	83 ec 0c             	sub    $0xc,%esp
c002c654:	68 f8 2f 03 c0       	push   $0xc0032ff8
c002c659:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002c65e:	68 68 0a 03 c0       	push   $0xc0030a68
c002c663:	68 d8 00 00 00       	push   $0xd8
c002c668:	68 19 30 03 c0       	push   $0xc0033019
c002c66d:	e8 0b c0 ff ff       	call   c002867d <debug_panic>
    next = strtok_r (NULL, DELIM, &saveptr);
c002c672:	83 ec 04             	sub    $0x4,%esp
c002c675:	55                   	push   %ebp
c002c676:	68 27 1c 03 c0       	push   $0xc0031c27
c002c67b:	6a 00                	push   $0x0
c002c67d:	e8 1b b5 ff ff       	call   c0027b9d <strtok_r>
c002c682:	89 c7                	mov    %eax,%edi
    if (next == NULL) {
c002c684:	83 c4 10             	add    $0x10,%esp
c002c687:	85 c0                	test   %eax,%eax
c002c689:	74 63                	je     c002c6ee <filesys_path_parse+0x181>
      strlcpy (*pure_name, token, READDIR_MAX_LEN + 1);
      success = true;
      break;
    }
    struct dir *nxt = dir_subdir_lookup (*dir, token);
c002c68b:	83 ec 08             	sub    $0x8,%esp
c002c68e:	53                   	push   %ebx
c002c68f:	ff 36                	pushl  (%esi)
c002c691:	e8 aa 0e 00 00       	call   c002d540 <dir_subdir_lookup>
c002c696:	89 c3                	mov    %eax,%ebx
    dir_close (*dir);
c002c698:	83 c4 04             	add    $0x4,%esp
c002c69b:	ff 36                	pushl  (%esi)
c002c69d:	e8 68 09 00 00       	call   c002d00a <dir_close>
    if (nxt == NULL) {
c002c6a2:	83 c4 10             	add    $0x10,%esp
c002c6a5:	85 db                	test   %ebx,%ebx
c002c6a7:	74 5d                	je     c002c706 <filesys_path_parse+0x199>
      break;
    }
    *dir = nxt;
c002c6a9:	89 1e                	mov    %ebx,(%esi)
    token = next;
c002c6ab:	89 fb                	mov    %edi,%ebx
  if (name == NULL)
c002c6ad:	85 db                	test   %ebx,%ebx
c002c6af:	74 15                	je     c002c6c6 <filesys_path_parse+0x159>
c002c6b1:	89 d8                	mov    %ebx,%eax
c002c6b3:	8d 4b 0f             	lea    0xf(%ebx),%ecx
    switch (name[i]) {
c002c6b6:	8a 10                	mov    (%eax),%dl
c002c6b8:	84 d2                	test   %dl,%dl
c002c6ba:	74 b6                	je     c002c672 <filesys_path_parse+0x105>
c002c6bc:	80 fa 2f             	cmp    $0x2f,%dl
c002c6bf:	74 05                	je     c002c6c6 <filesys_path_parse+0x159>
c002c6c1:	40                   	inc    %eax
  for (int i = 0; i < READDIR_MAX_LEN + 1; i++) {
c002c6c2:	39 c8                	cmp    %ecx,%eax
c002c6c4:	75 f0                	jne    c002c6b6 <filesys_path_parse+0x149>
      dir_close (*dir);
c002c6c6:	83 ec 0c             	sub    $0xc,%esp
c002c6c9:	ff 36                	pushl  (%esi)
c002c6cb:	e8 3a 09 00 00       	call   c002d00a <dir_close>
      break;
c002c6d0:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002c6d3:	b3 00                	mov    $0x0,%bl
  }
  free (path);
c002c6d5:	83 ec 0c             	sub    $0xc,%esp
c002c6d8:	ff 74 24 18          	pushl  0x18(%esp)
c002c6dc:	e8 e6 74 ff ff       	call   c0023bc7 <free>
  return success;
c002c6e1:	83 c4 10             	add    $0x10,%esp
}
c002c6e4:	88 d8                	mov    %bl,%al
c002c6e6:	83 c4 2c             	add    $0x2c,%esp
c002c6e9:	5b                   	pop    %ebx
c002c6ea:	5e                   	pop    %esi
c002c6eb:	5f                   	pop    %edi
c002c6ec:	5d                   	pop    %ebp
c002c6ed:	c3                   	ret    
      strlcpy (*pure_name, token, READDIR_MAX_LEN + 1);
c002c6ee:	83 ec 04             	sub    $0x4,%esp
c002c6f1:	6a 0f                	push   $0xf
c002c6f3:	53                   	push   %ebx
c002c6f4:	8b 44 24 54          	mov    0x54(%esp),%eax
c002c6f8:	ff 30                	pushl  (%eax)
c002c6fa:	e8 78 b6 ff ff       	call   c0027d77 <strlcpy>
      break;
c002c6ff:	83 c4 10             	add    $0x10,%esp
      success = true;
c002c702:	b3 01                	mov    $0x1,%bl
      break;
c002c704:	eb cf                	jmp    c002c6d5 <filesys_path_parse+0x168>
  bool success = false;
c002c706:	b3 00                	mov    $0x0,%bl
c002c708:	eb cb                	jmp    c002c6d5 <filesys_path_parse+0x168>
    return false;
c002c70a:	b3 00                	mov    $0x0,%bl
c002c70c:	eb d6                	jmp    c002c6e4 <filesys_path_parse+0x177>
c002c70e:	b3 00                	mov    $0x0,%bl
c002c710:	eb d2                	jmp    c002c6e4 <filesys_path_parse+0x177>

c002c712 <filesys_create>:
{
c002c712:	53                   	push   %ebx
c002c713:	83 ec 20             	sub    $0x20,%esp
c002c716:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  char *pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002c71a:	6a 01                	push   $0x1
c002c71c:	6a 0f                	push   $0xf
c002c71e:	e8 5a 74 ff ff       	call   c0023b7d <calloc>
c002c723:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (name != NULL && strlen(name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c727:	83 c4 10             	add    $0x10,%esp
c002c72a:	85 db                	test   %ebx,%ebx
c002c72c:	74 73                	je     c002c7a1 <filesys_create+0x8f>
c002c72e:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c731:	74 72                	je     c002c7a5 <filesys_create+0x93>
c002c733:	83 ec 0c             	sub    $0xc,%esp
c002c736:	53                   	push   %ebx
c002c737:	e8 08 fe ff ff       	call   c002c544 <filesys_is_root_dir>
c002c73c:	83 c4 10             	add    $0x10,%esp
c002c73f:	84 c0                	test   %al,%al
c002c741:	74 04                	je     c002c747 <filesys_create+0x35>
  bool success = false;
c002c743:	b3 00                	mov    $0x0,%bl
c002c745:	eb 60                	jmp    c002c7a7 <filesys_create+0x95>
  if (name != NULL && strlen(name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c747:	8d 44 24 07          	lea    0x7(%esp),%eax
c002c74b:	50                   	push   %eax
c002c74c:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002c750:	50                   	push   %eax
c002c751:	8d 44 24 14          	lea    0x14(%esp),%eax
c002c755:	50                   	push   %eax
c002c756:	53                   	push   %ebx
c002c757:	e8 11 fe ff ff       	call   c002c56d <filesys_path_parse>
c002c75c:	88 c3                	mov    %al,%bl
c002c75e:	83 c4 10             	add    $0x10,%esp
c002c761:	84 c0                	test   %al,%al
c002c763:	74 42                	je     c002c7a7 <filesys_create+0x95>
    success = !is_dir && dir_subfile_create (dir, pure_name, initial_size);
c002c765:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c002c76a:	74 19                	je     c002c785 <filesys_create+0x73>
c002c76c:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c771:	83 e3 01             	and    $0x1,%ebx
    dir_close (dir);
c002c774:	83 ec 0c             	sub    $0xc,%esp
c002c777:	ff 74 24 18          	pushl  0x18(%esp)
c002c77b:	e8 8a 08 00 00       	call   c002d00a <dir_close>
c002c780:	83 c4 10             	add    $0x10,%esp
c002c783:	eb 22                	jmp    c002c7a7 <filesys_create+0x95>
    success = !is_dir && dir_subfile_create (dir, pure_name, initial_size);
c002c785:	83 ec 04             	sub    $0x4,%esp
c002c788:	ff 74 24 28          	pushl  0x28(%esp)
c002c78c:	ff 74 24 10          	pushl  0x10(%esp)
c002c790:	ff 74 24 18          	pushl  0x18(%esp)
c002c794:	e8 68 0f 00 00       	call   c002d701 <dir_subfile_create>
c002c799:	0f b6 d8             	movzbl %al,%ebx
c002c79c:	83 c4 10             	add    $0x10,%esp
c002c79f:	eb d0                	jmp    c002c771 <filesys_create+0x5f>
  bool success = false;
c002c7a1:	b3 00                	mov    $0x0,%bl
c002c7a3:	eb 02                	jmp    c002c7a7 <filesys_create+0x95>
c002c7a5:	b3 00                	mov    $0x0,%bl
  free (pure_name);
c002c7a7:	83 ec 0c             	sub    $0xc,%esp
c002c7aa:	ff 74 24 14          	pushl  0x14(%esp)
c002c7ae:	e8 14 74 ff ff       	call   c0023bc7 <free>
}
c002c7b3:	88 d8                	mov    %bl,%al
c002c7b5:	83 c4 28             	add    $0x28,%esp
c002c7b8:	5b                   	pop    %ebx
c002c7b9:	c3                   	ret    

c002c7ba <filesys_open>:
{
c002c7ba:	56                   	push   %esi
c002c7bb:	53                   	push   %ebx
c002c7bc:	83 ec 1c             	sub    $0x1c,%esp
c002c7bf:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  char *pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002c7c3:	6a 01                	push   $0x1
c002c7c5:	6a 0f                	push   $0xf
c002c7c7:	e8 b1 73 ff ff       	call   c0023b7d <calloc>
c002c7cc:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (name != NULL && strlen (name) > 0 && filesys_is_root_dir(name)) {
c002c7d0:	83 c4 10             	add    $0x10,%esp
c002c7d3:	85 db                	test   %ebx,%ebx
c002c7d5:	0f 84 15 01 00 00    	je     c002c8f0 <filesys_open+0x136>
c002c7db:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c7de:	0f 84 13 01 00 00    	je     c002c8f7 <filesys_open+0x13d>
c002c7e4:	83 ec 0c             	sub    $0xc,%esp
c002c7e7:	53                   	push   %ebx
c002c7e8:	e8 57 fd ff ff       	call   c002c544 <filesys_is_root_dir>
c002c7ed:	83 c4 10             	add    $0x10,%esp
c002c7f0:	84 c0                	test   %al,%al
c002c7f2:	0f 85 c2 00 00 00    	jne    c002c8ba <filesys_open+0x100>
  else if (name != NULL  && strlen (name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c7f8:	83 ec 0c             	sub    $0xc,%esp
c002c7fb:	53                   	push   %ebx
c002c7fc:	e8 43 fd ff ff       	call   c002c544 <filesys_is_root_dir>
c002c801:	83 c4 10             	add    $0x10,%esp
c002c804:	84 c0                	test   %al,%al
c002c806:	0f 85 f9 00 00 00    	jne    c002c905 <filesys_open+0x14b>
c002c80c:	8d 44 24 07          	lea    0x7(%esp),%eax
c002c810:	50                   	push   %eax
c002c811:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002c815:	50                   	push   %eax
c002c816:	8d 44 24 14          	lea    0x14(%esp),%eax
c002c81a:	50                   	push   %eax
c002c81b:	53                   	push   %ebx
c002c81c:	e8 4c fd ff ff       	call   c002c56d <filesys_path_parse>
c002c821:	83 c4 10             	add    $0x10,%esp
c002c824:	84 c0                	test   %al,%al
c002c826:	0f 84 d2 00 00 00    	je     c002c8fe <filesys_open+0x144>
    retdir = dir_subdir_lookup (dir, pure_name);
c002c82c:	83 ec 08             	sub    $0x8,%esp
c002c82f:	ff 74 24 10          	pushl  0x10(%esp)
c002c833:	ff 74 24 18          	pushl  0x18(%esp)
c002c837:	e8 04 0d 00 00       	call   c002d540 <dir_subdir_lookup>
c002c83c:	89 c6                	mov    %eax,%esi
    retfile = dir_subfile_lookup (dir, pure_name);
c002c83e:	83 c4 08             	add    $0x8,%esp
c002c841:	ff 74 24 10          	pushl  0x10(%esp)
c002c845:	ff 74 24 18          	pushl  0x18(%esp)
c002c849:	e8 48 0f 00 00       	call   c002d796 <dir_subfile_lookup>
c002c84e:	89 c3                	mov    %eax,%ebx
    if (retdir != NULL) {
c002c850:	83 c4 10             	add    $0x10,%esp
c002c853:	85 f6                	test   %esi,%esi
c002c855:	0f 84 87 00 00 00    	je     c002c8e2 <filesys_open+0x128>
      file = file_open (inode_reopen (dir_get_inode (retdir)));
c002c85b:	83 ec 0c             	sub    $0xc,%esp
c002c85e:	56                   	push   %esi
c002c85f:	e8 cc 07 00 00       	call   c002d030 <dir_get_inode>
c002c864:	89 04 24             	mov    %eax,(%esp)
c002c867:	e8 76 15 00 00       	call   c002dde2 <inode_reopen>
c002c86c:	89 04 24             	mov    %eax,(%esp)
c002c86f:	e8 9e 03 00 00       	call   c002cc12 <file_open>
c002c874:	89 c3                	mov    %eax,%ebx
      file_set_dir (file, dir_reopen (dir));
c002c876:	83 c4 04             	add    $0x4,%esp
c002c879:	ff 74 24 18          	pushl  0x18(%esp)
c002c87d:	e8 6e 07 00 00       	call   c002cff0 <dir_reopen>
c002c882:	83 c4 08             	add    $0x8,%esp
c002c885:	50                   	push   %eax
c002c886:	53                   	push   %ebx
c002c887:	e8 21 06 00 00       	call   c002cead <file_set_dir>
      dir_close (retdir);
c002c88c:	89 34 24             	mov    %esi,(%esp)
c002c88f:	e8 76 07 00 00       	call   c002d00a <dir_close>
c002c894:	83 c4 10             	add    $0x10,%esp
    dir_close (dir);
c002c897:	83 ec 0c             	sub    $0xc,%esp
c002c89a:	ff 74 24 18          	pushl  0x18(%esp)
c002c89e:	e8 67 07 00 00       	call   c002d00a <dir_close>
c002c8a3:	83 c4 10             	add    $0x10,%esp
  free (pure_name);
c002c8a6:	83 ec 0c             	sub    $0xc,%esp
c002c8a9:	ff 74 24 14          	pushl  0x14(%esp)
c002c8ad:	e8 15 73 ff ff       	call   c0023bc7 <free>
}
c002c8b2:	89 d8                	mov    %ebx,%eax
c002c8b4:	83 c4 24             	add    $0x24,%esp
c002c8b7:	5b                   	pop    %ebx
c002c8b8:	5e                   	pop    %esi
c002c8b9:	c3                   	ret    
    file = file_open(inode_open(ROOT_DIR_SECTOR));
c002c8ba:	83 ec 0c             	sub    $0xc,%esp
c002c8bd:	6a 01                	push   $0x1
c002c8bf:	e8 2a 15 00 00       	call   c002ddee <inode_open>
c002c8c4:	89 04 24             	mov    %eax,(%esp)
c002c8c7:	e8 46 03 00 00       	call   c002cc12 <file_open>
c002c8cc:	89 c3                	mov    %eax,%ebx
    file_set_dir(file, dir_open_root());
c002c8ce:	e8 07 07 00 00       	call   c002cfda <dir_open_root>
c002c8d3:	83 c4 08             	add    $0x8,%esp
c002c8d6:	50                   	push   %eax
c002c8d7:	53                   	push   %ebx
c002c8d8:	e8 d0 05 00 00       	call   c002cead <file_set_dir>
c002c8dd:	83 c4 10             	add    $0x10,%esp
c002c8e0:	eb c4                	jmp    c002c8a6 <filesys_open+0xec>
      if (!is_dir) {
c002c8e2:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c002c8e7:	74 ae                	je     c002c897 <filesys_open+0xdd>
  struct file * file = NULL;
c002c8e9:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c8ee:	eb a7                	jmp    c002c897 <filesys_open+0xdd>
c002c8f0:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c8f5:	eb af                	jmp    c002c8a6 <filesys_open+0xec>
c002c8f7:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c8fc:	eb a8                	jmp    c002c8a6 <filesys_open+0xec>
c002c8fe:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c903:	eb a1                	jmp    c002c8a6 <filesys_open+0xec>
c002c905:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c90a:	eb 9a                	jmp    c002c8a6 <filesys_open+0xec>

c002c90c <filesys_remove>:
{
c002c90c:	53                   	push   %ebx
c002c90d:	83 ec 20             	sub    $0x20,%esp
c002c910:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  char *pure_name = calloc (READDIR_MAX_LEN + 1, 1);
c002c914:	6a 01                	push   $0x1
c002c916:	6a 0f                	push   $0xf
c002c918:	e8 60 72 ff ff       	call   c0023b7d <calloc>
c002c91d:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (name != NULL  && strlen (name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c921:	83 c4 10             	add    $0x10,%esp
c002c924:	85 db                	test   %ebx,%ebx
c002c926:	0f 84 91 00 00 00    	je     c002c9bd <filesys_remove+0xb1>
c002c92c:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c92f:	0f 84 8c 00 00 00    	je     c002c9c1 <filesys_remove+0xb5>
c002c935:	83 ec 0c             	sub    $0xc,%esp
c002c938:	53                   	push   %ebx
c002c939:	e8 06 fc ff ff       	call   c002c544 <filesys_is_root_dir>
c002c93e:	83 c4 10             	add    $0x10,%esp
c002c941:	84 c0                	test   %al,%al
c002c943:	74 04                	je     c002c949 <filesys_remove+0x3d>
  bool success = false;
c002c945:	b3 00                	mov    $0x0,%bl
c002c947:	eb 7a                	jmp    c002c9c3 <filesys_remove+0xb7>
  if (name != NULL  && strlen (name) > 0 && !filesys_is_root_dir (name) && filesys_path_parse (name, &dir, &pure_name, &is_dir)) {
c002c949:	8d 44 24 07          	lea    0x7(%esp),%eax
c002c94d:	50                   	push   %eax
c002c94e:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002c952:	50                   	push   %eax
c002c953:	8d 44 24 14          	lea    0x14(%esp),%eax
c002c957:	50                   	push   %eax
c002c958:	53                   	push   %ebx
c002c959:	e8 0f fc ff ff       	call   c002c56d <filesys_path_parse>
c002c95e:	88 c3                	mov    %al,%bl
c002c960:	83 c4 10             	add    $0x10,%esp
c002c963:	84 c0                	test   %al,%al
c002c965:	74 5c                	je     c002c9c3 <filesys_remove+0xb7>
    success = dir_subdir_delete (dir, pure_name) || (!is_dir && dir_subfile_delete (dir, pure_name));
c002c967:	83 ec 08             	sub    $0x8,%esp
c002c96a:	ff 74 24 10          	pushl  0x10(%esp)
c002c96e:	ff 74 24 18          	pushl  0x18(%esp)
c002c972:	e8 5c 0c 00 00       	call   c002d5d3 <dir_subdir_delete>
c002c977:	83 c4 10             	add    $0x10,%esp
c002c97a:	84 c0                	test   %al,%al
c002c97c:	75 26                	jne    c002c9a4 <filesys_remove+0x98>
c002c97e:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c002c983:	74 07                	je     c002c98c <filesys_remove+0x80>
c002c985:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c98a:	eb 1d                	jmp    c002c9a9 <filesys_remove+0x9d>
c002c98c:	83 ec 08             	sub    $0x8,%esp
c002c98f:	ff 74 24 10          	pushl  0x10(%esp)
c002c993:	ff 74 24 18          	pushl  0x18(%esp)
c002c997:	e8 ae 0e 00 00       	call   c002d84a <dir_subfile_delete>
c002c99c:	0f b6 d8             	movzbl %al,%ebx
c002c99f:	83 c4 10             	add    $0x10,%esp
c002c9a2:	eb 05                	jmp    c002c9a9 <filesys_remove+0x9d>
c002c9a4:	bb 01 00 00 00       	mov    $0x1,%ebx
c002c9a9:	83 e3 01             	and    $0x1,%ebx
    dir_close (dir);
c002c9ac:	83 ec 0c             	sub    $0xc,%esp
c002c9af:	ff 74 24 18          	pushl  0x18(%esp)
c002c9b3:	e8 52 06 00 00       	call   c002d00a <dir_close>
c002c9b8:	83 c4 10             	add    $0x10,%esp
c002c9bb:	eb 06                	jmp    c002c9c3 <filesys_remove+0xb7>
  bool success = false;
c002c9bd:	b3 00                	mov    $0x0,%bl
c002c9bf:	eb 02                	jmp    c002c9c3 <filesys_remove+0xb7>
c002c9c1:	b3 00                	mov    $0x0,%bl
  free (pure_name);
c002c9c3:	83 ec 0c             	sub    $0xc,%esp
c002c9c6:	ff 74 24 14          	pushl  0x14(%esp)
c002c9ca:	e8 f8 71 ff ff       	call   c0023bc7 <free>
}
c002c9cf:	88 d8                	mov    %bl,%al
c002c9d1:	83 c4 28             	add    $0x28,%esp
c002c9d4:	5b                   	pop    %ebx
c002c9d5:	c3                   	ret    

c002c9d6 <free_map_init>:
static struct bitmap *free_map;      /* Free map, one bit per sector. */

/* Initializes the free map. */
void
free_map_init (void) 
{
c002c9d6:	83 ec 18             	sub    $0x18,%esp
  free_map = bitmap_create (block_size (fs_device));
c002c9d9:	ff 35 38 6c 04 c0    	pushl  0xc0046c38
c002c9df:	e8 94 83 ff ff       	call   c0024d78 <block_size>
c002c9e4:	89 04 24             	mov    %eax,(%esp)
c002c9e7:	e8 62 cb ff ff       	call   c002954e <bitmap_create>
c002c9ec:	a3 f4 e4 03 c0       	mov    %eax,0xc003e4f4
  if (free_map == NULL)
c002c9f1:	83 c4 10             	add    $0x10,%esp
c002c9f4:	85 c0                	test   %eax,%eax
c002c9f6:	74 1f                	je     c002ca17 <free_map_init+0x41>
    PANIC ("bitmap creation failed--file system device is too large");
  bitmap_mark (free_map, FREE_MAP_SECTOR);
c002c9f8:	83 ec 08             	sub    $0x8,%esp
c002c9fb:	6a 00                	push   $0x0
c002c9fd:	50                   	push   %eax
c002c9fe:	e8 16 c9 ff ff       	call   c0029319 <bitmap_mark>
  bitmap_mark (free_map, ROOT_DIR_SECTOR);
c002ca03:	83 c4 08             	add    $0x8,%esp
c002ca06:	6a 01                	push   $0x1
c002ca08:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002ca0e:	e8 06 c9 ff ff       	call   c0029319 <bitmap_mark>
}
c002ca13:	83 c4 1c             	add    $0x1c,%esp
c002ca16:	c3                   	ret    
    PANIC ("bitmap creation failed--file system device is too large");
c002ca17:	68 4c 30 03 c0       	push   $0xc003304c
c002ca1c:	68 cc 0a 03 c0       	push   $0xc0030acc
c002ca21:	6a 11                	push   $0x11
c002ca23:	68 a7 30 03 c0       	push   $0xc00330a7
c002ca28:	e8 50 bc ff ff       	call   c002867d <debug_panic>

c002ca2d <free_map_allocate>:
   Returns true if successful, false if not enough consecutive
   sectors were available or if the free_map file could not be
   written. */
bool
free_map_allocate (size_t cnt, block_sector_t *sectorp)
{
c002ca2d:	56                   	push   %esi
c002ca2e:	53                   	push   %ebx
c002ca2f:	83 ec 04             	sub    $0x4,%esp
c002ca32:	8b 74 24 10          	mov    0x10(%esp),%esi
  block_sector_t sector = bitmap_scan_and_flip (free_map, 0, cnt, false);
c002ca36:	6a 00                	push   $0x0
c002ca38:	56                   	push   %esi
c002ca39:	6a 00                	push   $0x0
c002ca3b:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002ca41:	e8 3b ce ff ff       	call   c0029881 <bitmap_scan_and_flip>
  if (sector != BITMAP_ERROR
c002ca46:	83 c4 10             	add    $0x10,%esp
c002ca49:	83 f8 ff             	cmp    $0xffffffff,%eax
c002ca4c:	74 45                	je     c002ca93 <free_map_allocate+0x66>
c002ca4e:	89 c3                	mov    %eax,%ebx
      && free_map_file != NULL
c002ca50:	a1 f8 e4 03 c0       	mov    0xc003e4f8,%eax
c002ca55:	85 c0                	test   %eax,%eax
c002ca57:	74 16                	je     c002ca6f <free_map_allocate+0x42>
      && !bitmap_write (free_map, free_map_file))
c002ca59:	83 ec 08             	sub    $0x8,%esp
c002ca5c:	50                   	push   %eax
c002ca5d:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002ca63:	e8 d5 ce ff ff       	call   c002993d <bitmap_write>
c002ca68:	83 c4 10             	add    $0x10,%esp
c002ca6b:	84 c0                	test   %al,%al
c002ca6d:	74 12                	je     c002ca81 <free_map_allocate+0x54>
    {
      bitmap_set_multiple (free_map, sector, cnt, false); 
      sector = BITMAP_ERROR;
    }
  if (sector != BITMAP_ERROR)
    *sectorp = sector;
c002ca6f:	8b 44 24 14          	mov    0x14(%esp),%eax
c002ca73:	89 18                	mov    %ebx,(%eax)
  return sector != BITMAP_ERROR;
c002ca75:	83 fb ff             	cmp    $0xffffffff,%ebx
c002ca78:	0f 95 c0             	setne  %al
}
c002ca7b:	83 c4 04             	add    $0x4,%esp
c002ca7e:	5b                   	pop    %ebx
c002ca7f:	5e                   	pop    %esi
c002ca80:	c3                   	ret    
      bitmap_set_multiple (free_map, sector, cnt, false); 
c002ca81:	6a 00                	push   $0x0
c002ca83:	56                   	push   %esi
c002ca84:	53                   	push   %ebx
c002ca85:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002ca8b:	e8 cf c9 ff ff       	call   c002945f <bitmap_set_multiple>
c002ca90:	83 c4 10             	add    $0x10,%esp
{
c002ca93:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002ca98:	eb db                	jmp    c002ca75 <free_map_allocate+0x48>

c002ca9a <free_map_release>:

/* Makes CNT sectors starting at SECTOR available for use. */
void
free_map_release (block_sector_t sector, size_t cnt)
{
c002ca9a:	56                   	push   %esi
c002ca9b:	53                   	push   %ebx
c002ca9c:	83 ec 08             	sub    $0x8,%esp
c002ca9f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002caa3:	8b 74 24 18          	mov    0x18(%esp),%esi
  ASSERT (bitmap_all (free_map, sector, cnt));
c002caa7:	56                   	push   %esi
c002caa8:	53                   	push   %ebx
c002caa9:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002caaf:	e8 00 cd ff ff       	call   c00297b4 <bitmap_all>
c002cab4:	83 c4 10             	add    $0x10,%esp
c002cab7:	84 c0                	test   %al,%al
c002cab9:	74 29                	je     c002cae4 <free_map_release+0x4a>
  bitmap_set_multiple (free_map, sector, cnt, false);
c002cabb:	6a 00                	push   $0x0
c002cabd:	56                   	push   %esi
c002cabe:	53                   	push   %ebx
c002cabf:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002cac5:	e8 95 c9 ff ff       	call   c002945f <bitmap_set_multiple>
  bitmap_write (free_map, free_map_file);
c002caca:	83 c4 08             	add    $0x8,%esp
c002cacd:	ff 35 f8 e4 03 c0    	pushl  0xc003e4f8
c002cad3:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002cad9:	e8 5f ce ff ff       	call   c002993d <bitmap_write>
}
c002cade:	83 c4 14             	add    $0x14,%esp
c002cae1:	5b                   	pop    %ebx
c002cae2:	5e                   	pop    %esi
c002cae3:	c3                   	ret    
  ASSERT (bitmap_all (free_map, sector, cnt));
c002cae4:	83 ec 0c             	sub    $0xc,%esp
c002cae7:	68 84 30 03 c0       	push   $0xc0033084
c002caec:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002caf1:	68 b8 0a 03 c0       	push   $0xc0030ab8
c002caf6:	6a 2f                	push   $0x2f
c002caf8:	68 a7 30 03 c0       	push   $0xc00330a7
c002cafd:	e8 7b bb ff ff       	call   c002867d <debug_panic>

c002cb02 <free_map_open>:

/* Opens the free map file and reads it from disk. */
void
free_map_open (void) 
{
c002cb02:	83 ec 18             	sub    $0x18,%esp
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002cb05:	6a 00                	push   $0x0
c002cb07:	e8 e2 12 00 00       	call   c002ddee <inode_open>
c002cb0c:	89 04 24             	mov    %eax,(%esp)
c002cb0f:	e8 fe 00 00 00       	call   c002cc12 <file_open>
c002cb14:	a3 f8 e4 03 c0       	mov    %eax,0xc003e4f8
  if (free_map_file == NULL)
c002cb19:	83 c4 10             	add    $0x10,%esp
c002cb1c:	85 c0                	test   %eax,%eax
c002cb1e:	74 1a                	je     c002cb3a <free_map_open+0x38>
    PANIC ("can't open free map");
  if (!bitmap_read (free_map, free_map_file))
c002cb20:	83 ec 08             	sub    $0x8,%esp
c002cb23:	50                   	push   %eax
c002cb24:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002cb2a:	e8 aa cd ff ff       	call   c00298d9 <bitmap_read>
c002cb2f:	83 c4 10             	add    $0x10,%esp
c002cb32:	84 c0                	test   %al,%al
c002cb34:	74 1a                	je     c002cb50 <free_map_open+0x4e>
    PANIC ("can't read free map");
}
c002cb36:	83 c4 0c             	add    $0xc,%esp
c002cb39:	c3                   	ret    
    PANIC ("can't open free map");
c002cb3a:	68 c0 30 03 c0       	push   $0xc00330c0
c002cb3f:	68 a8 0a 03 c0       	push   $0xc0030aa8
c002cb44:	6a 3a                	push   $0x3a
c002cb46:	68 a7 30 03 c0       	push   $0xc00330a7
c002cb4b:	e8 2d bb ff ff       	call   c002867d <debug_panic>
    PANIC ("can't read free map");
c002cb50:	68 d4 30 03 c0       	push   $0xc00330d4
c002cb55:	68 a8 0a 03 c0       	push   $0xc0030aa8
c002cb5a:	6a 3c                	push   $0x3c
c002cb5c:	68 a7 30 03 c0       	push   $0xc00330a7
c002cb61:	e8 17 bb ff ff       	call   c002867d <debug_panic>

c002cb66 <free_map_close>:

/* Writes the free map to disk and closes the free map file. */
void
free_map_close (void) 
{
c002cb66:	83 ec 18             	sub    $0x18,%esp
  file_close (free_map_file);
c002cb69:	ff 35 f8 e4 03 c0    	pushl  0xc003e4f8
c002cb6f:	e8 36 02 00 00       	call   c002cdaa <file_close>
}
c002cb74:	83 c4 1c             	add    $0x1c,%esp
c002cb77:	c3                   	ret    

c002cb78 <free_map_create>:

/* Creates a new free map file on disk and writes the free map to
   it. */
void
free_map_create (void) 
{
c002cb78:	83 ec 18             	sub    $0x18,%esp
  /* Create inode. */
  if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map)))
c002cb7b:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002cb81:	e8 43 cd ff ff       	call   c00298c9 <bitmap_file_size>
c002cb86:	83 c4 08             	add    $0x8,%esp
c002cb89:	50                   	push   %eax
c002cb8a:	6a 00                	push   $0x0
c002cb8c:	e8 03 10 00 00       	call   c002db94 <inode_create>
c002cb91:	83 c4 10             	add    $0x10,%esp
c002cb94:	84 c0                	test   %al,%al
c002cb96:	74 38                	je     c002cbd0 <free_map_create+0x58>
    PANIC ("free map creation failed");

  /* Write bitmap to file. */
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002cb98:	83 ec 0c             	sub    $0xc,%esp
c002cb9b:	6a 00                	push   $0x0
c002cb9d:	e8 4c 12 00 00       	call   c002ddee <inode_open>
c002cba2:	89 04 24             	mov    %eax,(%esp)
c002cba5:	e8 68 00 00 00       	call   c002cc12 <file_open>
c002cbaa:	a3 f8 e4 03 c0       	mov    %eax,0xc003e4f8
  if (free_map_file == NULL)
c002cbaf:	83 c4 10             	add    $0x10,%esp
c002cbb2:	85 c0                	test   %eax,%eax
c002cbb4:	74 30                	je     c002cbe6 <free_map_create+0x6e>
    PANIC ("can't open free map");
  if (!bitmap_write (free_map, free_map_file))
c002cbb6:	83 ec 08             	sub    $0x8,%esp
c002cbb9:	50                   	push   %eax
c002cbba:	ff 35 f4 e4 03 c0    	pushl  0xc003e4f4
c002cbc0:	e8 78 cd ff ff       	call   c002993d <bitmap_write>
c002cbc5:	83 c4 10             	add    $0x10,%esp
c002cbc8:	84 c0                	test   %al,%al
c002cbca:	74 30                	je     c002cbfc <free_map_create+0x84>
    PANIC ("can't write free map");
}
c002cbcc:	83 c4 0c             	add    $0xc,%esp
c002cbcf:	c3                   	ret    
    PANIC ("free map creation failed");
c002cbd0:	68 e8 30 03 c0       	push   $0xc00330e8
c002cbd5:	68 98 0a 03 c0       	push   $0xc0030a98
c002cbda:	6a 4d                	push   $0x4d
c002cbdc:	68 a7 30 03 c0       	push   $0xc00330a7
c002cbe1:	e8 97 ba ff ff       	call   c002867d <debug_panic>
    PANIC ("can't open free map");
c002cbe6:	68 c0 30 03 c0       	push   $0xc00330c0
c002cbeb:	68 98 0a 03 c0       	push   $0xc0030a98
c002cbf0:	6a 52                	push   $0x52
c002cbf2:	68 a7 30 03 c0       	push   $0xc00330a7
c002cbf7:	e8 81 ba ff ff       	call   c002867d <debug_panic>
    PANIC ("can't write free map");
c002cbfc:	68 01 31 03 c0       	push   $0xc0033101
c002cc01:	68 98 0a 03 c0       	push   $0xc0030a98
c002cc06:	6a 54                	push   $0x54
c002cc08:	68 a7 30 03 c0       	push   $0xc00330a7
c002cc0d:	e8 6b ba ff ff       	call   c002867d <debug_panic>

c002cc12 <file_open>:
/* Opens a file for the given INODE, of which it takes ownership,
   and returns the new file.  Returns a null pointer if an
   allocation fails or if INODE is null. */
struct file *
file_open (struct inode *inode) 
{
c002cc12:	56                   	push   %esi
c002cc13:	53                   	push   %ebx
c002cc14:	83 ec 0c             	sub    $0xc,%esp
c002cc17:	8b 74 24 18          	mov    0x18(%esp),%esi
  struct file *file = calloc (1, sizeof *file);
c002cc1b:	6a 10                	push   $0x10
c002cc1d:	6a 01                	push   $0x1
c002cc1f:	e8 59 6f ff ff       	call   c0023b7d <calloc>
c002cc24:	89 c3                	mov    %eax,%ebx
  if (inode != NULL && file != NULL)
c002cc26:	83 c4 10             	add    $0x10,%esp
c002cc29:	85 f6                	test   %esi,%esi
c002cc2b:	74 19                	je     c002cc46 <file_open+0x34>
c002cc2d:	85 c0                	test   %eax,%eax
c002cc2f:	74 15                	je     c002cc46 <file_open+0x34>
    {
      file->inode = inode;
c002cc31:	89 30                	mov    %esi,(%eax)
      file->pos = 0;
c002cc33:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      file->deny_write = false;
c002cc3a:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    {
      inode_close (inode);
      free (file);
      return NULL; 
    }
}
c002cc3e:	89 d8                	mov    %ebx,%eax
c002cc40:	83 c4 04             	add    $0x4,%esp
c002cc43:	5b                   	pop    %ebx
c002cc44:	5e                   	pop    %esi
c002cc45:	c3                   	ret    
      inode_close (inode);
c002cc46:	83 ec 0c             	sub    $0xc,%esp
c002cc49:	56                   	push   %esi
c002cc4a:	e8 47 12 00 00       	call   c002de96 <inode_close>
      free (file);
c002cc4f:	89 1c 24             	mov    %ebx,(%esp)
c002cc52:	e8 70 6f ff ff       	call   c0023bc7 <free>
      return NULL; 
c002cc57:	83 c4 10             	add    $0x10,%esp
c002cc5a:	bb 00 00 00 00       	mov    $0x0,%ebx
c002cc5f:	eb dd                	jmp    c002cc3e <file_open+0x2c>

c002cc61 <file_reopen>:

/* Opens and returns a new file for the same inode as FILE.
   Returns a null pointer if unsuccessful. */
struct file *
file_reopen (struct file *file) 
{
c002cc61:	56                   	push   %esi
c002cc62:	53                   	push   %ebx
c002cc63:	83 ec 10             	sub    $0x10,%esp
c002cc66:	8b 74 24 1c          	mov    0x1c(%esp),%esi
#ifdef FILESYS
  struct file* f = file_open (inode_reopen (file->inode));
c002cc6a:	ff 36                	pushl  (%esi)
c002cc6c:	e8 71 11 00 00       	call   c002dde2 <inode_reopen>
c002cc71:	89 04 24             	mov    %eax,(%esp)
c002cc74:	e8 99 ff ff ff       	call   c002cc12 <file_open>
c002cc79:	89 c3                	mov    %eax,%ebx
  file_set_dir(f, dir_reopen(file->dir));
c002cc7b:	83 c4 04             	add    $0x4,%esp
c002cc7e:	ff 76 0c             	pushl  0xc(%esi)
c002cc81:	e8 6a 03 00 00       	call   c002cff0 <dir_reopen>
}

#ifdef FILESYS
void
file_set_dir(struct file* file, struct dir* dir) {
    file->dir = dir;
c002cc86:	89 43 0c             	mov    %eax,0xc(%ebx)
}
c002cc89:	89 d8                	mov    %ebx,%eax
c002cc8b:	83 c4 14             	add    $0x14,%esp
c002cc8e:	5b                   	pop    %ebx
c002cc8f:	5e                   	pop    %esi
c002cc90:	c3                   	ret    

c002cc91 <file_get_inode>:
  return file->inode;
c002cc91:	8b 44 24 04          	mov    0x4(%esp),%eax
c002cc95:	8b 00                	mov    (%eax),%eax
}
c002cc97:	c3                   	ret    

c002cc98 <file_read>:
{
c002cc98:	53                   	push   %ebx
c002cc99:	83 ec 08             	sub    $0x8,%esp
c002cc9c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  off_t bytes_read = inode_read_at (file->inode, buffer, size, file->pos);
c002cca0:	ff 73 04             	pushl  0x4(%ebx)
c002cca3:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cca7:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ccab:	ff 33                	pushl  (%ebx)
c002ccad:	e8 58 13 00 00       	call   c002e00a <inode_read_at>
  file->pos += bytes_read;
c002ccb2:	01 43 04             	add    %eax,0x4(%ebx)
}
c002ccb5:	83 c4 18             	add    $0x18,%esp
c002ccb8:	5b                   	pop    %ebx
c002ccb9:	c3                   	ret    

c002ccba <file_read_at>:
{
c002ccba:	83 ec 0c             	sub    $0xc,%esp
  return inode_read_at (file->inode, buffer, size, file_ofs);
c002ccbd:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ccc1:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ccc5:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ccc9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002cccd:	ff 30                	pushl  (%eax)
c002cccf:	e8 36 13 00 00       	call   c002e00a <inode_read_at>
}
c002ccd4:	83 c4 1c             	add    $0x1c,%esp
c002ccd7:	c3                   	ret    

c002ccd8 <file_write>:
{
c002ccd8:	53                   	push   %ebx
c002ccd9:	83 ec 08             	sub    $0x8,%esp
c002ccdc:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  off_t bytes_written = inode_write_at (file->inode, buffer, size, file->pos);
c002cce0:	ff 73 04             	pushl  0x4(%ebx)
c002cce3:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cce7:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cceb:	ff 33                	pushl  (%ebx)
c002cced:	e8 44 14 00 00       	call   c002e136 <inode_write_at>
  file->pos += bytes_written;
c002ccf2:	01 43 04             	add    %eax,0x4(%ebx)
}
c002ccf5:	83 c4 18             	add    $0x18,%esp
c002ccf8:	5b                   	pop    %ebx
c002ccf9:	c3                   	ret    

c002ccfa <file_write_at>:
{
c002ccfa:	83 ec 0c             	sub    $0xc,%esp
  return inode_write_at (file->inode, buffer, size, file_ofs);
c002ccfd:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cd01:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cd05:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cd09:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002cd0d:	ff 30                	pushl  (%eax)
c002cd0f:	e8 22 14 00 00       	call   c002e136 <inode_write_at>
}
c002cd14:	83 c4 1c             	add    $0x1c,%esp
c002cd17:	c3                   	ret    

c002cd18 <file_deny_write>:
{
c002cd18:	83 ec 0c             	sub    $0xc,%esp
c002cd1b:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002cd1f:	85 c0                	test   %eax,%eax
c002cd21:	74 0a                	je     c002cd2d <file_deny_write+0x15>
  if (!file->deny_write) 
c002cd23:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002cd27:	74 25                	je     c002cd4e <file_deny_write+0x36>
}
c002cd29:	83 c4 0c             	add    $0xc,%esp
c002cd2c:	c3                   	ret    
  ASSERT (file != NULL);
c002cd2d:	83 ec 0c             	sub    $0xc,%esp
c002cd30:	68 16 31 03 c0       	push   $0xc0033116
c002cd35:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002cd3a:	68 14 0b 03 c0       	push   $0xc0030b14
c002cd3f:	68 87 00 00 00       	push   $0x87
c002cd44:	68 23 31 03 c0       	push   $0xc0033123
c002cd49:	e8 2f b9 ff ff       	call   c002867d <debug_panic>
      file->deny_write = true;
c002cd4e:	c6 40 08 01          	movb   $0x1,0x8(%eax)
      inode_deny_write (file->inode);
c002cd52:	83 ec 0c             	sub    $0xc,%esp
c002cd55:	ff 30                	pushl  (%eax)
c002cd57:	e8 6d 15 00 00       	call   c002e2c9 <inode_deny_write>
c002cd5c:	83 c4 10             	add    $0x10,%esp
}
c002cd5f:	eb c8                	jmp    c002cd29 <file_deny_write+0x11>

c002cd61 <file_allow_write>:
{
c002cd61:	83 ec 0c             	sub    $0xc,%esp
c002cd64:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002cd68:	85 c0                	test   %eax,%eax
c002cd6a:	74 0a                	je     c002cd76 <file_allow_write+0x15>
  if (file->deny_write) 
c002cd6c:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002cd70:	75 25                	jne    c002cd97 <file_allow_write+0x36>
}
c002cd72:	83 c4 0c             	add    $0xc,%esp
c002cd75:	c3                   	ret    
  ASSERT (file != NULL);
c002cd76:	83 ec 0c             	sub    $0xc,%esp
c002cd79:	68 16 31 03 c0       	push   $0xc0033116
c002cd7e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002cd83:	68 00 0b 03 c0       	push   $0xc0030b00
c002cd88:	68 95 00 00 00       	push   $0x95
c002cd8d:	68 23 31 03 c0       	push   $0xc0033123
c002cd92:	e8 e6 b8 ff ff       	call   c002867d <debug_panic>
      file->deny_write = false;
c002cd97:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      inode_allow_write (file->inode);
c002cd9b:	83 ec 0c             	sub    $0xc,%esp
c002cd9e:	ff 30                	pushl  (%eax)
c002cda0:	e8 5c 15 00 00       	call   c002e301 <inode_allow_write>
c002cda5:	83 c4 10             	add    $0x10,%esp
}
c002cda8:	eb c8                	jmp    c002cd72 <file_allow_write+0x11>

c002cdaa <file_close>:
{
c002cdaa:	53                   	push   %ebx
c002cdab:	83 ec 08             	sub    $0x8,%esp
c002cdae:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (file != NULL)
c002cdb2:	85 db                	test   %ebx,%ebx
c002cdb4:	74 29                	je     c002cddf <file_close+0x35>
      file_allow_write (file);
c002cdb6:	83 ec 0c             	sub    $0xc,%esp
c002cdb9:	53                   	push   %ebx
c002cdba:	e8 a2 ff ff ff       	call   c002cd61 <file_allow_write>
      dir_close (file->dir);
c002cdbf:	83 c4 04             	add    $0x4,%esp
c002cdc2:	ff 73 0c             	pushl  0xc(%ebx)
c002cdc5:	e8 40 02 00 00       	call   c002d00a <dir_close>
      inode_close (file->inode);
c002cdca:	83 c4 04             	add    $0x4,%esp
c002cdcd:	ff 33                	pushl  (%ebx)
c002cdcf:	e8 c2 10 00 00       	call   c002de96 <inode_close>
      free (file); 
c002cdd4:	89 1c 24             	mov    %ebx,(%esp)
c002cdd7:	e8 eb 6d ff ff       	call   c0023bc7 <free>
c002cddc:	83 c4 10             	add    $0x10,%esp
}
c002cddf:	83 c4 08             	add    $0x8,%esp
c002cde2:	5b                   	pop    %ebx
c002cde3:	c3                   	ret    

c002cde4 <file_length>:
{
c002cde4:	83 ec 0c             	sub    $0xc,%esp
c002cde7:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002cdeb:	85 c0                	test   %eax,%eax
c002cded:	74 0e                	je     c002cdfd <file_length+0x19>
  return inode_length (file->inode);
c002cdef:	83 ec 0c             	sub    $0xc,%esp
c002cdf2:	ff 30                	pushl  (%eax)
c002cdf4:	e8 65 15 00 00       	call   c002e35e <inode_length>
}
c002cdf9:	83 c4 1c             	add    $0x1c,%esp
c002cdfc:	c3                   	ret    
  ASSERT (file != NULL);
c002cdfd:	83 ec 0c             	sub    $0xc,%esp
c002ce00:	68 16 31 03 c0       	push   $0xc0033116
c002ce05:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ce0a:	68 f4 0a 03 c0       	push   $0xc0030af4
c002ce0f:	68 a1 00 00 00       	push   $0xa1
c002ce14:	68 23 31 03 c0       	push   $0xc0033123
c002ce19:	e8 5f b8 ff ff       	call   c002867d <debug_panic>

c002ce1e <file_seek>:
{
c002ce1e:	83 ec 0c             	sub    $0xc,%esp
c002ce21:	8b 44 24 10          	mov    0x10(%esp),%eax
c002ce25:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (file != NULL);
c002ce29:	85 c0                	test   %eax,%eax
c002ce2b:	74 0b                	je     c002ce38 <file_seek+0x1a>
  ASSERT (new_pos >= 0);
c002ce2d:	85 d2                	test   %edx,%edx
c002ce2f:	78 28                	js     c002ce59 <file_seek+0x3b>
  file->pos = new_pos;
c002ce31:	89 50 04             	mov    %edx,0x4(%eax)
}
c002ce34:	83 c4 0c             	add    $0xc,%esp
c002ce37:	c3                   	ret    
  ASSERT (file != NULL);
c002ce38:	83 ec 0c             	sub    $0xc,%esp
c002ce3b:	68 16 31 03 c0       	push   $0xc0033116
c002ce40:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ce45:	68 e8 0a 03 c0       	push   $0xc0030ae8
c002ce4a:	68 aa 00 00 00       	push   $0xaa
c002ce4f:	68 23 31 03 c0       	push   $0xc0033123
c002ce54:	e8 24 b8 ff ff       	call   c002867d <debug_panic>
  ASSERT (new_pos >= 0);
c002ce59:	83 ec 0c             	sub    $0xc,%esp
c002ce5c:	68 38 31 03 c0       	push   $0xc0033138
c002ce61:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ce66:	68 e8 0a 03 c0       	push   $0xc0030ae8
c002ce6b:	68 ab 00 00 00       	push   $0xab
c002ce70:	68 23 31 03 c0       	push   $0xc0033123
c002ce75:	e8 03 b8 ff ff       	call   c002867d <debug_panic>

c002ce7a <file_tell>:
{
c002ce7a:	83 ec 0c             	sub    $0xc,%esp
c002ce7d:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002ce81:	85 c0                	test   %eax,%eax
c002ce83:	74 07                	je     c002ce8c <file_tell+0x12>
  return file->pos;
c002ce85:	8b 40 04             	mov    0x4(%eax),%eax
}
c002ce88:	83 c4 0c             	add    $0xc,%esp
c002ce8b:	c3                   	ret    
  ASSERT (file != NULL);
c002ce8c:	83 ec 0c             	sub    $0xc,%esp
c002ce8f:	68 16 31 03 c0       	push   $0xc0033116
c002ce94:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002ce99:	68 dc 0a 03 c0       	push   $0xc0030adc
c002ce9e:	68 b4 00 00 00       	push   $0xb4
c002cea3:	68 23 31 03 c0       	push   $0xc0033123
c002cea8:	e8 d0 b7 ff ff       	call   c002867d <debug_panic>

c002cead <file_set_dir>:
    file->dir = dir;
c002cead:	8b 54 24 08          	mov    0x8(%esp),%edx
c002ceb1:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ceb5:	89 50 0c             	mov    %edx,0xc(%eax)
c002ceb8:	c3                   	ret    

c002ceb9 <file_get_dir>:
}

struct dir*
file_get_dir(struct file* file) {
  return file->dir;
c002ceb9:	8b 44 24 04          	mov    0x4(%esp),%eax
c002cebd:	8b 40 0c             	mov    0xc(%eax),%eax
}
c002cec0:	c3                   	ret    

c002cec1 <lookup>:
   directory entry if OFSP is non-null.
   otherwise, returns false and ignores EP and OFSP. */
static bool
lookup (const struct dir *dir, const char *name,
        struct dir_entry *ep, off_t *ofsp) 
{
c002cec1:	55                   	push   %ebp
c002cec2:	57                   	push   %edi
c002cec3:	56                   	push   %esi
c002cec4:	53                   	push   %ebx
c002cec5:	83 ec 3c             	sub    $0x3c,%esp
c002cec8:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  struct dir_entry e;
  size_t ofs;
  
  ASSERT (dir != NULL);
c002cecc:	85 c0                	test   %eax,%eax
c002cece:	74 17                	je     c002cee7 <lookup+0x26>
c002ced0:	89 c6                	mov    %eax,%esi
  ASSERT (name != NULL);
c002ced2:	85 d2                	test   %edx,%edx
c002ced4:	74 2f                	je     c002cf05 <lookup+0x44>
c002ced6:	bb 00 00 00 00       	mov    $0x0,%ebx

  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002cedb:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
       ofs += sizeof e) 
    if (e.in_use && !strcmp (name, e.name)) 
c002cedf:	89 54 24 08          	mov    %edx,0x8(%esp)
c002cee3:	89 dd                	mov    %ebx,%ebp
c002cee5:	eb 3f                	jmp    c002cf26 <lookup+0x65>
  ASSERT (dir != NULL);
c002cee7:	83 ec 0c             	sub    $0xc,%esp
c002ceea:	68 45 31 03 c0       	push   $0xc0033145
c002ceef:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002cef4:	68 44 0b 03 c0       	push   $0xc0030b44
c002cef9:	6a 68                	push   $0x68
c002cefb:	68 51 31 03 c0       	push   $0xc0033151
c002cf00:	e8 78 b7 ff ff       	call   c002867d <debug_panic>
  ASSERT (name != NULL);
c002cf05:	83 ec 0c             	sub    $0xc,%esp
c002cf08:	68 a7 12 03 c0       	push   $0xc00312a7
c002cf0d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002cf12:	68 44 0b 03 c0       	push   $0xc0030b44
c002cf17:	6a 69                	push   $0x69
c002cf19:	68 51 31 03 c0       	push   $0xc0033151
c002cf1e:	e8 5a b7 ff ff       	call   c002867d <debug_panic>
       ofs += sizeof e) 
c002cf23:	83 c5 14             	add    $0x14,%ebp
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002cf26:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002cf2a:	55                   	push   %ebp
c002cf2b:	6a 14                	push   $0x14
c002cf2d:	57                   	push   %edi
c002cf2e:	ff 36                	pushl  (%esi)
c002cf30:	e8 d5 10 00 00       	call   c002e00a <inode_read_at>
c002cf35:	83 c4 10             	add    $0x10,%esp
c002cf38:	83 f8 14             	cmp    $0x14,%eax
c002cf3b:	75 46                	jne    c002cf83 <lookup+0xc2>
    if (e.in_use && !strcmp (name, e.name)) 
c002cf3d:	8a 5c 24 2f          	mov    0x2f(%esp),%bl
c002cf41:	84 db                	test   %bl,%bl
c002cf43:	74 de                	je     c002cf23 <lookup+0x62>
c002cf45:	83 ec 08             	sub    $0x8,%esp
c002cf48:	8d 44 24 28          	lea    0x28(%esp),%eax
c002cf4c:	50                   	push   %eax
c002cf4d:	ff 74 24 14          	pushl  0x14(%esp)
c002cf51:	e8 dc aa ff ff       	call   c0027a32 <strcmp>
c002cf56:	83 c4 10             	add    $0x10,%esp
c002cf59:	85 c0                	test   %eax,%eax
c002cf5b:	75 c6                	jne    c002cf23 <lookup+0x62>
      {
        if (ep != NULL)
c002cf5d:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002cf61:	85 ff                	test   %edi,%edi
c002cf63:	74 0b                	je     c002cf70 <lookup+0xaf>
          *ep = e;
c002cf65:	8d 74 24 1c          	lea    0x1c(%esp),%esi
c002cf69:	b9 05 00 00 00       	mov    $0x5,%ecx
c002cf6e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        if (ofsp != NULL)
c002cf70:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c002cf75:	74 0e                	je     c002cf85 <lookup+0xc4>
          *ofsp = ofs;
c002cf77:	8b 44 24 50          	mov    0x50(%esp),%eax
c002cf7b:	8b 54 24 04          	mov    0x4(%esp),%edx
c002cf7f:	89 10                	mov    %edx,(%eax)
c002cf81:	eb 02                	jmp    c002cf85 <lookup+0xc4>
        return true;
      }
  return false;
c002cf83:	b3 00                	mov    $0x0,%bl
}
c002cf85:	88 d8                	mov    %bl,%al
c002cf87:	83 c4 3c             	add    $0x3c,%esp
c002cf8a:	5b                   	pop    %ebx
c002cf8b:	5e                   	pop    %esi
c002cf8c:	5f                   	pop    %edi
c002cf8d:	5d                   	pop    %ebp
c002cf8e:	c3                   	ret    

c002cf8f <dir_open>:
{
c002cf8f:	56                   	push   %esi
c002cf90:	53                   	push   %ebx
c002cf91:	83 ec 0c             	sub    $0xc,%esp
c002cf94:	8b 74 24 18          	mov    0x18(%esp),%esi
  struct dir *dir = calloc (1, sizeof *dir);
c002cf98:	6a 08                	push   $0x8
c002cf9a:	6a 01                	push   $0x1
c002cf9c:	e8 dc 6b ff ff       	call   c0023b7d <calloc>
c002cfa1:	89 c3                	mov    %eax,%ebx
  if (inode != NULL && dir != NULL)
c002cfa3:	83 c4 10             	add    $0x10,%esp
c002cfa6:	85 f6                	test   %esi,%esi
c002cfa8:	74 15                	je     c002cfbf <dir_open+0x30>
c002cfaa:	85 c0                	test   %eax,%eax
c002cfac:	74 11                	je     c002cfbf <dir_open+0x30>
      dir->inode = inode;
c002cfae:	89 30                	mov    %esi,(%eax)
      dir->pos = 2 * sizeof (struct dir_entry); // jump '.' and '..' for readdir
c002cfb0:	c7 40 04 28 00 00 00 	movl   $0x28,0x4(%eax)
}
c002cfb7:	89 d8                	mov    %ebx,%eax
c002cfb9:	83 c4 04             	add    $0x4,%esp
c002cfbc:	5b                   	pop    %ebx
c002cfbd:	5e                   	pop    %esi
c002cfbe:	c3                   	ret    
      inode_close (inode);
c002cfbf:	83 ec 0c             	sub    $0xc,%esp
c002cfc2:	56                   	push   %esi
c002cfc3:	e8 ce 0e 00 00       	call   c002de96 <inode_close>
      free (dir);
c002cfc8:	89 1c 24             	mov    %ebx,(%esp)
c002cfcb:	e8 f7 6b ff ff       	call   c0023bc7 <free>
      return NULL; 
c002cfd0:	83 c4 10             	add    $0x10,%esp
c002cfd3:	bb 00 00 00 00       	mov    $0x0,%ebx
c002cfd8:	eb dd                	jmp    c002cfb7 <dir_open+0x28>

c002cfda <dir_open_root>:
{
c002cfda:	83 ec 18             	sub    $0x18,%esp
  return dir_open (inode_open (ROOT_DIR_SECTOR));
c002cfdd:	6a 01                	push   $0x1
c002cfdf:	e8 0a 0e 00 00       	call   c002ddee <inode_open>
c002cfe4:	89 04 24             	mov    %eax,(%esp)
c002cfe7:	e8 a3 ff ff ff       	call   c002cf8f <dir_open>
}
c002cfec:	83 c4 1c             	add    $0x1c,%esp
c002cfef:	c3                   	ret    

c002cff0 <dir_reopen>:
{
c002cff0:	83 ec 18             	sub    $0x18,%esp
  return dir_open (inode_reopen (dir->inode));
c002cff3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002cff7:	ff 30                	pushl  (%eax)
c002cff9:	e8 e4 0d 00 00       	call   c002dde2 <inode_reopen>
c002cffe:	89 04 24             	mov    %eax,(%esp)
c002d001:	e8 89 ff ff ff       	call   c002cf8f <dir_open>
}
c002d006:	83 c4 1c             	add    $0x1c,%esp
c002d009:	c3                   	ret    

c002d00a <dir_close>:
{
c002d00a:	53                   	push   %ebx
c002d00b:	83 ec 08             	sub    $0x8,%esp
c002d00e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (dir != NULL)
c002d012:	85 db                	test   %ebx,%ebx
c002d014:	74 15                	je     c002d02b <dir_close+0x21>
      inode_close (dir->inode);
c002d016:	83 ec 0c             	sub    $0xc,%esp
c002d019:	ff 33                	pushl  (%ebx)
c002d01b:	e8 76 0e 00 00       	call   c002de96 <inode_close>
      free (dir);
c002d020:	89 1c 24             	mov    %ebx,(%esp)
c002d023:	e8 9f 6b ff ff       	call   c0023bc7 <free>
c002d028:	83 c4 10             	add    $0x10,%esp
}
c002d02b:	83 c4 08             	add    $0x8,%esp
c002d02e:	5b                   	pop    %ebx
c002d02f:	c3                   	ret    

c002d030 <dir_get_inode>:
  return dir->inode;
c002d030:	8b 44 24 04          	mov    0x4(%esp),%eax
c002d034:	8b 00                	mov    (%eax),%eax
}
c002d036:	c3                   	ret    

c002d037 <dir_lookup>:
   On success, sets *INODE to an inode for the file, otherwise to
   a null pointer.  The caller must close *INODE. */
bool
dir_lookup (const struct dir *dir, const char *name,
            struct inode **inode) 
{
c002d037:	53                   	push   %ebx
c002d038:	83 ec 28             	sub    $0x28,%esp
c002d03b:	8b 44 24 30          	mov    0x30(%esp),%eax
c002d03f:	8b 54 24 34          	mov    0x34(%esp),%edx
c002d043:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  struct dir_entry e;

  ASSERT (dir != NULL);
c002d047:	85 c0                	test   %eax,%eax
c002d049:	74 2a                	je     c002d075 <dir_lookup+0x3e>
  ASSERT (name != NULL);
c002d04b:	85 d2                	test   %edx,%edx
c002d04d:	74 47                	je     c002d096 <dir_lookup+0x5f>

  if (lookup (dir, name, &e, NULL))
c002d04f:	83 ec 0c             	sub    $0xc,%esp
c002d052:	6a 00                	push   $0x0
c002d054:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c002d058:	e8 64 fe ff ff       	call   c002cec1 <lookup>
c002d05d:	83 c4 10             	add    $0x10,%esp
c002d060:	84 c0                	test   %al,%al
c002d062:	75 53                	jne    c002d0b7 <dir_lookup+0x80>
    *inode = inode_open (e.inode_sector);
  else
    *inode = NULL;
c002d064:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

  return *inode != NULL;
c002d06a:	83 3b 00             	cmpl   $0x0,(%ebx)
c002d06d:	0f 95 c0             	setne  %al
}
c002d070:	83 c4 28             	add    $0x28,%esp
c002d073:	5b                   	pop    %ebx
c002d074:	c3                   	ret    
  ASSERT (dir != NULL);
c002d075:	83 ec 0c             	sub    $0xc,%esp
c002d078:	68 45 31 03 c0       	push   $0xc0033145
c002d07d:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d082:	68 4c 0b 03 c0       	push   $0xc0030b4c
c002d087:	68 82 00 00 00       	push   $0x82
c002d08c:	68 51 31 03 c0       	push   $0xc0033151
c002d091:	e8 e7 b5 ff ff       	call   c002867d <debug_panic>
  ASSERT (name != NULL);
c002d096:	83 ec 0c             	sub    $0xc,%esp
c002d099:	68 a7 12 03 c0       	push   $0xc00312a7
c002d09e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d0a3:	68 4c 0b 03 c0       	push   $0xc0030b4c
c002d0a8:	68 83 00 00 00       	push   $0x83
c002d0ad:	68 51 31 03 c0       	push   $0xc0033151
c002d0b2:	e8 c6 b5 ff ff       	call   c002867d <debug_panic>
    *inode = inode_open (e.inode_sector);
c002d0b7:	83 ec 0c             	sub    $0xc,%esp
c002d0ba:	ff 74 24 18          	pushl  0x18(%esp)
c002d0be:	e8 2b 0d 00 00       	call   c002ddee <inode_open>
c002d0c3:	89 03                	mov    %eax,(%ebx)
c002d0c5:	83 c4 10             	add    $0x10,%esp
c002d0c8:	eb a0                	jmp    c002d06a <dir_lookup+0x33>

c002d0ca <dir_add>:
   Returns true if successful, false on failure.
   Fails if NAME is invalid (i.e. too long) or a disk or memory
   error occurs. */
bool
dir_add (struct dir *dir, const char *name, block_sector_t inode_sector)
{
c002d0ca:	55                   	push   %ebp
c002d0cb:	57                   	push   %edi
c002d0cc:	56                   	push   %esi
c002d0cd:	53                   	push   %ebx
c002d0ce:	83 ec 2c             	sub    $0x2c,%esp
c002d0d1:	8b 5c 24 40          	mov    0x40(%esp),%ebx
c002d0d5:	8b 74 24 44          	mov    0x44(%esp),%esi
  struct dir_entry e;
  off_t ofs;
  bool success = false;

  ASSERT (dir != NULL);
c002d0d9:	85 db                	test   %ebx,%ebx
c002d0db:	74 2c                	je     c002d109 <dir_add+0x3f>
  ASSERT (name != NULL);
c002d0dd:	85 f6                	test   %esi,%esi
c002d0df:	74 49                	je     c002d12a <dir_add+0x60>

  /* Check NAME for validity. */
  if (*name == '\0' || strlen (name) > NAME_MAX)
c002d0e1:	80 3e 00             	cmpb   $0x0,(%esi)
c002d0e4:	0f 84 84 01 00 00    	je     c002d26e <dir_add+0x1a4>
c002d0ea:	b0 00                	mov    $0x0,%al
c002d0ec:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002d0f1:	89 f7                	mov    %esi,%edi
c002d0f3:	f2 ae                	repnz scas %es:(%edi),%al
c002d0f5:	89 c8                	mov    %ecx,%eax
c002d0f7:	f7 d0                	not    %eax
c002d0f9:	48                   	dec    %eax
c002d0fa:	83 f8 0e             	cmp    $0xe,%eax
c002d0fd:	76 4c                	jbe    c002d14b <dir_add+0x81>
    return false;
c002d0ff:	bf 00 00 00 00       	mov    $0x0,%edi
c002d104:	e9 6a 01 00 00       	jmp    c002d273 <dir_add+0x1a9>
  ASSERT (dir != NULL);
c002d109:	83 ec 0c             	sub    $0xc,%esp
c002d10c:	68 45 31 03 c0       	push   $0xc0033145
c002d111:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d116:	68 3c 0b 03 c0       	push   $0xc0030b3c
c002d11b:	68 9a 00 00 00       	push   $0x9a
c002d120:	68 51 31 03 c0       	push   $0xc0033151
c002d125:	e8 53 b5 ff ff       	call   c002867d <debug_panic>
  ASSERT (name != NULL);
c002d12a:	83 ec 0c             	sub    $0xc,%esp
c002d12d:	68 a7 12 03 c0       	push   $0xc00312a7
c002d132:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d137:	68 3c 0b 03 c0       	push   $0xc0030b3c
c002d13c:	68 9b 00 00 00       	push   $0x9b
c002d141:	68 51 31 03 c0       	push   $0xc0033151
c002d146:	e8 32 b5 ff ff       	call   c002867d <debug_panic>

  /* Check that NAME is not in use. */
  if (lookup (dir, name, NULL, NULL))
c002d14b:	83 ec 0c             	sub    $0xc,%esp
c002d14e:	6a 00                	push   $0x0
c002d150:	b9 00 00 00 00       	mov    $0x0,%ecx
c002d155:	89 f2                	mov    %esi,%edx
c002d157:	89 d8                	mov    %ebx,%eax
c002d159:	e8 63 fd ff ff       	call   c002cec1 <lookup>
c002d15e:	89 c7                	mov    %eax,%edi
c002d160:	83 c4 10             	add    $0x10,%esp
c002d163:	84 c0                	test   %al,%al
c002d165:	0f 85 12 01 00 00    	jne    c002d27d <dir_add+0x1b3>
     current end-of-file.
     
     inode_read_at() will only return a short read at end of file.
     Otherwise, we'd need to verify that we didn't get a short
     read due to something intermittent such as low memory. */
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002d16b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002d172:	00 
c002d173:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c002d177:	ff 74 24 08          	pushl  0x8(%esp)
c002d17b:	6a 14                	push   $0x14
c002d17d:	55                   	push   %ebp
c002d17e:	ff 33                	pushl  (%ebx)
c002d180:	e8 85 0e 00 00       	call   c002e00a <inode_read_at>
c002d185:	83 c4 10             	add    $0x10,%esp
c002d188:	83 f8 14             	cmp    $0x14,%eax
c002d18b:	75 0e                	jne    c002d19b <dir_add+0xd1>
       ofs += sizeof e) 
    if (!e.in_use)
c002d18d:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c002d192:	74 07                	je     c002d19b <dir_add+0xd1>
       ofs += sizeof e) 
c002d194:	83 44 24 08 14       	addl   $0x14,0x8(%esp)
c002d199:	eb dc                	jmp    c002d177 <dir_add+0xad>
      break;

  /* Write slot. */
  e.in_use = true;
c002d19b:	c6 44 24 1f 01       	movb   $0x1,0x1f(%esp)
  strlcpy (e.name, name, sizeof e.name);
c002d1a0:	83 ec 04             	sub    $0x4,%esp
c002d1a3:	6a 0f                	push   $0xf
c002d1a5:	56                   	push   %esi
c002d1a6:	8d 74 24 18          	lea    0x18(%esp),%esi
c002d1aa:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002d1ae:	50                   	push   %eax
c002d1af:	e8 c3 ab ff ff       	call   c0027d77 <strlcpy>
  e.inode_sector = inode_sector;
c002d1b4:	8b 44 24 58          	mov    0x58(%esp),%eax
c002d1b8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002d1bc:	ff 74 24 18          	pushl  0x18(%esp)
c002d1c0:	6a 14                	push   $0x14
c002d1c2:	56                   	push   %esi
c002d1c3:	ff 33                	pushl  (%ebx)
c002d1c5:	e8 6c 0f 00 00       	call   c002e136 <inode_write_at>

  /* Write .. infomation for true subdir */
  if (success && inode_sector != inode_get_inumber (dir->inode)) {
c002d1ca:	83 c4 20             	add    $0x20,%esp
c002d1cd:	83 f8 14             	cmp    $0x14,%eax
c002d1d0:	0f 85 9d 00 00 00    	jne    c002d273 <dir_add+0x1a9>
c002d1d6:	83 ec 0c             	sub    $0xc,%esp
c002d1d9:	ff 33                	pushl  (%ebx)
c002d1db:	e8 ae 0c 00 00       	call   c002de8e <inode_get_inumber>
c002d1e0:	83 c4 10             	add    $0x10,%esp
c002d1e3:	39 44 24 48          	cmp    %eax,0x48(%esp)
c002d1e7:	0f 84 97 00 00 00    	je     c002d284 <dir_add+0x1ba>
    struct inode* inode = inode_open (inode_sector);
c002d1ed:	83 ec 0c             	sub    $0xc,%esp
c002d1f0:	ff 74 24 54          	pushl  0x54(%esp)
c002d1f4:	e8 f5 0b 00 00       	call   c002ddee <inode_open>
c002d1f9:	89 c6                	mov    %eax,%esi
    if(inode_is_dir (inode) || (inode_close (inode), 0)) {
c002d1fb:	89 04 24             	mov    %eax,(%esp)
c002d1fe:	e8 63 11 00 00       	call   c002e366 <inode_is_dir>
c002d203:	89 c7                	mov    %eax,%edi
c002d205:	83 c4 10             	add    $0x10,%esp
c002d208:	84 c0                	test   %al,%al
c002d20a:	74 4f                	je     c002d25b <dir_add+0x191>
      struct dir *subdir = dir_open (inode);
c002d20c:	83 ec 0c             	sub    $0xc,%esp
c002d20f:	56                   	push   %esi
c002d210:	e8 7a fd ff ff       	call   c002cf8f <dir_open>
c002d215:	89 c6                	mov    %eax,%esi
      lookup (subdir, "..", &e, &ofs);
c002d217:	8d 6c 24 1c          	lea    0x1c(%esp),%ebp
c002d21b:	83 c4 04             	add    $0x4,%esp
c002d21e:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d222:	50                   	push   %eax
c002d223:	89 e9                	mov    %ebp,%ecx
c002d225:	ba a2 21 03 c0       	mov    $0xc00321a2,%edx
c002d22a:	89 f0                	mov    %esi,%eax
c002d22c:	e8 90 fc ff ff       	call   c002cec1 <lookup>
      e.inode_sector = inode_get_inumber(dir->inode);
c002d231:	83 c4 04             	add    $0x4,%esp
c002d234:	ff 33                	pushl  (%ebx)
c002d236:	e8 53 0c 00 00       	call   c002de8e <inode_get_inumber>
c002d23b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
      inode_write_at(subdir->inode, &e, sizeof e, ofs);
c002d23f:	ff 74 24 18          	pushl  0x18(%esp)
c002d243:	6a 14                	push   $0x14
c002d245:	55                   	push   %ebp
c002d246:	ff 36                	pushl  (%esi)
c002d248:	e8 e9 0e 00 00       	call   c002e136 <inode_write_at>
      dir_close (subdir);
c002d24d:	83 c4 14             	add    $0x14,%esp
c002d250:	56                   	push   %esi
c002d251:	e8 b4 fd ff ff       	call   c002d00a <dir_close>
c002d256:	83 c4 10             	add    $0x10,%esp
c002d259:	eb 18                	jmp    c002d273 <dir_add+0x1a9>
    if(inode_is_dir (inode) || (inode_close (inode), 0)) {
c002d25b:	83 ec 0c             	sub    $0xc,%esp
c002d25e:	56                   	push   %esi
c002d25f:	e8 32 0c 00 00       	call   c002de96 <inode_close>
c002d264:	83 c4 10             	add    $0x10,%esp
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002d267:	bf 01 00 00 00       	mov    $0x1,%edi
c002d26c:	eb 05                	jmp    c002d273 <dir_add+0x1a9>
    return false;
c002d26e:	bf 00 00 00 00       	mov    $0x0,%edi
    }
  }
 done:
  return success;
}
c002d273:	89 f8                	mov    %edi,%eax
c002d275:	83 c4 2c             	add    $0x2c,%esp
c002d278:	5b                   	pop    %ebx
c002d279:	5e                   	pop    %esi
c002d27a:	5f                   	pop    %edi
c002d27b:	5d                   	pop    %ebp
c002d27c:	c3                   	ret    
  bool success = false;
c002d27d:	bf 00 00 00 00       	mov    $0x0,%edi
c002d282:	eb ef                	jmp    c002d273 <dir_add+0x1a9>
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002d284:	bf 01 00 00 00       	mov    $0x1,%edi
c002d289:	eb e8                	jmp    c002d273 <dir_add+0x1a9>

c002d28b <dir_create>:
{
c002d28b:	57                   	push   %edi
c002d28c:	56                   	push   %esi
c002d28d:	53                   	push   %ebx
c002d28e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002d292:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (inode_create (sector, entry_cnt * sizeof (struct dir_entry))) {
c002d296:	83 ec 08             	sub    $0x8,%esp
c002d299:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002d29c:	c1 e0 02             	shl    $0x2,%eax
c002d29f:	50                   	push   %eax
c002d2a0:	53                   	push   %ebx
c002d2a1:	e8 ee 08 00 00       	call   c002db94 <inode_create>
c002d2a6:	89 c6                	mov    %eax,%esi
c002d2a8:	83 c4 10             	add    $0x10,%esp
c002d2ab:	84 c0                	test   %al,%al
c002d2ad:	75 06                	jne    c002d2b5 <dir_create+0x2a>
}
c002d2af:	89 f0                	mov    %esi,%eax
c002d2b1:	5b                   	pop    %ebx
c002d2b2:	5e                   	pop    %esi
c002d2b3:	5f                   	pop    %edi
c002d2b4:	c3                   	ret    
    struct inode * inode = inode_open (sector);
c002d2b5:	83 ec 0c             	sub    $0xc,%esp
c002d2b8:	53                   	push   %ebx
c002d2b9:	e8 30 0b 00 00       	call   c002ddee <inode_open>
c002d2be:	89 c7                	mov    %eax,%edi
    inode_set_dir (inode);
c002d2c0:	89 04 24             	mov    %eax,(%esp)
c002d2c3:	e8 a6 10 00 00       	call   c002e36e <inode_set_dir>
    struct dir * dir = dir_open (inode);
c002d2c8:	89 3c 24             	mov    %edi,(%esp)
c002d2cb:	e8 bf fc ff ff       	call   c002cf8f <dir_open>
c002d2d0:	89 c7                	mov    %eax,%edi
    dir_add(dir, ".", sector);
c002d2d2:	83 c4 0c             	add    $0xc,%esp
c002d2d5:	53                   	push   %ebx
c002d2d6:	68 a3 21 03 c0       	push   $0xc00321a3
c002d2db:	50                   	push   %eax
c002d2dc:	e8 e9 fd ff ff       	call   c002d0ca <dir_add>
    dir_add(dir, "..", sector);
c002d2e1:	83 c4 0c             	add    $0xc,%esp
c002d2e4:	53                   	push   %ebx
c002d2e5:	68 a2 21 03 c0       	push   $0xc00321a2
c002d2ea:	57                   	push   %edi
c002d2eb:	e8 da fd ff ff       	call   c002d0ca <dir_add>
    dir_close(dir);
c002d2f0:	89 3c 24             	mov    %edi,(%esp)
c002d2f3:	e8 12 fd ff ff       	call   c002d00a <dir_close>
    return true;
c002d2f8:	83 c4 10             	add    $0x10,%esp
c002d2fb:	eb b2                	jmp    c002d2af <dir_create+0x24>

c002d2fd <dir_remove>:
/* Removes any entry for NAME in DIR.
   Returns true if successful, false on failure,
   which occurs only if there is no file with the given NAME. */
bool
dir_remove (struct dir *dir, const char *name) 
{
c002d2fd:	57                   	push   %edi
c002d2fe:	56                   	push   %esi
c002d2ff:	53                   	push   %ebx
c002d300:	83 ec 20             	sub    $0x20,%esp
c002d303:	8b 74 24 30          	mov    0x30(%esp),%esi
c002d307:	8b 54 24 34          	mov    0x34(%esp),%edx
  struct dir_entry e;
  struct inode *inode = NULL;
  bool success = false;
  off_t ofs;

  ASSERT (dir != NULL);
c002d30b:	85 f6                	test   %esi,%esi
c002d30d:	74 37                	je     c002d346 <dir_remove+0x49>
  ASSERT (name != NULL);
c002d30f:	85 d2                	test   %edx,%edx
c002d311:	74 54                	je     c002d367 <dir_remove+0x6a>

  /* Find directory entry. */
  if (!lookup (dir, name, &e, &ofs))
c002d313:	83 ec 0c             	sub    $0xc,%esp
c002d316:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d31a:	50                   	push   %eax
c002d31b:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c002d31f:	89 f0                	mov    %esi,%eax
c002d321:	e8 9b fb ff ff       	call   c002cec1 <lookup>
c002d326:	88 c3                	mov    %al,%bl
c002d328:	83 c4 10             	add    $0x10,%esp
c002d32b:	84 c0                	test   %al,%al
c002d32d:	75 59                	jne    c002d388 <dir_remove+0x8b>
  struct inode *inode = NULL;
c002d32f:	bf 00 00 00 00       	mov    $0x0,%edi
  /* Remove inode. */
  inode_remove (inode);
  success = true;

 done:
  inode_close (inode);
c002d334:	83 ec 0c             	sub    $0xc,%esp
c002d337:	57                   	push   %edi
c002d338:	e8 59 0b 00 00       	call   c002de96 <inode_close>
  return success;
}
c002d33d:	88 d8                	mov    %bl,%al
c002d33f:	83 c4 30             	add    $0x30,%esp
c002d342:	5b                   	pop    %ebx
c002d343:	5e                   	pop    %esi
c002d344:	5f                   	pop    %edi
c002d345:	c3                   	ret    
  ASSERT (dir != NULL);
c002d346:	83 ec 0c             	sub    $0xc,%esp
c002d349:	68 45 31 03 c0       	push   $0xc0033145
c002d34e:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d353:	68 30 0b 03 c0       	push   $0xc0030b30
c002d358:	68 d1 00 00 00       	push   $0xd1
c002d35d:	68 51 31 03 c0       	push   $0xc0033151
c002d362:	e8 16 b3 ff ff       	call   c002867d <debug_panic>
  ASSERT (name != NULL);
c002d367:	83 ec 0c             	sub    $0xc,%esp
c002d36a:	68 a7 12 03 c0       	push   $0xc00312a7
c002d36f:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d374:	68 30 0b 03 c0       	push   $0xc0030b30
c002d379:	68 d2 00 00 00       	push   $0xd2
c002d37e:	68 51 31 03 c0       	push   $0xc0033151
c002d383:	e8 f5 b2 ff ff       	call   c002867d <debug_panic>
  inode = inode_open (e.inode_sector);
c002d388:	83 ec 0c             	sub    $0xc,%esp
c002d38b:	ff 74 24 18          	pushl  0x18(%esp)
c002d38f:	e8 5a 0a 00 00       	call   c002ddee <inode_open>
c002d394:	89 c7                	mov    %eax,%edi
  if (inode == NULL)
c002d396:	83 c4 10             	add    $0x10,%esp
c002d399:	85 c0                	test   %eax,%eax
c002d39b:	74 37                	je     c002d3d4 <dir_remove+0xd7>
  e.in_use = false;
c002d39d:	c6 44 24 1f 00       	movb   $0x0,0x1f(%esp)
  if (inode_write_at (dir->inode, &e, sizeof e, ofs) != sizeof e) 
c002d3a2:	ff 74 24 08          	pushl  0x8(%esp)
c002d3a6:	6a 14                	push   $0x14
c002d3a8:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d3ac:	50                   	push   %eax
c002d3ad:	ff 36                	pushl  (%esi)
c002d3af:	e8 82 0d 00 00       	call   c002e136 <inode_write_at>
c002d3b4:	83 c4 10             	add    $0x10,%esp
c002d3b7:	83 f8 14             	cmp    $0x14,%eax
c002d3ba:	74 07                	je     c002d3c3 <dir_remove+0xc6>
  bool success = false;
c002d3bc:	b3 00                	mov    $0x0,%bl
c002d3be:	e9 71 ff ff ff       	jmp    c002d334 <dir_remove+0x37>
  inode_remove (inode);
c002d3c3:	83 ec 0c             	sub    $0xc,%esp
c002d3c6:	57                   	push   %edi
c002d3c7:	e8 0a 0c 00 00       	call   c002dfd6 <inode_remove>
c002d3cc:	83 c4 10             	add    $0x10,%esp
c002d3cf:	e9 60 ff ff ff       	jmp    c002d334 <dir_remove+0x37>
  bool success = false;
c002d3d4:	b3 00                	mov    $0x0,%bl
c002d3d6:	e9 59 ff ff ff       	jmp    c002d334 <dir_remove+0x37>

c002d3db <dir_readdir>:
/* Reads the next directory entry in DIR and stores the name in
   NAME.  Returns true if successful, false if the directory
   contains no more entries. */
bool
dir_readdir (struct dir *dir, char name[NAME_MAX + 1])
{
c002d3db:	57                   	push   %edi
c002d3dc:	56                   	push   %esi
c002d3dd:	53                   	push   %ebx
c002d3de:	83 ec 20             	sub    $0x20,%esp
c002d3e1:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  struct dir_entry e;

  ASSERT (dir != NULL);
c002d3e5:	85 db                	test   %ebx,%ebx
c002d3e7:	74 53                	je     c002d43c <dir_readdir+0x61>
  ASSERT (dir->inode != NULL);
c002d3e9:	83 3b 00             	cmpl   $0x0,(%ebx)
c002d3ec:	74 6f                	je     c002d45d <dir_readdir+0x82>
  ASSERT (dir->pos > 0);
c002d3ee:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c002d3f2:	0f 8e 86 00 00 00    	jle    c002d47e <dir_readdir+0xa3>

  while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e) 
c002d3f8:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002d3fc:	ff 73 04             	pushl  0x4(%ebx)
c002d3ff:	6a 14                	push   $0x14
c002d401:	57                   	push   %edi
c002d402:	ff 33                	pushl  (%ebx)
c002d404:	e8 01 0c 00 00       	call   c002e00a <inode_read_at>
c002d409:	83 c4 10             	add    $0x10,%esp
c002d40c:	83 f8 14             	cmp    $0x14,%eax
c002d40f:	0f 85 8a 00 00 00    	jne    c002d49f <dir_readdir+0xc4>
    {
      dir->pos += sizeof e;
c002d415:	83 43 04 14          	addl   $0x14,0x4(%ebx)
      if (e.in_use)
c002d419:	0f b6 74 24 1f       	movzbl 0x1f(%esp),%esi
c002d41e:	89 f0                	mov    %esi,%eax
c002d420:	84 c0                	test   %al,%al
c002d422:	74 d8                	je     c002d3fc <dir_readdir+0x21>
        {
          strlcpy (name, e.name, NAME_MAX + 1);
c002d424:	83 ec 04             	sub    $0x4,%esp
c002d427:	6a 0f                	push   $0xf
c002d429:	8d 44 24 18          	lea    0x18(%esp),%eax
c002d42d:	50                   	push   %eax
c002d42e:	ff 74 24 40          	pushl  0x40(%esp)
c002d432:	e8 40 a9 ff ff       	call   c0027d77 <strlcpy>
          return true;
c002d437:	83 c4 10             	add    $0x10,%esp
c002d43a:	eb 68                	jmp    c002d4a4 <dir_readdir+0xc9>
  ASSERT (dir != NULL);
c002d43c:	83 ec 0c             	sub    $0xc,%esp
c002d43f:	68 45 31 03 c0       	push   $0xc0033145
c002d444:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d449:	68 24 0b 03 c0       	push   $0xc0030b24
c002d44e:	68 f3 00 00 00       	push   $0xf3
c002d453:	68 51 31 03 c0       	push   $0xc0033151
c002d458:	e8 20 b2 ff ff       	call   c002867d <debug_panic>
  ASSERT (dir->inode != NULL);
c002d45d:	83 ec 0c             	sub    $0xc,%esp
c002d460:	68 6b 31 03 c0       	push   $0xc003316b
c002d465:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d46a:	68 24 0b 03 c0       	push   $0xc0030b24
c002d46f:	68 f4 00 00 00       	push   $0xf4
c002d474:	68 51 31 03 c0       	push   $0xc0033151
c002d479:	e8 ff b1 ff ff       	call   c002867d <debug_panic>
  ASSERT (dir->pos > 0);
c002d47e:	83 ec 0c             	sub    $0xc,%esp
c002d481:	68 7e 31 03 c0       	push   $0xc003317e
c002d486:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d48b:	68 24 0b 03 c0       	push   $0xc0030b24
c002d490:	68 f5 00 00 00       	push   $0xf5
c002d495:	68 51 31 03 c0       	push   $0xc0033151
c002d49a:	e8 de b1 ff ff       	call   c002867d <debug_panic>
        } 
    }
  return false;
c002d49f:	be 00 00 00 00       	mov    $0x0,%esi
}
c002d4a4:	89 f0                	mov    %esi,%eax
c002d4a6:	83 c4 20             	add    $0x20,%esp
c002d4a9:	5b                   	pop    %ebx
c002d4aa:	5e                   	pop    %esi
c002d4ab:	5f                   	pop    %edi
c002d4ac:	c3                   	ret    

c002d4ad <dir_subdir_create>:


bool
dir_subdir_create (struct dir* dir, const char* name) {
c002d4ad:	56                   	push   %esi
c002d4ae:	53                   	push   %ebx
c002d4af:	83 ec 14             	sub    $0x14,%esp
c002d4b2:	8b 74 24 20          	mov    0x20(%esp),%esi
c002d4b6:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  block_sector_t sector = -1u;
c002d4ba:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c002d4c1:	ff 
  if (  dir != NULL
c002d4c2:	85 f6                	test   %esi,%esi
c002d4c4:	74 6e                	je     c002d534 <dir_subdir_create+0x87>
    &&  name != NULL
c002d4c6:	85 db                	test   %ebx,%ebx
c002d4c8:	74 6e                	je     c002d538 <dir_subdir_create+0x8b>
    &&  strlen(name) > 0
c002d4ca:	80 3b 00             	cmpb   $0x0,(%ebx)
c002d4cd:	75 04                	jne    c002d4d3 <dir_subdir_create+0x26>
    return true;
  }
  if (sector != -1u) {
    free_map_release(sector, 1);
  }
  return false;
c002d4cf:	b0 00                	mov    $0x0,%al
c002d4d1:	eb 2f                	jmp    c002d502 <dir_subdir_create+0x55>
    &&  free_map_allocate(1, &sector)
c002d4d3:	83 ec 08             	sub    $0x8,%esp
c002d4d6:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d4da:	50                   	push   %eax
c002d4db:	6a 01                	push   $0x1
c002d4dd:	e8 4b f5 ff ff       	call   c002ca2d <free_map_allocate>
c002d4e2:	83 c4 10             	add    $0x10,%esp
c002d4e5:	84 c0                	test   %al,%al
c002d4e7:	75 1f                	jne    c002d508 <dir_subdir_create+0x5b>
  if (sector != -1u) {
c002d4e9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d4ed:	83 f8 ff             	cmp    $0xffffffff,%eax
c002d4f0:	74 4a                	je     c002d53c <dir_subdir_create+0x8f>
    free_map_release(sector, 1);
c002d4f2:	83 ec 08             	sub    $0x8,%esp
c002d4f5:	6a 01                	push   $0x1
c002d4f7:	50                   	push   %eax
c002d4f8:	e8 9d f5 ff ff       	call   c002ca9a <free_map_release>
c002d4fd:	83 c4 10             	add    $0x10,%esp
  return false;
c002d500:	b0 00                	mov    $0x0,%al
}
c002d502:	83 c4 14             	add    $0x14,%esp
c002d505:	5b                   	pop    %ebx
c002d506:	5e                   	pop    %esi
c002d507:	c3                   	ret    
    &&  dir_create(sector, 0)
c002d508:	83 ec 08             	sub    $0x8,%esp
c002d50b:	6a 00                	push   $0x0
c002d50d:	ff 74 24 18          	pushl  0x18(%esp)
c002d511:	e8 75 fd ff ff       	call   c002d28b <dir_create>
c002d516:	83 c4 10             	add    $0x10,%esp
c002d519:	84 c0                	test   %al,%al
c002d51b:	74 cc                	je     c002d4e9 <dir_subdir_create+0x3c>
    &&  dir_add(dir, name, sector)
c002d51d:	83 ec 04             	sub    $0x4,%esp
c002d520:	ff 74 24 10          	pushl  0x10(%esp)
c002d524:	53                   	push   %ebx
c002d525:	56                   	push   %esi
c002d526:	e8 9f fb ff ff       	call   c002d0ca <dir_add>
c002d52b:	83 c4 10             	add    $0x10,%esp
c002d52e:	84 c0                	test   %al,%al
c002d530:	74 b7                	je     c002d4e9 <dir_subdir_create+0x3c>
c002d532:	eb ce                	jmp    c002d502 <dir_subdir_create+0x55>
  return false;
c002d534:	b0 00                	mov    $0x0,%al
c002d536:	eb ca                	jmp    c002d502 <dir_subdir_create+0x55>
c002d538:	b0 00                	mov    $0x0,%al
c002d53a:	eb c6                	jmp    c002d502 <dir_subdir_create+0x55>
c002d53c:	b0 00                	mov    $0x0,%al
c002d53e:	eb c2                	jmp    c002d502 <dir_subdir_create+0x55>

c002d540 <dir_subdir_lookup>:

struct dir*
dir_subdir_lookup (struct dir* dir, const char* name) {
c002d540:	83 ec 1c             	sub    $0x1c,%esp
c002d543:	8b 44 24 20          	mov    0x20(%esp),%eax
c002d547:	8b 54 24 24          	mov    0x24(%esp),%edx
  struct inode* inode = NULL;
c002d54b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d552:	00 
  if (  dir != NULL
c002d553:	85 c0                	test   %eax,%eax
c002d555:	74 46                	je     c002d59d <dir_subdir_lookup+0x5d>
    &&  name != NULL
c002d557:	85 d2                	test   %edx,%edx
c002d559:	74 5c                	je     c002d5b7 <dir_subdir_lookup+0x77>
    &&  strlen(name) > 0
c002d55b:	80 3a 00             	cmpb   $0x0,(%edx)
c002d55e:	74 5e                	je     c002d5be <dir_subdir_lookup+0x7e>
    &&  dir_lookup(dir, name, &inode)
c002d560:	83 ec 04             	sub    $0x4,%esp
c002d563:	8d 4c 24 10          	lea    0x10(%esp),%ecx
c002d567:	51                   	push   %ecx
c002d568:	52                   	push   %edx
c002d569:	50                   	push   %eax
c002d56a:	e8 c8 fa ff ff       	call   c002d037 <dir_lookup>
c002d56f:	83 c4 10             	add    $0x10,%esp
c002d572:	84 c0                	test   %al,%al
c002d574:	74 4f                	je     c002d5c5 <dir_subdir_lookup+0x85>
    &&  inode != NULL
c002d576:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d57a:	85 c0                	test   %eax,%eax
c002d57c:	74 4e                	je     c002d5cc <dir_subdir_lookup+0x8c>
    &&  (inode_is_dir(inode) || (inode_close(inode), 0))
c002d57e:	83 ec 0c             	sub    $0xc,%esp
c002d581:	50                   	push   %eax
c002d582:	e8 df 0d 00 00       	call   c002e366 <inode_is_dir>
c002d587:	83 c4 10             	add    $0x10,%esp
c002d58a:	84 c0                	test   %al,%al
c002d58c:	74 13                	je     c002d5a1 <dir_subdir_lookup+0x61>
    ) {
    return dir_open(inode);
c002d58e:	83 ec 0c             	sub    $0xc,%esp
c002d591:	ff 74 24 18          	pushl  0x18(%esp)
c002d595:	e8 f5 f9 ff ff       	call   c002cf8f <dir_open>
c002d59a:	83 c4 10             	add    $0x10,%esp
  }
  return NULL;
}
c002d59d:	83 c4 1c             	add    $0x1c,%esp
c002d5a0:	c3                   	ret    
    &&  (inode_is_dir(inode) || (inode_close(inode), 0))
c002d5a1:	83 ec 0c             	sub    $0xc,%esp
c002d5a4:	ff 74 24 18          	pushl  0x18(%esp)
c002d5a8:	e8 e9 08 00 00       	call   c002de96 <inode_close>
c002d5ad:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002d5b0:	b8 00 00 00 00       	mov    $0x0,%eax
c002d5b5:	eb e6                	jmp    c002d59d <dir_subdir_lookup+0x5d>
c002d5b7:	b8 00 00 00 00       	mov    $0x0,%eax
c002d5bc:	eb df                	jmp    c002d59d <dir_subdir_lookup+0x5d>
c002d5be:	b8 00 00 00 00       	mov    $0x0,%eax
c002d5c3:	eb d8                	jmp    c002d59d <dir_subdir_lookup+0x5d>
c002d5c5:	b8 00 00 00 00       	mov    $0x0,%eax
c002d5ca:	eb d1                	jmp    c002d59d <dir_subdir_lookup+0x5d>
c002d5cc:	b8 00 00 00 00       	mov    $0x0,%eax
c002d5d1:	eb ca                	jmp    c002d59d <dir_subdir_lookup+0x5d>

c002d5d3 <dir_subdir_delete>:

bool
dir_subdir_delete (struct dir* dir, const char* name) {
c002d5d3:	55                   	push   %ebp
c002d5d4:	57                   	push   %edi
c002d5d5:	56                   	push   %esi
c002d5d6:	53                   	push   %ebx
c002d5d7:	83 ec 2c             	sub    $0x2c,%esp
c002d5da:	8b 74 24 40          	mov    0x40(%esp),%esi
c002d5de:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  struct inode* inode = NULL;
c002d5e2:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c002d5e9:	00 
  if (  dir != NULL
c002d5ea:	85 f6                	test   %esi,%esi
c002d5ec:	0f 84 fa 00 00 00    	je     c002d6ec <dir_subdir_delete+0x119>
    &&  name != NULL
c002d5f2:	85 db                	test   %ebx,%ebx
c002d5f4:	0f 84 f9 00 00 00    	je     c002d6f3 <dir_subdir_delete+0x120>
    &&  strlen(name) > 0
c002d5fa:	80 3b 00             	cmpb   $0x0,(%ebx)
c002d5fd:	75 0a                	jne    c002d609 <dir_subdir_delete+0x36>
      free (buffer);
      if (!not_empty) {
        return dir_remove (dir, name);
      }
  }
  return false;
c002d5ff:	b0 00                	mov    $0x0,%al
}
c002d601:	83 c4 2c             	add    $0x2c,%esp
c002d604:	5b                   	pop    %ebx
c002d605:	5e                   	pop    %esi
c002d606:	5f                   	pop    %edi
c002d607:	5d                   	pop    %ebp
c002d608:	c3                   	ret    
    &&  dir_lookup(dir, name, &inode)
c002d609:	83 ec 04             	sub    $0x4,%esp
c002d60c:	8d 44 24 20          	lea    0x20(%esp),%eax
c002d610:	50                   	push   %eax
c002d611:	53                   	push   %ebx
c002d612:	56                   	push   %esi
c002d613:	e8 1f fa ff ff       	call   c002d037 <dir_lookup>
c002d618:	83 c4 10             	add    $0x10,%esp
c002d61b:	84 c0                	test   %al,%al
c002d61d:	74 e2                	je     c002d601 <dir_subdir_delete+0x2e>
    &&  inode != NULL
c002d61f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d623:	85 c0                	test   %eax,%eax
c002d625:	0f 84 cf 00 00 00    	je     c002d6fa <dir_subdir_delete+0x127>
              inode_is_dir(inode)
c002d62b:	83 ec 0c             	sub    $0xc,%esp
c002d62e:	50                   	push   %eax
c002d62f:	e8 32 0d 00 00       	call   c002e366 <inode_is_dir>
    &&  ( (
c002d634:	83 c4 10             	add    $0x10,%esp
c002d637:	84 c0                	test   %al,%al
c002d639:	74 3e                	je     c002d679 <dir_subdir_delete+0xa6>
          &&  inode_get_inumber(inode) != inode_get_inumber(dir_get_inode(thread_current()->dir))
c002d63b:	83 ec 0c             	sub    $0xc,%esp
c002d63e:	ff 74 24 28          	pushl  0x28(%esp)
c002d642:	e8 47 08 00 00       	call   c002de8e <inode_get_inumber>
c002d647:	89 c7                	mov    %eax,%edi
c002d649:	e8 c8 36 ff ff       	call   c0020d16 <thread_current>
c002d64e:	83 c4 04             	add    $0x4,%esp
  return dir->inode;
c002d651:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
          &&  inode_get_inumber(inode) != inode_get_inumber(dir_get_inode(thread_current()->dir))
c002d657:	ff 30                	pushl  (%eax)
c002d659:	e8 30 08 00 00       	call   c002de8e <inode_get_inumber>
c002d65e:	83 c4 10             	add    $0x10,%esp
c002d661:	39 c7                	cmp    %eax,%edi
c002d663:	74 14                	je     c002d679 <dir_subdir_delete+0xa6>
          &&  inode_get_open_cnt(inode) <= 1
c002d665:	83 ec 0c             	sub    $0xc,%esp
c002d668:	ff 74 24 28          	pushl  0x28(%esp)
c002d66c:	e8 18 0d 00 00       	call   c002e389 <inode_get_open_cnt>
c002d671:	83 c4 10             	add    $0x10,%esp
c002d674:	83 f8 01             	cmp    $0x1,%eax
c002d677:	7e 16                	jle    c002d68f <dir_subdir_delete+0xbc>
        || (inode_close(inode), 0)
c002d679:	83 ec 0c             	sub    $0xc,%esp
c002d67c:	ff 74 24 28          	pushl  0x28(%esp)
c002d680:	e8 11 08 00 00       	call   c002de96 <inode_close>
c002d685:	83 c4 10             	add    $0x10,%esp
  return false;
c002d688:	b0 00                	mov    $0x0,%al
c002d68a:	e9 72 ff ff ff       	jmp    c002d601 <dir_subdir_delete+0x2e>
      struct dir* checker = dir_open(inode);
c002d68f:	83 ec 0c             	sub    $0xc,%esp
c002d692:	ff 74 24 28          	pushl  0x28(%esp)
c002d696:	e8 f4 f8 ff ff       	call   c002cf8f <dir_open>
c002d69b:	89 c5                	mov    %eax,%ebp
      char* buffer = calloc(NAME_MAX + 1, 1);
c002d69d:	83 c4 08             	add    $0x8,%esp
c002d6a0:	6a 01                	push   $0x1
c002d6a2:	6a 0f                	push   $0xf
c002d6a4:	e8 d4 64 ff ff       	call   c0023b7d <calloc>
c002d6a9:	89 c7                	mov    %eax,%edi
      bool not_empty = dir_readdir (checker, buffer);
c002d6ab:	83 c4 08             	add    $0x8,%esp
c002d6ae:	50                   	push   %eax
c002d6af:	55                   	push   %ebp
c002d6b0:	e8 26 fd ff ff       	call   c002d3db <dir_readdir>
c002d6b5:	88 44 24 1f          	mov    %al,0x1f(%esp)
      dir_close (checker);
c002d6b9:	89 2c 24             	mov    %ebp,(%esp)
c002d6bc:	e8 49 f9 ff ff       	call   c002d00a <dir_close>
      free (buffer);
c002d6c1:	89 3c 24             	mov    %edi,(%esp)
c002d6c4:	e8 fe 64 ff ff       	call   c0023bc7 <free>
      if (!not_empty) {
c002d6c9:	83 c4 10             	add    $0x10,%esp
c002d6cc:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c002d6d1:	74 07                	je     c002d6da <dir_subdir_delete+0x107>
  return false;
c002d6d3:	b0 00                	mov    $0x0,%al
c002d6d5:	e9 27 ff ff ff       	jmp    c002d601 <dir_subdir_delete+0x2e>
        return dir_remove (dir, name);
c002d6da:	83 ec 08             	sub    $0x8,%esp
c002d6dd:	53                   	push   %ebx
c002d6de:	56                   	push   %esi
c002d6df:	e8 19 fc ff ff       	call   c002d2fd <dir_remove>
c002d6e4:	83 c4 10             	add    $0x10,%esp
c002d6e7:	e9 15 ff ff ff       	jmp    c002d601 <dir_subdir_delete+0x2e>
  return false;
c002d6ec:	b0 00                	mov    $0x0,%al
c002d6ee:	e9 0e ff ff ff       	jmp    c002d601 <dir_subdir_delete+0x2e>
c002d6f3:	b0 00                	mov    $0x0,%al
c002d6f5:	e9 07 ff ff ff       	jmp    c002d601 <dir_subdir_delete+0x2e>
c002d6fa:	b0 00                	mov    $0x0,%al
c002d6fc:	e9 00 ff ff ff       	jmp    c002d601 <dir_subdir_delete+0x2e>

c002d701 <dir_subfile_create>:

bool
dir_subfile_create(struct dir* dir, const char* name, off_t initial_size) {
c002d701:	56                   	push   %esi
c002d702:	53                   	push   %ebx
c002d703:	83 ec 14             	sub    $0x14,%esp
c002d706:	8b 74 24 20          	mov    0x20(%esp),%esi
c002d70a:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  block_sector_t sector = -1u;
c002d70e:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c002d715:	ff 
  if (  dir != NULL
c002d716:	85 f6                	test   %esi,%esi
c002d718:	74 70                	je     c002d78a <dir_subfile_create+0x89>
    &&  name != NULL
c002d71a:	85 db                	test   %ebx,%ebx
c002d71c:	74 70                	je     c002d78e <dir_subfile_create+0x8d>
    &&  strlen(name) > 0
c002d71e:	80 3b 00             	cmpb   $0x0,(%ebx)
c002d721:	75 04                	jne    c002d727 <dir_subfile_create+0x26>
    return true;
  }
  if (sector != -1u) {
    free_map_release(sector, 1);
  }
  return false;
c002d723:	b0 00                	mov    $0x0,%al
c002d725:	eb 2f                	jmp    c002d756 <dir_subfile_create+0x55>
    &&  free_map_allocate(1, &sector)
c002d727:	83 ec 08             	sub    $0x8,%esp
c002d72a:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d72e:	50                   	push   %eax
c002d72f:	6a 01                	push   $0x1
c002d731:	e8 f7 f2 ff ff       	call   c002ca2d <free_map_allocate>
c002d736:	83 c4 10             	add    $0x10,%esp
c002d739:	84 c0                	test   %al,%al
c002d73b:	75 1f                	jne    c002d75c <dir_subfile_create+0x5b>
  if (sector != -1u) {
c002d73d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d741:	83 f8 ff             	cmp    $0xffffffff,%eax
c002d744:	74 4c                	je     c002d792 <dir_subfile_create+0x91>
    free_map_release(sector, 1);
c002d746:	83 ec 08             	sub    $0x8,%esp
c002d749:	6a 01                	push   $0x1
c002d74b:	50                   	push   %eax
c002d74c:	e8 49 f3 ff ff       	call   c002ca9a <free_map_release>
c002d751:	83 c4 10             	add    $0x10,%esp
  return false;
c002d754:	b0 00                	mov    $0x0,%al
}
c002d756:	83 c4 14             	add    $0x14,%esp
c002d759:	5b                   	pop    %ebx
c002d75a:	5e                   	pop    %esi
c002d75b:	c3                   	ret    
    &&  inode_create(sector, initial_size)
c002d75c:	83 ec 08             	sub    $0x8,%esp
c002d75f:	ff 74 24 30          	pushl  0x30(%esp)
c002d763:	ff 74 24 18          	pushl  0x18(%esp)
c002d767:	e8 28 04 00 00       	call   c002db94 <inode_create>
c002d76c:	83 c4 10             	add    $0x10,%esp
c002d76f:	84 c0                	test   %al,%al
c002d771:	74 ca                	je     c002d73d <dir_subfile_create+0x3c>
    &&  dir_add(dir, name, sector)
c002d773:	83 ec 04             	sub    $0x4,%esp
c002d776:	ff 74 24 10          	pushl  0x10(%esp)
c002d77a:	53                   	push   %ebx
c002d77b:	56                   	push   %esi
c002d77c:	e8 49 f9 ff ff       	call   c002d0ca <dir_add>
c002d781:	83 c4 10             	add    $0x10,%esp
c002d784:	84 c0                	test   %al,%al
c002d786:	74 b5                	je     c002d73d <dir_subfile_create+0x3c>
c002d788:	eb cc                	jmp    c002d756 <dir_subfile_create+0x55>
  return false;
c002d78a:	b0 00                	mov    $0x0,%al
c002d78c:	eb c8                	jmp    c002d756 <dir_subfile_create+0x55>
c002d78e:	b0 00                	mov    $0x0,%al
c002d790:	eb c4                	jmp    c002d756 <dir_subfile_create+0x55>
c002d792:	b0 00                	mov    $0x0,%al
c002d794:	eb c0                	jmp    c002d756 <dir_subfile_create+0x55>

c002d796 <dir_subfile_lookup>:

struct file*
dir_subfile_lookup(struct dir* dir, const char* name) {
c002d796:	56                   	push   %esi
c002d797:	53                   	push   %ebx
c002d798:	83 ec 14             	sub    $0x14,%esp
c002d79b:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c002d79f:	8b 44 24 24          	mov    0x24(%esp),%eax
  struct inode* inode = NULL;
c002d7a3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d7aa:	00 
  if (  dir != NULL
c002d7ab:	85 db                	test   %ebx,%ebx
c002d7ad:	74 78                	je     c002d827 <dir_subfile_lookup+0x91>
    &&  name != NULL
c002d7af:	85 c0                	test   %eax,%eax
c002d7b1:	74 7b                	je     c002d82e <dir_subfile_lookup+0x98>
    &&  strlen(name) > 0
c002d7b3:	80 38 00             	cmpb   $0x0,(%eax)
c002d7b6:	74 7d                	je     c002d835 <dir_subfile_lookup+0x9f>
    &&  dir_lookup(dir, name, &inode)
c002d7b8:	83 ec 04             	sub    $0x4,%esp
c002d7bb:	8d 54 24 10          	lea    0x10(%esp),%edx
c002d7bf:	52                   	push   %edx
c002d7c0:	50                   	push   %eax
c002d7c1:	53                   	push   %ebx
c002d7c2:	e8 70 f8 ff ff       	call   c002d037 <dir_lookup>
c002d7c7:	83 c4 10             	add    $0x10,%esp
c002d7ca:	84 c0                	test   %al,%al
c002d7cc:	74 6e                	je     c002d83c <dir_subfile_lookup+0xa6>
    &&  inode != NULL
c002d7ce:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d7d2:	85 c0                	test   %eax,%eax
c002d7d4:	74 6d                	je     c002d843 <dir_subfile_lookup+0xad>
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
c002d7d6:	83 ec 0c             	sub    $0xc,%esp
c002d7d9:	50                   	push   %eax
c002d7da:	e8 87 0b 00 00       	call   c002e366 <inode_is_dir>
c002d7df:	83 c4 10             	add    $0x10,%esp
c002d7e2:	84 c0                	test   %al,%al
c002d7e4:	75 2b                	jne    c002d811 <dir_subfile_lookup+0x7b>
    ) {
    struct file* file = file_open(inode);
c002d7e6:	83 ec 0c             	sub    $0xc,%esp
c002d7e9:	ff 74 24 18          	pushl  0x18(%esp)
c002d7ed:	e8 20 f4 ff ff       	call   c002cc12 <file_open>
c002d7f2:	89 c6                	mov    %eax,%esi
    file_set_dir(file, dir_reopen(dir));
c002d7f4:	89 1c 24             	mov    %ebx,(%esp)
c002d7f7:	e8 f4 f7 ff ff       	call   c002cff0 <dir_reopen>
c002d7fc:	83 c4 08             	add    $0x8,%esp
c002d7ff:	50                   	push   %eax
c002d800:	56                   	push   %esi
c002d801:	e8 a7 f6 ff ff       	call   c002cead <file_set_dir>
    return file;
c002d806:	83 c4 10             	add    $0x10,%esp
  }
  return NULL;
}
c002d809:	89 f0                	mov    %esi,%eax
c002d80b:	83 c4 14             	add    $0x14,%esp
c002d80e:	5b                   	pop    %ebx
c002d80f:	5e                   	pop    %esi
c002d810:	c3                   	ret    
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
c002d811:	83 ec 0c             	sub    $0xc,%esp
c002d814:	ff 74 24 18          	pushl  0x18(%esp)
c002d818:	e8 79 06 00 00       	call   c002de96 <inode_close>
c002d81d:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002d820:	be 00 00 00 00       	mov    $0x0,%esi
c002d825:	eb e2                	jmp    c002d809 <dir_subfile_lookup+0x73>
c002d827:	be 00 00 00 00       	mov    $0x0,%esi
c002d82c:	eb db                	jmp    c002d809 <dir_subfile_lookup+0x73>
c002d82e:	be 00 00 00 00       	mov    $0x0,%esi
c002d833:	eb d4                	jmp    c002d809 <dir_subfile_lookup+0x73>
c002d835:	be 00 00 00 00       	mov    $0x0,%esi
c002d83a:	eb cd                	jmp    c002d809 <dir_subfile_lookup+0x73>
c002d83c:	be 00 00 00 00       	mov    $0x0,%esi
c002d841:	eb c6                	jmp    c002d809 <dir_subfile_lookup+0x73>
c002d843:	be 00 00 00 00       	mov    $0x0,%esi
c002d848:	eb bf                	jmp    c002d809 <dir_subfile_lookup+0x73>

c002d84a <dir_subfile_delete>:

bool
dir_subfile_delete(struct dir* dir, const char* name) {
c002d84a:	56                   	push   %esi
c002d84b:	53                   	push   %ebx
c002d84c:	83 ec 14             	sub    $0x14,%esp
c002d84f:	8b 74 24 20          	mov    0x20(%esp),%esi
c002d853:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  struct inode* inode = NULL;
c002d857:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d85e:	00 
  if (  dir != NULL
c002d85f:	85 f6                	test   %esi,%esi
c002d861:	74 6d                	je     c002d8d0 <dir_subfile_delete+0x86>
    &&  name != NULL
c002d863:	85 db                	test   %ebx,%ebx
c002d865:	74 6d                	je     c002d8d4 <dir_subfile_delete+0x8a>
    &&  strlen(name) > 0
c002d867:	80 3b 00             	cmpb   $0x0,(%ebx)
c002d86a:	75 08                	jne    c002d874 <dir_subfile_delete+0x2a>
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
    ) {
    inode_close(inode);
    return dir_remove(dir, name);
  }
  return false;
c002d86c:	b0 00                	mov    $0x0,%al
}
c002d86e:	83 c4 14             	add    $0x14,%esp
c002d871:	5b                   	pop    %ebx
c002d872:	5e                   	pop    %esi
c002d873:	c3                   	ret    
    &&  dir_lookup(dir, name, &inode)
c002d874:	83 ec 04             	sub    $0x4,%esp
c002d877:	8d 44 24 10          	lea    0x10(%esp),%eax
c002d87b:	50                   	push   %eax
c002d87c:	53                   	push   %ebx
c002d87d:	56                   	push   %esi
c002d87e:	e8 b4 f7 ff ff       	call   c002d037 <dir_lookup>
c002d883:	83 c4 10             	add    $0x10,%esp
c002d886:	84 c0                	test   %al,%al
c002d888:	74 e4                	je     c002d86e <dir_subfile_delete+0x24>
    &&  inode != NULL
c002d88a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d88e:	85 c0                	test   %eax,%eax
c002d890:	74 46                	je     c002d8d8 <dir_subfile_delete+0x8e>
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
c002d892:	83 ec 0c             	sub    $0xc,%esp
c002d895:	50                   	push   %eax
c002d896:	e8 cb 0a 00 00       	call   c002e366 <inode_is_dir>
c002d89b:	83 c4 10             	add    $0x10,%esp
c002d89e:	84 c0                	test   %al,%al
c002d8a0:	75 1b                	jne    c002d8bd <dir_subfile_delete+0x73>
    inode_close(inode);
c002d8a2:	83 ec 0c             	sub    $0xc,%esp
c002d8a5:	ff 74 24 18          	pushl  0x18(%esp)
c002d8a9:	e8 e8 05 00 00       	call   c002de96 <inode_close>
    return dir_remove(dir, name);
c002d8ae:	83 c4 08             	add    $0x8,%esp
c002d8b1:	53                   	push   %ebx
c002d8b2:	56                   	push   %esi
c002d8b3:	e8 45 fa ff ff       	call   c002d2fd <dir_remove>
c002d8b8:	83 c4 10             	add    $0x10,%esp
c002d8bb:	eb b1                	jmp    c002d86e <dir_subfile_delete+0x24>
    &&  (!inode_is_dir(inode) || (inode_close(inode), 0))
c002d8bd:	83 ec 0c             	sub    $0xc,%esp
c002d8c0:	ff 74 24 18          	pushl  0x18(%esp)
c002d8c4:	e8 cd 05 00 00       	call   c002de96 <inode_close>
c002d8c9:	83 c4 10             	add    $0x10,%esp
  return false;
c002d8cc:	b0 00                	mov    $0x0,%al
c002d8ce:	eb 9e                	jmp    c002d86e <dir_subfile_delete+0x24>
c002d8d0:	b0 00                	mov    $0x0,%al
c002d8d2:	eb 9a                	jmp    c002d86e <dir_subfile_delete+0x24>
c002d8d4:	b0 00                	mov    $0x0,%al
c002d8d6:	eb 96                	jmp    c002d86e <dir_subfile_delete+0x24>
c002d8d8:	b0 00                	mov    $0x0,%al
c002d8da:	eb 92                	jmp    c002d86e <dir_subfile_delete+0x24>

c002d8dc <dir_is_dirfile>:

bool
dir_is_dirfile(struct fd_t* h) {
c002d8dc:	83 ec 18             	sub    $0x18,%esp
  return inode_is_dir(file_get_inode(h->ptr));
c002d8df:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d8e3:	ff 30                	pushl  (%eax)
c002d8e5:	e8 a7 f3 ff ff       	call   c002cc91 <file_get_inode>
c002d8ea:	89 04 24             	mov    %eax,(%esp)
c002d8ed:	e8 74 0a 00 00       	call   c002e366 <inode_is_dir>
c002d8f2:	83 c4 1c             	add    $0x1c,%esp
c002d8f5:	c3                   	ret    

c002d8f6 <byte_to_sector>:
   within INODE.
   Returns -1 if INODE does not contain data for a byte at offset
   POS. */
static block_sector_t
byte_to_sector (struct inode *inode, off_t pos, bool write) 
{
c002d8f6:	55                   	push   %ebp
c002d8f7:	57                   	push   %edi
c002d8f8:	56                   	push   %esi
c002d8f9:	53                   	push   %ebx
c002d8fa:	83 ec 3c             	sub    $0x3c,%esp
c002d8fd:	89 44 24 14          	mov    %eax,0x14(%esp)
c002d901:	89 54 24 18          	mov    %edx,0x18(%esp)
  ASSERT (inode != NULL);
c002d905:	85 c0                	test   %eax,%eax
c002d907:	74 67                	je     c002d970 <byte_to_sector+0x7a>
c002d909:	89 cb                	mov    %ecx,%ebx
  if (pos < inode->data.length)
    return inode->data.table + pos / BLOCK_SECTOR_SIZE;
  else
    return -1;
*/
  block_sector_t *l1 = calloc(TABLE_SIZE, sizeof *l1);
c002d90b:	83 ec 08             	sub    $0x8,%esp
c002d90e:	6a 04                	push   $0x4
c002d910:	68 80 00 00 00       	push   $0x80
c002d915:	e8 63 62 ff ff       	call   c0023b7d <calloc>
c002d91a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  block_sector_t *l2 = calloc(TABLE_SIZE, sizeof *l2);
c002d91e:	83 c4 08             	add    $0x8,%esp
c002d921:	6a 04                	push   $0x4
c002d923:	68 80 00 00 00       	push   $0x80
c002d928:	e8 50 62 ff ff       	call   c0023b7d <calloc>
c002d92d:	89 44 24 14          	mov    %eax,0x14(%esp)
  block_sector_t ret = -1;
  if (pos >= inode->data.length) {
c002d931:	8b 44 24 24          	mov    0x24(%esp),%eax
c002d935:	8b 40 1c             	mov    0x1c(%eax),%eax
c002d938:	83 c4 10             	add    $0x10,%esp
c002d93b:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002d93f:	0f 8f e9 01 00 00    	jg     c002db2e <byte_to_sector+0x238>
    if (!write)
c002d945:	84 db                	test   %bl,%bl
c002d947:	75 45                	jne    c002d98e <byte_to_sector+0x98>
  block_sector_t ret = -1;
c002d949:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
  cache_read (inode->data.table, l1);
  cache_read (l1[byte_to_l1_table (pos)], l2);
  ret = l2[byte_to_l2_table (pos)];

done:
  free(l1);
c002d94e:	83 ec 0c             	sub    $0xc,%esp
c002d951:	ff 74 24 18          	pushl  0x18(%esp)
c002d955:	e8 6d 62 ff ff       	call   c0023bc7 <free>
  free(l2);
c002d95a:	83 c4 04             	add    $0x4,%esp
c002d95d:	ff 74 24 10          	pushl  0x10(%esp)
c002d961:	e8 61 62 ff ff       	call   c0023bc7 <free>
  return ret;
}
c002d966:	89 e8                	mov    %ebp,%eax
c002d968:	83 c4 4c             	add    $0x4c,%esp
c002d96b:	5b                   	pop    %ebx
c002d96c:	5e                   	pop    %esi
c002d96d:	5f                   	pop    %edi
c002d96e:	5d                   	pop    %ebp
c002d96f:	c3                   	ret    
  ASSERT (inode != NULL);
c002d970:	83 ec 0c             	sub    $0xc,%esp
c002d973:	68 70 31 03 c0       	push   $0xc0033170
c002d978:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002d97d:	68 80 0b 03 c0       	push   $0xc0030b80
c002d982:	6a 49                	push   $0x49
c002d984:	68 8b 31 03 c0       	push   $0xc003318b
c002d989:	e8 ef ac ff ff       	call   c002867d <debug_panic>
    l1_st = byte_to_l1_table(inode->data.length);
c002d98e:	89 c2                	mov    %eax,%edx
c002d990:	c1 fa 10             	sar    $0x10,%edx
c002d993:	83 e2 7f             	and    $0x7f,%edx
c002d996:	89 d6                	mov    %edx,%esi
c002d998:	89 54 24 24          	mov    %edx,0x24(%esp)
    l2_st = byte_to_l2_table(inode->data.length);
c002d99c:	c1 f8 09             	sar    $0x9,%eax
c002d99f:	83 e0 7f             	and    $0x7f,%eax
c002d9a2:	89 c7                	mov    %eax,%edi
c002d9a4:	89 44 24 28          	mov    %eax,0x28(%esp)
    l1_ed = byte_to_l1_table(pos);
c002d9a8:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002d9ac:	89 d8                	mov    %ebx,%eax
c002d9ae:	c1 f8 10             	sar    $0x10,%eax
c002d9b1:	83 e0 7f             	and    $0x7f,%eax
c002d9b4:	89 c5                	mov    %eax,%ebp
c002d9b6:	89 44 24 20          	mov    %eax,0x20(%esp)
    l2_ed = byte_to_l2_table(pos);
c002d9ba:	c1 fb 09             	sar    $0x9,%ebx
c002d9bd:	83 e3 7f             	and    $0x7f,%ebx
    cache_read (inode->data.table, l1);
c002d9c0:	83 ec 08             	sub    $0x8,%esp
c002d9c3:	ff 74 24 14          	pushl  0x14(%esp)
c002d9c7:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c002d9cb:	ff 71 18             	pushl  0x18(%ecx)
c002d9ce:	e8 e4 10 00 00       	call   c002eab7 <cache_read>
    for (i = l1_st; i <= l1_ed; i++) {
c002d9d3:	83 c4 10             	add    $0x10,%esp
c002d9d6:	39 ee                	cmp    %ebp,%esi
c002d9d8:	0f 8f 21 01 00 00    	jg     c002daff <byte_to_sector+0x209>
c002d9de:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d9e2:	8d 04 b0             	lea    (%eax,%esi,4),%eax
c002d9e5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002d9e9:	89 74 24 08          	mov    %esi,0x8(%esp)
      r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002d9ed:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
c002d9f1:	e9 be 00 00 00       	jmp    c002dab4 <byte_to_sector+0x1be>
      l = (i == l1_st ? l2_st : 0);
c002d9f6:	8b 7c 24 28          	mov    0x28(%esp),%edi
c002d9fa:	e9 b5 00 00 00       	jmp    c002dab4 <byte_to_sector+0x1be>
      r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002d9ff:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002da03:	89 04 24             	mov    %eax,(%esp)
c002da06:	e9 be 00 00 00       	jmp    c002dac9 <byte_to_sector+0x1d3>
        if (!free_map_allocate (1, &l1[i]))
c002da0b:	83 ec 08             	sub    $0x8,%esp
c002da0e:	ff 74 24 24          	pushl  0x24(%esp)
c002da12:	6a 01                	push   $0x1
c002da14:	e8 14 f0 ff ff       	call   c002ca2d <free_map_allocate>
c002da19:	83 c4 10             	add    $0x10,%esp
c002da1c:	84 c0                	test   %al,%al
c002da1e:	0f 84 2a ff ff ff    	je     c002d94e <byte_to_sector+0x58>
        cache_write (l1[i], ones); // table init to -1
c002da24:	83 ec 08             	sub    $0x8,%esp
c002da27:	68 20 e5 03 c0       	push   $0xc003e520
c002da2c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002da30:	ff 30                	pushl  (%eax)
c002da32:	e8 2e 11 00 00       	call   c002eb65 <cache_write>
c002da37:	83 c4 10             	add    $0x10,%esp
c002da3a:	e9 9d 00 00 00       	jmp    c002dadc <byte_to_sector+0x1e6>
      for (j = l; j <= r; j++) {
c002da3f:	47                   	inc    %edi
c002da40:	83 c3 04             	add    $0x4,%ebx
c002da43:	39 3c 24             	cmp    %edi,(%esp)
c002da46:	7c 31                	jl     c002da79 <byte_to_sector+0x183>
        if (l2[j] == -1) {
c002da48:	8b 2b                	mov    (%ebx),%ebp
c002da4a:	83 fd ff             	cmp    $0xffffffff,%ebp
c002da4d:	75 f0                	jne    c002da3f <byte_to_sector+0x149>
          if (!free_map_allocate (1, &l2[j]))
c002da4f:	83 ec 08             	sub    $0x8,%esp
c002da52:	53                   	push   %ebx
c002da53:	6a 01                	push   $0x1
c002da55:	e8 d3 ef ff ff       	call   c002ca2d <free_map_allocate>
c002da5a:	83 c4 10             	add    $0x10,%esp
c002da5d:	84 c0                	test   %al,%al
c002da5f:	0f 84 e9 fe ff ff    	je     c002d94e <byte_to_sector+0x58>
          cache_write (l2[j], zeros);
c002da65:	83 ec 08             	sub    $0x8,%esp
c002da68:	68 20 e7 03 c0       	push   $0xc003e720
c002da6d:	ff 33                	pushl  (%ebx)
c002da6f:	e8 f1 10 00 00       	call   c002eb65 <cache_write>
c002da74:	83 c4 10             	add    $0x10,%esp
c002da77:	eb c6                	jmp    c002da3f <byte_to_sector+0x149>
      cache_write (l1[i], l2);
c002da79:	83 ec 08             	sub    $0x8,%esp
c002da7c:	ff 74 24 0c          	pushl  0xc(%esp)
c002da80:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002da84:	ff 30                	pushl  (%eax)
c002da86:	e8 da 10 00 00       	call   c002eb65 <cache_write>
    for (i = l1_st; i <= l1_ed; i++) {
c002da8b:	ff 44 24 18          	incl   0x18(%esp)
c002da8f:	8b 44 24 18          	mov    0x18(%esp),%eax
c002da93:	83 44 24 2c 04       	addl   $0x4,0x2c(%esp)
c002da98:	83 c4 10             	add    $0x10,%esp
c002da9b:	39 44 24 20          	cmp    %eax,0x20(%esp)
c002da9f:	7c 5e                	jl     c002daff <byte_to_sector+0x209>
      l = (i == l1_st ? l2_st : 0);
c002daa1:	8b 54 24 08          	mov    0x8(%esp),%edx
c002daa5:	39 54 24 24          	cmp    %edx,0x24(%esp)
c002daa9:	0f 84 47 ff ff ff    	je     c002d9f6 <byte_to_sector+0x100>
c002daaf:	bf 00 00 00 00       	mov    $0x0,%edi
      r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002dab4:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002dab8:	39 4c 24 20          	cmp    %ecx,0x20(%esp)
c002dabc:	0f 84 3d ff ff ff    	je     c002d9ff <byte_to_sector+0x109>
c002dac2:	c7 04 24 7f 00 00 00 	movl   $0x7f,(%esp)
      if (l1[i] == -1){
c002dac9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002dacd:	89 44 24 10          	mov    %eax,0x10(%esp)
c002dad1:	8b 28                	mov    (%eax),%ebp
c002dad3:	83 fd ff             	cmp    $0xffffffff,%ebp
c002dad6:	0f 84 2f ff ff ff    	je     c002da0b <byte_to_sector+0x115>
      cache_read (l1[i], l2);
c002dadc:	83 ec 08             	sub    $0x8,%esp
c002dadf:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002dae3:	56                   	push   %esi
c002dae4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002dae8:	ff 30                	pushl  (%eax)
c002daea:	e8 c8 0f 00 00       	call   c002eab7 <cache_read>
      for (j = l; j <= r; j++) {
c002daef:	83 c4 10             	add    $0x10,%esp
c002daf2:	3b 3c 24             	cmp    (%esp),%edi
c002daf5:	7f 82                	jg     c002da79 <byte_to_sector+0x183>
c002daf7:	8d 1c be             	lea    (%esi,%edi,4),%ebx
c002dafa:	e9 49 ff ff ff       	jmp    c002da48 <byte_to_sector+0x152>
    cache_write (inode->data.table, l1);
c002daff:	83 ec 08             	sub    $0x8,%esp
c002db02:	ff 74 24 14          	pushl  0x14(%esp)
c002db06:	8b 74 24 20          	mov    0x20(%esp),%esi
c002db0a:	ff 76 18             	pushl  0x18(%esi)
c002db0d:	e8 53 10 00 00       	call   c002eb65 <cache_write>
    inode->data.length = pos + 1;
c002db12:	8b 44 24 28          	mov    0x28(%esp),%eax
c002db16:	40                   	inc    %eax
c002db17:	89 46 1c             	mov    %eax,0x1c(%esi)
    cache_write (inode->sector, &inode->data);
c002db1a:	83 c4 08             	add    $0x8,%esp
c002db1d:	89 f0                	mov    %esi,%eax
c002db1f:	83 c0 18             	add    $0x18,%eax
c002db22:	50                   	push   %eax
c002db23:	ff 76 08             	pushl  0x8(%esi)
c002db26:	e8 3a 10 00 00       	call   c002eb65 <cache_write>
c002db2b:	83 c4 10             	add    $0x10,%esp
  cache_read (inode->data.table, l1);
c002db2e:	83 ec 08             	sub    $0x8,%esp
c002db31:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002db35:	57                   	push   %edi
c002db36:	8b 44 24 20          	mov    0x20(%esp),%eax
c002db3a:	ff 70 18             	pushl  0x18(%eax)
c002db3d:	e8 75 0f 00 00       	call   c002eab7 <cache_read>
  cache_read (l1[byte_to_l1_table (pos)], l2);
c002db42:	83 c4 08             	add    $0x8,%esp
c002db45:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002db49:	53                   	push   %ebx
c002db4a:	8b 74 24 24          	mov    0x24(%esp),%esi
c002db4e:	89 f0                	mov    %esi,%eax
c002db50:	c1 f8 10             	sar    $0x10,%eax
c002db53:	83 e0 7f             	and    $0x7f,%eax
c002db56:	ff 34 87             	pushl  (%edi,%eax,4)
c002db59:	e8 59 0f 00 00       	call   c002eab7 <cache_read>
  ret = l2[byte_to_l2_table (pos)];
c002db5e:	89 f0                	mov    %esi,%eax
c002db60:	c1 f8 09             	sar    $0x9,%eax
c002db63:	83 e0 7f             	and    $0x7f,%eax
c002db66:	8b 2c 83             	mov    (%ebx,%eax,4),%ebp
c002db69:	83 c4 10             	add    $0x10,%esp
c002db6c:	e9 dd fd ff ff       	jmp    c002d94e <byte_to_sector+0x58>

c002db71 <inode_init>:
static struct list open_inodes;

/* Initializes the inode module. */
void
inode_init (void) 
{
c002db71:	57                   	push   %edi
c002db72:	83 ec 14             	sub    $0x14,%esp
  list_init (&open_inodes);
c002db75:	68 00 e5 03 c0       	push   $0xc003e500
c002db7a:	e8 a5 ab ff ff       	call   c0028724 <list_init>
  memset (ones, -1, sizeof ones);
c002db7f:	ba 20 e5 03 c0       	mov    $0xc003e520,%edx
c002db84:	b9 00 02 00 00       	mov    $0x200,%ecx
c002db89:	b0 ff                	mov    $0xff,%al
c002db8b:	89 d7                	mov    %edx,%edi
c002db8d:	f3 aa                	rep stos %al,%es:(%edi)
}
c002db8f:	83 c4 18             	add    $0x18,%esp
c002db92:	5f                   	pop    %edi
c002db93:	c3                   	ret    

c002db94 <inode_create>:
   device.
   Returns true if successful.
   Returns false if memory or disk allocation fails. */
bool
inode_create (block_sector_t sector, off_t length)
{
c002db94:	55                   	push   %ebp
c002db95:	57                   	push   %edi
c002db96:	56                   	push   %esi
c002db97:	53                   	push   %ebx
c002db98:	83 ec 3c             	sub    $0x3c,%esp
c002db9b:	8b 5c 24 54          	mov    0x54(%esp),%ebx
  struct inode_disk *disk_inode = NULL;
  bool success = false;

  ASSERT (length >= 0);
c002db9f:	85 db                	test   %ebx,%ebx
c002dba1:	78 5b                	js     c002dbfe <inode_create+0x6a>

  /* If this assertion fails, the inode structure is not exactly
     one sector in size, and you should fix that. */
  ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);

  disk_inode = calloc (1, sizeof *disk_inode);
c002dba3:	83 ec 08             	sub    $0x8,%esp
c002dba6:	68 00 02 00 00       	push   $0x200
c002dbab:	6a 01                	push   $0x1
c002dbad:	e8 cb 5f ff ff       	call   c0023b7d <calloc>
c002dbb2:	89 c5                	mov    %eax,%ebp
  if (disk_inode != NULL)
c002dbb4:	83 c4 10             	add    $0x10,%esp
c002dbb7:	85 c0                	test   %eax,%eax
c002dbb9:	0f 84 19 02 00 00    	je     c002ddd8 <inode_create+0x244>
    {
      disk_inode->length = length;
c002dbbf:	89 58 04             	mov    %ebx,0x4(%eax)
      disk_inode->magic = INODE_MAGIC;
c002dbc2:	c7 80 fc 01 00 00 44 	movl   $0x494e4f44,0x1fc(%eax)
c002dbc9:	4f 4e 49 
      disk_inode->is_dir = false;
c002dbcc:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      if (free_map_allocate (1, &disk_inode->table)) 
c002dbd0:	83 ec 08             	sub    $0x8,%esp
c002dbd3:	50                   	push   %eax
c002dbd4:	6a 01                	push   $0x1
c002dbd6:	e8 52 ee ff ff       	call   c002ca2d <free_map_allocate>
c002dbdb:	88 44 24 1f          	mov    %al,0x1f(%esp)
c002dbdf:	83 c4 10             	add    $0x10,%esp
c002dbe2:	84 c0                	test   %al,%al
c002dbe4:	75 39                	jne    c002dc1f <inode_create+0x8b>
            free(l2);
          } else {
            success = true; 
          }
        } 
      free (disk_inode);
c002dbe6:	83 ec 0c             	sub    $0xc,%esp
c002dbe9:	55                   	push   %ebp
c002dbea:	e8 d8 5f ff ff       	call   c0023bc7 <free>
c002dbef:	83 c4 10             	add    $0x10,%esp
    }
  return success;
}
c002dbf2:	8a 44 24 0f          	mov    0xf(%esp),%al
c002dbf6:	83 c4 3c             	add    $0x3c,%esp
c002dbf9:	5b                   	pop    %ebx
c002dbfa:	5e                   	pop    %esi
c002dbfb:	5f                   	pop    %edi
c002dbfc:	5d                   	pop    %ebp
c002dbfd:	c3                   	ret    
  ASSERT (length >= 0);
c002dbfe:	83 ec 0c             	sub    $0xc,%esp
c002dc01:	68 a1 31 03 c0       	push   $0xc00331a1
c002dc06:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002dc0b:	68 a0 0b 03 c0       	push   $0xc0030ba0
c002dc10:	68 97 00 00 00       	push   $0x97
c002dc15:	68 8b 31 03 c0       	push   $0xc003318b
c002dc1a:	e8 5e aa ff ff       	call   c002867d <debug_panic>
          cache_write (sector, disk_inode);
c002dc1f:	83 ec 08             	sub    $0x8,%esp
c002dc22:	55                   	push   %ebp
c002dc23:	ff 74 24 5c          	pushl  0x5c(%esp)
c002dc27:	e8 39 0f 00 00       	call   c002eb65 <cache_write>
          cache_write (disk_inode->table, ones);
c002dc2c:	83 c4 08             	add    $0x8,%esp
c002dc2f:	68 20 e5 03 c0       	push   $0xc003e520
c002dc34:	ff 75 00             	pushl  0x0(%ebp)
c002dc37:	e8 29 0f 00 00       	call   c002eb65 <cache_write>
          if (length) {
c002dc3c:	83 c4 10             	add    $0x10,%esp
c002dc3f:	85 db                	test   %ebx,%ebx
c002dc41:	74 a3                	je     c002dbe6 <inode_create+0x52>
            block_sector_t *l1 = calloc(TABLE_SIZE, sizeof *l1);
c002dc43:	83 ec 08             	sub    $0x8,%esp
c002dc46:	6a 04                	push   $0x4
c002dc48:	68 80 00 00 00       	push   $0x80
c002dc4d:	e8 2b 5f ff ff       	call   c0023b7d <calloc>
c002dc52:	89 c7                	mov    %eax,%edi
c002dc54:	89 44 24 34          	mov    %eax,0x34(%esp)
            block_sector_t *l2 = calloc(TABLE_SIZE, sizeof *l2);
c002dc58:	83 c4 08             	add    $0x8,%esp
c002dc5b:	6a 04                	push   $0x4
c002dc5d:	68 80 00 00 00       	push   $0x80
c002dc62:	e8 16 5f ff ff       	call   c0023b7d <calloc>
c002dc67:	89 44 24 2c          	mov    %eax,0x2c(%esp)
            l1_ed = byte_to_l1_table(length - 1);
c002dc6b:	4b                   	dec    %ebx
c002dc6c:	89 d8                	mov    %ebx,%eax
c002dc6e:	c1 f8 10             	sar    $0x10,%eax
c002dc71:	83 e0 7f             	and    $0x7f,%eax
c002dc74:	89 44 24 30          	mov    %eax,0x30(%esp)
            l2_ed = byte_to_l2_table(length - 1);
c002dc78:	c1 fb 09             	sar    $0x9,%ebx
c002dc7b:	83 e3 7f             	and    $0x7f,%ebx
            cache_read (disk_inode->table, l1);
c002dc7e:	83 c4 08             	add    $0x8,%esp
c002dc81:	57                   	push   %edi
c002dc82:	ff 75 00             	pushl  0x0(%ebp)
c002dc85:	e8 2d 0e 00 00       	call   c002eab7 <cache_read>
c002dc8a:	89 7c 24 28          	mov    %edi,0x28(%esp)
c002dc8e:	83 c4 10             	add    $0x10,%esp
c002dc91:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c002dc98:	00 
              r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002dc99:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
c002dc9d:	89 6c 24 28          	mov    %ebp,0x28(%esp)
c002dca1:	e9 9c 00 00 00       	jmp    c002dd42 <inode_create+0x1ae>
c002dca6:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002dcaa:	e9 a6 00 00 00       	jmp    c002dd55 <inode_create+0x1c1>
                if (!free_map_allocate (1, &l1[i]))
c002dcaf:	83 ec 08             	sub    $0x8,%esp
c002dcb2:	ff 74 24 20          	pushl  0x20(%esp)
c002dcb6:	6a 01                	push   $0x1
c002dcb8:	e8 70 ed ff ff       	call   c002ca2d <free_map_allocate>
c002dcbd:	83 c4 10             	add    $0x10,%esp
c002dcc0:	84 c0                	test   %al,%al
c002dcc2:	0f 84 dc 00 00 00    	je     c002dda4 <inode_create+0x210>
                cache_write (l1[i], ones); // table init to -1
c002dcc8:	83 ec 08             	sub    $0x8,%esp
c002dccb:	68 20 e5 03 c0       	push   $0xc003e520
c002dcd0:	8b 44 24 20          	mov    0x20(%esp),%eax
c002dcd4:	ff 30                	pushl  (%eax)
c002dcd6:	e8 8a 0e 00 00       	call   c002eb65 <cache_write>
c002dcdb:	83 c4 10             	add    $0x10,%esp
c002dcde:	e9 83 00 00 00       	jmp    c002dd66 <inode_create+0x1d2>
              for (j = l; j <= r; j++) {
c002dce3:	46                   	inc    %esi
c002dce4:	83 c3 04             	add    $0x4,%ebx
c002dce7:	39 f5                	cmp    %esi,%ebp
c002dce9:	7c 2f                	jl     c002dd1a <inode_create+0x186>
                if (l2[j] == -1) {
c002dceb:	83 3b ff             	cmpl   $0xffffffff,(%ebx)
c002dcee:	75 f3                	jne    c002dce3 <inode_create+0x14f>
                  if (!free_map_allocate (1, &l2[j]))
c002dcf0:	83 ec 08             	sub    $0x8,%esp
c002dcf3:	53                   	push   %ebx
c002dcf4:	6a 01                	push   $0x1
c002dcf6:	e8 32 ed ff ff       	call   c002ca2d <free_map_allocate>
c002dcfb:	83 c4 10             	add    $0x10,%esp
c002dcfe:	84 c0                	test   %al,%al
c002dd00:	0f 84 a6 00 00 00    	je     c002ddac <inode_create+0x218>
                  cache_write (l2[j], zeros);
c002dd06:	83 ec 08             	sub    $0x8,%esp
c002dd09:	68 20 e7 03 c0       	push   $0xc003e720
c002dd0e:	ff 33                	pushl  (%ebx)
c002dd10:	e8 50 0e 00 00       	call   c002eb65 <cache_write>
c002dd15:	83 c4 10             	add    $0x10,%esp
c002dd18:	eb c9                	jmp    c002dce3 <inode_create+0x14f>
              cache_write (l1[i], l2);
c002dd1a:	83 ec 08             	sub    $0x8,%esp
c002dd1d:	ff 74 24 24          	pushl  0x24(%esp)
c002dd21:	8b 44 24 20          	mov    0x20(%esp),%eax
c002dd25:	ff 30                	pushl  (%eax)
c002dd27:	e8 39 0e 00 00       	call   c002eb65 <cache_write>
            for (i = 0; i <= l1_ed; i++) {
c002dd2c:	ff 44 24 20          	incl   0x20(%esp)
c002dd30:	8b 44 24 20          	mov    0x20(%esp),%eax
c002dd34:	83 44 24 28 04       	addl   $0x4,0x28(%esp)
c002dd39:	83 c4 10             	add    $0x10,%esp
c002dd3c:	39 44 24 20          	cmp    %eax,0x20(%esp)
c002dd40:	7c 44                	jl     c002dd86 <inode_create+0x1f2>
              r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002dd42:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002dd46:	39 4c 24 20          	cmp    %ecx,0x20(%esp)
c002dd4a:	0f 84 56 ff ff ff    	je     c002dca6 <inode_create+0x112>
c002dd50:	bd 7f 00 00 00       	mov    $0x7f,%ebp
              if (l1[i] == -1){
c002dd55:	8b 44 24 18          	mov    0x18(%esp),%eax
c002dd59:	89 44 24 14          	mov    %eax,0x14(%esp)
c002dd5d:	83 38 ff             	cmpl   $0xffffffff,(%eax)
c002dd60:	0f 84 49 ff ff ff    	je     c002dcaf <inode_create+0x11b>
              cache_read (l1[i], l2);
c002dd66:	83 ec 08             	sub    $0x8,%esp
c002dd69:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c002dd6d:	53                   	push   %ebx
c002dd6e:	8b 44 24 20          	mov    0x20(%esp),%eax
c002dd72:	ff 30                	pushl  (%eax)
c002dd74:	e8 3e 0d 00 00       	call   c002eab7 <cache_read>
c002dd79:	83 c4 10             	add    $0x10,%esp
c002dd7c:	be 00 00 00 00       	mov    $0x0,%esi
c002dd81:	e9 65 ff ff ff       	jmp    c002dceb <inode_create+0x157>
c002dd86:	8b 6c 24 28          	mov    0x28(%esp),%ebp
            cache_write (disk_inode->table, l1);
c002dd8a:	83 ec 08             	sub    $0x8,%esp
c002dd8d:	ff 74 24 2c          	pushl  0x2c(%esp)
c002dd91:	ff 75 00             	pushl  0x0(%ebp)
c002dd94:	e8 cc 0d 00 00       	call   c002eb65 <cache_write>
c002dd99:	83 c4 10             	add    $0x10,%esp
            success = true;
c002dd9c:	8a 44 24 0f          	mov    0xf(%esp),%al
c002dda0:	89 c7                	mov    %eax,%edi
c002dda2:	eb 0e                	jmp    c002ddb2 <inode_create+0x21e>
c002dda4:	89 c7                	mov    %eax,%edi
c002dda6:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002ddaa:	eb 06                	jmp    c002ddb2 <inode_create+0x21e>
c002ddac:	89 c7                	mov    %eax,%edi
c002ddae:	8b 6c 24 28          	mov    0x28(%esp),%ebp
            free(l1);
c002ddb2:	83 ec 0c             	sub    $0xc,%esp
c002ddb5:	ff 74 24 30          	pushl  0x30(%esp)
c002ddb9:	e8 09 5e ff ff       	call   c0023bc7 <free>
            free(l2);
c002ddbe:	83 c4 04             	add    $0x4,%esp
c002ddc1:	ff 74 24 28          	pushl  0x28(%esp)
c002ddc5:	e8 fd 5d ff ff       	call   c0023bc7 <free>
c002ddca:	83 c4 10             	add    $0x10,%esp
c002ddcd:	89 f8                	mov    %edi,%eax
c002ddcf:	88 44 24 0f          	mov    %al,0xf(%esp)
c002ddd3:	e9 0e fe ff ff       	jmp    c002dbe6 <inode_create+0x52>
  bool success = false;
c002ddd8:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
  return success;
c002dddd:	e9 10 fe ff ff       	jmp    c002dbf2 <inode_create+0x5e>

c002dde2 <inode_reopen>:
}

/* Reopens and returns INODE. */
struct inode *
inode_reopen (struct inode *inode)
{
c002dde2:	8b 44 24 04          	mov    0x4(%esp),%eax
  if (inode != NULL)
c002dde6:	85 c0                	test   %eax,%eax
c002dde8:	74 03                	je     c002dded <inode_reopen+0xb>
    inode->open_cnt++;
c002ddea:	ff 40 0c             	incl   0xc(%eax)
  return inode;
}
c002dded:	c3                   	ret    

c002ddee <inode_open>:
{
c002ddee:	56                   	push   %esi
c002ddef:	53                   	push   %ebx
c002ddf0:	83 ec 10             	sub    $0x10,%esp
c002ddf3:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
c002ddf7:	68 00 e5 03 c0       	push   $0xc003e500
c002ddfc:	e8 66 a9 ff ff       	call   c0028767 <list_begin>
c002de01:	89 c3                	mov    %eax,%ebx
c002de03:	83 c4 10             	add    $0x10,%esp
c002de06:	83 ec 0c             	sub    $0xc,%esp
c002de09:	68 00 e5 03 c0       	push   $0xc003e500
c002de0e:	e8 cc a9 ff ff       	call   c00287df <list_end>
c002de13:	83 c4 10             	add    $0x10,%esp
c002de16:	39 c3                	cmp    %eax,%ebx
c002de18:	74 29                	je     c002de43 <inode_open+0x55>
      if (inode->sector == sector) 
c002de1a:	39 73 08             	cmp    %esi,0x8(%ebx)
c002de1d:	74 10                	je     c002de2f <inode_open+0x41>
       e = list_next (e)) 
c002de1f:	83 ec 0c             	sub    $0xc,%esp
c002de22:	53                   	push   %ebx
c002de23:	e8 6f a9 ff ff       	call   c0028797 <list_next>
c002de28:	89 c3                	mov    %eax,%ebx
c002de2a:	83 c4 10             	add    $0x10,%esp
c002de2d:	eb d7                	jmp    c002de06 <inode_open+0x18>
          inode_reopen (inode);
c002de2f:	83 ec 0c             	sub    $0xc,%esp
c002de32:	53                   	push   %ebx
c002de33:	e8 aa ff ff ff       	call   c002dde2 <inode_reopen>
          return inode; 
c002de38:	83 c4 10             	add    $0x10,%esp
}
c002de3b:	89 d8                	mov    %ebx,%eax
c002de3d:	83 c4 04             	add    $0x4,%esp
c002de40:	5b                   	pop    %ebx
c002de41:	5e                   	pop    %esi
c002de42:	c3                   	ret    
  inode = malloc (sizeof *inode);
c002de43:	83 ec 0c             	sub    $0xc,%esp
c002de46:	68 18 02 00 00       	push   $0x218
c002de4b:	e8 d4 5b ff ff       	call   c0023a24 <malloc>
c002de50:	89 c3                	mov    %eax,%ebx
  if (inode == NULL)
c002de52:	83 c4 10             	add    $0x10,%esp
c002de55:	85 c0                	test   %eax,%eax
c002de57:	74 e2                	je     c002de3b <inode_open+0x4d>
  list_push_front (&open_inodes, &inode->elem);
c002de59:	83 ec 08             	sub    $0x8,%esp
c002de5c:	50                   	push   %eax
c002de5d:	68 00 e5 03 c0       	push   $0xc003e500
c002de62:	e8 ec ac ff ff       	call   c0028b53 <list_push_front>
  inode->sector = sector;
c002de67:	89 73 08             	mov    %esi,0x8(%ebx)
  inode->open_cnt = 1;
c002de6a:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
  inode->deny_write_cnt = 0;
c002de71:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
  inode->removed = false;
c002de78:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
  cache_read (inode->sector, &inode->data);
c002de7c:	83 c4 08             	add    $0x8,%esp
c002de7f:	8d 43 18             	lea    0x18(%ebx),%eax
c002de82:	50                   	push   %eax
c002de83:	56                   	push   %esi
c002de84:	e8 2e 0c 00 00       	call   c002eab7 <cache_read>
  return inode;
c002de89:	83 c4 10             	add    $0x10,%esp
c002de8c:	eb ad                	jmp    c002de3b <inode_open+0x4d>

c002de8e <inode_get_inumber>:

/* Returns INODE's inode number. */
block_sector_t
inode_get_inumber (const struct inode *inode)
{
  return inode->sector;
c002de8e:	8b 44 24 04          	mov    0x4(%esp),%eax
c002de92:	8b 40 08             	mov    0x8(%eax),%eax
}
c002de95:	c3                   	ret    

c002de96 <inode_close>:
/* Closes INODE and writes it to disk.
   If this was the last reference to INODE, frees its memory.
   If INODE was also a removed inode, frees its blocks. */
void
inode_close (struct inode* inode) 
{
c002de96:	55                   	push   %ebp
c002de97:	57                   	push   %edi
c002de98:	56                   	push   %esi
c002de99:	53                   	push   %ebx
c002de9a:	83 ec 2c             	sub    $0x2c,%esp
c002de9d:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  /* Ignore null pointer. */
  if (inode == NULL)
c002dea1:	85 ed                	test   %ebp,%ebp
c002dea3:	74 0f                	je     c002deb4 <inode_close+0x1e>
    return;

  /* Release resources if this was the last opener. */
  if (--inode->open_cnt == 0)
c002dea5:	8b 45 0c             	mov    0xc(%ebp),%eax
c002dea8:	48                   	dec    %eax
c002dea9:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002dead:	89 45 0c             	mov    %eax,0xc(%ebp)
c002deb0:	85 c0                	test   %eax,%eax
c002deb2:	74 08                	je     c002debc <inode_close+0x26>
        free_map_release (inode->data.table, 1);
      }

      free (inode); 
    }
}
c002deb4:	83 c4 2c             	add    $0x2c,%esp
c002deb7:	5b                   	pop    %ebx
c002deb8:	5e                   	pop    %esi
c002deb9:	5f                   	pop    %edi
c002deba:	5d                   	pop    %ebp
c002debb:	c3                   	ret    
      list_remove (&inode->elem);
c002debc:	83 ec 0c             	sub    $0xc,%esp
c002debf:	55                   	push   %ebp
c002dec0:	e8 c8 ac ff ff       	call   c0028b8d <list_remove>
      if (inode->removed) {
c002dec5:	83 c4 10             	add    $0x10,%esp
c002dec8:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
c002decc:	74 24                	je     c002def2 <inode_close+0x5c>
        if (inode->data.length) {
c002dece:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
c002ded1:	85 db                	test   %ebx,%ebx
c002ded3:	75 2b                	jne    c002df00 <inode_close+0x6a>
        free_map_release (inode->sector, 1);
c002ded5:	83 ec 08             	sub    $0x8,%esp
c002ded8:	6a 01                	push   $0x1
c002deda:	ff 75 08             	pushl  0x8(%ebp)
c002dedd:	e8 b8 eb ff ff       	call   c002ca9a <free_map_release>
        free_map_release (inode->data.table, 1);
c002dee2:	83 c4 08             	add    $0x8,%esp
c002dee5:	6a 01                	push   $0x1
c002dee7:	ff 75 18             	pushl  0x18(%ebp)
c002deea:	e8 ab eb ff ff       	call   c002ca9a <free_map_release>
c002deef:	83 c4 10             	add    $0x10,%esp
      free (inode); 
c002def2:	83 ec 0c             	sub    $0xc,%esp
c002def5:	55                   	push   %ebp
c002def6:	e8 cc 5c ff ff       	call   c0023bc7 <free>
c002defb:	83 c4 10             	add    $0x10,%esp
c002defe:	eb b4                	jmp    c002deb4 <inode_close+0x1e>
          block_sector_t *l1 = calloc(TABLE_SIZE, sizeof *l1);
c002df00:	83 ec 08             	sub    $0x8,%esp
c002df03:	6a 04                	push   $0x4
c002df05:	68 80 00 00 00       	push   $0x80
c002df0a:	e8 6e 5c ff ff       	call   c0023b7d <calloc>
c002df0f:	89 c7                	mov    %eax,%edi
c002df11:	89 44 24 20          	mov    %eax,0x20(%esp)
          block_sector_t *l2 = calloc(TABLE_SIZE, sizeof *l2);
c002df15:	83 c4 08             	add    $0x8,%esp
c002df18:	6a 04                	push   $0x4
c002df1a:	68 80 00 00 00       	push   $0x80
c002df1f:	e8 59 5c ff ff       	call   c0023b7d <calloc>
c002df24:	89 c6                	mov    %eax,%esi
          l1_ed = byte_to_l1_table(inode->data.length - 1);
c002df26:	4b                   	dec    %ebx
c002df27:	89 d8                	mov    %ebx,%eax
c002df29:	c1 f8 10             	sar    $0x10,%eax
c002df2c:	83 e0 7f             	and    $0x7f,%eax
c002df2f:	89 44 24 24          	mov    %eax,0x24(%esp)
          l2_ed = byte_to_l2_table(inode->data.length - 1);
c002df33:	c1 fb 09             	sar    $0x9,%ebx
c002df36:	83 e3 7f             	and    $0x7f,%ebx
          cache_read (inode->data.table, l1);
c002df39:	83 c4 08             	add    $0x8,%esp
c002df3c:	57                   	push   %edi
c002df3d:	ff 75 18             	pushl  0x18(%ebp)
c002df40:	e8 72 0b 00 00       	call   c002eab7 <cache_read>
c002df45:	83 c4 10             	add    $0x10,%esp
c002df48:	8b 44 24 0c          	mov    0xc(%esp),%eax
            r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002df4c:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
c002df50:	89 6c 24 40          	mov    %ebp,0x40(%esp)
c002df54:	89 c5                	mov    %eax,%ebp
c002df56:	39 6c 24 14          	cmp    %ebp,0x14(%esp)
c002df5a:	74 74                	je     c002dfd0 <inode_close+0x13a>
c002df5c:	bf 7f 00 00 00       	mov    $0x7f,%edi
c002df61:	89 6c 24 18          	mov    %ebp,0x18(%esp)
            cache_read (l1[i], l2);
c002df65:	83 ec 08             	sub    $0x8,%esp
c002df68:	56                   	push   %esi
c002df69:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002df6d:	ff 34 a8             	pushl  (%eax,%ebp,4)
c002df70:	e8 42 0b 00 00       	call   c002eab7 <cache_read>
c002df75:	83 c4 10             	add    $0x10,%esp
c002df78:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
              free_map_release (l2[j], 1);
c002df7c:	83 ec 08             	sub    $0x8,%esp
c002df7f:	6a 01                	push   $0x1
c002df81:	ff 34 9e             	pushl  (%esi,%ebx,4)
c002df84:	e8 11 eb ff ff       	call   c002ca9a <free_map_release>
            for (j = l; j <= r; j++) {
c002df89:	43                   	inc    %ebx
c002df8a:	83 c4 10             	add    $0x10,%esp
c002df8d:	39 fb                	cmp    %edi,%ebx
c002df8f:	7e eb                	jle    c002df7c <inode_close+0xe6>
            free_map_release(l1[i], 1);
c002df91:	83 ec 08             	sub    $0x8,%esp
c002df94:	6a 01                	push   $0x1
c002df96:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002df9a:	8b 54 24 24          	mov    0x24(%esp),%edx
c002df9e:	ff 34 90             	pushl  (%eax,%edx,4)
c002dfa1:	e8 f4 ea ff ff       	call   c002ca9a <free_map_release>
          for (i = 0; i <= l1_ed; i++) {
c002dfa6:	45                   	inc    %ebp
c002dfa7:	83 c4 10             	add    $0x10,%esp
c002dfaa:	39 6c 24 14          	cmp    %ebp,0x14(%esp)
c002dfae:	7d a6                	jge    c002df56 <inode_close+0xc0>
c002dfb0:	8b 6c 24 40          	mov    0x40(%esp),%ebp
          free(l1);
c002dfb4:	83 ec 0c             	sub    $0xc,%esp
c002dfb7:	ff 74 24 1c          	pushl  0x1c(%esp)
c002dfbb:	e8 07 5c ff ff       	call   c0023bc7 <free>
          free(l2);
c002dfc0:	89 34 24             	mov    %esi,(%esp)
c002dfc3:	e8 ff 5b ff ff       	call   c0023bc7 <free>
c002dfc8:	83 c4 10             	add    $0x10,%esp
c002dfcb:	e9 05 ff ff ff       	jmp    c002ded5 <inode_close+0x3f>
            r = (i == l1_ed ? l2_ed : TABLE_SIZE - 1);
c002dfd0:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
c002dfd4:	eb 8b                	jmp    c002df61 <inode_close+0xcb>

c002dfd6 <inode_remove>:

/* Marks INODE to be deleted when it is closed by the last caller who
   has it open. */
void
inode_remove (struct inode *inode) 
{
c002dfd6:	83 ec 0c             	sub    $0xc,%esp
c002dfd9:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (inode != NULL);
c002dfdd:	85 c0                	test   %eax,%eax
c002dfdf:	74 08                	je     c002dfe9 <inode_remove+0x13>
  inode->removed = true;
c002dfe1:	c6 40 10 01          	movb   $0x1,0x10(%eax)
}
c002dfe5:	83 c4 0c             	add    $0xc,%esp
c002dfe8:	c3                   	ret    
  ASSERT (inode != NULL);
c002dfe9:	83 ec 0c             	sub    $0xc,%esp
c002dfec:	68 70 31 03 c0       	push   $0xc0033170
c002dff1:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002dff6:	68 90 0b 03 c0       	push   $0xc0030b90
c002dffb:	68 3a 01 00 00       	push   $0x13a
c002e000:	68 8b 31 03 c0       	push   $0xc003318b
c002e005:	e8 73 a6 ff ff       	call   c002867d <debug_panic>

c002e00a <inode_read_at>:
/* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
   Returns the number of bytes actually read, which may be less
   than SIZE if an error occurs or end of file is reached. */
off_t
inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset) 
{
c002e00a:	55                   	push   %ebp
c002e00b:	57                   	push   %edi
c002e00c:	56                   	push   %esi
c002e00d:	53                   	push   %ebx
c002e00e:	83 ec 1c             	sub    $0x1c,%esp
c002e011:	8b 6c 24 38          	mov    0x38(%esp),%ebp
  uint8_t *buffer = buffer_;
  off_t bytes_read = 0;
  uint8_t *bounce = NULL;

  while (size > 0) 
c002e015:	85 ed                	test   %ebp,%ebp
c002e017:	0f 8e 07 01 00 00    	jle    c002e124 <inode_read_at+0x11a>
c002e01d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002e024:	00 
c002e025:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002e02c:	00 
c002e02d:	eb 49                	jmp    c002e078 <inode_read_at+0x6e>
    {
      /* Disk sector to read, starting byte offset within sector. */
      block_sector_t sector_idx = byte_to_sector (inode, offset, false);
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e02f:	4e                   	dec    %esi
c002e030:	81 ce 00 fe ff ff    	or     $0xfffffe00,%esi
c002e036:	46                   	inc    %esi
c002e037:	eb 5f                	jmp    c002e098 <inode_read_at+0x8e>
        }
      else 
        {
          /* Read sector into bounce buffer, then partially copy
             into caller's buffer. */
          if (bounce == NULL) 
c002e039:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c002e03e:	0f 84 ac 00 00 00    	je     c002e0f0 <inode_read_at+0xe6>
            {
              bounce = malloc (BLOCK_SECTOR_SIZE);
              if (bounce == NULL)
                break;
            }
          cache_read (sector_idx, bounce);
c002e044:	83 ec 08             	sub    $0x8,%esp
c002e047:	ff 74 24 0c          	pushl  0xc(%esp)
c002e04b:	57                   	push   %edi
c002e04c:	e8 66 0a 00 00       	call   c002eab7 <cache_read>
          memcpy (buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002e051:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e055:	03 44 24 44          	add    0x44(%esp),%eax
c002e059:	03 74 24 14          	add    0x14(%esp),%esi
c002e05d:	89 c7                	mov    %eax,%edi
c002e05f:	89 d9                	mov    %ebx,%ecx
c002e061:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
c002e063:	83 c4 10             	add    $0x10,%esp
        }
      
      /* Advance. */
      size -= chunk_size;
c002e066:	29 dd                	sub    %ebx,%ebp
      offset += chunk_size;
c002e068:	01 5c 24 3c          	add    %ebx,0x3c(%esp)
      bytes_read += chunk_size;
c002e06c:	01 5c 24 08          	add    %ebx,0x8(%esp)
  while (size > 0) 
c002e070:	85 ed                	test   %ebp,%ebp
c002e072:	0f 8e 94 00 00 00    	jle    c002e10c <inode_read_at+0x102>
      block_sector_t sector_idx = byte_to_sector (inode, offset, false);
c002e078:	b9 00 00 00 00       	mov    $0x0,%ecx
c002e07d:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c002e081:	8b 44 24 30          	mov    0x30(%esp),%eax
c002e085:	e8 6c f8 ff ff       	call   c002d8f6 <byte_to_sector>
c002e08a:	89 c7                	mov    %eax,%edi
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e08c:	8b 74 24 3c          	mov    0x3c(%esp),%esi
c002e090:	81 e6 ff 01 00 80    	and    $0x800001ff,%esi
c002e096:	78 97                	js     c002e02f <inode_read_at+0x25>
      off_t inode_left = inode_length (inode) - offset;
c002e098:	8b 44 24 30          	mov    0x30(%esp),%eax
c002e09c:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e09f:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002e0a3:	2b 44 24 3c          	sub    0x3c(%esp),%eax
      int chunk_size = size < min_left ? size : min_left;
c002e0a7:	89 c2                	mov    %eax,%edx
c002e0a9:	39 e8                	cmp    %ebp,%eax
c002e0ab:	7e 02                	jle    c002e0af <inode_read_at+0xa5>
c002e0ad:	89 ea                	mov    %ebp,%edx
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002e0af:	b8 00 02 00 00       	mov    $0x200,%eax
c002e0b4:	29 f0                	sub    %esi,%eax
      int chunk_size = size < min_left ? size : min_left;
c002e0b6:	89 d3                	mov    %edx,%ebx
c002e0b8:	39 c2                	cmp    %eax,%edx
c002e0ba:	7e 02                	jle    c002e0be <inode_read_at+0xb4>
c002e0bc:	89 c3                	mov    %eax,%ebx
      if (chunk_size <= 0)
c002e0be:	85 db                	test   %ebx,%ebx
c002e0c0:	7e 4a                	jle    c002e10c <inode_read_at+0x102>
      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002e0c2:	85 f6                	test   %esi,%esi
c002e0c4:	0f 85 6f ff ff ff    	jne    c002e039 <inode_read_at+0x2f>
c002e0ca:	81 fb 00 02 00 00    	cmp    $0x200,%ebx
c002e0d0:	0f 85 63 ff ff ff    	jne    c002e039 <inode_read_at+0x2f>
          cache_read (sector_idx, buffer + bytes_read);
c002e0d6:	83 ec 08             	sub    $0x8,%esp
c002e0d9:	8b 44 24 10          	mov    0x10(%esp),%eax
c002e0dd:	03 44 24 3c          	add    0x3c(%esp),%eax
c002e0e1:	50                   	push   %eax
c002e0e2:	57                   	push   %edi
c002e0e3:	e8 cf 09 00 00       	call   c002eab7 <cache_read>
c002e0e8:	83 c4 10             	add    $0x10,%esp
c002e0eb:	e9 76 ff ff ff       	jmp    c002e066 <inode_read_at+0x5c>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002e0f0:	83 ec 0c             	sub    $0xc,%esp
c002e0f3:	68 00 02 00 00       	push   $0x200
c002e0f8:	e8 27 59 ff ff       	call   c0023a24 <malloc>
c002e0fd:	89 44 24 14          	mov    %eax,0x14(%esp)
              if (bounce == NULL)
c002e101:	83 c4 10             	add    $0x10,%esp
c002e104:	85 c0                	test   %eax,%eax
c002e106:	0f 85 38 ff ff ff    	jne    c002e044 <inode_read_at+0x3a>
    }
  free (bounce);
c002e10c:	83 ec 0c             	sub    $0xc,%esp
c002e10f:	ff 74 24 10          	pushl  0x10(%esp)
c002e113:	e8 af 5a ff ff       	call   c0023bc7 <free>

  return bytes_read;
}
c002e118:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e11c:	83 c4 2c             	add    $0x2c,%esp
c002e11f:	5b                   	pop    %ebx
c002e120:	5e                   	pop    %esi
c002e121:	5f                   	pop    %edi
c002e122:	5d                   	pop    %ebp
c002e123:	c3                   	ret    
  off_t bytes_read = 0;
c002e124:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002e12b:	00 
  uint8_t *bounce = NULL;
c002e12c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002e133:	00 
c002e134:	eb d6                	jmp    c002e10c <inode_read_at+0x102>

c002e136 <inode_write_at>:
   (Normally a write at end of file would extend the inode, but
   growth is not yet implemented.) */
off_t
inode_write_at (struct inode *inode, const void *buffer_, off_t size,
                off_t offset) 
{
c002e136:	55                   	push   %ebp
c002e137:	57                   	push   %edi
c002e138:	56                   	push   %esi
c002e139:	53                   	push   %ebx
c002e13a:	83 ec 1c             	sub    $0x1c,%esp
  const uint8_t *buffer = buffer_;
  off_t bytes_written = 0;
  uint8_t *bounce = NULL;

  if (inode->deny_write_cnt)
c002e13d:	8b 44 24 30          	mov    0x30(%esp),%eax
c002e141:	8b 40 14             	mov    0x14(%eax),%eax
c002e144:	89 44 24 08          	mov    %eax,0x8(%esp)
c002e148:	85 c0                	test   %eax,%eax
c002e14a:	0f 85 57 01 00 00    	jne    c002e2a7 <inode_write_at+0x171>
    return 0;

  while (size > 0) 
c002e150:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002e155:	0f 8e 45 01 00 00    	jle    c002e2a0 <inode_write_at+0x16a>
c002e15b:	bd 00 00 00 00       	mov    $0x0,%ebp
c002e160:	eb 7f                	jmp    c002e1e1 <inode_write_at+0xab>
    {
      /* Sector to write, starting byte offset within sector. */
      block_sector_t sector_idx = byte_to_sector (inode, offset, true);
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e162:	48                   	dec    %eax
c002e163:	0d 00 fe ff ff       	or     $0xfffffe00,%eax
c002e168:	40                   	inc    %eax
c002e169:	e9 98 00 00 00       	jmp    c002e206 <inode_write_at+0xd0>
        break;

      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
        {
          /* Write full sector directly to disk. */
          cache_write (sector_idx, buffer + bytes_written);
c002e16e:	83 ec 08             	sub    $0x8,%esp
c002e171:	8b 44 24 10          	mov    0x10(%esp),%eax
c002e175:	03 44 24 3c          	add    0x3c(%esp),%eax
c002e179:	50                   	push   %eax
c002e17a:	ff 74 24 10          	pushl  0x10(%esp)
c002e17e:	e8 e2 09 00 00       	call   c002eb65 <cache_write>
c002e183:	83 c4 10             	add    $0x10,%esp
c002e186:	eb 42                	jmp    c002e1ca <inode_write_at+0x94>
        }
      else 
        {
          /* We need a bounce buffer. */
          if (bounce == NULL) 
c002e188:	85 ed                	test   %ebp,%ebp
c002e18a:	0f 84 d9 00 00 00    	je     c002e269 <inode_write_at+0x133>
            }

          /* If the sector contains data before or after the chunk
             we're writing, then we need to read in the sector
             first.  Otherwise we start with a sector of all zeros. */
          if (sector_ofs > 0 || chunk_size < sector_left) 
c002e190:	85 f6                	test   %esi,%esi
c002e192:	0f 8e b6 00 00 00    	jle    c002e24e <inode_write_at+0x118>
            cache_read (sector_idx, bounce);
c002e198:	83 ec 08             	sub    $0x8,%esp
c002e19b:	55                   	push   %ebp
c002e19c:	ff 74 24 10          	pushl  0x10(%esp)
c002e1a0:	e8 12 09 00 00       	call   c002eab7 <cache_read>
c002e1a5:	83 c4 10             	add    $0x10,%esp
          else
            memset (bounce, 0, BLOCK_SECTOR_SIZE);
          memcpy (bounce + sector_ofs, buffer + bytes_written, chunk_size);
c002e1a8:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
c002e1ac:	8b 74 24 08          	mov    0x8(%esp),%esi
c002e1b0:	03 74 24 34          	add    0x34(%esp),%esi
c002e1b4:	89 c7                	mov    %eax,%edi
c002e1b6:	89 d9                	mov    %ebx,%ecx
c002e1b8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
          cache_write ( sector_idx, bounce);
c002e1ba:	83 ec 08             	sub    $0x8,%esp
c002e1bd:	55                   	push   %ebp
c002e1be:	ff 74 24 10          	pushl  0x10(%esp)
c002e1c2:	e8 9e 09 00 00       	call   c002eb65 <cache_write>
c002e1c7:	83 c4 10             	add    $0x10,%esp
        }

      /* Advance. */
      size -= chunk_size;
c002e1ca:	29 5c 24 38          	sub    %ebx,0x38(%esp)
      offset += chunk_size;
c002e1ce:	01 5c 24 3c          	add    %ebx,0x3c(%esp)
      bytes_written += chunk_size;
c002e1d2:	01 5c 24 08          	add    %ebx,0x8(%esp)
  while (size > 0) 
c002e1d6:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002e1db:	0f 8e a7 00 00 00    	jle    c002e288 <inode_write_at+0x152>
      block_sector_t sector_idx = byte_to_sector (inode, offset, true);
c002e1e1:	b9 01 00 00 00       	mov    $0x1,%ecx
c002e1e6:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c002e1ea:	8b 44 24 30          	mov    0x30(%esp),%eax
c002e1ee:	e8 03 f7 ff ff       	call   c002d8f6 <byte_to_sector>
c002e1f3:	89 44 24 04          	mov    %eax,0x4(%esp)
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e1f7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002e1fb:	25 ff 01 00 80       	and    $0x800001ff,%eax
c002e200:	0f 88 5c ff ff ff    	js     c002e162 <inode_write_at+0x2c>
c002e206:	89 c6                	mov    %eax,%esi
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002e208:	bf 00 02 00 00       	mov    $0x200,%edi
c002e20d:	29 c7                	sub    %eax,%edi
      off_t inode_left = inode_length (inode) - offset;
c002e20f:	8b 44 24 30          	mov    0x30(%esp),%eax
c002e213:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e216:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002e21a:	2b 44 24 3c          	sub    0x3c(%esp),%eax
      int chunk_size = size < min_left ? size : min_left;
c002e21e:	89 c2                	mov    %eax,%edx
c002e220:	3b 44 24 38          	cmp    0x38(%esp),%eax
c002e224:	7e 04                	jle    c002e22a <inode_write_at+0xf4>
c002e226:	8b 54 24 38          	mov    0x38(%esp),%edx
c002e22a:	89 d3                	mov    %edx,%ebx
c002e22c:	39 fa                	cmp    %edi,%edx
c002e22e:	7e 02                	jle    c002e232 <inode_write_at+0xfc>
c002e230:	89 fb                	mov    %edi,%ebx
      if (chunk_size <= 0)
c002e232:	85 db                	test   %ebx,%ebx
c002e234:	7e 52                	jle    c002e288 <inode_write_at+0x152>
      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002e236:	85 f6                	test   %esi,%esi
c002e238:	0f 85 4a ff ff ff    	jne    c002e188 <inode_write_at+0x52>
c002e23e:	81 fb 00 02 00 00    	cmp    $0x200,%ebx
c002e244:	0f 84 24 ff ff ff    	je     c002e16e <inode_write_at+0x38>
          if (bounce == NULL) 
c002e24a:	85 ed                	test   %ebp,%ebp
c002e24c:	74 63                	je     c002e2b1 <inode_write_at+0x17b>
          if (sector_ofs > 0 || chunk_size < sector_left) 
c002e24e:	39 df                	cmp    %ebx,%edi
c002e250:	0f 8f 42 ff ff ff    	jg     c002e198 <inode_write_at+0x62>
            memset (bounce, 0, BLOCK_SECTOR_SIZE);
c002e256:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e25b:	89 ef                	mov    %ebp,%edi
c002e25d:	b8 00 00 00 00       	mov    $0x0,%eax
c002e262:	f3 ab                	rep stos %eax,%es:(%edi)
c002e264:	e9 3f ff ff ff       	jmp    c002e1a8 <inode_write_at+0x72>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002e269:	83 ec 0c             	sub    $0xc,%esp
c002e26c:	68 00 02 00 00       	push   $0x200
c002e271:	e8 ae 57 ff ff       	call   c0023a24 <malloc>
c002e276:	89 c5                	mov    %eax,%ebp
              if (bounce == NULL)
c002e278:	83 c4 10             	add    $0x10,%esp
c002e27b:	85 c0                	test   %eax,%eax
c002e27d:	0f 85 0d ff ff ff    	jne    c002e190 <inode_write_at+0x5a>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002e283:	bd 00 00 00 00       	mov    $0x0,%ebp
    }
  free (bounce);
c002e288:	83 ec 0c             	sub    $0xc,%esp
c002e28b:	55                   	push   %ebp
c002e28c:	e8 36 59 ff ff       	call   c0023bc7 <free>

  return bytes_written;
c002e291:	83 c4 10             	add    $0x10,%esp
}
c002e294:	8b 44 24 08          	mov    0x8(%esp),%eax
c002e298:	83 c4 1c             	add    $0x1c,%esp
c002e29b:	5b                   	pop    %ebx
c002e29c:	5e                   	pop    %esi
c002e29d:	5f                   	pop    %edi
c002e29e:	5d                   	pop    %ebp
c002e29f:	c3                   	ret    
  while (size > 0) 
c002e2a0:	bd 00 00 00 00       	mov    $0x0,%ebp
c002e2a5:	eb e1                	jmp    c002e288 <inode_write_at+0x152>
    return 0;
c002e2a7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002e2ae:	00 
c002e2af:	eb e3                	jmp    c002e294 <inode_write_at+0x15e>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002e2b1:	83 ec 0c             	sub    $0xc,%esp
c002e2b4:	68 00 02 00 00       	push   $0x200
c002e2b9:	e8 66 57 ff ff       	call   c0023a24 <malloc>
c002e2be:	89 c5                	mov    %eax,%ebp
              if (bounce == NULL)
c002e2c0:	83 c4 10             	add    $0x10,%esp
c002e2c3:	85 c0                	test   %eax,%eax
c002e2c5:	75 87                	jne    c002e24e <inode_write_at+0x118>
c002e2c7:	eb ba                	jmp    c002e283 <inode_write_at+0x14d>

c002e2c9 <inode_deny_write>:

/* Disables writes to INODE.
   May be called at most once per inode opener. */
void
inode_deny_write (struct inode *inode) 
{
c002e2c9:	83 ec 0c             	sub    $0xc,%esp
c002e2cc:	8b 54 24 10          	mov    0x10(%esp),%edx
  inode->deny_write_cnt++;
c002e2d0:	8b 42 14             	mov    0x14(%edx),%eax
c002e2d3:	40                   	inc    %eax
c002e2d4:	89 42 14             	mov    %eax,0x14(%edx)
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e2d7:	3b 42 0c             	cmp    0xc(%edx),%eax
c002e2da:	7f 04                	jg     c002e2e0 <inode_deny_write+0x17>
}
c002e2dc:	83 c4 0c             	add    $0xc,%esp
c002e2df:	c3                   	ret    
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e2e0:	83 ec 0c             	sub    $0xc,%esp
c002e2e3:	68 c8 31 03 c0       	push   $0xc00331c8
c002e2e8:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002e2ed:	68 6c 0b 03 c0       	push   $0xc0030b6c
c002e2f2:	68 bf 01 00 00       	push   $0x1bf
c002e2f7:	68 8b 31 03 c0       	push   $0xc003318b
c002e2fc:	e8 7c a3 ff ff       	call   c002867d <debug_panic>

c002e301 <inode_allow_write>:
/* Re-enables writes to INODE.
   Must be called once by each inode opener who has called
   inode_deny_write() on the inode, before closing the inode. */
void
inode_allow_write (struct inode *inode) 
{
c002e301:	83 ec 0c             	sub    $0xc,%esp
c002e304:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (inode->deny_write_cnt > 0);
c002e308:	8b 42 14             	mov    0x14(%edx),%eax
c002e30b:	85 c0                	test   %eax,%eax
c002e30d:	7e 0d                	jle    c002e31c <inode_allow_write+0x1b>
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e30f:	3b 42 0c             	cmp    0xc(%edx),%eax
c002e312:	7f 29                	jg     c002e33d <inode_allow_write+0x3c>
  inode->deny_write_cnt--;
c002e314:	48                   	dec    %eax
c002e315:	89 42 14             	mov    %eax,0x14(%edx)
}
c002e318:	83 c4 0c             	add    $0xc,%esp
c002e31b:	c3                   	ret    
  ASSERT (inode->deny_write_cnt > 0);
c002e31c:	83 ec 0c             	sub    $0xc,%esp
c002e31f:	68 ad 31 03 c0       	push   $0xc00331ad
c002e324:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002e329:	68 58 0b 03 c0       	push   $0xc0030b58
c002e32e:	68 c8 01 00 00       	push   $0x1c8
c002e333:	68 8b 31 03 c0       	push   $0xc003318b
c002e338:	e8 40 a3 ff ff       	call   c002867d <debug_panic>
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e33d:	83 ec 0c             	sub    $0xc,%esp
c002e340:	68 c8 31 03 c0       	push   $0xc00331c8
c002e345:	68 b3 0c 03 c0       	push   $0xc0030cb3
c002e34a:	68 58 0b 03 c0       	push   $0xc0030b58
c002e34f:	68 c9 01 00 00       	push   $0x1c9
c002e354:	68 8b 31 03 c0       	push   $0xc003318b
c002e359:	e8 1f a3 ff ff       	call   c002867d <debug_panic>

c002e35e <inode_length>:

/* Returns the length, in bytes, of INODE's data. */
off_t
inode_length (const struct inode *inode)
{
  return inode->data.length;
c002e35e:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e362:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002e365:	c3                   	ret    

c002e366 <inode_is_dir>:

bool 
inode_is_dir (const struct inode *inode) {
  return inode->data.is_dir;
c002e366:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e36a:	8a 40 20             	mov    0x20(%eax),%al
}
c002e36d:	c3                   	ret    

c002e36e <inode_set_dir>:

void
inode_set_dir (struct inode* inode) {
c002e36e:	83 ec 14             	sub    $0x14,%esp
c002e371:	8b 44 24 18          	mov    0x18(%esp),%eax
  inode->data.is_dir = true;
c002e375:	c6 40 20 01          	movb   $0x1,0x20(%eax)
  cache_write (inode->sector, &inode->data);
c002e379:	8d 50 18             	lea    0x18(%eax),%edx
c002e37c:	52                   	push   %edx
c002e37d:	ff 70 08             	pushl  0x8(%eax)
c002e380:	e8 e0 07 00 00       	call   c002eb65 <cache_write>
}
c002e385:	83 c4 1c             	add    $0x1c,%esp
c002e388:	c3                   	ret    

c002e389 <inode_get_open_cnt>:

int
inode_get_open_cnt (struct inode* inode) {
  return inode->open_cnt;
c002e389:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e38d:	8b 40 0c             	mov    0xc(%eax),%eax
c002e390:	c3                   	ret    

c002e391 <fsutil_ls>:
#include "threads/vaddr.h"

/* List files in the root directory. */
void
fsutil_ls (char **argv UNUSED) 
{
c002e391:	56                   	push   %esi
c002e392:	53                   	push   %ebx
c002e393:	83 ec 20             	sub    $0x20,%esp
  struct dir *dir;
  char name[NAME_MAX + 1];
  
  printf ("Files in the root directory:\n");
c002e396:	68 f1 31 03 c0       	push   $0xc00331f1
c002e39b:	e8 c4 bd ff ff       	call   c002a164 <puts>
  dir = dir_open_root ();
c002e3a0:	e8 35 ec ff ff       	call   c002cfda <dir_open_root>
  if (dir == NULL)
c002e3a5:	83 c4 10             	add    $0x10,%esp
c002e3a8:	85 c0                	test   %eax,%eax
c002e3aa:	74 08                	je     c002e3b4 <fsutil_ls+0x23>
c002e3ac:	89 c6                	mov    %eax,%esi
    PANIC ("root dir open failed");
  while (dir_readdir (dir, name))
c002e3ae:	8d 5c 24 01          	lea    0x1(%esp),%ebx
c002e3b2:	eb 22                	jmp    c002e3d6 <fsutil_ls+0x45>
    PANIC ("root dir open failed");
c002e3b4:	68 0e 32 03 c0       	push   $0xc003320e
c002e3b9:	68 e8 0b 03 c0       	push   $0xc0030be8
c002e3be:	6a 18                	push   $0x18
c002e3c0:	68 23 32 03 c0       	push   $0xc0033223
c002e3c5:	e8 b3 a2 ff ff       	call   c002867d <debug_panic>
    printf ("%s\n", name);
c002e3ca:	83 ec 0c             	sub    $0xc,%esp
c002e3cd:	53                   	push   %ebx
c002e3ce:	e8 91 bd ff ff       	call   c002a164 <puts>
c002e3d3:	83 c4 10             	add    $0x10,%esp
  while (dir_readdir (dir, name))
c002e3d6:	83 ec 08             	sub    $0x8,%esp
c002e3d9:	53                   	push   %ebx
c002e3da:	56                   	push   %esi
c002e3db:	e8 fb ef ff ff       	call   c002d3db <dir_readdir>
c002e3e0:	83 c4 10             	add    $0x10,%esp
c002e3e3:	84 c0                	test   %al,%al
c002e3e5:	75 e3                	jne    c002e3ca <fsutil_ls+0x39>
  dir_close (dir);
c002e3e7:	83 ec 0c             	sub    $0xc,%esp
c002e3ea:	56                   	push   %esi
c002e3eb:	e8 1a ec ff ff       	call   c002d00a <dir_close>
  printf ("End of listing.\n");
c002e3f0:	c7 04 24 3a 32 03 c0 	movl   $0xc003323a,(%esp)
c002e3f7:	e8 68 bd ff ff       	call   c002a164 <puts>
}
c002e3fc:	83 c4 24             	add    $0x24,%esp
c002e3ff:	5b                   	pop    %ebx
c002e400:	5e                   	pop    %esi
c002e401:	c3                   	ret    

c002e402 <fsutil_cat>:

/* Prints the contents of file ARGV[1] to the system console as
   hex and ASCII. */
void
fsutil_cat (char **argv)
{
c002e402:	57                   	push   %edi
c002e403:	56                   	push   %esi
c002e404:	53                   	push   %ebx
  const char *file_name = argv[1];
c002e405:	8b 44 24 10          	mov    0x10(%esp),%eax
c002e409:	8b 70 04             	mov    0x4(%eax),%esi
  
  struct file *file;
  char *buffer;

  printf ("Printing '%s' to the console...\n", file_name);
c002e40c:	83 ec 08             	sub    $0x8,%esp
c002e40f:	56                   	push   %esi
c002e410:	68 14 33 03 c0       	push   $0xc0033314
c002e415:	e8 b5 87 ff ff       	call   c0026bcf <printf>
  file = filesys_open (file_name);
c002e41a:	89 34 24             	mov    %esi,(%esp)
c002e41d:	e8 98 e3 ff ff       	call   c002c7ba <filesys_open>
  if (file == NULL)
c002e422:	83 c4 10             	add    $0x10,%esp
c002e425:	85 c0                	test   %eax,%eax
c002e427:	74 41                	je     c002e46a <fsutil_cat+0x68>
c002e429:	89 c3                	mov    %eax,%ebx
    PANIC ("%s: open failed", file_name);
  buffer = palloc_get_page (PAL_ASSERT);
c002e42b:	83 ec 0c             	sub    $0xc,%esp
c002e42e:	6a 01                	push   $0x1
c002e430:	e8 79 52 ff ff       	call   c00236ae <palloc_get_page>
c002e435:	89 c6                	mov    %eax,%esi
c002e437:	83 c4 10             	add    $0x10,%esp
  for (;;) 
    {
      off_t pos = file_tell (file);
c002e43a:	83 ec 0c             	sub    $0xc,%esp
c002e43d:	53                   	push   %ebx
c002e43e:	e8 37 ea ff ff       	call   c002ce7a <file_tell>
c002e443:	89 c7                	mov    %eax,%edi
      off_t n = file_read (file, buffer, PGSIZE);
c002e445:	83 c4 0c             	add    $0xc,%esp
c002e448:	68 00 10 00 00       	push   $0x1000
c002e44d:	56                   	push   %esi
c002e44e:	53                   	push   %ebx
c002e44f:	e8 44 e8 ff ff       	call   c002cc98 <file_read>
      if (n == 0)
c002e454:	83 c4 10             	add    $0x10,%esp
c002e457:	85 c0                	test   %eax,%eax
c002e459:	74 29                	je     c002e484 <fsutil_cat+0x82>
        break;

      hex_dump (pos, buffer, n, true); 
c002e45b:	6a 01                	push   $0x1
c002e45d:	50                   	push   %eax
c002e45e:	56                   	push   %esi
c002e45f:	57                   	push   %edi
c002e460:	e8 13 8f ff ff       	call   c0027378 <hex_dump>
    {
c002e465:	83 c4 10             	add    $0x10,%esp
c002e468:	eb d0                	jmp    c002e43a <fsutil_cat+0x38>
    PANIC ("%s: open failed", file_name);
c002e46a:	83 ec 0c             	sub    $0xc,%esp
c002e46d:	56                   	push   %esi
c002e46e:	68 4a 32 03 c0       	push   $0xc003324a
c002e473:	68 dc 0b 03 c0       	push   $0xc0030bdc
c002e478:	6a 2c                	push   $0x2c
c002e47a:	68 23 32 03 c0       	push   $0xc0033223
c002e47f:	e8 f9 a1 ff ff       	call   c002867d <debug_panic>
    }
  palloc_free_page (buffer);
c002e484:	83 ec 0c             	sub    $0xc,%esp
c002e487:	56                   	push   %esi
c002e488:	e8 4b 53 ff ff       	call   c00237d8 <palloc_free_page>
  file_close (file);
c002e48d:	89 1c 24             	mov    %ebx,(%esp)
c002e490:	e8 15 e9 ff ff       	call   c002cdaa <file_close>
}
c002e495:	83 c4 10             	add    $0x10,%esp
c002e498:	5b                   	pop    %ebx
c002e499:	5e                   	pop    %esi
c002e49a:	5f                   	pop    %edi
c002e49b:	c3                   	ret    

c002e49c <fsutil_rm>:

/* Deletes file ARGV[1]. */
void
fsutil_rm (char **argv) 
{
c002e49c:	53                   	push   %ebx
c002e49d:	83 ec 10             	sub    $0x10,%esp
  const char *file_name = argv[1];
c002e4a0:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e4a4:	8b 58 04             	mov    0x4(%eax),%ebx
  
  printf ("Deleting '%s'...\n", file_name);
c002e4a7:	53                   	push   %ebx
c002e4a8:	68 5a 32 03 c0       	push   $0xc003325a
c002e4ad:	e8 1d 87 ff ff       	call   c0026bcf <printf>
  if (!filesys_remove (file_name))
c002e4b2:	89 1c 24             	mov    %ebx,(%esp)
c002e4b5:	e8 52 e4 ff ff       	call   c002c90c <filesys_remove>
c002e4ba:	83 c4 10             	add    $0x10,%esp
c002e4bd:	84 c0                	test   %al,%al
c002e4bf:	74 05                	je     c002e4c6 <fsutil_rm+0x2a>
    PANIC ("%s: delete failed\n", file_name);
}
c002e4c1:	83 c4 08             	add    $0x8,%esp
c002e4c4:	5b                   	pop    %ebx
c002e4c5:	c3                   	ret    
    PANIC ("%s: delete failed\n", file_name);
c002e4c6:	83 ec 0c             	sub    $0xc,%esp
c002e4c9:	53                   	push   %ebx
c002e4ca:	68 6c 32 03 c0       	push   $0xc003326c
c002e4cf:	68 d0 0b 03 c0       	push   $0xc0030bd0
c002e4d4:	6a 43                	push   $0x43
c002e4d6:	68 23 32 03 c0       	push   $0xc0033223
c002e4db:	e8 9d a1 ff ff       	call   c002867d <debug_panic>

c002e4e0 <fsutil_extract>:

/* Extracts a ustar-format tar archive from the scratch block
   device into the Pintos file system. */
void
fsutil_extract (char **argv UNUSED) 
{
c002e4e0:	55                   	push   %ebp
c002e4e1:	57                   	push   %edi
c002e4e2:	56                   	push   %esi
c002e4e3:	53                   	push   %ebx
c002e4e4:	83 ec 38             	sub    $0x38,%esp

  struct block *src;
  void *header, *data;

  /* Allocate buffers. */
  header = malloc (BLOCK_SECTOR_SIZE);
c002e4e7:	68 00 02 00 00       	push   $0x200
c002e4ec:	e8 33 55 ff ff       	call   c0023a24 <malloc>
c002e4f1:	89 c7                	mov    %eax,%edi
c002e4f3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  data = malloc (BLOCK_SECTOR_SIZE);
c002e4f7:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002e4fe:	e8 21 55 ff ff       	call   c0023a24 <malloc>
c002e503:	89 c6                	mov    %eax,%esi
  if (header == NULL || data == NULL)
c002e505:	83 c4 10             	add    $0x10,%esp
c002e508:	85 ff                	test   %edi,%edi
c002e50a:	74 29                	je     c002e535 <fsutil_extract+0x55>
c002e50c:	85 c0                	test   %eax,%eax
c002e50e:	74 25                	je     c002e535 <fsutil_extract+0x55>
    PANIC ("couldn't allocate buffers");

  /* Open source block device. */
  src = block_get_role (BLOCK_SCRATCH);
c002e510:	83 ec 0c             	sub    $0xc,%esp
c002e513:	6a 02                	push   $0x2
c002e515:	e8 a0 66 ff ff       	call   c0024bba <block_get_role>
c002e51a:	89 c5                	mov    %eax,%ebp
  if (src == NULL)
c002e51c:	83 c4 10             	add    $0x10,%esp
c002e51f:	85 c0                	test   %eax,%eax
c002e521:	74 28                	je     c002e54b <fsutil_extract+0x6b>
    PANIC ("couldn't open scratch device");

  printf ("Extracting ustar archive from scratch device "
c002e523:	83 ec 0c             	sub    $0xc,%esp
c002e526:	68 38 33 03 c0       	push   $0xc0033338
c002e52b:	e8 34 bc ff ff       	call   c002a164 <puts>
c002e530:	83 c4 10             	add    $0x10,%esp
c002e533:	eb 61                	jmp    c002e596 <fsutil_extract+0xb6>
    PANIC ("couldn't allocate buffers");
c002e535:	68 7f 32 03 c0       	push   $0xc003327f
c002e53a:	68 c0 0b 03 c0       	push   $0xc0030bc0
c002e53f:	6a 54                	push   $0x54
c002e541:	68 23 32 03 c0       	push   $0xc0033223
c002e546:	e8 32 a1 ff ff       	call   c002867d <debug_panic>
    PANIC ("couldn't open scratch device");
c002e54b:	68 99 32 03 c0       	push   $0xc0033299
c002e550:	68 c0 0b 03 c0       	push   $0xc0030bc0
c002e555:	6a 59                	push   $0x59
c002e557:	68 23 32 03 c0       	push   $0xc0033223
c002e55c:	e8 1c a1 ff ff       	call   c002867d <debug_panic>

      /* Read and parse ustar header. */
      block_read (src, sector++, header);
      error = ustar_parse_header (header, &file_name, &type, &size);
      if (error != NULL)
        PANIC ("bad ustar header in sector %"PRDSNu" (%s)", sector - 1, error);
c002e561:	83 ec 08             	sub    $0x8,%esp
c002e564:	50                   	push   %eax
c002e565:	a1 24 e9 03 c0       	mov    0xc003e924,%eax
c002e56a:	48                   	dec    %eax
c002e56b:	50                   	push   %eax
c002e56c:	68 7c 33 03 c0       	push   $0xc003337c
c002e571:	68 c0 0b 03 c0       	push   $0xc0030bc0
c002e576:	6a 69                	push   $0x69
c002e578:	68 23 32 03 c0       	push   $0xc0033223
c002e57d:	e8 fb a0 ff ff       	call   c002867d <debug_panic>
        {
          /* End of archive. */
          break;
        }
      else if (type == USTAR_DIRECTORY)
        printf ("ignoring directory %s\n", file_name);
c002e582:	83 ec 08             	sub    $0x8,%esp
c002e585:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e589:	68 b6 32 03 c0       	push   $0xc00332b6
c002e58e:	e8 3c 86 ff ff       	call   c0026bcf <printf>
c002e593:	83 c4 10             	add    $0x10,%esp
      block_read (src, sector++, header);
c002e596:	a1 24 e9 03 c0       	mov    0xc003e924,%eax
c002e59b:	8d 50 01             	lea    0x1(%eax),%edx
c002e59e:	89 15 24 e9 03 c0    	mov    %edx,0xc003e924
c002e5a4:	83 ec 04             	sub    $0x4,%esp
c002e5a7:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002e5ab:	57                   	push   %edi
c002e5ac:	50                   	push   %eax
c002e5ad:	55                   	push   %ebp
c002e5ae:	e8 35 67 ff ff       	call   c0024ce8 <block_read>
      error = ustar_parse_header (header, &file_name, &type, &size);
c002e5b3:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002e5b7:	50                   	push   %eax
c002e5b8:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002e5bc:	50                   	push   %eax
c002e5bd:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002e5c1:	50                   	push   %eax
c002e5c2:	57                   	push   %edi
c002e5c3:	e8 2f 9e ff ff       	call   c00283f7 <ustar_parse_header>
      if (error != NULL)
c002e5c8:	83 c4 20             	add    $0x20,%esp
c002e5cb:	85 c0                	test   %eax,%eax
c002e5cd:	75 92                	jne    c002e561 <fsutil_extract+0x81>
      if (type == USTAR_EOF)
c002e5cf:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e5d3:	83 f8 ff             	cmp    $0xffffffff,%eax
c002e5d6:	0f 84 0f 01 00 00    	je     c002e6eb <fsutil_extract+0x20b>
      else if (type == USTAR_DIRECTORY)
c002e5dc:	83 f8 35             	cmp    $0x35,%eax
c002e5df:	74 a1                	je     c002e582 <fsutil_extract+0xa2>
      else if (type == USTAR_REGULAR)
c002e5e1:	83 f8 30             	cmp    $0x30,%eax
c002e5e4:	75 b0                	jne    c002e596 <fsutil_extract+0xb6>
        {
          struct file *dst;

          printf ("Putting '%s' into the file system...\n", file_name);
c002e5e6:	83 ec 08             	sub    $0x8,%esp
c002e5e9:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e5ed:	68 a0 33 03 c0       	push   $0xc00333a0
c002e5f2:	e8 d8 85 ff ff       	call   c0026bcf <printf>

          /* Create destination file. */
          if (!filesys_create (file_name, size))
c002e5f7:	83 c4 08             	add    $0x8,%esp
c002e5fa:	ff 74 24 24          	pushl  0x24(%esp)
c002e5fe:	ff 74 24 20          	pushl  0x20(%esp)
c002e602:	e8 0b e1 ff ff       	call   c002c712 <filesys_create>
c002e607:	83 c4 10             	add    $0x10,%esp
c002e60a:	84 c0                	test   %al,%al
c002e60c:	74 32                	je     c002e640 <fsutil_extract+0x160>
            PANIC ("%s: create failed", file_name);
          dst = filesys_open (file_name);
c002e60e:	83 ec 0c             	sub    $0xc,%esp
c002e611:	ff 74 24 20          	pushl  0x20(%esp)
c002e615:	e8 a0 e1 ff ff       	call   c002c7ba <filesys_open>
c002e61a:	89 c7                	mov    %eax,%edi
          if (dst == NULL)
c002e61c:	83 c4 10             	add    $0x10,%esp
c002e61f:	85 c0                	test   %eax,%eax
c002e621:	74 3a                	je     c002e65d <fsutil_extract+0x17d>
            PANIC ("%s: open failed", file_name);
          /* Do copy. */
          while (size > 0)
c002e623:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e627:	85 c0                	test   %eax,%eax
c002e629:	0f 8f 88 00 00 00    	jg     c002e6b7 <fsutil_extract+0x1d7>
                       file_name, size);
              size -= chunk_size;
            }

          /* Finish up. */
          file_close (dst);
c002e62f:	83 ec 0c             	sub    $0xc,%esp
c002e632:	57                   	push   %edi
c002e633:	e8 72 e7 ff ff       	call   c002cdaa <file_close>
c002e638:	83 c4 10             	add    $0x10,%esp
    {
c002e63b:	e9 56 ff ff ff       	jmp    c002e596 <fsutil_extract+0xb6>
            PANIC ("%s: create failed", file_name);
c002e640:	83 ec 0c             	sub    $0xc,%esp
c002e643:	ff 74 24 20          	pushl  0x20(%esp)
c002e647:	68 cd 32 03 c0       	push   $0xc00332cd
c002e64c:	68 c0 0b 03 c0       	push   $0xc0030bc0
c002e651:	6a 7a                	push   $0x7a
c002e653:	68 23 32 03 c0       	push   $0xc0033223
c002e658:	e8 20 a0 ff ff       	call   c002867d <debug_panic>
            PANIC ("%s: open failed", file_name);
c002e65d:	83 ec 0c             	sub    $0xc,%esp
c002e660:	ff 74 24 20          	pushl  0x20(%esp)
c002e664:	68 4a 32 03 c0       	push   $0xc003324a
c002e669:	68 c0 0b 03 c0       	push   $0xc0030bc0
c002e66e:	6a 7d                	push   $0x7d
c002e670:	68 23 32 03 c0       	push   $0xc0033223
c002e675:	e8 03 a0 ff ff       	call   c002867d <debug_panic>
              block_read (src, sector++, data);
c002e67a:	a1 24 e9 03 c0       	mov    0xc003e924,%eax
c002e67f:	8d 50 01             	lea    0x1(%eax),%edx
c002e682:	89 15 24 e9 03 c0    	mov    %edx,0xc003e924
c002e688:	83 ec 04             	sub    $0x4,%esp
c002e68b:	56                   	push   %esi
c002e68c:	50                   	push   %eax
c002e68d:	55                   	push   %ebp
c002e68e:	e8 55 66 ff ff       	call   c0024ce8 <block_read>
              if (file_write (dst, data, chunk_size) != chunk_size)
c002e693:	83 c4 0c             	add    $0xc,%esp
c002e696:	53                   	push   %ebx
c002e697:	56                   	push   %esi
c002e698:	57                   	push   %edi
c002e699:	e8 3a e6 ff ff       	call   c002ccd8 <file_write>
c002e69e:	83 c4 10             	add    $0x10,%esp
c002e6a1:	39 c3                	cmp    %eax,%ebx
c002e6a3:	75 22                	jne    c002e6c7 <fsutil_extract+0x1e7>
              size -= chunk_size;
c002e6a5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e6a9:	29 d8                	sub    %ebx,%eax
c002e6ab:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          while (size > 0)
c002e6af:	85 c0                	test   %eax,%eax
c002e6b1:	0f 8e 78 ff ff ff    	jle    c002e62f <fsutil_extract+0x14f>
              int chunk_size = (size > BLOCK_SECTOR_SIZE
c002e6b7:	89 c3                	mov    %eax,%ebx
c002e6b9:	3d 00 02 00 00       	cmp    $0x200,%eax
c002e6be:	7e ba                	jle    c002e67a <fsutil_extract+0x19a>
c002e6c0:	bb 00 02 00 00       	mov    $0x200,%ebx
c002e6c5:	eb b3                	jmp    c002e67a <fsutil_extract+0x19a>
                PANIC ("%s: write failed with %d bytes unwritten",
c002e6c7:	83 ec 08             	sub    $0x8,%esp
c002e6ca:	ff 74 24 24          	pushl  0x24(%esp)
c002e6ce:	ff 74 24 20          	pushl  0x20(%esp)
c002e6d2:	68 c8 33 03 c0       	push   $0xc00333c8
c002e6d7:	68 c0 0b 03 c0       	push   $0xc0030bc0
c002e6dc:	68 87 00 00 00       	push   $0x87
c002e6e1:	68 23 32 03 c0       	push   $0xc0033223
c002e6e6:	e8 92 9f ff ff       	call   c002867d <debug_panic>

  /* Erase the ustar header from the start of the block device,
     so that the extraction operation is idempotent.  We erase
     two blocks because two blocks of zeros are the ustar
     end-of-archive marker. */
  printf ("Erasing ustar archive...\n");
c002e6eb:	83 ec 0c             	sub    $0xc,%esp
c002e6ee:	68 df 32 03 c0       	push   $0xc00332df
c002e6f3:	e8 6c ba ff ff       	call   c002a164 <puts>
  memset (header, 0, BLOCK_SECTOR_SIZE);
c002e6f8:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e6fd:	b8 00 00 00 00       	mov    $0x0,%eax
c002e702:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
c002e706:	f3 ab                	rep stos %eax,%es:(%edi)
  block_write (src, 0, header);
c002e708:	83 c4 0c             	add    $0xc,%esp
c002e70b:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002e70f:	57                   	push   %edi
c002e710:	6a 00                	push   $0x0
c002e712:	55                   	push   %ebp
c002e713:	e8 04 66 ff ff       	call   c0024d1c <block_write>
  block_write (src, 1, header);
c002e718:	83 c4 0c             	add    $0xc,%esp
c002e71b:	57                   	push   %edi
c002e71c:	6a 01                	push   $0x1
c002e71e:	55                   	push   %ebp
c002e71f:	e8 f8 65 ff ff       	call   c0024d1c <block_write>

  free (data);
c002e724:	89 34 24             	mov    %esi,(%esp)
c002e727:	e8 9b 54 ff ff       	call   c0023bc7 <free>
  free (header);
c002e72c:	89 3c 24             	mov    %edi,(%esp)
c002e72f:	e8 93 54 ff ff       	call   c0023bc7 <free>
}
c002e734:	83 c4 3c             	add    $0x3c,%esp
c002e737:	5b                   	pop    %ebx
c002e738:	5e                   	pop    %esi
c002e739:	5f                   	pop    %edi
c002e73a:	5d                   	pop    %ebp
c002e73b:	c3                   	ret    

c002e73c <fsutil_append>:
   the device.  This position is independent of that used for
   fsutil_extract(), so `extract' should precede all
   `append's. */
void
fsutil_append (char **argv)
{
c002e73c:	55                   	push   %ebp
c002e73d:	57                   	push   %edi
c002e73e:	56                   	push   %esi
c002e73f:	53                   	push   %ebx
c002e740:	83 ec 24             	sub    $0x24,%esp
  static block_sector_t sector = 0;

  const char *file_name = argv[1];
c002e743:	8b 44 24 38          	mov    0x38(%esp),%eax
c002e747:	8b 40 04             	mov    0x4(%eax),%eax
c002e74a:	89 44 24 14          	mov    %eax,0x14(%esp)
  void *buffer;
  struct file *src;
  struct block *dst;
  off_t size;

  printf ("Appending '%s' to ustar archive on scratch device...\n", file_name);
c002e74e:	50                   	push   %eax
c002e74f:	68 f4 33 03 c0       	push   $0xc00333f4
c002e754:	e8 76 84 ff ff       	call   c0026bcf <printf>

  /* Allocate buffer. */
  buffer = malloc (BLOCK_SECTOR_SIZE);
c002e759:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002e760:	e8 bf 52 ff ff       	call   c0023a24 <malloc>
  if (buffer == NULL)
c002e765:	83 c4 10             	add    $0x10,%esp
c002e768:	85 c0                	test   %eax,%eax
c002e76a:	0f 84 d6 00 00 00    	je     c002e846 <fsutil_append+0x10a>
c002e770:	89 c5                	mov    %eax,%ebp
    PANIC ("couldn't allocate buffer");

  /* Open source file. */
  src = filesys_open (file_name);
c002e772:	83 ec 0c             	sub    $0xc,%esp
c002e775:	ff 74 24 18          	pushl  0x18(%esp)
c002e779:	e8 3c e0 ff ff       	call   c002c7ba <filesys_open>
c002e77e:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (src == NULL)
c002e782:	83 c4 10             	add    $0x10,%esp
c002e785:	85 c0                	test   %eax,%eax
c002e787:	0f 84 d2 00 00 00    	je     c002e85f <fsutil_append+0x123>
    PANIC ("%s: open failed", file_name);
  size = file_length (src);
c002e78d:	83 ec 0c             	sub    $0xc,%esp
c002e790:	ff 74 24 14          	pushl  0x14(%esp)
c002e794:	e8 4b e6 ff ff       	call   c002cde4 <file_length>
c002e799:	89 c6                	mov    %eax,%esi

  /* Open target block device. */
  dst = block_get_role (BLOCK_SCRATCH);
c002e79b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c002e7a2:	e8 13 64 ff ff       	call   c0024bba <block_get_role>
c002e7a7:	89 44 24 14          	mov    %eax,0x14(%esp)
  if (dst == NULL)
c002e7ab:	83 c4 10             	add    $0x10,%esp
c002e7ae:	85 c0                	test   %eax,%eax
c002e7b0:	0f 84 c9 00 00 00    	je     c002e87f <fsutil_append+0x143>
    PANIC ("couldn't open scratch device");
  
  /* Write ustar header to first sector. */
  if (!ustar_make_header (file_name, USTAR_REGULAR, size, buffer))
c002e7b6:	55                   	push   %ebp
c002e7b7:	56                   	push   %esi
c002e7b8:	6a 30                	push   $0x30
c002e7ba:	ff 74 24 18          	pushl  0x18(%esp)
c002e7be:	e8 56 9a ff ff       	call   c0028219 <ustar_make_header>
c002e7c3:	83 c4 10             	add    $0x10,%esp
c002e7c6:	84 c0                	test   %al,%al
c002e7c8:	0f 84 ca 00 00 00    	je     c002e898 <fsutil_append+0x15c>
    PANIC ("%s: name too long for ustar format", file_name);
  block_write (dst, sector++, buffer);
c002e7ce:	a1 20 e9 03 c0       	mov    0xc003e920,%eax
c002e7d3:	8d 50 01             	lea    0x1(%eax),%edx
c002e7d6:	89 15 20 e9 03 c0    	mov    %edx,0xc003e920
c002e7dc:	83 ec 04             	sub    $0x4,%esp
c002e7df:	55                   	push   %ebp
c002e7e0:	50                   	push   %eax
c002e7e1:	ff 74 24 10          	pushl  0x10(%esp)
c002e7e5:	e8 32 65 ff ff       	call   c0024d1c <block_write>

  /* Do copy. */
  while (size > 0) 
c002e7ea:	83 c4 10             	add    $0x10,%esp
c002e7ed:	85 f6                	test   %esi,%esi
c002e7ef:	0f 8f 29 01 00 00    	jg     c002e91e <fsutil_append+0x1e2>
    }

  /* Write ustar end-of-archive marker, which is two consecutive
     sectors full of zeros.  Don't advance our position past
     them, though, in case we have more files to append. */
  memset (buffer, 0, BLOCK_SECTOR_SIZE);
c002e7f5:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e7fa:	b8 00 00 00 00       	mov    $0x0,%eax
c002e7ff:	89 ef                	mov    %ebp,%edi
c002e801:	f3 ab                	rep stos %eax,%es:(%edi)
  block_write (dst, sector, buffer);
c002e803:	83 ec 04             	sub    $0x4,%esp
c002e806:	55                   	push   %ebp
c002e807:	ff 35 20 e9 03 c0    	pushl  0xc003e920
c002e80d:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002e811:	57                   	push   %edi
c002e812:	e8 05 65 ff ff       	call   c0024d1c <block_write>
  block_write (dst, sector, buffer + 1);
c002e817:	83 c4 0c             	add    $0xc,%esp
c002e81a:	8d 45 01             	lea    0x1(%ebp),%eax
c002e81d:	50                   	push   %eax
c002e81e:	ff 35 20 e9 03 c0    	pushl  0xc003e920
c002e824:	57                   	push   %edi
c002e825:	e8 f2 64 ff ff       	call   c0024d1c <block_write>

  /* Finish up. */
  file_close (src);
c002e82a:	83 c4 04             	add    $0x4,%esp
c002e82d:	ff 74 24 14          	pushl  0x14(%esp)
c002e831:	e8 74 e5 ff ff       	call   c002cdaa <file_close>
  free (buffer);
c002e836:	89 2c 24             	mov    %ebp,(%esp)
c002e839:	e8 89 53 ff ff       	call   c0023bc7 <free>
}
c002e83e:	83 c4 2c             	add    $0x2c,%esp
c002e841:	5b                   	pop    %ebx
c002e842:	5e                   	pop    %esi
c002e843:	5f                   	pop    %edi
c002e844:	5d                   	pop    %ebp
c002e845:	c3                   	ret    
    PANIC ("couldn't allocate buffer");
c002e846:	68 f8 32 03 c0       	push   $0xc00332f8
c002e84b:	68 b0 0b 03 c0       	push   $0xc0030bb0
c002e850:	68 b5 00 00 00       	push   $0xb5
c002e855:	68 23 32 03 c0       	push   $0xc0033223
c002e85a:	e8 1e 9e ff ff       	call   c002867d <debug_panic>
    PANIC ("%s: open failed", file_name);
c002e85f:	83 ec 0c             	sub    $0xc,%esp
c002e862:	ff 74 24 18          	pushl  0x18(%esp)
c002e866:	68 4a 32 03 c0       	push   $0xc003324a
c002e86b:	68 b0 0b 03 c0       	push   $0xc0030bb0
c002e870:	68 ba 00 00 00       	push   $0xba
c002e875:	68 23 32 03 c0       	push   $0xc0033223
c002e87a:	e8 fe 9d ff ff       	call   c002867d <debug_panic>
    PANIC ("couldn't open scratch device");
c002e87f:	68 99 32 03 c0       	push   $0xc0033299
c002e884:	68 b0 0b 03 c0       	push   $0xc0030bb0
c002e889:	68 c0 00 00 00       	push   $0xc0
c002e88e:	68 23 32 03 c0       	push   $0xc0033223
c002e893:	e8 e5 9d ff ff       	call   c002867d <debug_panic>
    PANIC ("%s: name too long for ustar format", file_name);
c002e898:	83 ec 0c             	sub    $0xc,%esp
c002e89b:	ff 74 24 18          	pushl  0x18(%esp)
c002e89f:	68 2c 34 03 c0       	push   $0xc003342c
c002e8a4:	68 b0 0b 03 c0       	push   $0xc0030bb0
c002e8a9:	68 c4 00 00 00       	push   $0xc4
c002e8ae:	68 23 32 03 c0       	push   $0xc0033223
c002e8b3:	e8 c5 9d ff ff       	call   c002867d <debug_panic>
      if (sector >= block_size (dst))
c002e8b8:	83 ec 0c             	sub    $0xc,%esp
c002e8bb:	ff 74 24 10          	pushl  0x10(%esp)
c002e8bf:	e8 b4 64 ff ff       	call   c0024d78 <block_size>
c002e8c4:	83 c4 10             	add    $0x10,%esp
c002e8c7:	3b 05 20 e9 03 c0    	cmp    0xc003e920,%eax
c002e8cd:	76 60                	jbe    c002e92f <fsutil_append+0x1f3>
      if (file_read (src, buffer, chunk_size) != chunk_size)
c002e8cf:	83 ec 04             	sub    $0x4,%esp
c002e8d2:	53                   	push   %ebx
c002e8d3:	55                   	push   %ebp
c002e8d4:	ff 74 24 14          	pushl  0x14(%esp)
c002e8d8:	e8 bb e3 ff ff       	call   c002cc98 <file_read>
c002e8dd:	83 c4 10             	add    $0x10,%esp
c002e8e0:	39 c3                	cmp    %eax,%ebx
c002e8e2:	75 6b                	jne    c002e94f <fsutil_append+0x213>
      memset (buffer + chunk_size, 0, BLOCK_SECTOR_SIZE - chunk_size);
c002e8e4:	b9 00 02 00 00       	mov    $0x200,%ecx
c002e8e9:	29 d9                	sub    %ebx,%ecx
c002e8eb:	8d 54 1d 00          	lea    0x0(%ebp,%ebx,1),%edx
c002e8ef:	89 d7                	mov    %edx,%edi
c002e8f1:	b0 00                	mov    $0x0,%al
c002e8f3:	f3 aa                	rep stos %al,%es:(%edi)
      block_write (dst, sector++, buffer);
c002e8f5:	a1 20 e9 03 c0       	mov    0xc003e920,%eax
c002e8fa:	8d 50 01             	lea    0x1(%eax),%edx
c002e8fd:	89 15 20 e9 03 c0    	mov    %edx,0xc003e920
c002e903:	83 ec 04             	sub    $0x4,%esp
c002e906:	55                   	push   %ebp
c002e907:	50                   	push   %eax
c002e908:	ff 74 24 10          	pushl  0x10(%esp)
c002e90c:	e8 0b 64 ff ff       	call   c0024d1c <block_write>
      size -= chunk_size;
c002e911:	29 de                	sub    %ebx,%esi
  while (size > 0) 
c002e913:	83 c4 10             	add    $0x10,%esp
c002e916:	85 f6                	test   %esi,%esi
c002e918:	0f 8e d7 fe ff ff    	jle    c002e7f5 <fsutil_append+0xb9>
      int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
c002e91e:	89 f3                	mov    %esi,%ebx
c002e920:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c002e926:	7e 90                	jle    c002e8b8 <fsutil_append+0x17c>
c002e928:	bb 00 02 00 00       	mov    $0x200,%ebx
c002e92d:	eb 89                	jmp    c002e8b8 <fsutil_append+0x17c>
        PANIC ("%s: out of space on scratch device", file_name);
c002e92f:	83 ec 0c             	sub    $0xc,%esp
c002e932:	ff 74 24 18          	pushl  0x18(%esp)
c002e936:	68 50 34 03 c0       	push   $0xc0033450
c002e93b:	68 b0 0b 03 c0       	push   $0xc0030bb0
c002e940:	68 cc 00 00 00       	push   $0xcc
c002e945:	68 23 32 03 c0       	push   $0xc0033223
c002e94a:	e8 2e 9d ff ff       	call   c002867d <debug_panic>
        PANIC ("%s: read failed with %"PROTd" bytes unread", file_name, size);
c002e94f:	83 ec 08             	sub    $0x8,%esp
c002e952:	56                   	push   %esi
c002e953:	ff 74 24 18          	pushl  0x18(%esp)
c002e957:	68 74 34 03 c0       	push   $0xc0033474
c002e95c:	68 b0 0b 03 c0       	push   $0xc0030bb0
c002e961:	68 ce 00 00 00       	push   $0xce
c002e966:	68 23 32 03 c0       	push   $0xc0033223
c002e96b:	e8 0d 9d ff ff       	call   c002867d <debug_panic>

c002e970 <cache_get_free>:
                                cache.sector_index = sector; } while (false)
static int cache_get_free (void);

static int
cache_get_free () { // only called by locked func
  current_cache = next_cache(current_cache);
c002e970:	a1 40 e9 03 c0       	mov    0xc003e940,%eax
c002e975:	40                   	inc    %eax
c002e976:	25 3f 00 00 80       	and    $0x8000003f,%eax
c002e97b:	78 2b                	js     c002e9a8 <cache_get_free+0x38>
c002e97d:	89 c2                	mov    %eax,%edx
c002e97f:	a3 40 e9 03 c0       	mov    %eax,0xc003e940
  while (caches[current_cache].used && caches[current_cache].recent) {
c002e984:	89 c1                	mov    %eax,%ecx
c002e986:	c1 e1 06             	shl    $0x6,%ecx
c002e989:	01 c1                	add    %eax,%ecx
c002e98b:	80 3c cd a4 eb 03 c0 	cmpb   $0x0,-0x3ffc145c(,%ecx,8)
c002e992:	00 
c002e993:	74 63                	je     c002e9f8 <cache_get_free+0x88>
c002e995:	89 c1                	mov    %eax,%ecx
c002e997:	c1 e1 06             	shl    $0x6,%ecx
c002e99a:	01 c8                	add    %ecx,%eax
c002e99c:	80 3c c5 a5 eb 03 c0 	cmpb   $0x0,-0x3ffc145b(,%eax,8)
c002e9a3:	00 
c002e9a4:	75 2d                	jne    c002e9d3 <cache_get_free+0x63>
c002e9a6:	eb 5c                	jmp    c002ea04 <cache_get_free+0x94>
  current_cache = next_cache(current_cache);
c002e9a8:	48                   	dec    %eax
c002e9a9:	83 c8 c0             	or     $0xffffffc0,%eax
c002e9ac:	40                   	inc    %eax
c002e9ad:	eb ce                	jmp    c002e97d <cache_get_free+0xd>
    caches[current_cache].recent = false;
    current_cache = next_cache(current_cache);
c002e9af:	89 c2                	mov    %eax,%edx
  while (caches[current_cache].used && caches[current_cache].recent) {
c002e9b1:	89 c1                	mov    %eax,%ecx
c002e9b3:	c1 e1 06             	shl    $0x6,%ecx
c002e9b6:	01 c1                	add    %eax,%ecx
c002e9b8:	80 3c cd a4 eb 03 c0 	cmpb   $0x0,-0x3ffc145c(,%ecx,8)
c002e9bf:	00 
c002e9c0:	74 31                	je     c002e9f3 <cache_get_free+0x83>
c002e9c2:	89 c1                	mov    %eax,%ecx
c002e9c4:	c1 e1 06             	shl    $0x6,%ecx
c002e9c7:	01 c8                	add    %ecx,%eax
c002e9c9:	80 3c c5 a5 eb 03 c0 	cmpb   $0x0,-0x3ffc145b(,%eax,8)
c002e9d0:	00 
c002e9d1:	74 2b                	je     c002e9fe <cache_get_free+0x8e>
    caches[current_cache].recent = false;
c002e9d3:	89 d0                	mov    %edx,%eax
c002e9d5:	c1 e0 06             	shl    $0x6,%eax
c002e9d8:	01 d0                	add    %edx,%eax
c002e9da:	c6 04 c5 a5 eb 03 c0 	movb   $0x0,-0x3ffc145b(,%eax,8)
c002e9e1:	00 
    current_cache = next_cache(current_cache);
c002e9e2:	8d 42 01             	lea    0x1(%edx),%eax
c002e9e5:	25 3f 00 00 80       	and    $0x8000003f,%eax
c002e9ea:	79 c3                	jns    c002e9af <cache_get_free+0x3f>
c002e9ec:	48                   	dec    %eax
c002e9ed:	83 c8 c0             	or     $0xffffffc0,%eax
c002e9f0:	40                   	inc    %eax
c002e9f1:	eb bc                	jmp    c002e9af <cache_get_free+0x3f>
c002e9f3:	a3 40 e9 03 c0       	mov    %eax,0xc003e940
      caches[current_cache].dirty = false;
    }
    caches[current_cache].used = false;
    used_cnt --;
  }
  return current_cache;
c002e9f8:	a1 40 e9 03 c0       	mov    0xc003e940,%eax
}
c002e9fd:	c3                   	ret    
c002e9fe:	89 15 40 e9 03 c0    	mov    %edx,0xc003e940
cache_get_free () { // only called by locked func
c002ea04:	83 ec 0c             	sub    $0xc,%esp
    if (caches[current_cache].dirty) {
c002ea07:	89 d0                	mov    %edx,%eax
c002ea09:	c1 e0 06             	shl    $0x6,%eax
c002ea0c:	01 d0                	add    %edx,%eax
c002ea0e:	80 3c c5 a6 eb 03 c0 	cmpb   $0x0,-0x3ffc145a(,%eax,8)
c002ea15:	00 
c002ea16:	75 24                	jne    c002ea3c <cache_get_free+0xcc>
    caches[current_cache].used = false;
c002ea18:	8b 15 40 e9 03 c0    	mov    0xc003e940,%edx
c002ea1e:	89 d0                	mov    %edx,%eax
c002ea20:	c1 e0 06             	shl    $0x6,%eax
c002ea23:	01 d0                	add    %edx,%eax
c002ea25:	c6 04 c5 a4 eb 03 c0 	movb   $0x0,-0x3ffc145c(,%eax,8)
c002ea2c:	00 
    used_cnt --;
c002ea2d:	ff 0d 44 e9 03 c0    	decl   0xc003e944
  return current_cache;
c002ea33:	a1 40 e9 03 c0       	mov    0xc003e940,%eax
}
c002ea38:	83 c4 0c             	add    $0xc,%esp
c002ea3b:	c3                   	ret    
      write_fs(caches[current_cache]);
c002ea3c:	83 ec 04             	sub    $0x4,%esp
c002ea3f:	89 d0                	mov    %edx,%eax
c002ea41:	c1 e0 06             	shl    $0x6,%eax
c002ea44:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002ea47:	8d 0c cd a0 e9 03 c0 	lea    -0x3ffc1660(,%ecx,8),%ecx
c002ea4e:	51                   	push   %ecx
c002ea4f:	01 d0                	add    %edx,%eax
c002ea51:	ff 34 c5 a0 eb 03 c0 	pushl  -0x3ffc1460(,%eax,8)
c002ea58:	ff 35 38 6c 04 c0    	pushl  0xc0046c38
c002ea5e:	e8 b9 62 ff ff       	call   c0024d1c <block_write>
      caches[current_cache].dirty = false;
c002ea63:	8b 15 40 e9 03 c0    	mov    0xc003e940,%edx
c002ea69:	89 d0                	mov    %edx,%eax
c002ea6b:	c1 e0 06             	shl    $0x6,%eax
c002ea6e:	01 d0                	add    %edx,%eax
c002ea70:	c6 04 c5 a6 eb 03 c0 	movb   $0x0,-0x3ffc145a(,%eax,8)
c002ea77:	00 
c002ea78:	83 c4 10             	add    $0x10,%esp
c002ea7b:	eb 9b                	jmp    c002ea18 <cache_get_free+0xa8>

c002ea7d <cache_init>:

void
cache_init () {
c002ea7d:	57                   	push   %edi
c002ea7e:	83 ec 14             	sub    $0x14,%esp
  lock_init (&cache_lock);
c002ea81:	68 60 e9 03 c0       	push   $0xc003e960
c002ea86:	e8 d4 42 ff ff       	call   c0022d5f <lock_init>
  used_cnt = 0;
c002ea8b:	c7 05 44 e9 03 c0 00 	movl   $0x0,0xc003e944
c002ea92:	00 00 00 
  current_cache = -1;
c002ea95:	c7 05 40 e9 03 c0 ff 	movl   $0xffffffff,0xc003e940
c002ea9c:	ff ff ff 
  memset(caches, 0, sizeof caches);
c002ea9f:	ba a0 e9 03 c0       	mov    $0xc003e9a0,%edx
c002eaa4:	b9 80 20 00 00       	mov    $0x2080,%ecx
c002eaa9:	b8 00 00 00 00       	mov    $0x0,%eax
c002eaae:	89 d7                	mov    %edx,%edi
c002eab0:	f3 ab                	rep stos %eax,%es:(%edi)
}
c002eab2:	83 c4 18             	add    $0x18,%esp
c002eab5:	5f                   	pop    %edi
c002eab6:	c3                   	ret    

c002eab7 <cache_read>:

void
cache_read (block_sector_t sector, void *buffer) {
c002eab7:	57                   	push   %edi
c002eab8:	56                   	push   %esi
c002eab9:	53                   	push   %ebx
c002eaba:	8b 74 24 10          	mov    0x10(%esp),%esi
  lock_acquire (&cache_lock);
c002eabe:	83 ec 0c             	sub    $0xc,%esp
c002eac1:	68 60 e9 03 c0       	push   $0xc003e960
c002eac6:	e8 08 44 ff ff       	call   c0022ed3 <lock_acquire>
c002eacb:	b8 a0 eb 03 c0       	mov    $0xc003eba0,%eax
c002ead0:	83 c4 10             	add    $0x10,%esp
  int i;
  for (i = 0; i < CACHE_SIZE; ++i)
c002ead3:	bb 00 00 00 00       	mov    $0x0,%ebx
c002ead8:	eb 0b                	jmp    c002eae5 <cache_read+0x2e>
c002eada:	43                   	inc    %ebx
c002eadb:	05 08 02 00 00       	add    $0x208,%eax
c002eae0:	83 fb 40             	cmp    $0x40,%ebx
c002eae3:	74 45                	je     c002eb2a <cache_read+0x73>
    if (caches[i].used && caches[i].sector_index == sector)
c002eae5:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
c002eae9:	74 ef                	je     c002eada <cache_read+0x23>
c002eaeb:	39 30                	cmp    %esi,(%eax)
c002eaed:	75 eb                	jne    c002eada <cache_read+0x23>
      break;
  if (i == CACHE_SIZE) {
c002eaef:	83 fb 40             	cmp    $0x40,%ebx
c002eaf2:	74 36                	je     c002eb2a <cache_read+0x73>
    i = cache_get_free ();
    occupy_cache(caches[i], sector);
    read_fs(caches[i]);
  }
  caches[i].recent = true;
c002eaf4:	89 d8                	mov    %ebx,%eax
c002eaf6:	c1 e0 06             	shl    $0x6,%eax
c002eaf9:	8d 14 18             	lea    (%eax,%ebx,1),%edx
c002eafc:	c6 04 d5 a5 eb 03 c0 	movb   $0x1,-0x3ffc145b(,%edx,8)
c002eb03:	01 
  memcpy (buffer, caches[i].buffer, BLOCK_SECTOR_SIZE);
c002eb04:	8d 34 d5 a0 e9 03 c0 	lea    -0x3ffc1660(,%edx,8),%esi
c002eb0b:	b9 80 00 00 00       	mov    $0x80,%ecx
c002eb10:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002eb14:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lock_release (&cache_lock);
c002eb16:	83 ec 0c             	sub    $0xc,%esp
c002eb19:	68 60 e9 03 c0       	push   $0xc003e960
c002eb1e:	e8 4d 45 ff ff       	call   c0023070 <lock_release>
}
c002eb23:	83 c4 10             	add    $0x10,%esp
c002eb26:	5b                   	pop    %ebx
c002eb27:	5e                   	pop    %esi
c002eb28:	5f                   	pop    %edi
c002eb29:	c3                   	ret    
    i = cache_get_free ();
c002eb2a:	e8 41 fe ff ff       	call   c002e970 <cache_get_free>
c002eb2f:	89 c3                	mov    %eax,%ebx
    occupy_cache(caches[i], sector);
c002eb31:	ff 05 44 e9 03 c0    	incl   0xc003e944
c002eb37:	c1 e0 06             	shl    $0x6,%eax
c002eb3a:	01 d8                	add    %ebx,%eax
c002eb3c:	8d 04 c5 a0 e9 03 c0 	lea    -0x3ffc1660(,%eax,8),%eax
c002eb43:	c6 80 04 02 00 00 01 	movb   $0x1,0x204(%eax)
c002eb4a:	89 b0 00 02 00 00    	mov    %esi,0x200(%eax)
    read_fs(caches[i]);
c002eb50:	83 ec 04             	sub    $0x4,%esp
c002eb53:	50                   	push   %eax
c002eb54:	56                   	push   %esi
c002eb55:	ff 35 38 6c 04 c0    	pushl  0xc0046c38
c002eb5b:	e8 88 61 ff ff       	call   c0024ce8 <block_read>
c002eb60:	83 c4 10             	add    $0x10,%esp
c002eb63:	eb 8f                	jmp    c002eaf4 <cache_read+0x3d>

c002eb65 <cache_write>:

void
cache_write (block_sector_t sector, const void *buffer) {
c002eb65:	57                   	push   %edi
c002eb66:	56                   	push   %esi
c002eb67:	53                   	push   %ebx
c002eb68:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002eb6c:	8b 74 24 14          	mov    0x14(%esp),%esi
  lock_acquire (&cache_lock);
c002eb70:	83 ec 0c             	sub    $0xc,%esp
c002eb73:	68 60 e9 03 c0       	push   $0xc003e960
c002eb78:	e8 56 43 ff ff       	call   c0022ed3 <lock_acquire>
c002eb7d:	ba a0 eb 03 c0       	mov    $0xc003eba0,%edx
c002eb82:	83 c4 10             	add    $0x10,%esp
  int i;
  for (i = 0; i < CACHE_SIZE; ++i)
c002eb85:	b8 00 00 00 00       	mov    $0x0,%eax
c002eb8a:	eb 0c                	jmp    c002eb98 <cache_write+0x33>
c002eb8c:	40                   	inc    %eax
c002eb8d:	81 c2 08 02 00 00    	add    $0x208,%edx
c002eb93:	83 f8 40             	cmp    $0x40,%eax
c002eb96:	74 4b                	je     c002ebe3 <cache_write+0x7e>
    if (caches[i].used && caches[i].sector_index == sector) 
c002eb98:	80 7a 04 00          	cmpb   $0x0,0x4(%edx)
c002eb9c:	74 ee                	je     c002eb8c <cache_write+0x27>
c002eb9e:	39 1a                	cmp    %ebx,(%edx)
c002eba0:	75 ea                	jne    c002eb8c <cache_write+0x27>
      break;
  if (i == CACHE_SIZE) {
c002eba2:	83 f8 40             	cmp    $0x40,%eax
c002eba5:	74 3c                	je     c002ebe3 <cache_write+0x7e>
    i = cache_get_free ();
    occupy_cache(caches[i], sector);
  }
  caches[i].dirty = true;
c002eba7:	89 c2                	mov    %eax,%edx
c002eba9:	c1 e2 06             	shl    $0x6,%edx
c002ebac:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c002ebaf:	8d 0c cd a0 e9 03 c0 	lea    -0x3ffc1660(,%ecx,8),%ecx
c002ebb6:	c6 81 06 02 00 00 01 	movb   $0x1,0x206(%ecx)
  caches[i].recent = true;
c002ebbd:	c6 81 05 02 00 00 01 	movb   $0x1,0x205(%ecx)
  memcpy (caches[i].buffer, buffer, BLOCK_SECTOR_SIZE);
c002ebc4:	89 c8                	mov    %ecx,%eax
c002ebc6:	b9 80 00 00 00       	mov    $0x80,%ecx
c002ebcb:	89 c7                	mov    %eax,%edi
c002ebcd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lock_release (&cache_lock);
c002ebcf:	83 ec 0c             	sub    $0xc,%esp
c002ebd2:	68 60 e9 03 c0       	push   $0xc003e960
c002ebd7:	e8 94 44 ff ff       	call   c0023070 <lock_release>
}
c002ebdc:	83 c4 10             	add    $0x10,%esp
c002ebdf:	5b                   	pop    %ebx
c002ebe0:	5e                   	pop    %esi
c002ebe1:	5f                   	pop    %edi
c002ebe2:	c3                   	ret    
    i = cache_get_free ();
c002ebe3:	e8 88 fd ff ff       	call   c002e970 <cache_get_free>
    occupy_cache(caches[i], sector);
c002ebe8:	ff 05 44 e9 03 c0    	incl   0xc003e944
c002ebee:	89 c2                	mov    %eax,%edx
c002ebf0:	c1 e2 06             	shl    $0x6,%edx
c002ebf3:	01 c2                	add    %eax,%edx
c002ebf5:	8d 14 d5 a0 e9 03 c0 	lea    -0x3ffc1660(,%edx,8),%edx
c002ebfc:	c6 82 04 02 00 00 01 	movb   $0x1,0x204(%edx)
c002ec03:	89 9a 00 02 00 00    	mov    %ebx,0x200(%edx)
c002ec09:	eb 9c                	jmp    c002eba7 <cache_write+0x42>

c002ec0b <cache_done>:

void
cache_done () {
c002ec0b:	56                   	push   %esi
c002ec0c:	53                   	push   %ebx
c002ec0d:	83 ec 04             	sub    $0x4,%esp
c002ec10:	bb a0 e9 03 c0       	mov    $0xc003e9a0,%ebx
c002ec15:	be a0 6b 04 c0       	mov    $0xc0046ba0,%esi
c002ec1a:	eb 0a                	jmp    c002ec26 <cache_done+0x1b>
c002ec1c:	81 c3 08 02 00 00    	add    $0x208,%ebx
  int i;
  for (i = 0; i < CACHE_SIZE; ++i)
c002ec22:	39 f3                	cmp    %esi,%ebx
c002ec24:	74 2c                	je     c002ec52 <cache_done+0x47>
    if (caches[i].used && caches[i].dirty)
c002ec26:	80 bb 04 02 00 00 00 	cmpb   $0x0,0x204(%ebx)
c002ec2d:	74 ed                	je     c002ec1c <cache_done+0x11>
c002ec2f:	80 bb 06 02 00 00 00 	cmpb   $0x0,0x206(%ebx)
c002ec36:	74 e4                	je     c002ec1c <cache_done+0x11>
      write_fs (caches[i]);
c002ec38:	83 ec 04             	sub    $0x4,%esp
c002ec3b:	53                   	push   %ebx
c002ec3c:	ff b3 00 02 00 00    	pushl  0x200(%ebx)
c002ec42:	ff 35 38 6c 04 c0    	pushl  0xc0046c38
c002ec48:	e8 cf 60 ff ff       	call   c0024d1c <block_write>
c002ec4d:	83 c4 10             	add    $0x10,%esp
c002ec50:	eb ca                	jmp    c002ec1c <cache_done+0x11>
c002ec52:	83 c4 04             	add    $0x4,%esp
c002ec55:	5b                   	pop    %ebx
c002ec56:	5e                   	pop    %esi
c002ec57:	c3                   	ret    

c002ec58 <destroy_page>:
	lock_release(&frame_lock);
}

static void
destroy_page (struct hash_elem *p_, void *aux UNUSED)
{
c002ec58:	57                   	push   %edi
c002ec59:	56                   	push   %esi
c002ec5a:	53                   	push   %ebx
c002ec5b:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	struct page *p = hash_entry (p_, struct page, elem);
c002ec5f:	8d 73 f4             	lea    -0xc(%ebx),%esi
	if (p->frame != NULL) {
c002ec62:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c002ec66:	74 22                	je     c002ec8a <destroy_page+0x32>
		pagedir_clear_page(thread_current()->pagedir, p->vaddr);
c002ec68:	8b 7b f4             	mov    -0xc(%ebx),%edi
c002ec6b:	e8 a6 20 ff ff       	call   c0020d16 <thread_current>
c002ec70:	83 ec 08             	sub    $0x8,%esp
c002ec73:	57                   	push   %edi
c002ec74:	ff 70 64             	pushl  0x64(%eax)
c002ec77:	e8 27 c5 ff ff       	call   c002b1a3 <pagedir_clear_page>
		frame_free(p->frame);
c002ec7c:	83 c4 04             	add    $0x4,%esp
c002ec7f:	ff 73 08             	pushl  0x8(%ebx)
c002ec82:	e8 03 06 00 00       	call   c002f28a <frame_free>
c002ec87:	83 c4 10             	add    $0x10,%esp
	}
	hash_delete(thread_current()->pages, &p->elem);
c002ec8a:	e8 87 20 ff ff       	call   c0020d16 <thread_current>
c002ec8f:	83 ec 08             	sub    $0x8,%esp
c002ec92:	53                   	push   %ebx
c002ec93:	ff b0 dc 00 00 00    	pushl  0xdc(%eax)
c002ec99:	e8 78 b0 ff ff       	call   c0029d16 <hash_delete>
	free(p);
c002ec9e:	89 34 24             	mov    %esi,(%esp)
c002eca1:	e8 21 4f ff ff       	call   c0023bc7 <free>
}
c002eca6:	83 c4 10             	add    $0x10,%esp
c002eca9:	5b                   	pop    %ebx
c002ecaa:	5e                   	pop    %esi
c002ecab:	5f                   	pop    %edi
c002ecac:	c3                   	ret    

c002ecad <page_init>:
page_init() {
c002ecad:	83 ec 18             	sub    $0x18,%esp
	lock_init(&page_lock);
c002ecb0:	68 40 6c 04 c0       	push   $0xc0046c40
c002ecb5:	e8 a5 40 ff ff       	call   c0022d5f <lock_init>
}
c002ecba:	83 c4 1c             	add    $0x1c,%esp
c002ecbd:	c3                   	ret    

c002ecbe <install_page>:
{
c002ecbe:	57                   	push   %edi
c002ecbf:	56                   	push   %esi
c002ecc0:	53                   	push   %ebx
c002ecc1:	8b 74 24 10          	mov    0x10(%esp),%esi
c002ecc5:	8b 7c 24 18          	mov    0x18(%esp),%edi
	struct thread *t = thread_current ();
c002ecc9:	e8 48 20 ff ff       	call   c0020d16 <thread_current>
c002ecce:	89 c3                	mov    %eax,%ebx
	return (pagedir_get_page (t->pagedir, upage) == NULL
c002ecd0:	83 ec 08             	sub    $0x8,%esp
c002ecd3:	56                   	push   %esi
c002ecd4:	ff 70 64             	pushl  0x64(%eax)
c002ecd7:	e8 4e c3 ff ff       	call   c002b02a <pagedir_get_page>
	        && pagedir_set_page (t->pagedir, upage, kpage, writable));
c002ecdc:	83 c4 10             	add    $0x10,%esp
c002ecdf:	ba 00 00 00 00       	mov    $0x0,%edx
c002ece4:	85 c0                	test   %eax,%eax
c002ece6:	74 09                	je     c002ecf1 <install_page+0x33>
c002ece8:	88 d0                	mov    %dl,%al
c002ecea:	83 e0 01             	and    $0x1,%eax
}
c002eced:	5b                   	pop    %ebx
c002ecee:	5e                   	pop    %esi
c002ecef:	5f                   	pop    %edi
c002ecf0:	c3                   	ret    
	        && pagedir_set_page (t->pagedir, upage, kpage, writable));
c002ecf1:	89 f8                	mov    %edi,%eax
c002ecf3:	0f b6 f8             	movzbl %al,%edi
c002ecf6:	57                   	push   %edi
c002ecf7:	ff 74 24 18          	pushl  0x18(%esp)
c002ecfb:	56                   	push   %esi
c002ecfc:	ff 73 64             	pushl  0x64(%ebx)
c002ecff:	e8 b1 c1 ff ff       	call   c002aeb5 <pagedir_set_page>
c002ed04:	83 c4 10             	add    $0x10,%esp
c002ed07:	85 c0                	test   %eax,%eax
c002ed09:	0f 95 c2             	setne  %dl
c002ed0c:	0f b6 d2             	movzbl %dl,%edx
c002ed0f:	eb d7                	jmp    c002ece8 <install_page+0x2a>

c002ed11 <page_out>:
{
c002ed11:	56                   	push   %esi
c002ed12:	53                   	push   %ebx
c002ed13:	83 ec 0c             	sub    $0xc,%esp
c002ed16:	8b 5c 24 18          	mov    0x18(%esp),%ebx
	pagedir_clear_page(p->thread->pagedir, (void *) p->vaddr);
c002ed1a:	ff 33                	pushl  (%ebx)
c002ed1c:	8b 43 08             	mov    0x8(%ebx),%eax
c002ed1f:	ff 70 64             	pushl  0x64(%eax)
c002ed22:	e8 7c c4 ff ff       	call   c002b1a3 <pagedir_clear_page>
	dirty = pagedir_is_dirty (p->thread->pagedir, (const void *) p->vaddr);
c002ed27:	83 c4 08             	add    $0x8,%esp
c002ed2a:	ff 33                	pushl  (%ebx)
c002ed2c:	8b 43 08             	mov    0x8(%ebx),%eax
c002ed2f:	ff 70 64             	pushl  0x64(%eax)
c002ed32:	e8 89 c3 ff ff       	call   c002b0c0 <pagedir_is_dirty>
	if (p->file == NULL) {
c002ed37:	83 c4 10             	add    $0x10,%esp
c002ed3a:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
c002ed3e:	74 4f                	je     c002ed8f <page_out+0x7e>
		if (dirty) {
c002ed40:	85 c0                	test   %eax,%eax
c002ed42:	74 37                	je     c002ed7b <page_out+0x6a>
			if (p->private) {
c002ed44:	80 7b 18 00          	cmpb   $0x0,0x18(%ebx)
c002ed48:	74 5a                	je     c002eda4 <page_out+0x93>
				lock_acquire(&filesys_lock);
c002ed4a:	83 ec 0c             	sub    $0xc,%esp
c002ed4d:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002ed52:	e8 7c 41 ff ff       	call   c0022ed3 <lock_acquire>
				success = swap_out(p);
c002ed57:	89 1c 24             	mov    %ebx,(%esp)
c002ed5a:	e8 2f 06 00 00       	call   c002f38e <swap_out>
c002ed5f:	85 c0                	test   %eax,%eax
c002ed61:	0f 95 c0             	setne  %al
c002ed64:	89 c6                	mov    %eax,%esi
				lock_release(&filesys_lock);
c002ed66:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002ed6d:	e8 fe 42 ff ff       	call   c0023070 <lock_release>
c002ed72:	83 c4 10             	add    $0x10,%esp
	if (success) {
c002ed75:	89 f0                	mov    %esi,%eax
c002ed77:	84 c0                	test   %al,%al
c002ed79:	74 0c                	je     c002ed87 <page_out+0x76>
		p->frame = NULL;
c002ed7b:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
c002ed82:	be 01 00 00 00       	mov    $0x1,%esi
}
c002ed87:	89 f0                	mov    %esi,%eax
c002ed89:	83 c4 04             	add    $0x4,%esp
c002ed8c:	5b                   	pop    %ebx
c002ed8d:	5e                   	pop    %esi
c002ed8e:	c3                   	ret    
		success = swap_out(p);
c002ed8f:	83 ec 0c             	sub    $0xc,%esp
c002ed92:	53                   	push   %ebx
c002ed93:	e8 f6 05 00 00       	call   c002f38e <swap_out>
c002ed98:	83 c4 10             	add    $0x10,%esp
c002ed9b:	85 c0                	test   %eax,%eax
c002ed9d:	0f 95 c0             	setne  %al
c002eda0:	89 c6                	mov    %eax,%esi
c002eda2:	eb d1                	jmp    c002ed75 <page_out+0x64>
				lock_acquire(&filesys_lock);
c002eda4:	83 ec 0c             	sub    $0xc,%esp
c002eda7:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002edac:	e8 22 41 ff ff       	call   c0022ed3 <lock_acquire>
				success = file_write_at(p->file, (const void *) p->frame->base, p->read_bytes, p->file_offset);
c002edb1:	ff 73 24             	pushl  0x24(%ebx)
c002edb4:	ff 73 28             	pushl  0x28(%ebx)
c002edb7:	8b 43 14             	mov    0x14(%ebx),%eax
c002edba:	ff 30                	pushl  (%eax)
c002edbc:	ff 73 20             	pushl  0x20(%ebx)
c002edbf:	e8 36 df ff ff       	call   c002ccfa <file_write_at>
c002edc4:	83 c4 14             	add    $0x14,%esp
c002edc7:	85 c0                	test   %eax,%eax
c002edc9:	0f 95 c0             	setne  %al
c002edcc:	89 c6                	mov    %eax,%esi
				lock_release(&filesys_lock);
c002edce:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002edd3:	e8 98 42 ff ff       	call   c0023070 <lock_release>
c002edd8:	83 c4 10             	add    $0x10,%esp
c002eddb:	eb 98                	jmp    c002ed75 <page_out+0x64>

c002eddd <page_alloc>:
page_alloc(void *vaddr, bool writable) {
c002eddd:	57                   	push   %edi
c002edde:	56                   	push   %esi
c002eddf:	53                   	push   %ebx
c002ede0:	8b 7c 24 14          	mov    0x14(%esp),%edi
	lock_acquire(&frame_lock);
c002ede4:	83 ec 0c             	sub    $0xc,%esp
c002ede7:	68 00 6c 04 c0       	push   $0xc0046c00
c002edec:	e8 e2 40 ff ff       	call   c0022ed3 <lock_acquire>
	struct thread *t = thread_current();
c002edf1:	e8 20 1f ff ff       	call   c0020d16 <thread_current>
c002edf6:	89 c6                	mov    %eax,%esi
	struct page *p = malloc(sizeof *p);
c002edf8:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
c002edff:	e8 20 4c ff ff       	call   c0023a24 <malloc>
c002ee04:	89 c3                	mov    %eax,%ebx
	if (p != NULL) {
c002ee06:	83 c4 10             	add    $0x10,%esp
c002ee09:	85 c0                	test   %eax,%eax
c002ee0b:	74 4d                	je     c002ee5a <page_alloc+0x7d>
		p->vaddr = vaddr;
c002ee0d:	8b 44 24 10          	mov    0x10(%esp),%eax
c002ee11:	89 03                	mov    %eax,(%ebx)
		p->writable = writable;
c002ee13:	89 f8                	mov    %edi,%eax
c002ee15:	88 43 04             	mov    %al,0x4(%ebx)
		p->frame = NULL;
c002ee18:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
		p->private = writable;
c002ee1f:	88 43 18             	mov    %al,0x18(%ebx)
		p->file = NULL;
c002ee22:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
		p->file_offset = 0;
c002ee29:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
		p->read_bytes = 0;
c002ee30:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
		p->sector = (block_sector_t) -1;
c002ee37:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
		p->thread = t;
c002ee3e:	89 73 08             	mov    %esi,0x8(%ebx)
		if (hash_insert(t->pages, &p->elem) != NULL) {
c002ee41:	83 ec 08             	sub    $0x8,%esp
c002ee44:	8d 43 0c             	lea    0xc(%ebx),%eax
c002ee47:	50                   	push   %eax
c002ee48:	ff b6 dc 00 00 00    	pushl  0xdc(%esi)
c002ee4e:	e8 fd ad ff ff       	call   c0029c50 <hash_insert>
c002ee53:	83 c4 10             	add    $0x10,%esp
c002ee56:	85 c0                	test   %eax,%eax
c002ee58:	75 16                	jne    c002ee70 <page_alloc+0x93>
	lock_release(&frame_lock);
c002ee5a:	83 ec 0c             	sub    $0xc,%esp
c002ee5d:	68 00 6c 04 c0       	push   $0xc0046c00
c002ee62:	e8 09 42 ff ff       	call   c0023070 <lock_release>
	return p;
c002ee67:	83 c4 10             	add    $0x10,%esp
}
c002ee6a:	89 d8                	mov    %ebx,%eax
c002ee6c:	5b                   	pop    %ebx
c002ee6d:	5e                   	pop    %esi
c002ee6e:	5f                   	pop    %edi
c002ee6f:	c3                   	ret    
			free (p);
c002ee70:	83 ec 0c             	sub    $0xc,%esp
c002ee73:	53                   	push   %ebx
c002ee74:	e8 4e 4d ff ff       	call   c0023bc7 <free>
c002ee79:	83 c4 10             	add    $0x10,%esp
			p = NULL;
c002ee7c:	bb 00 00 00 00       	mov    $0x0,%ebx
c002ee81:	eb d7                	jmp    c002ee5a <page_alloc+0x7d>

c002ee83 <page_for_addr>:
page_for_addr(void *vaddr) {
c002ee83:	83 ec 3c             	sub    $0x3c,%esp
  return (void *) ((uintptr_t) va & ~PGMASK);
c002ee86:	8b 44 24 40          	mov    0x40(%esp),%eax
c002ee8a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002ee8f:	89 44 24 04          	mov    %eax,0x4(%esp)
	e = hash_find(thread_current()->pages, &p.elem);
c002ee93:	e8 7e 1e ff ff       	call   c0020d16 <thread_current>
c002ee98:	83 ec 08             	sub    $0x8,%esp
c002ee9b:	8d 54 24 18          	lea    0x18(%esp),%edx
c002ee9f:	52                   	push   %edx
c002eea0:	ff b0 dc 00 00 00    	pushl  0xdc(%eax)
c002eea6:	e8 48 ae ff ff       	call   c0029cf3 <hash_find>
	if (e != NULL) {
c002eeab:	83 c4 10             	add    $0x10,%esp
c002eeae:	85 c0                	test   %eax,%eax
c002eeb0:	74 07                	je     c002eeb9 <page_for_addr+0x36>
		return hash_entry(e, struct page, elem);
c002eeb2:	83 e8 0c             	sub    $0xc,%eax
}
c002eeb5:	83 c4 3c             	add    $0x3c,%esp
c002eeb8:	c3                   	ret    
	if ((p.vaddr > PHYS_BASE - STACK_MAX) && ((void *)thread_current()->esp - 32 <= vaddr)) {
c002eeb9:	81 7c 24 04 00 00 80 	cmpl   $0xbf800000,0x4(%esp)
c002eec0:	bf 
c002eec1:	76 27                	jbe    c002eeea <page_for_addr+0x67>
c002eec3:	e8 4e 1e ff ff       	call   c0020d16 <thread_current>
c002eec8:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
c002eece:	83 e8 20             	sub    $0x20,%eax
c002eed1:	39 44 24 40          	cmp    %eax,0x40(%esp)
c002eed5:	72 1a                	jb     c002eef1 <page_for_addr+0x6e>
		return page_alloc(p.vaddr, true);
c002eed7:	83 ec 08             	sub    $0x8,%esp
c002eeda:	6a 01                	push   $0x1
c002eedc:	ff 74 24 10          	pushl  0x10(%esp)
c002eee0:	e8 f8 fe ff ff       	call   c002eddd <page_alloc>
c002eee5:	83 c4 10             	add    $0x10,%esp
c002eee8:	eb cb                	jmp    c002eeb5 <page_for_addr+0x32>
	return NULL;
c002eeea:	b8 00 00 00 00       	mov    $0x0,%eax
c002eeef:	eb c4                	jmp    c002eeb5 <page_for_addr+0x32>
c002eef1:	b8 00 00 00 00       	mov    $0x0,%eax
c002eef6:	eb bd                	jmp    c002eeb5 <page_for_addr+0x32>

c002eef8 <page_in>:
page_in(void *vaddr) {
c002eef8:	57                   	push   %edi
c002eef9:	56                   	push   %esi
c002eefa:	53                   	push   %ebx
	struct page *p = page_for_addr(vaddr);
c002eefb:	83 ec 0c             	sub    $0xc,%esp
c002eefe:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ef02:	e8 7c ff ff ff       	call   c002ee83 <page_for_addr>
	if (p == NULL) {
c002ef07:	83 c4 10             	add    $0x10,%esp
c002ef0a:	85 c0                	test   %eax,%eax
c002ef0c:	0f 84 c9 00 00 00    	je     c002efdb <page_in+0xe3>
c002ef12:	89 c3                	mov    %eax,%ebx
	frame_alloc(p);
c002ef14:	83 ec 0c             	sub    $0xc,%esp
c002ef17:	50                   	push   %eax
c002ef18:	e8 b7 01 00 00       	call   c002f0d4 <frame_alloc>
	if (p->frame == NULL) {
c002ef1d:	83 c4 10             	add    $0x10,%esp
c002ef20:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
c002ef24:	0f 84 b5 00 00 00    	je     c002efdf <page_in+0xe7>
	lock_acquire(&frame_lock);
c002ef2a:	83 ec 0c             	sub    $0xc,%esp
c002ef2d:	68 00 6c 04 c0       	push   $0xc0046c00
c002ef32:	e8 9c 3f ff ff       	call   c0022ed3 <lock_acquire>
	if (p->sector != (block_sector_t) -1) {
c002ef37:	83 c4 10             	add    $0x10,%esp
c002ef3a:	83 7b 1c ff          	cmpl   $0xffffffff,0x1c(%ebx)
c002ef3e:	74 3a                	je     c002ef7a <page_in+0x82>
		lock_acquire(&filesys_lock);
c002ef40:	83 ec 0c             	sub    $0xc,%esp
c002ef43:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002ef48:	e8 86 3f ff ff       	call   c0022ed3 <lock_acquire>
		swap_in(p);
c002ef4d:	89 1c 24             	mov    %ebx,(%esp)
c002ef50:	e8 e1 03 00 00       	call   c002f336 <swap_in>
		lock_release(&filesys_lock);
c002ef55:	c7 04 24 c0 6b 04 c0 	movl   $0xc0046bc0,(%esp)
c002ef5c:	e8 0f 41 ff ff       	call   c0023070 <lock_release>
c002ef61:	83 c4 10             	add    $0x10,%esp
	lock_release(&frame_lock);
c002ef64:	83 ec 0c             	sub    $0xc,%esp
c002ef67:	68 00 6c 04 c0       	push   $0xc0046c00
c002ef6c:	e8 ff 40 ff ff       	call   c0023070 <lock_release>
	return true;
c002ef71:	83 c4 10             	add    $0x10,%esp
c002ef74:	b0 01                	mov    $0x1,%al
}
c002ef76:	5b                   	pop    %ebx
c002ef77:	5e                   	pop    %esi
c002ef78:	5f                   	pop    %edi
c002ef79:	c3                   	ret    
	else if (p->file != NULL) {
c002ef7a:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
c002ef7e:	74 46                	je     c002efc6 <page_in+0xce>
		lock_acquire(&filesys_lock);
c002ef80:	83 ec 0c             	sub    $0xc,%esp
c002ef83:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002ef88:	e8 46 3f ff ff       	call   c0022ed3 <lock_acquire>
		off_t read_bytes = file_read_at(p->file, p->frame->base, p->read_bytes, p->file_offset);
c002ef8d:	ff 73 24             	pushl  0x24(%ebx)
c002ef90:	ff 73 28             	pushl  0x28(%ebx)
c002ef93:	8b 43 14             	mov    0x14(%ebx),%eax
c002ef96:	ff 30                	pushl  (%eax)
c002ef98:	ff 73 20             	pushl  0x20(%ebx)
c002ef9b:	e8 1a dd ff ff       	call   c002ccba <file_read_at>
c002efa0:	89 c6                	mov    %eax,%esi
		lock_release(&filesys_lock);
c002efa2:	83 c4 14             	add    $0x14,%esp
c002efa5:	68 c0 6b 04 c0       	push   $0xc0046bc0
c002efaa:	e8 c1 40 ff ff       	call   c0023070 <lock_release>
		off_t zero_bytes = PGSIZE - read_bytes;
c002efaf:	b9 00 10 00 00       	mov    $0x1000,%ecx
c002efb4:	29 f1                	sub    %esi,%ecx
		memset (p->frame->base + read_bytes, 0, zero_bytes);
c002efb6:	8b 43 14             	mov    0x14(%ebx),%eax
c002efb9:	03 30                	add    (%eax),%esi
c002efbb:	b0 00                	mov    $0x0,%al
c002efbd:	89 f7                	mov    %esi,%edi
c002efbf:	f3 aa                	rep stos %al,%es:(%edi)
c002efc1:	83 c4 10             	add    $0x10,%esp
c002efc4:	eb 9e                	jmp    c002ef64 <page_in+0x6c>
		memset (p->frame->base, 0, PGSIZE);
c002efc6:	8b 43 14             	mov    0x14(%ebx),%eax
c002efc9:	8b 10                	mov    (%eax),%edx
c002efcb:	b9 00 04 00 00       	mov    $0x400,%ecx
c002efd0:	b8 00 00 00 00       	mov    $0x0,%eax
c002efd5:	89 d7                	mov    %edx,%edi
c002efd7:	f3 ab                	rep stos %eax,%es:(%edi)
c002efd9:	eb 89                	jmp    c002ef64 <page_in+0x6c>
		return false;
c002efdb:	b0 00                	mov    $0x0,%al
c002efdd:	eb 97                	jmp    c002ef76 <page_in+0x7e>
		return false;
c002efdf:	b0 00                	mov    $0x0,%al
c002efe1:	eb 93                	jmp    c002ef76 <page_in+0x7e>

c002efe3 <page_free>:
page_free(struct page *p) {
c002efe3:	55                   	push   %ebp
c002efe4:	57                   	push   %edi
c002efe5:	56                   	push   %esi
c002efe6:	53                   	push   %ebx
c002efe7:	83 ec 18             	sub    $0x18,%esp
c002efea:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
	lock_acquire(&frame_lock);
c002efee:	68 00 6c 04 c0       	push   $0xc0046c00
c002eff3:	e8 db 3e ff ff       	call   c0022ed3 <lock_acquire>
	struct thread *t = thread_current();
c002eff8:	e8 19 1d ff ff       	call   c0020d16 <thread_current>
c002effd:	89 c7                	mov    %eax,%edi
	if (p->frame != NULL) {
c002efff:	8b 73 14             	mov    0x14(%ebx),%esi
c002f002:	83 c4 10             	add    $0x10,%esp
c002f005:	85 f6                	test   %esi,%esi
c002f007:	74 2e                	je     c002f037 <page_free+0x54>
		if (p->file && !p->private) {
c002f009:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
c002f00d:	74 06                	je     c002f015 <page_free+0x32>
c002f00f:	80 7b 18 00          	cmpb   $0x0,0x18(%ebx)
c002f013:	74 50                	je     c002f065 <page_free+0x82>
			pagedir_clear_page(thread_current()->pagedir, p->vaddr);
c002f015:	8b 2b                	mov    (%ebx),%ebp
c002f017:	e8 fa 1c ff ff       	call   c0020d16 <thread_current>
c002f01c:	83 ec 08             	sub    $0x8,%esp
c002f01f:	55                   	push   %ebp
c002f020:	ff 70 64             	pushl  0x64(%eax)
c002f023:	e8 7b c1 ff ff       	call   c002b1a3 <pagedir_clear_page>
c002f028:	83 c4 10             	add    $0x10,%esp
		frame_free(f);
c002f02b:	83 ec 0c             	sub    $0xc,%esp
c002f02e:	56                   	push   %esi
c002f02f:	e8 56 02 00 00       	call   c002f28a <frame_free>
c002f034:	83 c4 10             	add    $0x10,%esp
	hash_delete(t->pages, &p->elem);
c002f037:	83 ec 08             	sub    $0x8,%esp
c002f03a:	8d 43 0c             	lea    0xc(%ebx),%eax
c002f03d:	50                   	push   %eax
c002f03e:	ff b7 dc 00 00 00    	pushl  0xdc(%edi)
c002f044:	e8 cd ac ff ff       	call   c0029d16 <hash_delete>
	free(p);
c002f049:	89 1c 24             	mov    %ebx,(%esp)
c002f04c:	e8 76 4b ff ff       	call   c0023bc7 <free>
	lock_release(&frame_lock);
c002f051:	c7 04 24 00 6c 04 c0 	movl   $0xc0046c00,(%esp)
c002f058:	e8 13 40 ff ff       	call   c0023070 <lock_release>
}
c002f05d:	83 c4 1c             	add    $0x1c,%esp
c002f060:	5b                   	pop    %ebx
c002f061:	5e                   	pop    %esi
c002f062:	5f                   	pop    %edi
c002f063:	5d                   	pop    %ebp
c002f064:	c3                   	ret    
			page_out(p);
c002f065:	83 ec 0c             	sub    $0xc,%esp
c002f068:	53                   	push   %ebx
c002f069:	e8 a3 fc ff ff       	call   c002ed11 <page_out>
c002f06e:	83 c4 10             	add    $0x10,%esp
c002f071:	eb b8                	jmp    c002f02b <page_free+0x48>

c002f073 <page_exit>:

/* Destroys the current process's page table. */
void
page_exit (void)
{
c002f073:	83 ec 0c             	sub    $0xc,%esp
	struct hash *h = thread_current()->pages;
c002f076:	e8 9b 1c ff ff       	call   c0020d16 <thread_current>
c002f07b:	8b 80 dc 00 00 00    	mov    0xdc(%eax),%eax
	if (h != NULL)
c002f081:	85 c0                	test   %eax,%eax
c002f083:	74 11                	je     c002f096 <page_exit+0x23>
		hash_destroy(h, destroy_page);
c002f085:	83 ec 08             	sub    $0x8,%esp
c002f088:	68 58 ec 02 c0       	push   $0xc002ec58
c002f08d:	50                   	push   %eax
c002f08e:	e8 90 ab ff ff       	call   c0029c23 <hash_destroy>
c002f093:	83 c4 10             	add    $0x10,%esp
}
c002f096:	83 c4 0c             	add    $0xc,%esp
c002f099:	c3                   	ret    

c002f09a <page_hash>:
  return (uintptr_t) va >> PGBITS;
c002f09a:	8b 44 24 04          	mov    0x4(%esp),%eax
c002f09e:	8b 40 f4             	mov    -0xc(%eax),%eax
c002f0a1:	c1 e8 0c             	shr    $0xc,%eax

unsigned
page_hash(const struct hash_elem *e, void *aux UNUSED) {
	const struct page *p = hash_entry(e, struct page, elem);
	return pg_no(p->vaddr);
}
c002f0a4:	c3                   	ret    

c002f0a5 <page_less>:
bool
page_less(const struct hash_elem *lhs, const struct hash_elem *rhs, void *aux UNUSED) {
	const struct page *plhs = hash_entry(lhs, struct page, elem);
	const struct page *prhs = hash_entry(rhs, struct page, elem);

	return plhs->vaddr < prhs->vaddr;
c002f0a5:	8b 44 24 08          	mov    0x8(%esp),%eax
c002f0a9:	8b 54 24 04          	mov    0x4(%esp),%edx
c002f0ad:	8b 40 f4             	mov    -0xc(%eax),%eax
c002f0b0:	39 42 f4             	cmp    %eax,-0xc(%edx)
c002f0b3:	0f 92 c0             	setb   %al
c002f0b6:	c3                   	ret    

c002f0b7 <frame_init>:


struct list frames;

void
frame_init() {
c002f0b7:	83 ec 18             	sub    $0x18,%esp
	lock_init(&frame_lock);
c002f0ba:	68 00 6c 04 c0       	push   $0xc0046c00
c002f0bf:	e8 9b 3c ff ff       	call   c0022d5f <lock_init>
	list_init(&frames);
c002f0c4:	c7 04 24 74 6c 04 c0 	movl   $0xc0046c74,(%esp)
c002f0cb:	e8 54 96 ff ff       	call   c0028724 <list_init>
}
c002f0d0:	83 c4 1c             	add    $0x1c,%esp
c002f0d3:	c3                   	ret    

c002f0d4 <frame_alloc>:

bool
frame_alloc(struct page *p) {
c002f0d4:	57                   	push   %edi
c002f0d5:	56                   	push   %esi
c002f0d6:	53                   	push   %ebx
c002f0d7:	8b 5c 24 10          	mov    0x10(%esp),%ebx
//	printf("frame_alloc\n");
	lock_acquire (&frame_lock);
c002f0db:	83 ec 0c             	sub    $0xc,%esp
c002f0de:	68 00 6c 04 c0       	push   $0xc0046c00
c002f0e3:	e8 eb 3d ff ff       	call   c0022ed3 <lock_acquire>

	p->frame = malloc(sizeof *p->frame);
c002f0e8:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
c002f0ef:	e8 30 49 ff ff       	call   c0023a24 <malloc>
c002f0f4:	89 c6                	mov    %eax,%esi
c002f0f6:	89 43 14             	mov    %eax,0x14(%ebx)
	p->frame->base = palloc_get_page(PAL_USER);
c002f0f9:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c002f100:	e8 a9 45 ff ff       	call   c00236ae <palloc_get_page>
c002f105:	89 06                	mov    %eax,(%esi)

	if (p->frame->base != NULL) {
c002f107:	8b 53 14             	mov    0x14(%ebx),%edx
c002f10a:	8b 02                	mov    (%edx),%eax
c002f10c:	83 c4 10             	add    $0x10,%esp
c002f10f:	85 c0                	test   %eax,%eax
c002f111:	74 43                	je     c002f156 <frame_alloc+0x82>
		install_page(p->vaddr, p->frame->base, p->writable);
c002f113:	83 ec 04             	sub    $0x4,%esp
c002f116:	0f b6 53 04          	movzbl 0x4(%ebx),%edx
c002f11a:	52                   	push   %edx
c002f11b:	50                   	push   %eax
c002f11c:	ff 33                	pushl  (%ebx)
c002f11e:	e8 9b fb ff ff       	call   c002ecbe <install_page>
		p->frame->page = p;
c002f123:	8b 43 14             	mov    0x14(%ebx),%eax
c002f126:	89 58 04             	mov    %ebx,0x4(%eax)
		list_push_back(&frames, &p->frame->elem);
c002f129:	83 c4 08             	add    $0x8,%esp
c002f12c:	8b 43 14             	mov    0x14(%ebx),%eax
c002f12f:	83 c0 08             	add    $0x8,%eax
c002f132:	50                   	push   %eax
c002f133:	68 74 6c 04 c0       	push   $0xc0046c74
c002f138:	e8 33 9a ff ff       	call   c0028b70 <list_push_back>
c002f13d:	83 c4 10             	add    $0x10,%esp

		p->frame = victim;
		p->frame->page = p;
		install_page(p->vaddr, p->frame->base, p->writable);
	}
	lock_release(&frame_lock);
c002f140:	83 ec 0c             	sub    $0xc,%esp
c002f143:	68 00 6c 04 c0       	push   $0xc0046c00
c002f148:	e8 23 3f ff ff       	call   c0023070 <lock_release>
	return true;
c002f14d:	83 c4 10             	add    $0x10,%esp
}
c002f150:	b0 01                	mov    $0x1,%al
c002f152:	5b                   	pop    %ebx
c002f153:	5e                   	pop    %esi
c002f154:	5f                   	pop    %edi
c002f155:	c3                   	ret    
		free(p->frame);
c002f156:	83 ec 0c             	sub    $0xc,%esp
c002f159:	52                   	push   %edx
c002f15a:	e8 68 4a ff ff       	call   c0023bc7 <free>
		p->frame = NULL;
c002f15f:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
		for (struct list_elem *e = list_begin(&frames); e != list_end(&frames); e = list_next(e)){
c002f166:	c7 04 24 74 6c 04 c0 	movl   $0xc0046c74,(%esp)
c002f16d:	e8 f5 95 ff ff       	call   c0028767 <list_begin>
c002f172:	89 c6                	mov    %eax,%esi
c002f174:	83 c4 10             	add    $0x10,%esp
c002f177:	83 ec 0c             	sub    $0xc,%esp
c002f17a:	68 74 6c 04 c0       	push   $0xc0046c74
c002f17f:	e8 5b 96 ff ff       	call   c00287df <list_end>
c002f184:	83 c4 10             	add    $0x10,%esp
c002f187:	39 c6                	cmp    %eax,%esi
c002f189:	74 77                	je     c002f202 <frame_alloc+0x12e>
			if (entry->page == NULL) {
c002f18b:	8b 46 fc             	mov    -0x4(%esi),%eax
c002f18e:	85 c0                	test   %eax,%eax
c002f190:	74 49                	je     c002f1db <frame_alloc+0x107>
			if (pagedir_is_accessed(entry->page->thread->pagedir, entry->page->vaddr)) {
c002f192:	83 ec 08             	sub    $0x8,%esp
c002f195:	ff 30                	pushl  (%eax)
c002f197:	8b 40 08             	mov    0x8(%eax),%eax
c002f19a:	ff 70 64             	pushl  0x64(%eax)
c002f19d:	e8 4a bf ff ff       	call   c002b0ec <pagedir_is_accessed>
c002f1a2:	83 c4 10             	add    $0x10,%esp
c002f1a5:	85 c0                	test   %eax,%eax
c002f1a7:	74 24                	je     c002f1cd <frame_alloc+0xf9>
				pagedir_set_accessed (entry->page->thread->pagedir, entry->page->vaddr, false);
c002f1a9:	8b 46 fc             	mov    -0x4(%esi),%eax
c002f1ac:	83 ec 04             	sub    $0x4,%esp
c002f1af:	6a 00                	push   $0x0
c002f1b1:	ff 30                	pushl  (%eax)
c002f1b3:	8b 40 08             	mov    0x8(%eax),%eax
c002f1b6:	ff 70 64             	pushl  0x64(%eax)
c002f1b9:	e8 a3 c0 ff ff       	call   c002b261 <pagedir_set_accessed>
		for (struct list_elem *e = list_begin(&frames); e != list_end(&frames); e = list_next(e)){
c002f1be:	89 34 24             	mov    %esi,(%esp)
c002f1c1:	e8 d1 95 ff ff       	call   c0028797 <list_next>
c002f1c6:	89 c6                	mov    %eax,%esi
c002f1c8:	83 c4 10             	add    $0x10,%esp
c002f1cb:	eb aa                	jmp    c002f177 <frame_alloc+0xa3>
			page_out(entry->page);
c002f1cd:	83 ec 0c             	sub    $0xc,%esp
c002f1d0:	ff 76 fc             	pushl  -0x4(%esi)
c002f1d3:	e8 39 fb ff ff       	call   c002ed11 <page_out>
			break;
c002f1d8:	83 c4 10             	add    $0x10,%esp
		if (victim == NULL) {
c002f1db:	83 ee 08             	sub    $0x8,%esi
c002f1de:	74 22                	je     c002f202 <frame_alloc+0x12e>
		p->frame = victim;
c002f1e0:	89 73 14             	mov    %esi,0x14(%ebx)
		p->frame->page = p;
c002f1e3:	89 5e 04             	mov    %ebx,0x4(%esi)
		install_page(p->vaddr, p->frame->base, p->writable);
c002f1e6:	83 ec 04             	sub    $0x4,%esp
c002f1e9:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
c002f1ed:	50                   	push   %eax
c002f1ee:	8b 43 14             	mov    0x14(%ebx),%eax
c002f1f1:	ff 30                	pushl  (%eax)
c002f1f3:	ff 33                	pushl  (%ebx)
c002f1f5:	e8 c4 fa ff ff       	call   c002ecbe <install_page>
c002f1fa:	83 c4 10             	add    $0x10,%esp
c002f1fd:	e9 3e ff ff ff       	jmp    c002f140 <frame_alloc+0x6c>
			for (struct list_elem *e = list_begin(&frames); e != list_end(&frames); e = list_next(e)){
c002f202:	83 ec 0c             	sub    $0xc,%esp
c002f205:	68 74 6c 04 c0       	push   $0xc0046c74
c002f20a:	e8 58 95 ff ff       	call   c0028767 <list_begin>
c002f20f:	89 c7                	mov    %eax,%edi
c002f211:	83 c4 10             	add    $0x10,%esp
c002f214:	83 ec 0c             	sub    $0xc,%esp
c002f217:	68 74 6c 04 c0       	push   $0xc0046c74
c002f21c:	e8 be 95 ff ff       	call   c00287df <list_end>
c002f221:	83 c4 10             	add    $0x10,%esp
c002f224:	39 c7                	cmp    %eax,%edi
c002f226:	74 58                	je     c002f280 <frame_alloc+0x1ac>
				entry = list_entry(e, struct frame, elem);
c002f228:	8d 77 f8             	lea    -0x8(%edi),%esi
				if (entry->page == NULL) {
c002f22b:	8b 47 fc             	mov    -0x4(%edi),%eax
c002f22e:	85 c0                	test   %eax,%eax
c002f230:	74 ae                	je     c002f1e0 <frame_alloc+0x10c>
				if (pagedir_is_accessed(entry->page->thread->pagedir, entry->page->vaddr)) {
c002f232:	83 ec 08             	sub    $0x8,%esp
c002f235:	ff 30                	pushl  (%eax)
c002f237:	8b 40 08             	mov    0x8(%eax),%eax
c002f23a:	ff 70 64             	pushl  0x64(%eax)
c002f23d:	e8 aa be ff ff       	call   c002b0ec <pagedir_is_accessed>
c002f242:	83 c4 10             	add    $0x10,%esp
c002f245:	85 c0                	test   %eax,%eax
c002f247:	74 24                	je     c002f26d <frame_alloc+0x199>
					pagedir_set_accessed (entry->page->thread->pagedir, entry->page->vaddr, false);
c002f249:	8b 47 fc             	mov    -0x4(%edi),%eax
c002f24c:	83 ec 04             	sub    $0x4,%esp
c002f24f:	6a 00                	push   $0x0
c002f251:	ff 30                	pushl  (%eax)
c002f253:	8b 40 08             	mov    0x8(%eax),%eax
c002f256:	ff 70 64             	pushl  0x64(%eax)
c002f259:	e8 03 c0 ff ff       	call   c002b261 <pagedir_set_accessed>
			for (struct list_elem *e = list_begin(&frames); e != list_end(&frames); e = list_next(e)){
c002f25e:	89 3c 24             	mov    %edi,(%esp)
c002f261:	e8 31 95 ff ff       	call   c0028797 <list_next>
c002f266:	89 c7                	mov    %eax,%edi
c002f268:	83 c4 10             	add    $0x10,%esp
c002f26b:	eb a7                	jmp    c002f214 <frame_alloc+0x140>
				page_out(entry->page);
c002f26d:	83 ec 0c             	sub    $0xc,%esp
c002f270:	ff 77 fc             	pushl  -0x4(%edi)
c002f273:	e8 99 fa ff ff       	call   c002ed11 <page_out>
				break;
c002f278:	83 c4 10             	add    $0x10,%esp
c002f27b:	e9 60 ff ff ff       	jmp    c002f1e0 <frame_alloc+0x10c>
c002f280:	be 00 00 00 00       	mov    $0x0,%esi
c002f285:	e9 56 ff ff ff       	jmp    c002f1e0 <frame_alloc+0x10c>

c002f28a <frame_free>:

void
frame_free(struct frame *f) {
c002f28a:	53                   	push   %ebx
c002f28b:	83 ec 14             	sub    $0x14,%esp
c002f28e:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
//	lock_acquire(&frame_lock);
	palloc_free_page(f->base);
c002f292:	ff 33                	pushl  (%ebx)
c002f294:	e8 3f 45 ff ff       	call   c00237d8 <palloc_free_page>
//	printf("ok\n");
	list_remove(&f->elem);
c002f299:	8d 43 08             	lea    0x8(%ebx),%eax
c002f29c:	89 04 24             	mov    %eax,(%esp)
c002f29f:	e8 e9 98 ff ff       	call   c0028b8d <list_remove>
//	printf("done\n");
	free(f);
c002f2a4:	89 1c 24             	mov    %ebx,(%esp)
c002f2a7:	e8 1b 49 ff ff       	call   c0023bc7 <free>
//	lock_release(&frame_lock);
c002f2ac:	83 c4 18             	add    $0x18,%esp
c002f2af:	5b                   	pop    %ebx
c002f2b0:	c3                   	ret    

c002f2b1 <swap_init>:
static struct bitmap *swap_bitmap;

#define PAGE_SECTORS (PGSIZE / BLOCK_SECTOR_SIZE)

void
swap_init () {
c002f2b1:	83 ec 18             	sub    $0x18,%esp
	swap_device = block_get_role (BLOCK_SWAP);
c002f2b4:	6a 03                	push   $0x3
c002f2b6:	e8 ff 58 ff ff       	call   c0024bba <block_get_role>
c002f2bb:	a3 a4 6b 04 c0       	mov    %eax,0xc0046ba4
	if (swap_device == NULL) {
c002f2c0:	83 c4 10             	add    $0x10,%esp
c002f2c3:	85 c0                	test   %eax,%eax
c002f2c5:	74 36                	je     c002f2fd <swap_init+0x4c>
		printf ("no swap device--swap disabled\n");
		swap_bitmap = bitmap_create(0);
	}
	else {
		swap_bitmap = bitmap_create(block_size(swap_device) / PAGE_SECTORS);
c002f2c7:	83 ec 0c             	sub    $0xc,%esp
c002f2ca:	50                   	push   %eax
c002f2cb:	e8 a8 5a ff ff       	call   c0024d78 <block_size>
c002f2d0:	c1 e8 03             	shr    $0x3,%eax
c002f2d3:	89 04 24             	mov    %eax,(%esp)
c002f2d6:	e8 73 a2 ff ff       	call   c002954e <bitmap_create>
c002f2db:	a3 a0 6b 04 c0       	mov    %eax,0xc0046ba0
c002f2e0:	83 c4 10             	add    $0x10,%esp
	}
	if (swap_bitmap == NULL) {
c002f2e3:	83 3d a0 6b 04 c0 00 	cmpl   $0x0,0xc0046ba0
c002f2ea:	74 34                	je     c002f320 <swap_init+0x6f>
		PANIC("couldn't create swap bitmap");
	}
	lock_init (&swap_lock);
c002f2ec:	83 ec 0c             	sub    $0xc,%esp
c002f2ef:	68 a0 6c 04 c0       	push   $0xc0046ca0
c002f2f4:	e8 66 3a ff ff       	call   c0022d5f <lock_init>
}
c002f2f9:	83 c4 1c             	add    $0x1c,%esp
c002f2fc:	c3                   	ret    
		printf ("no swap device--swap disabled\n");
c002f2fd:	83 ec 0c             	sub    $0xc,%esp
c002f300:	68 9c 34 03 c0       	push   $0xc003349c
c002f305:	e8 5a ae ff ff       	call   c002a164 <puts>
		swap_bitmap = bitmap_create(0);
c002f30a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002f311:	e8 38 a2 ff ff       	call   c002954e <bitmap_create>
c002f316:	a3 a0 6b 04 c0       	mov    %eax,0xc0046ba0
c002f31b:	83 c4 10             	add    $0x10,%esp
c002f31e:	eb c3                	jmp    c002f2e3 <swap_init+0x32>
		PANIC("couldn't create swap bitmap");
c002f320:	68 ba 34 03 c0       	push   $0xc00334ba
c002f325:	68 f4 0b 03 c0       	push   $0xc0030bf4
c002f32a:	6a 17                	push   $0x17
c002f32c:	68 d6 34 03 c0       	push   $0xc00334d6
c002f331:	e8 47 93 ff ff       	call   c002867d <debug_panic>

c002f336 <swap_in>:

void
swap_in(struct page *p) {
c002f336:	56                   	push   %esi
c002f337:	53                   	push   %ebx
c002f338:	83 ec 04             	sub    $0x4,%esp
c002f33b:	8b 74 24 10          	mov    0x10(%esp),%esi
	size_t i;

	for (i = 0; i < PAGE_SECTORS; i++) {
c002f33f:	bb 00 00 00 00       	mov    $0x0,%ebx
		block_read(swap_device, p->sector + i, p->frame->base + i * BLOCK_SECTOR_SIZE);
c002f344:	83 ec 04             	sub    $0x4,%esp
c002f347:	8b 56 14             	mov    0x14(%esi),%edx
c002f34a:	89 d8                	mov    %ebx,%eax
c002f34c:	c1 e0 09             	shl    $0x9,%eax
c002f34f:	03 02                	add    (%edx),%eax
c002f351:	50                   	push   %eax
c002f352:	89 d8                	mov    %ebx,%eax
c002f354:	03 46 1c             	add    0x1c(%esi),%eax
c002f357:	50                   	push   %eax
c002f358:	ff 35 a4 6b 04 c0    	pushl  0xc0046ba4
c002f35e:	e8 85 59 ff ff       	call   c0024ce8 <block_read>
	for (i = 0; i < PAGE_SECTORS; i++) {
c002f363:	43                   	inc    %ebx
c002f364:	83 c4 10             	add    $0x10,%esp
c002f367:	83 fb 08             	cmp    $0x8,%ebx
c002f36a:	75 d8                	jne    c002f344 <swap_in+0xe>
	}
	bitmap_reset(swap_bitmap, p->sector / PAGE_SECTORS);
c002f36c:	83 ec 08             	sub    $0x8,%esp
c002f36f:	8b 46 1c             	mov    0x1c(%esi),%eax
c002f372:	c1 e8 03             	shr    $0x3,%eax
c002f375:	50                   	push   %eax
c002f376:	ff 35 a0 6b 04 c0    	pushl  0xc0046ba0
c002f37c:	e8 b5 9f ff ff       	call   c0029336 <bitmap_reset>
	p->sector = -1;
c002f381:	c7 46 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%esi)
}
c002f388:	83 c4 14             	add    $0x14,%esp
c002f38b:	5b                   	pop    %ebx
c002f38c:	5e                   	pop    %esi
c002f38d:	c3                   	ret    

c002f38e <swap_out>:

bool
swap_out(struct page *p) {
c002f38e:	56                   	push   %esi
c002f38f:	53                   	push   %ebx
c002f390:	83 ec 10             	sub    $0x10,%esp
c002f393:	8b 74 24 1c          	mov    0x1c(%esp),%esi
	size_t slot;
	size_t i;

	lock_acquire (&swap_lock);
c002f397:	68 a0 6c 04 c0       	push   $0xc0046ca0
c002f39c:	e8 32 3b ff ff       	call   c0022ed3 <lock_acquire>
	slot = bitmap_scan_and_flip(swap_bitmap, 0, 1, false);
c002f3a1:	6a 00                	push   $0x0
c002f3a3:	6a 01                	push   $0x1
c002f3a5:	6a 00                	push   $0x0
c002f3a7:	ff 35 a0 6b 04 c0    	pushl  0xc0046ba0
c002f3ad:	e8 cf a4 ff ff       	call   c0029881 <bitmap_scan_and_flip>
c002f3b2:	89 c3                	mov    %eax,%ebx
	lock_release (&swap_lock);
c002f3b4:	83 c4 14             	add    $0x14,%esp
c002f3b7:	68 a0 6c 04 c0       	push   $0xc0046ca0
c002f3bc:	e8 af 3c ff ff       	call   c0023070 <lock_release>
	if (slot == BITMAP_ERROR)
c002f3c1:	83 c4 10             	add    $0x10,%esp
c002f3c4:	83 fb ff             	cmp    $0xffffffff,%ebx
c002f3c7:	74 54                	je     c002f41d <swap_out+0x8f>
		return false;

	p->sector = slot * PAGE_SECTORS;
c002f3c9:	c1 e3 03             	shl    $0x3,%ebx
c002f3cc:	89 5e 1c             	mov    %ebx,0x1c(%esi)

	for (i = 0; i < PAGE_SECTORS; i++) {
c002f3cf:	bb 00 00 00 00       	mov    $0x0,%ebx
		block_write(swap_device, p->sector + i, (uint8_t *) p->frame->base + i * BLOCK_SECTOR_SIZE);
c002f3d4:	83 ec 04             	sub    $0x4,%esp
c002f3d7:	8b 56 14             	mov    0x14(%esi),%edx
c002f3da:	89 d8                	mov    %ebx,%eax
c002f3dc:	c1 e0 09             	shl    $0x9,%eax
c002f3df:	03 02                	add    (%edx),%eax
c002f3e1:	50                   	push   %eax
c002f3e2:	89 d8                	mov    %ebx,%eax
c002f3e4:	03 46 1c             	add    0x1c(%esi),%eax
c002f3e7:	50                   	push   %eax
c002f3e8:	ff 35 a4 6b 04 c0    	pushl  0xc0046ba4
c002f3ee:	e8 29 59 ff ff       	call   c0024d1c <block_write>
	for (i = 0; i < PAGE_SECTORS; i++) {
c002f3f3:	43                   	inc    %ebx
c002f3f4:	83 c4 10             	add    $0x10,%esp
c002f3f7:	83 fb 08             	cmp    $0x8,%ebx
c002f3fa:	75 d8                	jne    c002f3d4 <swap_out+0x46>
	}

	p->private = false;
c002f3fc:	c6 46 18 00          	movb   $0x0,0x18(%esi)
	p->file = NULL;
c002f400:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
	p->file_offset = 0;
c002f407:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
	p->read_bytes = 0;
c002f40e:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)

	return true;
c002f415:	b0 01                	mov    $0x1,%al
}
c002f417:	83 c4 04             	add    $0x4,%esp
c002f41a:	5b                   	pop    %ebx
c002f41b:	5e                   	pop    %esi
c002f41c:	c3                   	ret    
		return false;
c002f41d:	b0 00                	mov    $0x0,%al
c002f41f:	eb f6                	jmp    c002f417 <swap_out+0x89>
